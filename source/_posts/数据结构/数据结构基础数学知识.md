---
title: 数据结构基础数学知识
urlname: data-structure-basic-math
date: 2018-03-3 22:33:17
tags:
- 数据结构
categories:
- 数据结构
---

## 指数公式

- (X<sup>A</sup>)*(X<sup>B</sup>) = X<sup>(A+B)</sup>
- (X<sup>A</sup>)/X<sup>B</sup>) = X<sup>(A-B)</sup>
- (X<sup>A</sup>)<sup>B</sup> = X<sup>A*B</sup>

## 对数公式

- X<sup>A</sup> = B => log<sub>X</sub>(B) = A
- log<sub>A</sub>(B) = log<sub>C</sub>(B)/log<sub>C</sub>(A);A,B,C > 0, A != 1
- log(AB) = log(A) + log(B); A,B > 0
- log(A/B) = log(A) - log(B); A,B > 0
- log(A<sup>B</sup>) = B*log(A);A > 0
- X > 0 => log(X) < X

## 级数

- ∑i=0~N(A^i) = (A^(N+1)-1)/(A-1)
- ∑i=0~N(A^i) <= 1/(1-A)当0<A<1
- ∑i=1~N(i) = N(N+1)/2 ≈ N^2/2
- ∑i=1~N(i^2) = N(N+1)(2N+1)/6 ≈ N^3/3
- ∑i=1~N(i^k) = N^(k+1)/|k+1|当k!=1
- H<sub>N</sub> = ∑i=1~N(1/i) ≈ log(e,N)，H<sub>N</sub>称为调和数


## 模运算

- (A mod N) = (B mod N) => N整除(A-B)
- 如果M>N，则M mod N < M/2

注：取模运算耗费很大

## 数据结构证明常用方法

- 归纳法：证明基准情形->归纳假设->证明下一个值也成立
- 反例证明：举出反例
- 反证法：假设定理不成立，然后证明某个已知的性质不成立，从而证明原假设是错误的

## 递归
当一个函数用自身来定义时就称为递归的，编写递归例程需要遵循两四条基本法则：

- 基准情形：必须总有某些基准情形无需递归即可求解
- 不断递进：递归调用总是朝着基准情形推进
- 设计法则：假设所有的递归调用都能运行
- 合成效益法则：求解一个问题同一实例时切勿在不同递归调用中做重复性工作 

## 算法分析基础

- 大O标记：如果存在正常数c以及n<sub>0</sub>使得当N>=n<sub>0</sub>时T(N)<=cf(N)，则记为T(N)=O(f(N))
- 大Ω标记：如果存在正常数c以及n<sub>0</sub>使得当N>=n<sub>0</sub>时T(N)>=cf(N),则记为T(N)=Ω(f(N))
- Θ标记：T(N)=Θ(f(N))当且仅当T(N)=O(f(N)) AND T(N)=Ω(f(N))
- 小o标记：T(N)=o(f(N))当且仅当T(N)=O(f(N)) AND T(N)!=Ω(f(N))
- 如果T<sub>1</sub>(N)=O(f(N))且T<sub>2</sub>(N)=O(g(N))，则T<sub>1</sub>(N)+T<sub>2</sub>(N)=max(O(f(N)),O(g(N))); T<sub>1</sub>(N)\*T<sub>2</sub>(N)=O(f(N)\*g(N))
- 如果T(N)是一个k次多项式，则log<sup>k</sup>(N)=O(N)

## 时间复杂度计算一般法则

- FOR循环：一次FOR循环的运行时间至多是该循环语句（包括测试）的运行时间乘以迭代的次数。
- 嵌套的FOR循环：从里向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句运行时间乘以所有的for循环的大小的乘积。
- 顺序语句：将各个语句的运行时间求和即可。
- IF/ELSE语句：if/else语句运行时间不超过判断再加上两部分运行时间长者的和。
- 如果一个算法用常数时间将问题的的大小削减为其一部分，那么该算法就是（O(log(N))）；如果使用常数时间只是把问题减少一个常数，那么这种算法就是O(N)。

## 联机算法
在任意时刻算法对要操作的数据只读入（扫描）一次，一旦被读入并处理，它就不需要在被记忆了。而在此处理过程中算法能对它已经读入的数据立即给出相应子序列问题的正确答案。仅需要常量空间并以线性时间运行的联机算法几乎是完美算法。



{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/Limbo.jpg","path":"images/Limbo.jpg","modified":0,"renderable":0},{"_id":"source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":0},{"_id":"source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":0},{"_id":"source/images/binary-tree-test.png","path":"images/binary-tree-test.png","modified":0,"renderable":0},{"_id":"source/images/binomial-queue-merge-process.jpg","path":"images/binomial-queue-merge-process.jpg","modified":0,"renderable":0},{"_id":"source/images/binomial-queue-merge.jpg","path":"images/binomial-queue-merge.jpg","modified":0,"renderable":0},{"_id":"source/images/binomial-queue-structure.jpg","path":"images/binomial-queue-structure.jpg","modified":0,"renderable":0},{"_id":"source/images/binomial-tree.png","path":"images/binomial-tree.png","modified":0,"renderable":0},{"_id":"source/images/d-heap.png","path":"images/d-heap.png","modified":0,"renderable":0},{"_id":"source/images/design-patterns-classification.png","path":"images/design-patterns-classification.png","modified":0,"renderable":0},{"_id":"source/images/disk-physical-structure.png","path":"images/disk-physical-structure.png","modified":0,"renderable":0},{"_id":"source/images/expression-tree.png","path":"images/expression-tree.png","modified":0,"renderable":0},{"_id":"source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":0},{"_id":"source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":0},{"_id":"source/images/graph-sample.jpg","path":"images/graph-sample.jpg","modified":0,"renderable":0},{"_id":"source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":0},{"_id":"source/images/low-middle-high.png","path":"images/low-middle-high.png","modified":0,"renderable":0},{"_id":"source/images/msgget.png","path":"images/msgget.png","modified":0,"renderable":0},{"_id":"source/images/multi-table.png","path":"images/multi-table.png","modified":0,"renderable":0},{"_id":"source/images/multiplexer.png","path":"images/multiplexer.png","modified":0,"renderable":0},{"_id":"source/images/nonrecursive-post-stack.png","path":"images/nonrecursive-post-stack.png","modified":0,"renderable":0},{"_id":"source/images/nonrecursive-stack.png","path":"images/nonrecursive-stack.png","modified":0,"renderable":0},{"_id":"source/images/null-path-length.png","path":"images/null-path-length.png","modified":0,"renderable":0},{"_id":"source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":0},{"_id":"source/images/process-address-space.png","path":"images/process-address-space.png","modified":0,"renderable":0},{"_id":"source/images/process-and-high-level.png","path":"images/process-and-high-level.png","modified":0,"renderable":0},{"_id":"source/images/process-five-status.png","path":"images/process-five-status.png","modified":0,"renderable":0},{"_id":"source/images/process-only.png","path":"images/process-only.png","modified":0,"renderable":0},{"_id":"source/images/process-queue-model.png","path":"images/process-queue-model.png","modified":0,"renderable":0},{"_id":"source/images/process-seven-status.png","path":"images/process-seven-status.png","modified":0,"renderable":0},{"_id":"source/images/process-status.png","path":"images/process-status.png","modified":0,"renderable":0},{"_id":"source/images/resource-assignment.jpg","path":"images/resource-assignment.jpg","modified":0,"renderable":0},{"_id":"source/images/recursive-stack.png","path":"images/recursive-stack.png","modified":0,"renderable":0},{"_id":"source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":0},{"_id":"source/images/share-memory.png","path":"images/share-memory.png","modified":0,"renderable":0},{"_id":"source/images/sliding-window.png","path":"images/sliding-window.png","modified":0,"renderable":0},{"_id":"source/images/sort-algorithm-compare.png","path":"images/sort-algorithm-compare.png","modified":0,"renderable":0},{"_id":"source/images/tcp-close-at-same-time.png","path":"images/tcp-close-at-same-time.png","modified":0,"renderable":0},{"_id":"source/images/tcp-head.png","path":"images/tcp-head.png","modified":0,"renderable":0},{"_id":"source/images/tcp-half-close.png","path":"images/tcp-half-close.png","modified":0,"renderable":0},{"_id":"source/images/tcp-open-at-same-time.png","path":"images/tcp-open-at-same-time.png","modified":0,"renderable":0},{"_id":"source/images/three-way-handshake.png","path":"images/three-way-handshake.png","modified":0,"renderable":0},{"_id":"source/images/udp-head.png","path":"images/udp-head.png","modified":0,"renderable":0},{"_id":"source/images/stl-components.jpg","path":"images/stl-components.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp-state-change.png","path":"images/tcp-state-change.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/binary-tree-traversal.jpg","path":"images/binary-tree-traversal.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"source/images/tcp-socket.png","path":"images/tcp-socket.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/expression-tree-test.png","path":"images/expression-tree-test.png","modified":0,"renderable":0},{"_id":"source/images/brute-pattern-algorithm-step.png","path":"images/brute-pattern-algorithm-step.png","modified":0,"renderable":0},{"_id":"source/images/kmp-algorithm-next.png","path":"images/kmp-algorithm-next.png","modified":0,"renderable":0},{"_id":"source/images/kmp-algorithm-pattern.png","path":"images/kmp-algorithm-pattern.png","modified":0,"renderable":0},{"_id":"source/images/kmp-algorithm-step.png","path":"images/kmp-algorithm-step.png","modified":0,"renderable":0},{"_id":"source/images/kmp-next-not-equal.png","path":"images/kmp-next-not-equal.png","modified":0,"renderable":0},{"_id":"source/images/kmp-next-array.png","path":"images/kmp-next-array.png","modified":0,"renderable":0},{"_id":"source/images/binary-tree-five-shape.png","path":"images/binary-tree-five-shape.png","modified":0,"renderable":0},{"_id":"source/images/kmp-next-array-improve.png","path":"images/kmp-next-array-improve.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1528265268658},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1528265268658},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1528265268659},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1528265268660},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1528265268660},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1528265268661},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1528265268662},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1528265268663},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1528265268662},{"_id":"themes/next/README.cn.md","hash":"87950c415dd162ff78e98b41f1148b85462103e2","modified":1528265268664},{"_id":"themes/next/README.md","hash":"927f82cfeb5969a89b815b5ec3a3f2881e3b1bb4","modified":1528265268664},{"_id":"themes/next/_config.yml","hash":"a5c69eb78108021548531fb79d1c84d6c262f3ed","modified":1528898132262},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1528265268667},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1528265268666},{"_id":"themes/next/package-lock.json","hash":"523694e4fb6118123a0c4b748651907a00ae2ead","modified":1528265268733},{"_id":"themes/next/package.json","hash":"d682588da6a60e8a54ce09de86306fa1907c9e6f","modified":1528265268734},{"_id":"source/categories/index.md","hash":"0f2856099d30c831772bd7e68a52722ebddf0d4b","modified":1528265268530},{"_id":"source/tags/index.md","hash":"8fea3073390933469876fe3f1f73525f3b5ce8f4","modified":1528265268580},{"_id":"source/images/Limbo.jpg","hash":"897ee786280ead7ec5830142baabd7eff44ee708","modified":1528265268531},{"_id":"source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1528265268533},{"_id":"source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1528265268532},{"_id":"source/images/binary-tree-test.png","hash":"aca4e5e06612ca2b3d2640b4d2e515f5b437ad06","modified":1528265268533},{"_id":"source/images/binomial-queue-merge-process.jpg","hash":"1edf69e1ed305fc7cb4a5dad600be1ba630c501d","modified":1528265268537},{"_id":"source/images/binomial-queue-merge.jpg","hash":"01aebecbf0596f324efc99a71c226e1c4905127d","modified":1528265268538},{"_id":"source/images/binomial-queue-structure.jpg","hash":"77c27fd486990c4ee9c3ff6ed05443893f26e493","modified":1528265268539},{"_id":"source/images/binomial-tree.png","hash":"d5c3b9c6e11576ab2b3956846f40ae48d6a49cb9","modified":1528265268540},{"_id":"source/images/d-heap.png","hash":"50d84ac4b12e914457cc19c0638cda80ccf22e46","modified":1528265268541},{"_id":"source/images/design-patterns-classification.png","hash":"47aeeade588cdbff8e71d1f9be65045227572606","modified":1528265268542},{"_id":"source/images/disk-physical-structure.png","hash":"19addfd12880e0ecad05799360deaab85a8112bf","modified":1528265268543},{"_id":"source/images/expression-tree.png","hash":"b968bc274482e52efe2301b6814524974cfe6e42","modified":1528265268544},{"_id":"source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1528265268544},{"_id":"source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1528265268545},{"_id":"source/images/graph-sample.jpg","hash":"a9700cb66302dbed3d1e5ef2e0368e29fb5bb307","modified":1528265268546},{"_id":"source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1528265268547},{"_id":"source/images/low-middle-high.png","hash":"d942fb04d831b565e0f5803ef4e8036aa403e4be","modified":1528265268547},{"_id":"source/images/msgget.png","hash":"0c5d8ff8f19cf782e3e4f58101d5256d199b358c","modified":1528265268548},{"_id":"source/images/multi-table.png","hash":"425d6e7d9579e2f925d23c668d70c16aba9ba90c","modified":1528265268549},{"_id":"source/images/multiplexer.png","hash":"3ba357afb855c67b84594bd0dd84b15ca676890a","modified":1528265268550},{"_id":"source/images/nonrecursive-post-stack.png","hash":"8518df140094a4e38892ec37b3a523956ccfe95f","modified":1528265268551},{"_id":"source/images/nonrecursive-stack.png","hash":"1c38427337b753296cdaba6f16781864e963287d","modified":1528265268551},{"_id":"source/images/null-path-length.png","hash":"ed8bab0f45e1a2e2b3b495e7f59c6a9592546b5d","modified":1528265268552},{"_id":"source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1528265268553},{"_id":"source/images/process-address-space.png","hash":"f0bb0c1a933c06bebce05c5bb29e79cf1fc81387","modified":1528265268554},{"_id":"source/images/process-and-high-level.png","hash":"8bcad6efb969c7e92487323f4c1c285b4a06cf18","modified":1528265268555},{"_id":"source/images/process-five-status.png","hash":"01717391e90221d923b7ed929fe1e2fe1e7cf35f","modified":1528265268556},{"_id":"source/images/process-only.png","hash":"2dc9d276f998256864d303c14b4684f6b7d4779b","modified":1528265268557},{"_id":"source/images/process-queue-model.png","hash":"0aa5855f4a06f79dd13453df2e0cbc06368dedbd","modified":1528265268558},{"_id":"source/images/process-seven-status.png","hash":"ac30626141597cd6b915453fb60229cd287431ae","modified":1528265268558},{"_id":"source/images/process-status.png","hash":"eadbd2d0d202057e72fc39d6c52d22c05210fc2b","modified":1528265268559},{"_id":"source/images/resource-assignment.jpg","hash":"cae52f14baa423397b83ec9fa6db0a72435779e4","modified":1528265268561},{"_id":"source/images/recursive-stack.png","hash":"41d20503bec029b394bb9e4289cf79d1d2ffb87e","modified":1528265268560},{"_id":"source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1528265268561},{"_id":"source/images/share-memory.png","hash":"fcdd3127214acab0a1df5c610c9ba95c41ac5827","modified":1528265268562},{"_id":"source/images/sliding-window.png","hash":"42fdad0c26ce060b0b1686408c503baf1291f763","modified":1528265268563},{"_id":"source/images/sort-algorithm-compare.png","hash":"20e3f16464852d40c7323a74581db8cea9f6c3ae","modified":1528265268564},{"_id":"source/images/tcp-close-at-same-time.png","hash":"1866929d9ba85d46e4f3aad6c23a74eabbfe992a","modified":1528265268567},{"_id":"source/images/tcp-head.png","hash":"e28c4a83f053c1c98ac235546b1e331a368b79ba","modified":1528265268570},{"_id":"source/images/tcp-half-close.png","hash":"df5100d8de3e930e35115aa6d949e683e90436c9","modified":1528265268568},{"_id":"source/images/tcp-open-at-same-time.png","hash":"a9a8d59578854a255a60c403ed94ac41041ba185","modified":1528265268571},{"_id":"source/images/three-way-handshake.png","hash":"465ae0eaf9a9d1b6a03b75357816fcb3dc6af24e","modified":1528265268578},{"_id":"source/images/udp-head.png","hash":"1fa2a8aba7f0c2d21f1e01c726da9a1bff164571","modified":1528265268579},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1528265268667},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1528265268668},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1528265268669},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1528265268670},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1528265268670},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1528265268671},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1528265268672},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1528265268672},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1528265268673},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1528265268674},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1528265268674},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1528265268675},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1528265268676},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1528265268676},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1528265268677},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1528265268677},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1528265268680},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1528265268728},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1528265268729},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1528265268730},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1528265268730},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1528265268731},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1528265268732},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1528265268732},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1528265268735},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1528265268736},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1528265268946},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1528265268946},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1528265268947},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528265268827},{"_id":"source/_posts/C++/C++.PNG","hash":"a0a8b62e783b68e621bd41cbd24b9b8c1126062c","modified":1528265268492},{"_id":"source/_posts/C++/C++多态分类及其实现和C模拟实现多态.md","hash":"7beb472c2b7ab871eb80ed77533fa1de67b228d9","modified":1528899736567},{"_id":"source/_posts/C++/C++输入输出基础.md","hash":"e2315c11657d16914e1f1d16f8ce0b6191f25a98","modified":1528899732223},{"_id":"source/_posts/C++/C-C++类型转换总结.md","hash":"af094870bf2dce6dfb06c24d6b07ab1ab2d54dcd","modified":1528899728079},{"_id":"source/_posts/C++/STL概述.md","hash":"450d1abde32cf93cf3c2085eb9288403e6feacc3","modified":1528899723919},{"_id":"source/_posts/C++/struct位段和字节对齐原理及其计算法则.md","hash":"8aa0029fb17e12534385faff0f5167428a0bf76d","modified":1528899719663},{"_id":"source/_posts/C++/结构体struct与类class的关系和区别.md","hash":"de980a9dfabd464da94e925b9b83f65462618620","modified":1528899740687},{"_id":"source/_posts/Hexo/GitHub+Hexo搭建个人博客站及备份原始网站数据过程记录.md","hash":"4cbda2a03ebaef57e82d11dd94a5a50f3695f741","modified":1528899708318},{"_id":"source/_posts/Hexo/hello-world.md","hash":"7deadd21e3cd076558d074ca56723724bbfbfe49","modified":1528899703816},{"_id":"source/_posts/操作系统/操作系统.PNG","hash":"a71ada1bf1f1e436d8d44a62472b256d29733305","modified":1528265268501},{"_id":"source/_posts/操作系统/Linux下C++实现一个简单的线程池.md","hash":"681de69ef2595820e239b3745af3fa63ccb14313","modified":1528899685976},{"_id":"source/_posts/操作系统/操作系统概述.md","hash":"7ab1c9332a24ffbcc40bb47a0c1e22bc24641f87","modified":1528899679807},{"_id":"source/_posts/操作系统/磁盘调度策略介绍与实现.md","hash":"8b23999d2a905ffccd6668279d8dc083e93c5dd5","modified":1528899675065},{"_id":"source/_posts/操作系统/进程与线程.md","hash":"e52d173e556acf6dbc1ef509fd1030bd401cf329","modified":1528899614080},{"_id":"source/_posts/操作系统/进程或线程死锁.md","hash":"64a09878f930e3641887b0fd3ab6adf49c92c040","modified":1528899670871},{"_id":"source/_posts/操作系统/进程状态模型.md","hash":"cda7be47ce78f8dd14a31033c625f1dd0b0d2878","modified":1528899690191},{"_id":"source/_posts/算法设计/各大排序算法分析与实现.md","hash":"4deb16a22a5ed4fd951d78678c1ee99ef6646939","modified":1528899524825},{"_id":"source/_posts/算法设计/最大连续子序列和.md","hash":"07f9a314f2ecdbf2997e6c305e8e47bb95b78223","modified":1528899497098},{"_id":"source/_posts/算法设计/欧几里得计算最大公因数数学原理及实现.md","hash":"bf5555850c9a44bf6a7a0b8e19d81a856a69288e","modified":1528899518897},{"_id":"source/_posts/算法设计/选择问题-TopK问题：N个元素的数组找到最大K个数.md","hash":"0cf5fa15c1319dfd9535d5983d8de846026b2e8a","modified":1528900327400},{"_id":"source/_posts/数据结构/二叉树的前序遍历_中序遍历_后序遍历的递归实现以及非递归实现.md","hash":"c974e067061f71050c52e3a47815c102928e87be","modified":1529833948533},{"_id":"source/_posts/数据结构/二叉树非递归前_中_后_层序遍历的不同实现.md","hash":"2e971b0e0c79285884a127e7fed29ef2283b2eb8","modified":1528898742498},{"_id":"source/_posts/数据结构/优先队列的定义与二叉堆实现.md","hash":"2d3d4e6dc6d51413233c4476d017e4d87b86b1b6","modified":1528898802728},{"_id":"source/_posts/数据结构/数据结构.PNG","hash":"5380aecab1b6cdf6cd11a1c2bd8b33d8c29db460","modified":1528897379126},{"_id":"source/_posts/数据结构/散列的定义与实现.md","hash":"9117b12b2647b12b6267a7f760e15f8ea5c3235c","modified":1528898858087},{"_id":"source/_posts/数据结构/数据结构之二叉查找树.md","hash":"0b24ef8645b32e60ddd7ed9f16d39e1587bbffe1","modified":1528898819480},{"_id":"source/_posts/数据结构/数据结构之二项队列的定义与实现.md","hash":"3c0bcf8d4c52707c3ccc09798e7f583ea080d77a","modified":1528898777761},{"_id":"source/_posts/数据结构/数据结构之单向链表-指针实现.md","hash":"6928e39f3db5a887f8929507e4f1e107ebc24d4f","modified":1528898865704},{"_id":"source/_posts/数据结构/数据结构之单向链表-游标实现.md","hash":"4cf01633bfe0a375711307f7e9a64686f4f69ab3","modified":1528898841112},{"_id":"source/_posts/数据结构/数据结构之双向循环链表-指针实现.md","hash":"68b10fae6ef407d5d762de6b52b5e7a64c775b66","modified":1528898789072},{"_id":"source/_posts/数据结构/数据结构之多维数组以及特殊矩阵的压缩存储.md","hash":"92a67531de816b056379263efaf991d60df25c84","modified":1529566612606},{"_id":"source/_posts/数据结构/数据结构之多重表.md","hash":"483192491949162e34d024e26e90545d8b482e4b","modified":1528898871032},{"_id":"source/_posts/数据结构/数据结构之左式堆.md","hash":"70553114eda338c41d62cf5b2a95c9bf19dd91ef","modified":1528898797993},{"_id":"source/_posts/数据结构/数据结构之斜堆.md","hash":"c21e04d628eddb527903d94aa94eb429a8df4ecd","modified":1528898793631},{"_id":"source/_posts/数据结构/数据结构之栈的定义与实现.md","hash":"06d559fac02845fc9c5fa1f75558912805fff28f","modified":1528898876721},{"_id":"source/_posts/数据结构/数据结构之树基础.md","hash":"70672f4cd4407753591860757c70fbb7de148c44","modified":1529833403500},{"_id":"source/_posts/数据结构/数据结构之队列的定义与实现.md","hash":"880c02e1f9208b330557700c7a57c02f66d2c123","modified":1528898814393},{"_id":"source/_posts/数据结构/数据结构基础数学知识.md","hash":"7146db7d36b341a6d1b4b428fe0f954ad4dc6500","modified":1528898652528},{"_id":"source/_posts/数据结构/数据结构简介.md","hash":"e507e86d8cc10563325e1e9ff44267e675090adb","modified":1528898706245},{"_id":"source/_posts/数据结构/表达式树的定义与实现.md","hash":"6ada27e4cf6b98ac94737090150b7abbc7c8bfa6","modified":1528898845119},{"_id":"source/_posts/计算机网络/TCP-UDP基础以及区别.md","hash":"bb1f3ad2d5f39f78c885720ec747e11c6670a777","modified":1528899597425},{"_id":"source/_posts/计算机网络/计算机网络.PNG","hash":"1fc863324ed3606398d4cd03845f9a77dc970726","modified":1528265268529},{"_id":"source/images/stl-components.jpg","hash":"12d7e2ac18df430353b6b543233152851bd1852a","modified":1528265268567},{"_id":"source/images/tcp-state-change.png","hash":"11e910979c9a1b193c7e2a9d562e2c1c0f74666d","modified":1528265268577},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1528265268679},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1528265268679},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1528265268681},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1528265268681},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1528265268682},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1528265268683},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1528265268684},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1528265268684},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1528265268685},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1528265268686},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1528265268687},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1528265268689},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1528265268689},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1528265268690},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1528265268691},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1528265268697},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1528265268698},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1528265268702},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1528265268719},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1528265268719},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1528265268720},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1528265268721},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1528265268721},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1528265268722},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1528265268722},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1528265268737},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1528265268738},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1528265268739},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1528265268739},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1528265268740},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1528265268741},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1528265268742},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1528265268742},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1528265268743},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1528265268826},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1528265268828},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1528265268829},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1528265268830},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1528265268829},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1528265268831},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1528265268832},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1528265268832},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1528265268833},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1528265268835},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1528265268834},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1528265268836},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1528265268835},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1528265268837},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1528265268836},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1528265268838},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1528265268838},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1528265268839},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1528265268840},{"_id":"source/images/binary-tree-traversal.jpg","hash":"6c69f73772617694652f4c6ad5b555efdfc174e1","modified":1528265268536},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528265268700},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528265268701},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528265268802},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528265268801},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528265268804},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528265268823},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528265268825},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1528265268687},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1528265268688},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1528265268692},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1528265268693},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1528265268693},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1528265268694},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1528265268695},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1528265268695},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1528265268696},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1528265268699},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1528265268700},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1528265268701},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1528265268703},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1528265268704},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1528265268705},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1528265268706},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1528265268706},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1528265268707},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1528265268707},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1528265268708},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1528265268709},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1528265268709},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1528265268710},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1528265268711},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1528265268711},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1528265268712},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1528265268713},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1528265268714},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1528265268715},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1528265268715},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1528265268716},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1528265268717},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1528265268717},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1528265268718},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1528265268725},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1528265268726},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1528265268727},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1528265268728},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1528265268800},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1528265268801},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1528265268803},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1528265268803},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1528265268823},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1528265268822},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1528265268824},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1528265268825},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1528265268841},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1528265268842},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1528265268842},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1528265268843},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1528265268844},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1528265268844},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1528265268845},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1528265268846},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1528265268848},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1528265268849},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1528265268849},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1528265268861},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1528265268866},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1528265268867},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1528265268888},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1528265268889},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1528265268890},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1528265268891},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1528265268891},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1528265268868},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1528265268869},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1528265268882},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1528265268883},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1528265268884},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1528265268885},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1528265268906},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1528265268909},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1528265268910},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1528265268911},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1528265268912},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1528265268912},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1528265268913},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1528265268918},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1528265268919},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1528265268919},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1528265268920},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1528265268921},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1528265268922},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1528265268922},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1528265268923},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1528265268924},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1528265268924},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1528265268925},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1528265268926},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1528265268926},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1528265268927},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1528265268914},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1528265268915},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1528265268917},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1528265268929},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1528265268929},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1528265268930},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1528265268938},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1528265268939},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1528265268942},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1528265268943},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1528265268945},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1528265268908},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1528265268724},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1528265268724},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1528265268745},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1528265268746},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1528265268746},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1528265268747},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1528265268748},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1528265268760},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1528265268779},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1528265268794},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1528265268795},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1528265268796},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1528265268797},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1528265268798},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1528265268798},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1528265268799},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1528265268805},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1528265268806},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1528265268807},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1528265268807},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1528265268808},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1528265268809},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1528265268809},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1528265268810},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1528265268813},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1528265268814},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1528265268814},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1528265268816},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1528265268815},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1528265268818},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1528265268818},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1528265268819},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1528265268820},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1528265268820},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1528265268821},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1528265268847},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1528265268857},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1528265268860},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1528265268859},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1528265268893},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1528265268893},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1528265268894},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1528265268870},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1528265268871},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1528265268871},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1528265268872},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1528265268873},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1528265268874},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1528265268879},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1528265268880},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1528265268881},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1528265268886},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1528265268887},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1528265268936},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1528265268937},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1528265268858},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1528265268904},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1528265268905},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1528265268941},{"_id":"source/images/tcp-socket.png","hash":"5214575899fc262acc2353237713fb48d56e93df","modified":1528265268575},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1528265268749},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1528265268753},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1528265268755},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1528265268754},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1528265268750},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1528265268750},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1528265268751},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1528265268752},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1528265268752},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1528265268757},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1528265268757},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1528265268758},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1528265268759},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1528265268759},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1528265268761},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1528265268762},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1528265268763},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1528265268763},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1528265268764},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1528265268765},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1528265268765},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1528265268766},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1528265268767},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1528265268767},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1528265268768},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1528265268769},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1528265268770},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1528265268770},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1528265268771},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1528265268772},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1528265268773},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1528265268774},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1528265268774},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1528265268775},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1528265268776},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1528265268776},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1528265268777},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1528265268778},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1528265268779},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1528265268780},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1528265268781},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1528265268782},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1528265268782},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1528265268783},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1528265268784},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1528265268785},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1528265268784},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1528265268786},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1528265268787},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1528265268788},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1528265268789},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1528265268789},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1528265268790},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1528265268791},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1528265268791},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1528265268793},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1528265268792},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1528265268793},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1528265268812},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1528265268811},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1528265268817},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1528265268852},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1528265268853},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1528265268854},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1528265268855},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1528265268856},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1528265268896},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1528265268899},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1528265268903},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1528265268875},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1528265268875},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1528265268876},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1528265268877},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1528265268877},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1528265268878},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1528265268865},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1528265268934},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1528265268901},{"_id":"source/_posts/前_中缀表达式转后缀表达式和后缀表达式求值的计算.md","hash":"918d8b5c2f7d54d2a9f97507686f62095ce88a87","modified":1528895278335},{"_id":"source/images/expression-tree-test.png","hash":"5a631659a50f4163eb8de146d2e0c02694aa0110","modified":1528878628650},{"_id":"source/_posts/算法设计/前_中缀表达式转后缀表达式和后缀表达式求值的计算.md","hash":"8436d358bc72f14b8041ae84a44399a80e6eeff6","modified":1528962898381},{"_id":"public/baidusitemap.xml","hash":"699e9b181e68d960a8e51480392b9049c35785c6","modified":1531036826727},{"_id":"public/sitemap.xml","hash":"f46146d854bda9ac4b3804ba962ce141613b67ed","modified":1531036826768},{"_id":"public/categories/index.html","hash":"cf773469c138f7fc58afa4893c2daa1441d80015","modified":1531036827292},{"_id":"public/tags/index.html","hash":"1d3294c4a4222cb14019eaeffc1acf9d0d7c3ce4","modified":1531036827293},{"_id":"public/archives/2018/02/index.html","hash":"ba4a165f6bfd106d4d97622154acac0ea5ad385e","modified":1531036827295},{"_id":"public/archives/2018/03/page/3/index.html","hash":"71e21916656f2b1020f6d6376691d3efa065a932","modified":1531036827295},{"_id":"public/archives/2018/04/index.html","hash":"44570b2b49d55489f6d3c02529ed54eaffa9f1ab","modified":1531036827295},{"_id":"public/archives/2018/05/index.html","hash":"a5c9efdf736f481d7b15ab090967b5acf6be9cac","modified":1531036827296},{"_id":"public/archives/2018/06/index.html","hash":"2138232bca587eb8ed02bce4802ccd5114cc4214","modified":1531036827317},{"_id":"public/public/categories/cplusplus/index.html","hash":"0481dd3ae94ec29e5127d0339fd1bcafb534c4a4","modified":1531036827296},{"_id":"public/public/categories/Hexo/index.html","hash":"52eceab383314a0b3accecb42e48e38b85e23036","modified":1531036827296},{"_id":"public/public/categories/operating-system/index.html","hash":"851178c0ccf403e00af3b01e8a67ea222a6c351e","modified":1531036827296},{"_id":"public/public/categories/algorithms-design/index.html","hash":"7ae139ce17aa5f85285ad652066148f94405f196","modified":1531036827318},{"_id":"public/public/categories/computer-network/index.html","hash":"a80c6b06d5b619409e20fa5cace506ca761cceb3","modified":1531036827297},{"_id":"public/tags/C/page/2/index.html","hash":"350755dc74951931b3e82a2ca4bece400108e0c5","modified":1531036827297},{"_id":"public/tags/STL/index.html","hash":"6dba0ede89715c605f9fb5de9d9a0d67415638b8","modified":1531036827297},{"_id":"public/tags/Hexo/index.html","hash":"ebfab8d5956750c7d4c783a97be4c08493af18a3","modified":1531036827297},{"_id":"public/tags/操作系统/index.html","hash":"ece6250366cbbafd0d7b1dab84c22346d034fa10","modified":1531036827297},{"_id":"public/tags/算法设计/index.html","hash":"84c9a3dfe7e97f249b781244d6fbee63fc646727","modified":1531036827351},{"_id":"public/tags/Linux/index.html","hash":"472da806c40036b7dc2e7a037207e0f2822266b5","modified":1531036827298},{"_id":"public/algorithms-design/prefix-infix-to-postfix.html","hash":"3e18b04510a7ce2a1ce205e3a20566c0719d6980","modified":1531036827299},{"_id":"public/data-structure/one-way-cursor-list.html","hash":"723f1c209c71d2f2e1d428368857686aa7f9c0a7","modified":1531036827299},{"_id":"public/data-structure/multi-table.html","hash":"5bad526b57b33b016bc574890cd0bbc524a9c23e","modified":1531036827299},{"_id":"public/data-structure/binary-tree-traversal-non-recursive.html","hash":"23f05e1e89efc340660ec0a5acccb5ea56cc5564","modified":1531036827300},{"_id":"public/data-structure/double-circular-linked-list.html","hash":"537ea44b1a8bdb110991c9525e2580ab3c629983","modified":1531036827300},{"_id":"public/algorithms-design/euclidean-algorithm-foundation.html","hash":"26f87ab97d65a57be7c2d245f128ae3eb5257397","modified":1531036827300},{"_id":"public/algorithms-design/max-subsequence-sum.html","hash":"51665ccb61f8c3bb601dd3f35dfedef39911f6a4","modified":1531036827300},{"_id":"public/algorithms-design/top-k-problem.html","hash":"372c884b3beefbe5fa79741b41372e9812ce8d89","modified":1531036827300},{"_id":"public/computer-network/tcp-up-foundation.html","hash":"72b6ca8fe937124dc70873f26ebed7dabc80ae2c","modified":1531036827301},{"_id":"public/operating-system/linux-cpp-thread-pool.html","hash":"3aa4ca11eb9cca9168962c32aced1db9ae46ab4d","modified":1531036827301},{"_id":"public/operating-system/disk-scheduling.html","hash":"eb00db734f290cf38aeb48a5f842a816018caef5","modified":1531036827301},{"_id":"public/operating-system/dead-lock.html","hash":"e89f6b0cbba50a0eaa47c359417e719df763ac10","modified":1531036827301},{"_id":"public/algorithms-design/sort-algorithm.html","hash":"aed6774a93d27a7a96d4043957d8b15a71f91f49","modified":1531036827301},{"_id":"public/cplusplus/stl-foundation.html","hash":"64e504147920927f2ea6eeb75ff3560d928b49be","modified":1531036827301},{"_id":"public/cplusplus/cpp-type-convert.html","hash":"263d3146148a93251d5f41e4aab0458e93b82a3f","modified":1531036827302},{"_id":"public/cplusplus/struct-byte-alignment.html","hash":"889ce4c185d1a074446ba839d6c100c8f5fe4d9c","modified":1531036827302},{"_id":"public/cplusplus/struct-class.html","hash":"8dc405927b466fbf91489eff9896ffc5a14da266","modified":1531036827302},{"_id":"public/cplusplus/cpp-polymorphism.html","hash":"bc47181357775f8ed54b1d6d27ed6a3711891ed7","modified":1531036827302},{"_id":"public/cplusplus/cpp-io.html","hash":"1d2aa76567146331b83a4e819f5cadc3859d9cde","modified":1531036827303},{"_id":"public/data-structure/binomial-queue.html","hash":"3c6cfadee9c9dcfd82c700c271ccad755f9bf928","modified":1531036827303},{"_id":"public/data-structure/self-adjusting-heap.html","hash":"6450f12855b85d46be1144ef2db7b59f8d84283e","modified":1531036827303},{"_id":"public/data-structure/leftist-heap.html","hash":"d9e9c84ecb13767ecd016e5b5fb2eb53ca972e5e","modified":1531036827303},{"_id":"public/data-structure/priority-queue.html","hash":"7b72874e8427d7ca2ea1baa4de67baf92eb8d20b","modified":1531036827304},{"_id":"public/data-structure/hash-table.html","hash":"3e2a702481975d85e254e0cdc01aa82d79c70634","modified":1531036827304},{"_id":"public/data-structure/binary-search-tree.html","hash":"040685b90493140ee6448c8c7c765d63239d8918","modified":1531036827304},{"_id":"public/data-structure/expression-tree.html","hash":"48d0b744a1f80145a1f4bb405fd2222abc236689","modified":1531036827304},{"_id":"public/data-structure/binary-tree-traversal.html","hash":"1a0217d59d310cddc7220e285662619e85187038","modified":1531036827304},{"_id":"public/operating-system/process-state-model.html","hash":"07e00cb3da59c513a489ff453a79274ec4b3fa4b","modified":1531036827305},{"_id":"public/operating-system/process-thread.html","hash":"351dd41276ec73763d31ecf9acb2f77a6708238a","modified":1531036827305},{"_id":"public/operating-system/os-introduction.html","hash":"391602b600c20d97edbd4175d86a528788302477","modified":1531036827305},{"_id":"public/data-structure/tree-foundation.html","hash":"65bda3bb645b21a10358be2dd851afc9d5391084","modified":1531036827306},{"_id":"public/data-structure/multi-dimensional-arrays.html","hash":"0e0bc056227e60c1103361824ff479fab2dbe847","modified":1531036827306},{"_id":"public/data-structure/queue.html","hash":"af019af23343f3529a1d1312979318cf9525c1c1","modified":1531036827306},{"_id":"public/data-structure/stack.html","hash":"52f2cb5d96cfcb2839c61828b3bd0827575220a9","modified":1531036827307},{"_id":"public/data-structure/one-way-linked-list.html","hash":"a9b79926f5833a47bf446d2e6aed7be8ec9426f8","modified":1531036827307},{"_id":"public/data-structure/data-structure-basic-math.html","hash":"3e02f33966b1b3bc799636c96be35058a4a6dd20","modified":1531036827308},{"_id":"public/data-structure/data-structure-introduction.html","hash":"fa5d9d3af8138dfbbb36976c6cc78c7318c9c8f0","modified":1531036827308},{"_id":"public/Hexo/build-blog-website.html","hash":"ab343e72a5f11358001b3430e12364b6470a5092","modified":1531036827308},{"_id":"public/Hexo/hello-world.html","hash":"bba7dfc7c8a1ef85a85b1583a15285fa1f7b9ebe","modified":1531036827309},{"_id":"public/archives/index.html","hash":"2906dda10b25dbd789ad04724aa19a6879b589dd","modified":1531036827309},{"_id":"public/archives/page/2/index.html","hash":"cb9ba4ceb82b72c48da6a4a9e1db1f71b82fd215","modified":1531036827309},{"_id":"public/archives/page/3/index.html","hash":"db64a9c88cddc041071bc202f29e80630a888d85","modified":1531036827309},{"_id":"public/archives/page/4/index.html","hash":"0cd4a7f75f76a692377e0dd56fbf80980481a2b2","modified":1531036827310},{"_id":"public/archives/2018/index.html","hash":"9d9b5395d7aa901fbbe5e6d74878c9a71fd33ab8","modified":1531036827310},{"_id":"public/archives/2018/page/2/index.html","hash":"16c447dbd9e3f009d08d01a1ca7388c201eb356d","modified":1531036827310},{"_id":"public/archives/2018/page/3/index.html","hash":"fc94e05006542550feb01440f446f3ca22451544","modified":1531036827312},{"_id":"public/archives/2018/page/4/index.html","hash":"81188833e86c4466e63de4e0dc5293859bdd98ef","modified":1531036827313},{"_id":"public/archives/2018/03/index.html","hash":"597a7b7f6b32f95dcf1958a9e50c1e1f63ce0e5a","modified":1531036827313},{"_id":"public/archives/2018/03/page/2/index.html","hash":"71239731a125a9839ad7e4a3fce44bd7b1ff968e","modified":1531036827316},{"_id":"public/public/categories/data-structure/index.html","hash":"aff9797fdee5e4f8abb41955aedd03ab61ffb642","modified":1531036827320},{"_id":"public/public/categories/data-structure/page/2/index.html","hash":"4f30848ae7eba29f303989f52c1aafad2f5b41f8","modified":1531036827332},{"_id":"public/index.html","hash":"9be69c6249ad13c44c488fc937f814b20a9f0803","modified":1531036827334},{"_id":"public/page/2/index.html","hash":"f8fecc32939afe12b77520c134df93d22807a438","modified":1531036827347},{"_id":"public/page/3/index.html","hash":"90a7a4692a283f1dd7405a5bb1b21f89e4b0ea40","modified":1531036827348},{"_id":"public/page/4/index.html","hash":"f698dd42a80b2e9511969643df3ad5d5663a50b5","modified":1531036827348},{"_id":"public/tags/C/index.html","hash":"8de8ceb3f7030993c28a639a97a545fdf195e0e2","modified":1531036827349},{"_id":"public/tags/数据结构/index.html","hash":"e8e25885a740692f47e5947639481f028086a779","modified":1531036827349},{"_id":"public/tags/数据结构/page/2/index.html","hash":"4fbac539a6ba52537dde3b53841cb2128916e58a","modified":1531036827351},{"_id":"public/tags/计算机网络/index.html","hash":"1362b23552e1389fc5b5f97b0bd086d9cd30dfd8","modified":1531036827298},{"_id":"public/images/Limbo.jpg","hash":"897ee786280ead7ec5830142baabd7eff44ee708","modified":1528895857014},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1528895857014},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1528895857015},{"_id":"public/images/binary-tree-test.png","hash":"aca4e5e06612ca2b3d2640b4d2e515f5b437ad06","modified":1528895857015},{"_id":"public/images/binomial-queue-merge-process.jpg","hash":"1edf69e1ed305fc7cb4a5dad600be1ba630c501d","modified":1528895857015},{"_id":"public/images/binomial-queue-merge.jpg","hash":"01aebecbf0596f324efc99a71c226e1c4905127d","modified":1528895857015},{"_id":"public/images/binomial-queue-structure.jpg","hash":"77c27fd486990c4ee9c3ff6ed05443893f26e493","modified":1528895857015},{"_id":"public/images/binomial-tree.png","hash":"d5c3b9c6e11576ab2b3956846f40ae48d6a49cb9","modified":1528895857015},{"_id":"public/images/d-heap.png","hash":"50d84ac4b12e914457cc19c0638cda80ccf22e46","modified":1528895857015},{"_id":"public/images/design-patterns-classification.png","hash":"47aeeade588cdbff8e71d1f9be65045227572606","modified":1528895857015},{"_id":"public/images/disk-physical-structure.png","hash":"19addfd12880e0ecad05799360deaab85a8112bf","modified":1528895857015},{"_id":"public/images/expression-tree.png","hash":"b968bc274482e52efe2301b6814524974cfe6e42","modified":1528895857015},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1528895857015},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1528895857015},{"_id":"public/images/graph-sample.jpg","hash":"a9700cb66302dbed3d1e5ef2e0368e29fb5bb307","modified":1528895857015},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1528895857016},{"_id":"public/images/low-middle-high.png","hash":"d942fb04d831b565e0f5803ef4e8036aa403e4be","modified":1528895857016},{"_id":"public/images/msgget.png","hash":"0c5d8ff8f19cf782e3e4f58101d5256d199b358c","modified":1528895857016},{"_id":"public/images/multi-table.png","hash":"425d6e7d9579e2f925d23c668d70c16aba9ba90c","modified":1528895857016},{"_id":"public/images/multiplexer.png","hash":"3ba357afb855c67b84594bd0dd84b15ca676890a","modified":1528895857016},{"_id":"public/images/nonrecursive-post-stack.png","hash":"8518df140094a4e38892ec37b3a523956ccfe95f","modified":1528895857016},{"_id":"public/images/nonrecursive-stack.png","hash":"1c38427337b753296cdaba6f16781864e963287d","modified":1528895857016},{"_id":"public/images/null-path-length.png","hash":"ed8bab0f45e1a2e2b3b495e7f59c6a9592546b5d","modified":1528895857016},{"_id":"public/images/process-address-space.png","hash":"f0bb0c1a933c06bebce05c5bb29e79cf1fc81387","modified":1528895857016},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1528895857016},{"_id":"public/images/process-and-high-level.png","hash":"8bcad6efb969c7e92487323f4c1c285b4a06cf18","modified":1528895857016},{"_id":"public/images/process-five-status.png","hash":"01717391e90221d923b7ed929fe1e2fe1e7cf35f","modified":1528895857016},{"_id":"public/images/process-only.png","hash":"2dc9d276f998256864d303c14b4684f6b7d4779b","modified":1528895857016},{"_id":"public/images/process-queue-model.png","hash":"0aa5855f4a06f79dd13453df2e0cbc06368dedbd","modified":1528895857017},{"_id":"public/images/process-status.png","hash":"eadbd2d0d202057e72fc39d6c52d22c05210fc2b","modified":1528895857017},{"_id":"public/images/process-seven-status.png","hash":"ac30626141597cd6b915453fb60229cd287431ae","modified":1528895857017},{"_id":"public/images/resource-assignment.jpg","hash":"cae52f14baa423397b83ec9fa6db0a72435779e4","modified":1528895857017},{"_id":"public/images/recursive-stack.png","hash":"41d20503bec029b394bb9e4289cf79d1d2ffb87e","modified":1528895857017},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1528895857017},{"_id":"public/images/sliding-window.png","hash":"42fdad0c26ce060b0b1686408c503baf1291f763","modified":1528895857017},{"_id":"public/images/share-memory.png","hash":"fcdd3127214acab0a1df5c610c9ba95c41ac5827","modified":1528895857017},{"_id":"public/images/sort-algorithm-compare.png","hash":"20e3f16464852d40c7323a74581db8cea9f6c3ae","modified":1528895857017},{"_id":"public/images/tcp-close-at-same-time.png","hash":"1866929d9ba85d46e4f3aad6c23a74eabbfe992a","modified":1528895857017},{"_id":"public/images/tcp-head.png","hash":"e28c4a83f053c1c98ac235546b1e331a368b79ba","modified":1528895857017},{"_id":"public/images/tcp-half-close.png","hash":"df5100d8de3e930e35115aa6d949e683e90436c9","modified":1528895857017},{"_id":"public/images/tcp-open-at-same-time.png","hash":"a9a8d59578854a255a60c403ed94ac41041ba185","modified":1528895857017},{"_id":"public/images/three-way-handshake.png","hash":"465ae0eaf9a9d1b6a03b75357816fcb3dc6af24e","modified":1528895857017},{"_id":"public/images/udp-head.png","hash":"1fa2a8aba7f0c2d21f1e01c726da9a1bff164571","modified":1528895857018},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1528895857018},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1528895857018},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1528895857018},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1528895857018},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1528895857018},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1528895857018},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1528895857018},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1528895857018},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1528895857018},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1528895857018},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1528895857018},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1528895857019},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1528895857019},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1528895857019},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1528895857019},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1528895857019},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1528895857019},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1528895857019},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1528895857019},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1528895857019},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1528895857019},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1528895857019},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1528895857019},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1528895857019},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1528895857019},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1528895857019},{"_id":"public/images/expression-tree-test.png","hash":"5a631659a50f4163eb8de146d2e0c02694aa0110","modified":1528895857020},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1528895857684},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1528895857691},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1528895857706},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1528895857706},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1528895857706},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1528895857706},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1528895857706},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1528895857706},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1528895857706},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1528895857706},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1528895857706},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1528895857706},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1528895857706},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1528895857706},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1528895857707},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1528895857707},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1528895857707},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1528895857708},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1528895857708},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1528895857708},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1528895857708},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1528895857709},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1528895857709},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1528895857709},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1528895857709},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1528895857709},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1528895857709},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1528895857709},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1528895857709},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1528895857709},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1528895857709},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1528895857709},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1528895857710},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1528895857710},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1528895857710},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1528895857710},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1528895857710},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1528895857710},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1528895857710},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1528895857710},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1528895857710},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1528895857710},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1528895857710},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1528895857710},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1528895857710},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1528895857711},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1528895857711},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1528895857711},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1528895857711},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1528895857711},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1528895857711},{"_id":"public/css/main.css","hash":"fd234c01b3b86d7334ab9e3c4081f962c5497f78","modified":1528895857711},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1528895857711},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1528895857711},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1528895857711},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1528895857711},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1528895857712},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1528895857712},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1528895857712},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1528895857712},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1528895857712},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1528895857712},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1528895857712},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1528895857712},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1528895857712},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1528895857712},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1528895857712},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1528895857713},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1528895857713},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1528895857713},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1528895857713},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1528895857713},{"_id":"public/images/stl-components.jpg","hash":"12d7e2ac18df430353b6b543233152851bd1852a","modified":1528895857713},{"_id":"public/images/tcp-state-change.png","hash":"11e910979c9a1b193c7e2a9d562e2c1c0f74666d","modified":1528895857714},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1528895857714},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1528895857714},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1528895857714},{"_id":"public/images/binary-tree-traversal.jpg","hash":"6c69f73772617694652f4c6ad5b555efdfc174e1","modified":1528895857766},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1528895857795},{"_id":"public/images/tcp-socket.png","hash":"5214575899fc262acc2353237713fb48d56e93df","modified":1528895857814},{"_id":"source/_posts/算法设计/中_后缀表达式转前缀表达式和前缀表达式求值.md","hash":"ca7000c5f136116ca42bd39354135779f18be029","modified":1528982353103},{"_id":"source/_posts/算法设计/前_后缀表达式转中缀表达式.md","hash":"305c016679692c66efcdb602274989f96f941761","modified":1529509184631},{"_id":"public/archives/page/5/index.html","hash":"bf0d2a902b5486c82dd537b59a118bc0b4101d72","modified":1531036827293},{"_id":"public/archives/2018/page/5/index.html","hash":"13e52ad4bb9beff3f6125f77821d3e96e96e4a90","modified":1531036827295},{"_id":"public/page/5/index.html","hash":"0467bef2137c37e389cffd6ef4f94170c7e9ffdb","modified":1531036827349},{"_id":"public/algorithms-design/prefix-postfix-to-infix.html","hash":"2cad313df54de48eeec5e9a855c0012171d94e71","modified":1531036827299},{"_id":"public/algorithms-design/infix-postfix-to-prefix.html","hash":"553657ea50cecf2bd58322a50d873d4cee951162","modified":1531036827299},{"_id":"source/images/brute-pattern-algorithm-step.png","hash":"9545cde85347219b0a119e7efc94f1920ba3b30f","modified":1529594268268},{"_id":"source/images/kmp-algorithm-next.png","hash":"740e9ffd4c3e9317ae9bea9849c4aa2d7902352c","modified":1529668399176},{"_id":"source/images/kmp-algorithm-pattern.png","hash":"4153c2a10c3b497791d68150d6b42bfb3057346e","modified":1529594237612},{"_id":"source/images/kmp-algorithm-step.png","hash":"ea75d135e912c0fa3111eb64d315ee17e61b3607","modified":1529594539648},{"_id":"source/images/kmp-next-not-equal.png","hash":"37258d6fd838330b8a514e7c9b1ca6572c755de5","modified":1529738455026},{"_id":"source/images/kmp-next-array.png","hash":"c2f02ef0c22b2a9dd57c5b45b97772c572aebf9c","modified":1529668260968},{"_id":"source/_posts/算法设计/字符串模式匹配及KMP算法分析与实现.md","hash":"0cab7ab2627db2dfb0b4d3e1dddead05a2948372","modified":1529741671885},{"_id":"public/algorithms-design/string-pattern-match-kmp.html","hash":"97d6a6662de2e23a90f55d5fcb241f10b5db4509","modified":1531036827298},{"_id":"public/images/kmp-algorithm-next.png","hash":"740e9ffd4c3e9317ae9bea9849c4aa2d7902352c","modified":1529739160158},{"_id":"public/images/brute-pattern-algorithm-step.png","hash":"9545cde85347219b0a119e7efc94f1920ba3b30f","modified":1529739160158},{"_id":"public/images/kmp-algorithm-pattern.png","hash":"4153c2a10c3b497791d68150d6b42bfb3057346e","modified":1529739160158},{"_id":"public/images/kmp-next-not-equal.png","hash":"37258d6fd838330b8a514e7c9b1ca6572c755de5","modified":1529739160158},{"_id":"public/images/kmp-next-array.png","hash":"c2f02ef0c22b2a9dd57c5b45b97772c572aebf9c","modified":1529739160158},{"_id":"public/images/kmp-algorithm-step.png","hash":"ea75d135e912c0fa3111eb64d315ee17e61b3607","modified":1529739160159},{"_id":"source/images/binary-tree-five-shape.png","hash":"706f29c2c004ac08305b7b98787294301736140e","modified":1529826182300},{"_id":"source/images/kmp-next-array-improve.png","hash":"94c2ec331b977543252e3d0a50c645716d034bdf","modified":1529740708312},{"_id":"source/_posts/数据结构/稀疏矩阵压缩存储之三元组.md","hash":"8464b6291622d5347c3443943d93e540091f32c5","modified":1529924632329},{"_id":"source/_posts/数据结构/稀疏矩阵压缩存储之十字链表.md","hash":"d205ad33fb6b477a267116875772ea9acd407eb2","modified":1530014905968},{"_id":"public/data-structure/sparse-matrix-triple-table.html","hash":"bcd9b9526d8ece934a6d86a12e3d36ee453b900c","modified":1531036827298},{"_id":"public/data-structure/sparse-matrix-orthogonal-linked-list.html","hash":"88ca8ccd1d2dd801aed0e3d22d94286948bc74a2","modified":1531036827298},{"_id":"public/public/categories/data-structure/page/3/index.html","hash":"30873d9ad84e3eda78dd15c139f83e2a622e7ea5","modified":1531036827296},{"_id":"public/tags/数据结构/page/3/index.html","hash":"d34c3d672f409f96fb23055427f19ebfa8b36ccb","modified":1531036827297},{"_id":"source/_posts/算法设计/前_后缀表达式重建表达式树.md","hash":"e93d57b3c916872a0307bffc1858c9bd1ea1ea05","modified":1531036720427},{"_id":"public/archives/2018/07/index.html","hash":"38bc8df4a669f870d15403467e564f56fe94cae7","modified":1531036827425},{"_id":"public/algorithms-design/prefix-postfix-to-expr-tree.html","hash":"864253ea37e74aa1d17d9850fed04aa259974e37","modified":1531036827429}],"Category":[{"name":"C++","_id":"cji37vw1q00048kvneepgk4dy"},{"name":"Hexo","_id":"cji37vw2b000o8kvne8ukbame"},{"name":"操作系统","_id":"cji37vw2k00128kvn6rbfyxog"},{"name":"算法设计","_id":"cji37vw32001s8kvnh2mp17oy"},{"name":"数据结构","_id":"cji37vw3j002g8kvn8ocmeapi"},{"name":"计算机网络","_id":"cji37vw4p004c8kvn7yr38zos"}],"Data":[],"Page":[{"title":"分类","date":"2018-03-01T10:43:41.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-03-01 18:43:41\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-06-06T06:07:48.530Z","path":"categories/index.html","layout":"page","_id":"cji37vvxm00008kvn15idbu5b","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-03-01T10:36:35.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-03-01 18:36:35\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-06-06T06:07:48.580Z","path":"tags/index.html","layout":"page","_id":"cji37vvxp00018kvn87z8pf5v","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++输入输出基础","urlname":"cpp-io","date":"2018-03-12T01:05:24.000Z","copyright":true,"mathjax":true,"_content":"\n## C++输入输出基础知识\n\nC++语言自身没有定义输入输出语句，其通过标准库来提供IO能力。在C++中iostream库为常用的IO库，该库包含两个基础类型istream和ostream，分别表示输入流（即读）与输出流（即写）。其中流指的是一个字符序列。标准库中定义了四个IO对象，分别为cin（标准输入）、cout（标准输出）、cerr（非缓冲标准错误流）、clog（缓冲标准错误流）。在使用诸如“cout<<something;”语句时，该语句返回输入输出流对象的引用，这也是为什么可以采用“cout<<something1<<something2;”这种格式的原因。\n\n在使用一个istream对象作为条件时，其返回的是输入流的有效状态标记，如果流是有效的则返回真，否则如果读到流末尾（EOF）或者无效输入（读入一个整数实际输入不是整数）返回假。\n\n## C++IO库概览\n\nC++IO库不仅定义了istream和ostream，还定义其他IO类型，具体见下：\n\n- 头文件iostream\n \n\t1. istream，wistream：用来从流中读取数据，w代表宽字符（wchar_t）\n\t2. ostream，wostream：用来向流写入数据\n\t3. iostream，wiostream：读写流。\n\n- 头文件fstream\n\n\t1. ifstream，wifstream：从文件读取数据\n\t2. ofstream，wofstream：向文件写入数据\n\t3. fstream，wfstream：读写文件\n\n- 头文件sstream\n\n\t1. istringstream，wistream：从string中读取数据\n\t2. ostringstream，wostringstream：向string写入数据\n\t3. stringstream，wstringstream：读写string\n\n- 头文件iomanip\n\n在以上流类型中，ifstream和istringstream继承于istream，而ofstream和ostringstream则继承于ostream。IO对象是一种不能进行拷贝或者赋值的对象，而且由于在写过程中对象的状态会发生改变，流对象也不能设置为const（const对象不能调用非const类型的成员函数）。\n\n在进行IO操作时，难免会发生错误，因此IO类定义了一系列条件状态，如下所示：\n\n\t1. ::iostate：是一种机器相关的类型，提供了条件状态的完整功能\n\t2. ::badbit：表明流已崩溃\n\t3. ::failbit：表明一个IO操作失败\n\t4. ::eofbit：表明流已达到末尾\n\t5. ::goodbit表明流未处于错误状态，值保证为0\n\t6. .eof()：若eofbit置位则返回true\n\t7. .fail()：若badbit或failbit置位则返回true\n\t8. .good()：流有效则返回true\n\t9. .clear()：所有条件状态复位，流状态成为有效，返回void\n\t10. .clear(iostate flag)：根据flag标志位将相应条件状态复位，返回void\n\t11. .setstate(iostate flag)：根据flag标志位将相应条件状态置位，返回void\n\t12. .rdstate()：返回流当前条件状态，返回值为iostate类型\n\n一旦一个流发生错误，其上所有的后续操作均会失败，只有处于无错状态时才能读写数据。\n\n## 输出缓冲管理\n\n每一个输出流都有一个缓冲区用于保存程序读写的数据。缓冲机制的存在使得输出不一定被立刻显示或者写入文件出来，而导致真正读写发生（即缓冲刷新）主要有如下原因：\n\n\t1. 程序正常结束，执行缓冲刷新\n\t2. 缓冲区满\n\t3. 使用endl等操作符显式刷新缓冲区\n\t4. 每个输出操作后用unitbuff设置流的内部状态来清空缓冲区，cerr默认设置unitbuff，因此cerr是立刻刷新的\n\t5. 一个输出流被关联到另外一个流时，当读写该流时关联流的缓冲区会被立刻刷新，默认cin和cerr关联到cout，导致读cin或者写cerr会刷新cout缓冲区\n\n以下代码为立刻刷新缓冲区的方式：\n\n```cpp\ncout << \"Hello world!\" << endl; //输出Hello world!+换行并刷新缓冲区\ncout << \"Hello world!\" << flush; //输出Hello world!并刷新缓冲区\ncout << \"Hello world!\" << ends; //输出Hello world!+空字符并刷新缓冲区\ncout << unitbuff; //所有输出操作立刻刷新缓冲区\ncout << nounitbuff; //还原正常缓冲\n```\n\n在程序崩溃后，输出缓冲将不会被刷新。\n\n## 关联输入输出流\n\n当一个输入流被关联到一个输出流时，任何从输入流读取数据的操作均会导致输出流被刷新。关联流的函数为tie，其重载为两个版本：\n\n\t1. tie()无参数，返回指向关联到输出流的指针，没有关联返回空指针\n\t2. tie(ostream对象指针)，将自己关联到输出流\n\t\n以下下代码演示关联操作\n```cpp\ncin.tie(&cout); //将cin关联到cout上，标准库默认关联\nostream *oldTie = cin.tie(nullptr); //cin不在与其他流关联\ncin.tie(&cerr); //关联到cerr，读取cin会刷新cerr\n```\n\n## 文件输入输出\n\n头文件fstream定义了文件读写的相关类型。由于fstream继承于iostream，因此iostream操作都可以使用。但是新增了一些操作，如下所示：\n\n\t1. fstream fObject(\"fileName\")：创建一个流并打开某个文件\n\t2. fstream fObject(\"fileName\", mode)：创建一个流并打开某个文件，mode指定读写模式\n\t3. fObject.open(\"fileName\")：并打开某个文件\n\t4. fObject.close()：关闭流绑定的文件\n\t5. fObject.is_open()：判断流是否和文件关联且未关闭并返回bool值\n\nfstream对象在销毁时会自动调用close函数。\n\n在文件输入输出中，主要有如下读写模式：\n\n\t1. in：只读打开，只能对ifstream和fstream设置\n\t2. out：只写，会覆盖原始数据，只能对ofstream和fstream对象设置\n\t3. app：每次写均定位到文件末尾，只要trunc没被设置\n\t4. ate：打开文件后立即定位末尾，可和任何模式组合使用\n\t5. trunc：截断文件，只有当out被设置时才能被设定\n\t6. binary：二进制方式读写，可和任何模式组合使用\n\n## string流\n\n在sstream头文件中定义了三个类型来支持内存IO，这几个类型可以直接项string读写数据。sstream也继承自iostream，但有自己一些特殊的操作，如下：\n\n\t1. sstream sObject(string s)：保存字符串s的一个拷贝，此构造函数是explicit的，编译器不会自动执行转换\n\t2. sObject.str()：返回保存的string拷贝\n\t3. sObject.str(string s)：将字符串s拷贝到对象中，返回void\n\n以下为一个sstream使用范例：\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nint main(int argc, _TCHAR* argv[])\n{\n        stringstream Test;\n        string data(\"Hello World!\");\n        Test.str(data);\n        string outPut;\n        while (Test >> outPut) {\n                cout << outPut << endl;\n        }\n        Test.clear();\n        Test << \"Hi\" << \"World\";\n        cout << Test.str() << endl;\n        return 0;\n}\n```\n\n整个控制台输出为：\n\n\tHello\n\tWorld!\n\tHiWorldorld!\n\n## 格式化输入输出\n\n标准库定义了一组操纵符用来修改流的格式状态，且格式控制由设置和复原成对出现。具体操作符可见相关手册。\n\n同时IO库还定义了一组未格式化的输入输出操作，用于将流当成无解释的字节序列（不跳过空格）来处理，具体见下：\n\n- 单字节操作\n\n\t1. object.get(ch)：读取下一个字节存入ch中，返回对象\n\t2. object.put(ch)：将字符写到流中，返回对象\n\t3. object.get()：读取下一个字节并作为int类型返回\n\t4. object.putback(ch)：读将字符放入流中，返回对象\n\t5. object.unget()：将对象object向后移动一个字节，返回对象\n\t6. object.peek()：读取下一个字节并作为int类型返回但不从流中删除\n\n- 多字节操作\n\n\t1. obejct.get(sink, size, delim)：从流中最多读出size个字节，遇到delim或者文件结尾或者读满size个字节则停止读写，将delim放在输入流中且不丢弃delim，读出的数据放入sink数组中\n\t2. obejct.getline(sink, size, delim)：和get类似，不过会读取并丢弃delim\n\t3. obejct.read(sink, size)：读取最多size个字节并放入sink数组\n\t4. obejct.gcount()：返回上一个未格式化操作读取的字节数\n\t5. obejct.write(src, size)：将数组src的size个字节写入流中\n\t6. obejct.ignore(size, delim)：读取并忽略size个字节，包括delim\n\n## 流随机访问\n\n大多数系统cin\\cout\\cerr\\clog的流不支持随机访问，因此一般只有istream和ostream支持随机访问。通常由两组函数tell（返回当前位置）和seek（定位到某一位置）根据是输入流还是输出流主要有tellg\\tellp、seekg\\seekp，g表示读取数据，p表示写入数据，函数各定义如下：\n\n\t1. tellg\\tellp：返回输入流或者输出流标记的当前位置\n\t2. sekg(pos)\\seekp(pos)：将输入输出流重定位到决定位置pos\n\t3. sekg(off, from)、sekp(off, from)：输入输出定位到from之前或者之后的off个字符，from可以是beg（流开始）、cur（流当前）、end（流结尾）\t\n\n\n\n\n\n## 参考文章\n\n[C++标准设备的输入/输出（cin,cout,cerr,clog,>>,<<）](http://www.weixueyuan.net/view/5875.html)\n\n[c++里关于cerr,clog,cout三者的区别](http://blog.csdn.net/zx824/article/details/6644455)\n\n[clog，cout，cerr 输出机制](http://www.cnblogs.com/xiezhw3/p/4349766.html)\n\n[C/C++ 标准输入输出重定向](http://www.cnblogs.com/hjslovewcl/archive/2011/01/10/2314356.html)\n\n\n\n\n\n\n\n\n\n","source":"_posts/C++/C++输入输出基础.md","raw":"---\ntitle: C++输入输出基础\nurlname: cpp-io\ndate: 2018-03-12 9:05:24\ncopyright: true\nmathjax: true\ntags:\n- C++\ncategories:\n- C++\n---\n\n## C++输入输出基础知识\n\nC++语言自身没有定义输入输出语句，其通过标准库来提供IO能力。在C++中iostream库为常用的IO库，该库包含两个基础类型istream和ostream，分别表示输入流（即读）与输出流（即写）。其中流指的是一个字符序列。标准库中定义了四个IO对象，分别为cin（标准输入）、cout（标准输出）、cerr（非缓冲标准错误流）、clog（缓冲标准错误流）。在使用诸如“cout<<something;”语句时，该语句返回输入输出流对象的引用，这也是为什么可以采用“cout<<something1<<something2;”这种格式的原因。\n\n在使用一个istream对象作为条件时，其返回的是输入流的有效状态标记，如果流是有效的则返回真，否则如果读到流末尾（EOF）或者无效输入（读入一个整数实际输入不是整数）返回假。\n\n## C++IO库概览\n\nC++IO库不仅定义了istream和ostream，还定义其他IO类型，具体见下：\n\n- 头文件iostream\n \n\t1. istream，wistream：用来从流中读取数据，w代表宽字符（wchar_t）\n\t2. ostream，wostream：用来向流写入数据\n\t3. iostream，wiostream：读写流。\n\n- 头文件fstream\n\n\t1. ifstream，wifstream：从文件读取数据\n\t2. ofstream，wofstream：向文件写入数据\n\t3. fstream，wfstream：读写文件\n\n- 头文件sstream\n\n\t1. istringstream，wistream：从string中读取数据\n\t2. ostringstream，wostringstream：向string写入数据\n\t3. stringstream，wstringstream：读写string\n\n- 头文件iomanip\n\n在以上流类型中，ifstream和istringstream继承于istream，而ofstream和ostringstream则继承于ostream。IO对象是一种不能进行拷贝或者赋值的对象，而且由于在写过程中对象的状态会发生改变，流对象也不能设置为const（const对象不能调用非const类型的成员函数）。\n\n在进行IO操作时，难免会发生错误，因此IO类定义了一系列条件状态，如下所示：\n\n\t1. ::iostate：是一种机器相关的类型，提供了条件状态的完整功能\n\t2. ::badbit：表明流已崩溃\n\t3. ::failbit：表明一个IO操作失败\n\t4. ::eofbit：表明流已达到末尾\n\t5. ::goodbit表明流未处于错误状态，值保证为0\n\t6. .eof()：若eofbit置位则返回true\n\t7. .fail()：若badbit或failbit置位则返回true\n\t8. .good()：流有效则返回true\n\t9. .clear()：所有条件状态复位，流状态成为有效，返回void\n\t10. .clear(iostate flag)：根据flag标志位将相应条件状态复位，返回void\n\t11. .setstate(iostate flag)：根据flag标志位将相应条件状态置位，返回void\n\t12. .rdstate()：返回流当前条件状态，返回值为iostate类型\n\n一旦一个流发生错误，其上所有的后续操作均会失败，只有处于无错状态时才能读写数据。\n\n## 输出缓冲管理\n\n每一个输出流都有一个缓冲区用于保存程序读写的数据。缓冲机制的存在使得输出不一定被立刻显示或者写入文件出来，而导致真正读写发生（即缓冲刷新）主要有如下原因：\n\n\t1. 程序正常结束，执行缓冲刷新\n\t2. 缓冲区满\n\t3. 使用endl等操作符显式刷新缓冲区\n\t4. 每个输出操作后用unitbuff设置流的内部状态来清空缓冲区，cerr默认设置unitbuff，因此cerr是立刻刷新的\n\t5. 一个输出流被关联到另外一个流时，当读写该流时关联流的缓冲区会被立刻刷新，默认cin和cerr关联到cout，导致读cin或者写cerr会刷新cout缓冲区\n\n以下代码为立刻刷新缓冲区的方式：\n\n```cpp\ncout << \"Hello world!\" << endl; //输出Hello world!+换行并刷新缓冲区\ncout << \"Hello world!\" << flush; //输出Hello world!并刷新缓冲区\ncout << \"Hello world!\" << ends; //输出Hello world!+空字符并刷新缓冲区\ncout << unitbuff; //所有输出操作立刻刷新缓冲区\ncout << nounitbuff; //还原正常缓冲\n```\n\n在程序崩溃后，输出缓冲将不会被刷新。\n\n## 关联输入输出流\n\n当一个输入流被关联到一个输出流时，任何从输入流读取数据的操作均会导致输出流被刷新。关联流的函数为tie，其重载为两个版本：\n\n\t1. tie()无参数，返回指向关联到输出流的指针，没有关联返回空指针\n\t2. tie(ostream对象指针)，将自己关联到输出流\n\t\n以下下代码演示关联操作\n```cpp\ncin.tie(&cout); //将cin关联到cout上，标准库默认关联\nostream *oldTie = cin.tie(nullptr); //cin不在与其他流关联\ncin.tie(&cerr); //关联到cerr，读取cin会刷新cerr\n```\n\n## 文件输入输出\n\n头文件fstream定义了文件读写的相关类型。由于fstream继承于iostream，因此iostream操作都可以使用。但是新增了一些操作，如下所示：\n\n\t1. fstream fObject(\"fileName\")：创建一个流并打开某个文件\n\t2. fstream fObject(\"fileName\", mode)：创建一个流并打开某个文件，mode指定读写模式\n\t3. fObject.open(\"fileName\")：并打开某个文件\n\t4. fObject.close()：关闭流绑定的文件\n\t5. fObject.is_open()：判断流是否和文件关联且未关闭并返回bool值\n\nfstream对象在销毁时会自动调用close函数。\n\n在文件输入输出中，主要有如下读写模式：\n\n\t1. in：只读打开，只能对ifstream和fstream设置\n\t2. out：只写，会覆盖原始数据，只能对ofstream和fstream对象设置\n\t3. app：每次写均定位到文件末尾，只要trunc没被设置\n\t4. ate：打开文件后立即定位末尾，可和任何模式组合使用\n\t5. trunc：截断文件，只有当out被设置时才能被设定\n\t6. binary：二进制方式读写，可和任何模式组合使用\n\n## string流\n\n在sstream头文件中定义了三个类型来支持内存IO，这几个类型可以直接项string读写数据。sstream也继承自iostream，但有自己一些特殊的操作，如下：\n\n\t1. sstream sObject(string s)：保存字符串s的一个拷贝，此构造函数是explicit的，编译器不会自动执行转换\n\t2. sObject.str()：返回保存的string拷贝\n\t3. sObject.str(string s)：将字符串s拷贝到对象中，返回void\n\n以下为一个sstream使用范例：\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nint main(int argc, _TCHAR* argv[])\n{\n        stringstream Test;\n        string data(\"Hello World!\");\n        Test.str(data);\n        string outPut;\n        while (Test >> outPut) {\n                cout << outPut << endl;\n        }\n        Test.clear();\n        Test << \"Hi\" << \"World\";\n        cout << Test.str() << endl;\n        return 0;\n}\n```\n\n整个控制台输出为：\n\n\tHello\n\tWorld!\n\tHiWorldorld!\n\n## 格式化输入输出\n\n标准库定义了一组操纵符用来修改流的格式状态，且格式控制由设置和复原成对出现。具体操作符可见相关手册。\n\n同时IO库还定义了一组未格式化的输入输出操作，用于将流当成无解释的字节序列（不跳过空格）来处理，具体见下：\n\n- 单字节操作\n\n\t1. object.get(ch)：读取下一个字节存入ch中，返回对象\n\t2. object.put(ch)：将字符写到流中，返回对象\n\t3. object.get()：读取下一个字节并作为int类型返回\n\t4. object.putback(ch)：读将字符放入流中，返回对象\n\t5. object.unget()：将对象object向后移动一个字节，返回对象\n\t6. object.peek()：读取下一个字节并作为int类型返回但不从流中删除\n\n- 多字节操作\n\n\t1. obejct.get(sink, size, delim)：从流中最多读出size个字节，遇到delim或者文件结尾或者读满size个字节则停止读写，将delim放在输入流中且不丢弃delim，读出的数据放入sink数组中\n\t2. obejct.getline(sink, size, delim)：和get类似，不过会读取并丢弃delim\n\t3. obejct.read(sink, size)：读取最多size个字节并放入sink数组\n\t4. obejct.gcount()：返回上一个未格式化操作读取的字节数\n\t5. obejct.write(src, size)：将数组src的size个字节写入流中\n\t6. obejct.ignore(size, delim)：读取并忽略size个字节，包括delim\n\n## 流随机访问\n\n大多数系统cin\\cout\\cerr\\clog的流不支持随机访问，因此一般只有istream和ostream支持随机访问。通常由两组函数tell（返回当前位置）和seek（定位到某一位置）根据是输入流还是输出流主要有tellg\\tellp、seekg\\seekp，g表示读取数据，p表示写入数据，函数各定义如下：\n\n\t1. tellg\\tellp：返回输入流或者输出流标记的当前位置\n\t2. sekg(pos)\\seekp(pos)：将输入输出流重定位到决定位置pos\n\t3. sekg(off, from)、sekp(off, from)：输入输出定位到from之前或者之后的off个字符，from可以是beg（流开始）、cur（流当前）、end（流结尾）\t\n\n\n\n\n\n## 参考文章\n\n[C++标准设备的输入/输出（cin,cout,cerr,clog,>>,<<）](http://www.weixueyuan.net/view/5875.html)\n\n[c++里关于cerr,clog,cout三者的区别](http://blog.csdn.net/zx824/article/details/6644455)\n\n[clog，cout，cerr 输出机制](http://www.cnblogs.com/xiezhw3/p/4349766.html)\n\n[C/C++ 标准输入输出重定向](http://www.cnblogs.com/hjslovewcl/archive/2011/01/10/2314356.html)\n\n\n\n\n\n\n\n\n\n","slug":"C++/C++输入输出基础","published":1,"updated":"2018-06-13T14:22:12.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x280000gsvnrvalqn0j","content":"<h2 id=\"C-输入输出基础知识\"><a href=\"#C-输入输出基础知识\" class=\"headerlink\" title=\"C++输入输出基础知识\"></a>C++输入输出基础知识</h2><p>C++语言自身没有定义输入输出语句，其通过标准库来提供IO能力。在C++中iostream库为常用的IO库，该库包含两个基础类型istream和ostream，分别表示输入流（即读）与输出流（即写）。其中流指的是一个字符序列。标准库中定义了四个IO对象，分别为cin（标准输入）、cout（标准输出）、cerr（非缓冲标准错误流）、clog（缓冲标准错误流）。在使用诸如“cout&lt;&lt;something;”语句时，该语句返回输入输出流对象的引用，这也是为什么可以采用“cout&lt;&lt;something1&lt;&lt;something2;”这种格式的原因。</p>\n<p>在使用一个istream对象作为条件时，其返回的是输入流的有效状态标记，如果流是有效的则返回真，否则如果读到流末尾（EOF）或者无效输入（读入一个整数实际输入不是整数）返回假。</p>\n<h2 id=\"C-IO库概览\"><a href=\"#C-IO库概览\" class=\"headerlink\" title=\"C++IO库概览\"></a>C++IO库概览</h2><p>C++IO库不仅定义了istream和ostream，还定义其他IO类型，具体见下：</p>\n<ul>\n<li><p>头文件iostream</p>\n<ol>\n<li>istream，wistream：用来从流中读取数据，w代表宽字符（wchar_t）</li>\n<li>ostream，wostream：用来向流写入数据</li>\n<li>iostream，wiostream：读写流。</li>\n</ol>\n</li>\n<li><p>头文件fstream</p>\n<ol>\n<li>ifstream，wifstream：从文件读取数据</li>\n<li>ofstream，wofstream：向文件写入数据</li>\n<li>fstream，wfstream：读写文件</li>\n</ol>\n</li>\n<li><p>头文件sstream</p>\n<ol>\n<li>istringstream，wistream：从string中读取数据</li>\n<li>ostringstream，wostringstream：向string写入数据</li>\n<li>stringstream，wstringstream：读写string</li>\n</ol>\n</li>\n<li><p>头文件iomanip</p>\n</li>\n</ul>\n<p>在以上流类型中，ifstream和istringstream继承于istream，而ofstream和ostringstream则继承于ostream。IO对象是一种不能进行拷贝或者赋值的对象，而且由于在写过程中对象的状态会发生改变，流对象也不能设置为const（const对象不能调用非const类型的成员函数）。</p>\n<p>在进行IO操作时，难免会发生错误，因此IO类定义了一系列条件状态，如下所示：</p>\n<pre><code>1. ::iostate：是一种机器相关的类型，提供了条件状态的完整功能\n2. ::badbit：表明流已崩溃\n3. ::failbit：表明一个IO操作失败\n4. ::eofbit：表明流已达到末尾\n5. ::goodbit表明流未处于错误状态，值保证为0\n6. .eof()：若eofbit置位则返回true\n7. .fail()：若badbit或failbit置位则返回true\n8. .good()：流有效则返回true\n9. .clear()：所有条件状态复位，流状态成为有效，返回void\n10. .clear(iostate flag)：根据flag标志位将相应条件状态复位，返回void\n11. .setstate(iostate flag)：根据flag标志位将相应条件状态置位，返回void\n12. .rdstate()：返回流当前条件状态，返回值为iostate类型\n</code></pre><p>一旦一个流发生错误，其上所有的后续操作均会失败，只有处于无错状态时才能读写数据。</p>\n<h2 id=\"输出缓冲管理\"><a href=\"#输出缓冲管理\" class=\"headerlink\" title=\"输出缓冲管理\"></a>输出缓冲管理</h2><p>每一个输出流都有一个缓冲区用于保存程序读写的数据。缓冲机制的存在使得输出不一定被立刻显示或者写入文件出来，而导致真正读写发生（即缓冲刷新）主要有如下原因：</p>\n<pre><code>1. 程序正常结束，执行缓冲刷新\n2. 缓冲区满\n3. 使用endl等操作符显式刷新缓冲区\n4. 每个输出操作后用unitbuff设置流的内部状态来清空缓冲区，cerr默认设置unitbuff，因此cerr是立刻刷新的\n5. 一个输出流被关联到另外一个流时，当读写该流时关联流的缓冲区会被立刻刷新，默认cin和cerr关联到cout，导致读cin或者写cerr会刷新cout缓冲区\n</code></pre><p>以下代码为立刻刷新缓冲区的方式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello world!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//输出Hello world!+换行并刷新缓冲区</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello world!\"</span> &lt;&lt; flush; <span class=\"comment\">//输出Hello world!并刷新缓冲区</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello world!\"</span> &lt;&lt; ends; <span class=\"comment\">//输出Hello world!+空字符并刷新缓冲区</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; unitbuff; <span class=\"comment\">//所有输出操作立刻刷新缓冲区</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; nounitbuff; <span class=\"comment\">//还原正常缓冲</span></span><br></pre></td></tr></table></figure>\n<p>在程序崩溃后，输出缓冲将不会被刷新。</p>\n<h2 id=\"关联输入输出流\"><a href=\"#关联输入输出流\" class=\"headerlink\" title=\"关联输入输出流\"></a>关联输入输出流</h2><p>当一个输入流被关联到一个输出流时，任何从输入流读取数据的操作均会导致输出流被刷新。关联流的函数为tie，其重载为两个版本：</p>\n<pre><code>1. tie()无参数，返回指向关联到输出流的指针，没有关联返回空指针\n2. tie(ostream对象指针)，将自己关联到输出流\n</code></pre><p>以下下代码演示关联操作<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cin</span>.tie(&amp;<span class=\"built_in\">cout</span>); <span class=\"comment\">//将cin关联到cout上，标准库默认关联</span></span><br><span class=\"line\">ostream *oldTie = <span class=\"built_in\">cin</span>.tie(<span class=\"literal\">nullptr</span>); <span class=\"comment\">//cin不在与其他流关联</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.tie(&amp;<span class=\"built_in\">cerr</span>); <span class=\"comment\">//关联到cerr，读取cin会刷新cerr</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"文件输入输出\"><a href=\"#文件输入输出\" class=\"headerlink\" title=\"文件输入输出\"></a>文件输入输出</h2><p>头文件fstream定义了文件读写的相关类型。由于fstream继承于iostream，因此iostream操作都可以使用。但是新增了一些操作，如下所示：</p>\n<pre><code>1. fstream fObject(&quot;fileName&quot;)：创建一个流并打开某个文件\n2. fstream fObject(&quot;fileName&quot;, mode)：创建一个流并打开某个文件，mode指定读写模式\n3. fObject.open(&quot;fileName&quot;)：并打开某个文件\n4. fObject.close()：关闭流绑定的文件\n5. fObject.is_open()：判断流是否和文件关联且未关闭并返回bool值\n</code></pre><p>fstream对象在销毁时会自动调用close函数。</p>\n<p>在文件输入输出中，主要有如下读写模式：</p>\n<pre><code>1. in：只读打开，只能对ifstream和fstream设置\n2. out：只写，会覆盖原始数据，只能对ofstream和fstream对象设置\n3. app：每次写均定位到文件末尾，只要trunc没被设置\n4. ate：打开文件后立即定位末尾，可和任何模式组合使用\n5. trunc：截断文件，只有当out被设置时才能被设定\n6. binary：二进制方式读写，可和任何模式组合使用\n</code></pre><h2 id=\"string流\"><a href=\"#string流\" class=\"headerlink\" title=\"string流\"></a>string流</h2><p>在sstream头文件中定义了三个类型来支持内存IO，这几个类型可以直接项string读写数据。sstream也继承自iostream，但有自己一些特殊的操作，如下：</p>\n<pre><code>1. sstream sObject(string s)：保存字符串s的一个拷贝，此构造函数是explicit的，编译器不会自动执行转换\n2. sObject.str()：返回保存的string拷贝\n3. sObject.str(string s)：将字符串s拷贝到对象中，返回void\n</code></pre><p>以下为一个sstream使用范例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, _TCHAR* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stringstream</span> Test;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">data</span><span class=\"params\">(<span class=\"string\">\"Hello World!\"</span>)</span></span>;</span><br><span class=\"line\">        Test.str(data);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> outPut;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (Test &gt;&gt; outPut) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; outPut &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Test.clear();</span><br><span class=\"line\">        Test &lt;&lt; <span class=\"string\">\"Hi\"</span> &lt;&lt; <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个控制台输出为：</p>\n<pre><code>Hello\nWorld!\nHiWorldorld!\n</code></pre><h2 id=\"格式化输入输出\"><a href=\"#格式化输入输出\" class=\"headerlink\" title=\"格式化输入输出\"></a>格式化输入输出</h2><p>标准库定义了一组操纵符用来修改流的格式状态，且格式控制由设置和复原成对出现。具体操作符可见相关手册。</p>\n<p>同时IO库还定义了一组未格式化的输入输出操作，用于将流当成无解释的字节序列（不跳过空格）来处理，具体见下：</p>\n<ul>\n<li><p>单字节操作</p>\n<ol>\n<li>object.get(ch)：读取下一个字节存入ch中，返回对象</li>\n<li>object.put(ch)：将字符写到流中，返回对象</li>\n<li>object.get()：读取下一个字节并作为int类型返回</li>\n<li>object.putback(ch)：读将字符放入流中，返回对象</li>\n<li>object.unget()：将对象object向后移动一个字节，返回对象</li>\n<li>object.peek()：读取下一个字节并作为int类型返回但不从流中删除</li>\n</ol>\n</li>\n<li><p>多字节操作</p>\n<ol>\n<li>obejct.get(sink, size, delim)：从流中最多读出size个字节，遇到delim或者文件结尾或者读满size个字节则停止读写，将delim放在输入流中且不丢弃delim，读出的数据放入sink数组中</li>\n<li>obejct.getline(sink, size, delim)：和get类似，不过会读取并丢弃delim</li>\n<li>obejct.read(sink, size)：读取最多size个字节并放入sink数组</li>\n<li>obejct.gcount()：返回上一个未格式化操作读取的字节数</li>\n<li>obejct.write(src, size)：将数组src的size个字节写入流中</li>\n<li>obejct.ignore(size, delim)：读取并忽略size个字节，包括delim</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"流随机访问\"><a href=\"#流随机访问\" class=\"headerlink\" title=\"流随机访问\"></a>流随机访问</h2><p>大多数系统cin\\cout\\cerr\\clog的流不支持随机访问，因此一般只有istream和ostream支持随机访问。通常由两组函数tell（返回当前位置）和seek（定位到某一位置）根据是输入流还是输出流主要有tellg\\tellp、seekg\\seekp，g表示读取数据，p表示写入数据，函数各定义如下：</p>\n<pre><code>1. tellg\\tellp：返回输入流或者输出流标记的当前位置\n2. sekg(pos)\\seekp(pos)：将输入输出流重定位到决定位置pos\n3. sekg(off, from)、sekp(off, from)：输入输出定位到from之前或者之后的off个字符，from可以是beg（流开始）、cur（流当前）、end（流结尾）    \n</code></pre><h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.weixueyuan.net/view/5875.html\" target=\"_blank\" rel=\"noopener\">C++标准设备的输入/输出（cin,cout,cerr,clog,&gt;&gt;,&lt;&lt;）</a></p>\n<p><a href=\"http://blog.csdn.net/zx824/article/details/6644455\" target=\"_blank\" rel=\"noopener\">c++里关于cerr,clog,cout三者的区别</a></p>\n<p><a href=\"http://www.cnblogs.com/xiezhw3/p/4349766.html\" target=\"_blank\" rel=\"noopener\">clog，cout，cerr 输出机制</a></p>\n<p><a href=\"http://www.cnblogs.com/hjslovewcl/archive/2011/01/10/2314356.html\" target=\"_blank\" rel=\"noopener\">C/C++ 标准输入输出重定向</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-输入输出基础知识\"><a href=\"#C-输入输出基础知识\" class=\"headerlink\" title=\"C++输入输出基础知识\"></a>C++输入输出基础知识</h2><p>C++语言自身没有定义输入输出语句，其通过标准库来提供IO能力。在C++中iostream库为常用的IO库，该库包含两个基础类型istream和ostream，分别表示输入流（即读）与输出流（即写）。其中流指的是一个字符序列。标准库中定义了四个IO对象，分别为cin（标准输入）、cout（标准输出）、cerr（非缓冲标准错误流）、clog（缓冲标准错误流）。在使用诸如“cout&lt;&lt;something;”语句时，该语句返回输入输出流对象的引用，这也是为什么可以采用“cout&lt;&lt;something1&lt;&lt;something2;”这种格式的原因。</p>\n<p>在使用一个istream对象作为条件时，其返回的是输入流的有效状态标记，如果流是有效的则返回真，否则如果读到流末尾（EOF）或者无效输入（读入一个整数实际输入不是整数）返回假。</p>\n<h2 id=\"C-IO库概览\"><a href=\"#C-IO库概览\" class=\"headerlink\" title=\"C++IO库概览\"></a>C++IO库概览</h2><p>C++IO库不仅定义了istream和ostream，还定义其他IO类型，具体见下：</p>\n<ul>\n<li><p>头文件iostream</p>\n<ol>\n<li>istream，wistream：用来从流中读取数据，w代表宽字符（wchar_t）</li>\n<li>ostream，wostream：用来向流写入数据</li>\n<li>iostream，wiostream：读写流。</li>\n</ol>\n</li>\n<li><p>头文件fstream</p>\n<ol>\n<li>ifstream，wifstream：从文件读取数据</li>\n<li>ofstream，wofstream：向文件写入数据</li>\n<li>fstream，wfstream：读写文件</li>\n</ol>\n</li>\n<li><p>头文件sstream</p>\n<ol>\n<li>istringstream，wistream：从string中读取数据</li>\n<li>ostringstream，wostringstream：向string写入数据</li>\n<li>stringstream，wstringstream：读写string</li>\n</ol>\n</li>\n<li><p>头文件iomanip</p>\n</li>\n</ul>\n<p>在以上流类型中，ifstream和istringstream继承于istream，而ofstream和ostringstream则继承于ostream。IO对象是一种不能进行拷贝或者赋值的对象，而且由于在写过程中对象的状态会发生改变，流对象也不能设置为const（const对象不能调用非const类型的成员函数）。</p>\n<p>在进行IO操作时，难免会发生错误，因此IO类定义了一系列条件状态，如下所示：</p>\n<pre><code>1. ::iostate：是一种机器相关的类型，提供了条件状态的完整功能\n2. ::badbit：表明流已崩溃\n3. ::failbit：表明一个IO操作失败\n4. ::eofbit：表明流已达到末尾\n5. ::goodbit表明流未处于错误状态，值保证为0\n6. .eof()：若eofbit置位则返回true\n7. .fail()：若badbit或failbit置位则返回true\n8. .good()：流有效则返回true\n9. .clear()：所有条件状态复位，流状态成为有效，返回void\n10. .clear(iostate flag)：根据flag标志位将相应条件状态复位，返回void\n11. .setstate(iostate flag)：根据flag标志位将相应条件状态置位，返回void\n12. .rdstate()：返回流当前条件状态，返回值为iostate类型\n</code></pre><p>一旦一个流发生错误，其上所有的后续操作均会失败，只有处于无错状态时才能读写数据。</p>\n<h2 id=\"输出缓冲管理\"><a href=\"#输出缓冲管理\" class=\"headerlink\" title=\"输出缓冲管理\"></a>输出缓冲管理</h2><p>每一个输出流都有一个缓冲区用于保存程序读写的数据。缓冲机制的存在使得输出不一定被立刻显示或者写入文件出来，而导致真正读写发生（即缓冲刷新）主要有如下原因：</p>\n<pre><code>1. 程序正常结束，执行缓冲刷新\n2. 缓冲区满\n3. 使用endl等操作符显式刷新缓冲区\n4. 每个输出操作后用unitbuff设置流的内部状态来清空缓冲区，cerr默认设置unitbuff，因此cerr是立刻刷新的\n5. 一个输出流被关联到另外一个流时，当读写该流时关联流的缓冲区会被立刻刷新，默认cin和cerr关联到cout，导致读cin或者写cerr会刷新cout缓冲区\n</code></pre><p>以下代码为立刻刷新缓冲区的方式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello world!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">//输出Hello world!+换行并刷新缓冲区</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello world!\"</span> &lt;&lt; flush; <span class=\"comment\">//输出Hello world!并刷新缓冲区</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello world!\"</span> &lt;&lt; ends; <span class=\"comment\">//输出Hello world!+空字符并刷新缓冲区</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; unitbuff; <span class=\"comment\">//所有输出操作立刻刷新缓冲区</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; nounitbuff; <span class=\"comment\">//还原正常缓冲</span></span><br></pre></td></tr></table></figure>\n<p>在程序崩溃后，输出缓冲将不会被刷新。</p>\n<h2 id=\"关联输入输出流\"><a href=\"#关联输入输出流\" class=\"headerlink\" title=\"关联输入输出流\"></a>关联输入输出流</h2><p>当一个输入流被关联到一个输出流时，任何从输入流读取数据的操作均会导致输出流被刷新。关联流的函数为tie，其重载为两个版本：</p>\n<pre><code>1. tie()无参数，返回指向关联到输出流的指针，没有关联返回空指针\n2. tie(ostream对象指针)，将自己关联到输出流\n</code></pre><p>以下下代码演示关联操作<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cin</span>.tie(&amp;<span class=\"built_in\">cout</span>); <span class=\"comment\">//将cin关联到cout上，标准库默认关联</span></span><br><span class=\"line\">ostream *oldTie = <span class=\"built_in\">cin</span>.tie(<span class=\"literal\">nullptr</span>); <span class=\"comment\">//cin不在与其他流关联</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.tie(&amp;<span class=\"built_in\">cerr</span>); <span class=\"comment\">//关联到cerr，读取cin会刷新cerr</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"文件输入输出\"><a href=\"#文件输入输出\" class=\"headerlink\" title=\"文件输入输出\"></a>文件输入输出</h2><p>头文件fstream定义了文件读写的相关类型。由于fstream继承于iostream，因此iostream操作都可以使用。但是新增了一些操作，如下所示：</p>\n<pre><code>1. fstream fObject(&quot;fileName&quot;)：创建一个流并打开某个文件\n2. fstream fObject(&quot;fileName&quot;, mode)：创建一个流并打开某个文件，mode指定读写模式\n3. fObject.open(&quot;fileName&quot;)：并打开某个文件\n4. fObject.close()：关闭流绑定的文件\n5. fObject.is_open()：判断流是否和文件关联且未关闭并返回bool值\n</code></pre><p>fstream对象在销毁时会自动调用close函数。</p>\n<p>在文件输入输出中，主要有如下读写模式：</p>\n<pre><code>1. in：只读打开，只能对ifstream和fstream设置\n2. out：只写，会覆盖原始数据，只能对ofstream和fstream对象设置\n3. app：每次写均定位到文件末尾，只要trunc没被设置\n4. ate：打开文件后立即定位末尾，可和任何模式组合使用\n5. trunc：截断文件，只有当out被设置时才能被设定\n6. binary：二进制方式读写，可和任何模式组合使用\n</code></pre><h2 id=\"string流\"><a href=\"#string流\" class=\"headerlink\" title=\"string流\"></a>string流</h2><p>在sstream头文件中定义了三个类型来支持内存IO，这几个类型可以直接项string读写数据。sstream也继承自iostream，但有自己一些特殊的操作，如下：</p>\n<pre><code>1. sstream sObject(string s)：保存字符串s的一个拷贝，此构造函数是explicit的，编译器不会自动执行转换\n2. sObject.str()：返回保存的string拷贝\n3. sObject.str(string s)：将字符串s拷贝到对象中，返回void\n</code></pre><p>以下为一个sstream使用范例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, _TCHAR* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stringstream</span> Test;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">data</span><span class=\"params\">(<span class=\"string\">\"Hello World!\"</span>)</span></span>;</span><br><span class=\"line\">        Test.str(data);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> outPut;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (Test &gt;&gt; outPut) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; outPut &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Test.clear();</span><br><span class=\"line\">        Test &lt;&lt; <span class=\"string\">\"Hi\"</span> &lt;&lt; <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个控制台输出为：</p>\n<pre><code>Hello\nWorld!\nHiWorldorld!\n</code></pre><h2 id=\"格式化输入输出\"><a href=\"#格式化输入输出\" class=\"headerlink\" title=\"格式化输入输出\"></a>格式化输入输出</h2><p>标准库定义了一组操纵符用来修改流的格式状态，且格式控制由设置和复原成对出现。具体操作符可见相关手册。</p>\n<p>同时IO库还定义了一组未格式化的输入输出操作，用于将流当成无解释的字节序列（不跳过空格）来处理，具体见下：</p>\n<ul>\n<li><p>单字节操作</p>\n<ol>\n<li>object.get(ch)：读取下一个字节存入ch中，返回对象</li>\n<li>object.put(ch)：将字符写到流中，返回对象</li>\n<li>object.get()：读取下一个字节并作为int类型返回</li>\n<li>object.putback(ch)：读将字符放入流中，返回对象</li>\n<li>object.unget()：将对象object向后移动一个字节，返回对象</li>\n<li>object.peek()：读取下一个字节并作为int类型返回但不从流中删除</li>\n</ol>\n</li>\n<li><p>多字节操作</p>\n<ol>\n<li>obejct.get(sink, size, delim)：从流中最多读出size个字节，遇到delim或者文件结尾或者读满size个字节则停止读写，将delim放在输入流中且不丢弃delim，读出的数据放入sink数组中</li>\n<li>obejct.getline(sink, size, delim)：和get类似，不过会读取并丢弃delim</li>\n<li>obejct.read(sink, size)：读取最多size个字节并放入sink数组</li>\n<li>obejct.gcount()：返回上一个未格式化操作读取的字节数</li>\n<li>obejct.write(src, size)：将数组src的size个字节写入流中</li>\n<li>obejct.ignore(size, delim)：读取并忽略size个字节，包括delim</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"流随机访问\"><a href=\"#流随机访问\" class=\"headerlink\" title=\"流随机访问\"></a>流随机访问</h2><p>大多数系统cin\\cout\\cerr\\clog的流不支持随机访问，因此一般只有istream和ostream支持随机访问。通常由两组函数tell（返回当前位置）和seek（定位到某一位置）根据是输入流还是输出流主要有tellg\\tellp、seekg\\seekp，g表示读取数据，p表示写入数据，函数各定义如下：</p>\n<pre><code>1. tellg\\tellp：返回输入流或者输出流标记的当前位置\n2. sekg(pos)\\seekp(pos)：将输入输出流重定位到决定位置pos\n3. sekg(off, from)、sekp(off, from)：输入输出定位到from之前或者之后的off个字符，from可以是beg（流开始）、cur（流当前）、end（流结尾）    \n</code></pre><h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.weixueyuan.net/view/5875.html\" target=\"_blank\" rel=\"noopener\">C++标准设备的输入/输出（cin,cout,cerr,clog,&gt;&gt;,&lt;&lt;）</a></p>\n<p><a href=\"http://blog.csdn.net/zx824/article/details/6644455\" target=\"_blank\" rel=\"noopener\">c++里关于cerr,clog,cout三者的区别</a></p>\n<p><a href=\"http://www.cnblogs.com/xiezhw3/p/4349766.html\" target=\"_blank\" rel=\"noopener\">clog，cout，cerr 输出机制</a></p>\n<p><a href=\"http://www.cnblogs.com/hjslovewcl/archive/2011/01/10/2314356.html\" target=\"_blank\" rel=\"noopener\">C/C++ 标准输入输出重定向</a></p>\n"},{"title":"C++多态分类及其实现和C模拟实现多态","urlname":"cpp-polymorphism","date":"2018-03-12T04:59:43.000Z","copyright":true,"mathjax":true,"_content":"\n## 多态基础\n\n多态是指程序在运行时，相同的消息给予不同的对象可能会产生不同的行为，可以简单概括为“一个接口，多种方法”。按照多态发生的时机分为动态多态和静态多态。多态是面向对象程序设计三大特征之一（封装、继承、多态）。\n\n## 动态多态\n\n动态多态是指在运行时确定采用的行为，这在C++中动态多态是通过虚函数和继承实现，同时在使用基类指针或者引用调用虚函数时会执行动态绑定。\n\n## 静态多态\n\n静态多态是指在编译时期就能确定行为的一种多态行为，静态动态在C++实现中可分为函数重载与泛型编程。以下分别介绍\n\n### 函数重载\n\n在C++中，函数重载是指函数具有相同的名字但是具有不同参数的函数，在调用函数时编译器根据参数匹配规则选择一个最佳匹配的函数进行调用，调用的函数在编译阶段即完成\n\n### 泛型编程\n\n泛型编程实现的多态又称为参数多态，是指在声明定义函数、复合类型、变量时不指定具体的类型，而把类型作为参数使用，使得该声明定义对各种具体的类型都适用。STL大量使用了泛型编程技术。\n\n## C模拟实现多态\n\n在C++实现动态多态中，其内部原理是采用虚函数表+虚函数表指针的方式。在定义了虚函数的类中，编译器会自动添加一个虚函数表指针，通过该指针在运行过程可以正确找到需要调用函数的入口地址（函数指针）。在C中，有一种指针void *称为无类型指针，这种指针可以指向任意的数据类型，因此我们可以通过该指针实现不同数据的定义以及处理方式，比如我定义一个数据处理基结构，其定义如下：\n\n```cpp\nstruct Base\n{\n\tvoid *data; //数据\n\t//dealFun是一个指针，指向一个返回值为void且参数 void *类型\n\tvoid (*dealFun)(void *inData); \n};\n\nstruct CString\n{\n\tchar *cData;\n\tvoid (*dealFun)(void *inData); //假设为一逐字符打印函数\n};\n\n//链表节点\nstruct Node\n{\n\tint data;\n\tNode *next;\n};\n\nstruct List\n{\n\tNode *listData; //单链表\n\tvoid (*dealFun)(void *inData); //假设为打印单链表函数\n};\n\nvoid printCString(void *CString)\n{\n\tchar *cycleIter = (char *)CString;\n\twhile (cycleIter != nullptr && *cycleIter != '\\0') {\n\t\tprintf(\"%c\", *cycleIter); ++cycleIter;\n\t}\n\tprintf(\"\\n\");\n}\n\nvoid printNode(void *inNode)\n{\n\tNode *cycleIter = (Node *)inNode;\n\twhile (cycleIter != nullptr) {\n\t\tprintf(\"%d\\t\", cycleIter->data);\n\t\tcycleIter = cycleIter->next;\n\t}\n\tprintf(\"\\n\");\n}\n\n\n\nint main()\n{\n\tCString cData = {\"Hello world\", &printCString};\n\tNode nodeData[2] = {{0,&nodeData[1]},{1,nullptr}};\n\tList listData = {nodeData, &printNode};\n\tBase *test1 = (Base *)&cData;\n\tBase *test2 = (Base *)&listData;\n\ttest1->dealFun(test1->data);\n\ttest2->dealFun(test2->data);\n\treturn 0;\n}\n\n```\n\n上述程序输出的结果为：\n\n\tHello world\n\t0       1\n\n\n\n## 参考文章\n\n[多态分类-强制多态，参数多态，过载多态，包含多态的理解](http://www.cnblogs.com/gaojing/archive/2007/05/03/735004.html)\n\n[C++ 多态深度剖析](http://blog.jobbole.com/107432/)\n\n[多态 (计算机科学)](https://zh.wikipedia.org/wiki/多型_(计算机科学))\n\n[技巧：用C语言实现程序的多态性](https://www.ibm.com/developerworks/cn/linux/l-cn-cpolym/index.html)\n\n[C语言实现多态](https://www.jianshu.com/p/bcecbfa8ff81)","source":"_posts/C++/C++多态分类及其实现和C模拟实现多态.md","raw":"---\ntitle: C++多态分类及其实现和C模拟实现多态\nurlname: cpp-polymorphism\ndate: 2018-03-12 12:59:43\ncopyright: true\nmathjax: true\ntags:\n- C++\ncategories:\n- C++\n---\n\n## 多态基础\n\n多态是指程序在运行时，相同的消息给予不同的对象可能会产生不同的行为，可以简单概括为“一个接口，多种方法”。按照多态发生的时机分为动态多态和静态多态。多态是面向对象程序设计三大特征之一（封装、继承、多态）。\n\n## 动态多态\n\n动态多态是指在运行时确定采用的行为，这在C++中动态多态是通过虚函数和继承实现，同时在使用基类指针或者引用调用虚函数时会执行动态绑定。\n\n## 静态多态\n\n静态多态是指在编译时期就能确定行为的一种多态行为，静态动态在C++实现中可分为函数重载与泛型编程。以下分别介绍\n\n### 函数重载\n\n在C++中，函数重载是指函数具有相同的名字但是具有不同参数的函数，在调用函数时编译器根据参数匹配规则选择一个最佳匹配的函数进行调用，调用的函数在编译阶段即完成\n\n### 泛型编程\n\n泛型编程实现的多态又称为参数多态，是指在声明定义函数、复合类型、变量时不指定具体的类型，而把类型作为参数使用，使得该声明定义对各种具体的类型都适用。STL大量使用了泛型编程技术。\n\n## C模拟实现多态\n\n在C++实现动态多态中，其内部原理是采用虚函数表+虚函数表指针的方式。在定义了虚函数的类中，编译器会自动添加一个虚函数表指针，通过该指针在运行过程可以正确找到需要调用函数的入口地址（函数指针）。在C中，有一种指针void *称为无类型指针，这种指针可以指向任意的数据类型，因此我们可以通过该指针实现不同数据的定义以及处理方式，比如我定义一个数据处理基结构，其定义如下：\n\n```cpp\nstruct Base\n{\n\tvoid *data; //数据\n\t//dealFun是一个指针，指向一个返回值为void且参数 void *类型\n\tvoid (*dealFun)(void *inData); \n};\n\nstruct CString\n{\n\tchar *cData;\n\tvoid (*dealFun)(void *inData); //假设为一逐字符打印函数\n};\n\n//链表节点\nstruct Node\n{\n\tint data;\n\tNode *next;\n};\n\nstruct List\n{\n\tNode *listData; //单链表\n\tvoid (*dealFun)(void *inData); //假设为打印单链表函数\n};\n\nvoid printCString(void *CString)\n{\n\tchar *cycleIter = (char *)CString;\n\twhile (cycleIter != nullptr && *cycleIter != '\\0') {\n\t\tprintf(\"%c\", *cycleIter); ++cycleIter;\n\t}\n\tprintf(\"\\n\");\n}\n\nvoid printNode(void *inNode)\n{\n\tNode *cycleIter = (Node *)inNode;\n\twhile (cycleIter != nullptr) {\n\t\tprintf(\"%d\\t\", cycleIter->data);\n\t\tcycleIter = cycleIter->next;\n\t}\n\tprintf(\"\\n\");\n}\n\n\n\nint main()\n{\n\tCString cData = {\"Hello world\", &printCString};\n\tNode nodeData[2] = {{0,&nodeData[1]},{1,nullptr}};\n\tList listData = {nodeData, &printNode};\n\tBase *test1 = (Base *)&cData;\n\tBase *test2 = (Base *)&listData;\n\ttest1->dealFun(test1->data);\n\ttest2->dealFun(test2->data);\n\treturn 0;\n}\n\n```\n\n上述程序输出的结果为：\n\n\tHello world\n\t0       1\n\n\n\n## 参考文章\n\n[多态分类-强制多态，参数多态，过载多态，包含多态的理解](http://www.cnblogs.com/gaojing/archive/2007/05/03/735004.html)\n\n[C++ 多态深度剖析](http://blog.jobbole.com/107432/)\n\n[多态 (计算机科学)](https://zh.wikipedia.org/wiki/多型_(计算机科学))\n\n[技巧：用C语言实现程序的多态性](https://www.ibm.com/developerworks/cn/linux/l-cn-cpolym/index.html)\n\n[C语言实现多态](https://www.jianshu.com/p/bcecbfa8ff81)","slug":"C++/C++多态分类及其实现和C模拟实现多态","published":1,"updated":"2018-06-13T14:22:16.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x2h0001gsvnprmvglig","content":"<h2 id=\"多态基础\"><a href=\"#多态基础\" class=\"headerlink\" title=\"多态基础\"></a>多态基础</h2><p>多态是指程序在运行时，相同的消息给予不同的对象可能会产生不同的行为，可以简单概括为“一个接口，多种方法”。按照多态发生的时机分为动态多态和静态多态。多态是面向对象程序设计三大特征之一（封装、继承、多态）。</p>\n<h2 id=\"动态多态\"><a href=\"#动态多态\" class=\"headerlink\" title=\"动态多态\"></a>动态多态</h2><p>动态多态是指在运行时确定采用的行为，这在C++中动态多态是通过虚函数和继承实现，同时在使用基类指针或者引用调用虚函数时会执行动态绑定。</p>\n<h2 id=\"静态多态\"><a href=\"#静态多态\" class=\"headerlink\" title=\"静态多态\"></a>静态多态</h2><p>静态多态是指在编译时期就能确定行为的一种多态行为，静态动态在C++实现中可分为函数重载与泛型编程。以下分别介绍</p>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>在C++中，函数重载是指函数具有相同的名字但是具有不同参数的函数，在调用函数时编译器根据参数匹配规则选择一个最佳匹配的函数进行调用，调用的函数在编译阶段即完成</p>\n<h3 id=\"泛型编程\"><a href=\"#泛型编程\" class=\"headerlink\" title=\"泛型编程\"></a>泛型编程</h3><p>泛型编程实现的多态又称为参数多态，是指在声明定义函数、复合类型、变量时不指定具体的类型，而把类型作为参数使用，使得该声明定义对各种具体的类型都适用。STL大量使用了泛型编程技术。</p>\n<h2 id=\"C模拟实现多态\"><a href=\"#C模拟实现多态\" class=\"headerlink\" title=\"C模拟实现多态\"></a>C模拟实现多态</h2><p>在C++实现动态多态中，其内部原理是采用虚函数表+虚函数表指针的方式。在定义了虚函数的类中，编译器会自动添加一个虚函数表指针，通过该指针在运行过程可以正确找到需要调用函数的入口地址（函数指针）。在C中，有一种指针void *称为无类型指针，这种指针可以指向任意的数据类型，因此我们可以通过该指针实现不同数据的定义以及处理方式，比如我定义一个数据处理基结构，其定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\t<span class=\"comment\">//dealFun是一个指针，指向一个返回值为void且参数 void *类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealFun)(<span class=\"keyword\">void</span> *inData); </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CString</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *cData;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealFun)(<span class=\"keyword\">void</span> *inData); <span class=\"comment\">//假设为一逐字符打印函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//链表节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tNode *listData; <span class=\"comment\">//单链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealFun)(<span class=\"keyword\">void</span> *inData); <span class=\"comment\">//假设为打印单链表函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printCString</span><span class=\"params\">(<span class=\"keyword\">void</span> *CString)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *cycleIter = (<span class=\"keyword\">char</span> *)CString;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> &amp;&amp; *cycleIter != <span class=\"string\">'\\0'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, *cycleIter); ++cycleIter;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printNode</span><span class=\"params\">(<span class=\"keyword\">void</span> *inNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tNode *cycleIter = (Node *)inNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\t\"</span>, cycleIter-&gt;data);</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tCString cData = &#123;<span class=\"string\">\"Hello world\"</span>, &amp;printCString&#125;;</span><br><span class=\"line\">\tNode nodeData[<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">0</span>,&amp;nodeData[<span class=\"number\">1</span>]&#125;,&#123;<span class=\"number\">1</span>,<span class=\"literal\">nullptr</span>&#125;&#125;;</span><br><span class=\"line\">\tList listData = &#123;nodeData, &amp;printNode&#125;;</span><br><span class=\"line\">\tBase *test1 = (Base *)&amp;cData;</span><br><span class=\"line\">\tBase *test2 = (Base *)&amp;listData;</span><br><span class=\"line\">\ttest1-&gt;dealFun(test1-&gt;data);</span><br><span class=\"line\">\ttest2-&gt;dealFun(test2-&gt;data);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述程序输出的结果为：</p>\n<pre><code>Hello world\n0       1\n</code></pre><h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.cnblogs.com/gaojing/archive/2007/05/03/735004.html\" target=\"_blank\" rel=\"noopener\">多态分类-强制多态，参数多态，过载多态，包含多态的理解</a></p>\n<p><a href=\"http://blog.jobbole.com/107432/\" target=\"_blank\" rel=\"noopener\">C++ 多态深度剖析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/多型_(计算机科学\" target=\"_blank\" rel=\"noopener\">多态 (计算机科学)</a>)</p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-cpolym/index.html\" target=\"_blank\" rel=\"noopener\">技巧：用C语言实现程序的多态性</a></p>\n<p><a href=\"https://www.jianshu.com/p/bcecbfa8ff81\" target=\"_blank\" rel=\"noopener\">C语言实现多态</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"多态基础\"><a href=\"#多态基础\" class=\"headerlink\" title=\"多态基础\"></a>多态基础</h2><p>多态是指程序在运行时，相同的消息给予不同的对象可能会产生不同的行为，可以简单概括为“一个接口，多种方法”。按照多态发生的时机分为动态多态和静态多态。多态是面向对象程序设计三大特征之一（封装、继承、多态）。</p>\n<h2 id=\"动态多态\"><a href=\"#动态多态\" class=\"headerlink\" title=\"动态多态\"></a>动态多态</h2><p>动态多态是指在运行时确定采用的行为，这在C++中动态多态是通过虚函数和继承实现，同时在使用基类指针或者引用调用虚函数时会执行动态绑定。</p>\n<h2 id=\"静态多态\"><a href=\"#静态多态\" class=\"headerlink\" title=\"静态多态\"></a>静态多态</h2><p>静态多态是指在编译时期就能确定行为的一种多态行为，静态动态在C++实现中可分为函数重载与泛型编程。以下分别介绍</p>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>在C++中，函数重载是指函数具有相同的名字但是具有不同参数的函数，在调用函数时编译器根据参数匹配规则选择一个最佳匹配的函数进行调用，调用的函数在编译阶段即完成</p>\n<h3 id=\"泛型编程\"><a href=\"#泛型编程\" class=\"headerlink\" title=\"泛型编程\"></a>泛型编程</h3><p>泛型编程实现的多态又称为参数多态，是指在声明定义函数、复合类型、变量时不指定具体的类型，而把类型作为参数使用，使得该声明定义对各种具体的类型都适用。STL大量使用了泛型编程技术。</p>\n<h2 id=\"C模拟实现多态\"><a href=\"#C模拟实现多态\" class=\"headerlink\" title=\"C模拟实现多态\"></a>C模拟实现多态</h2><p>在C++实现动态多态中，其内部原理是采用虚函数表+虚函数表指针的方式。在定义了虚函数的类中，编译器会自动添加一个虚函数表指针，通过该指针在运行过程可以正确找到需要调用函数的入口地址（函数指针）。在C中，有一种指针void *称为无类型指针，这种指针可以指向任意的数据类型，因此我们可以通过该指针实现不同数据的定义以及处理方式，比如我定义一个数据处理基结构，其定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\t<span class=\"comment\">//dealFun是一个指针，指向一个返回值为void且参数 void *类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealFun)(<span class=\"keyword\">void</span> *inData); </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CString</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *cData;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealFun)(<span class=\"keyword\">void</span> *inData); <span class=\"comment\">//假设为一逐字符打印函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//链表节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tNode *listData; <span class=\"comment\">//单链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealFun)(<span class=\"keyword\">void</span> *inData); <span class=\"comment\">//假设为打印单链表函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printCString</span><span class=\"params\">(<span class=\"keyword\">void</span> *CString)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *cycleIter = (<span class=\"keyword\">char</span> *)CString;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> &amp;&amp; *cycleIter != <span class=\"string\">'\\0'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, *cycleIter); ++cycleIter;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printNode</span><span class=\"params\">(<span class=\"keyword\">void</span> *inNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tNode *cycleIter = (Node *)inNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\t\"</span>, cycleIter-&gt;data);</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tCString cData = &#123;<span class=\"string\">\"Hello world\"</span>, &amp;printCString&#125;;</span><br><span class=\"line\">\tNode nodeData[<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">0</span>,&amp;nodeData[<span class=\"number\">1</span>]&#125;,&#123;<span class=\"number\">1</span>,<span class=\"literal\">nullptr</span>&#125;&#125;;</span><br><span class=\"line\">\tList listData = &#123;nodeData, &amp;printNode&#125;;</span><br><span class=\"line\">\tBase *test1 = (Base *)&amp;cData;</span><br><span class=\"line\">\tBase *test2 = (Base *)&amp;listData;</span><br><span class=\"line\">\ttest1-&gt;dealFun(test1-&gt;data);</span><br><span class=\"line\">\ttest2-&gt;dealFun(test2-&gt;data);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述程序输出的结果为：</p>\n<pre><code>Hello world\n0       1\n</code></pre><h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.cnblogs.com/gaojing/archive/2007/05/03/735004.html\" target=\"_blank\" rel=\"noopener\">多态分类-强制多态，参数多态，过载多态，包含多态的理解</a></p>\n<p><a href=\"http://blog.jobbole.com/107432/\" target=\"_blank\" rel=\"noopener\">C++ 多态深度剖析</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/多型_(计算机科学\" target=\"_blank\" rel=\"noopener\">多态 (计算机科学)</a>)</p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-cpolym/index.html\" target=\"_blank\" rel=\"noopener\">技巧：用C语言实现程序的多态性</a></p>\n<p><a href=\"https://www.jianshu.com/p/bcecbfa8ff81\" target=\"_blank\" rel=\"noopener\">C语言实现多态</a></p>\n"},{"title":"C/C++类型转换总结","urlname":"cpp-type-convert","date":"2018-03-13T02:40:43.000Z","copyright":true,"mathjax":true,"_content":"\n## 类型转换基础\n\n对象的类型定义了对象能包含的数据和能够参与的运算，如果在表达式中混杂了多种不同的类型，编译器可能（有些类型转换非法则编译错误）会帮我们进行隐式的类型转换。如果两种类型能够进行相互转换则称两种类型是关联的。类型在进行隐式转换总体规则向上提升，即转换成精度和表达范围更广的数据类型。类型转换按照是否为自动可分为隐式转换和显式转换。隐式转换是由编译器自动完成的，无需编程人员的介入，显示转换是编程人员希望进行类型转换而显式要求编译器进行类型转换的过程。\n\n## 隐式转换\n\n在表达式中，如果我们在不同类型之间进行赋值，其根据类型不同得到不同的结果，如下为基本的转换规则\n\n1. 非布尔->布尔：0->false; 非0->true\n2. 布尔->非布尔：false->0; true->1\n3. 浮点->整数：近似处理，保留浮点数小数点之前的部分\n4. 整数->浮点数：小数部分记为0，如果整数所占空间超过浮点类型容量，精度会产生损失\n5. 给无符号类型一个超过其表示范围的值时，结果是初始值对无符号类型表示数值的总数取模以后的余数。例如unsigned char(8 bit) 可以表示0-255，如果赋一个区间以外的值，则实际结果为该值对256取模所得的余数。unsigned char x = -1; // x = 255\n6. 当赋给带符号类型一个超过其表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃，也可能产生垃圾数据（未定义）\n7. 无符号数转换为更大的数据类型时, 只需简单地在开头添加0，这种运算称为0扩展\n8. 将有符号数转换为更大的数据类型需要执行符号扩展，规则是将当前数符号位扩展至所需要的位数\n9. 当数据类型转换时，同时需要在不同数据大小，以及无符号和有符号之间转换时，C语言标准要求先进行数据大小的转换，之后再进行无符号和有符号之间的转换。C语言中的强制类型转换保持二进制位值不变，只是改变解释位的方式。\n10. 将一个大的数据类型转换为小的数据类型时，不管是无符号数还是有符号数都是简单地进行位截断\n11. 进行整数的算术运算时，当结果变量的位数不足以存放实际实际结果的位数时，运算的结果就会因截断而产生溢出\n\n如下图所示为一段测试代码：\n\n```cpp\n#include <iostream>\n#include <limits>\nusing namespace std;\n\nint main()\n{\n\tbool bValue = true;\n\tchar cValue = numeric_limits<char>::max();\n\tshort sValue = numeric_limits<short>::max();\n\tint iValue = numeric_limits<int>::max();\n\tlong lValue = numeric_limits<long>::max();\n\tlong long llValue = numeric_limits<long long>::max();\n\tfloat fValue = numeric_limits<float>::max();\n\tdouble dValue = numeric_limits<double>::max();\n\tlong double ldValue = numeric_limits<long double>::max();\n\n\t//测试开始\n\tcout << (bValue=cValue) << \" \" << (bValue=sValue) << \" \" << (bValue=iValue) <<endl;\n\tcout << (bValue=lValue) << \" \" << (bValue=llValue) << \" \" << (bValue=fValue) <<endl;\n\tcout << (bValue=dValue) << \" \" << (bValue=ldValue) << endl;\n}\n```\n\n以上输出为全1。在进行未定义转换时，可能不同的编译器结果不一致。由于无符号与有符号之间的转换往往出乎意料，一般避免进行转换。\n\n隐式转换主要发生在以下情况中：\n\n        1. 在大多数表达式中，比int类型小的整型值提升为较大的整数类型\n        2. 在条件中，非布尔值转换为布尔类型\n        3. 初始化或者赋值语句，右侧转变为左侧类型\n        4. 如果算数运算表达式有多种类型，需要转换成同一种类型\n        5. 函数调用\n\n## 整型提升\n\n整型提升负责把小整数装换成较大的整数类型，对于bool、char、signed char、unsigned char、short、unisned short等类型，只要他们所有可能的值都能存在int类型中，就会提升为int，否则提升为unsigned int。wchar_t、char16_t、char32_6提升成int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种，前提是能容纳原始类型所有可能的值\n\n无符号与有符号之间的转换有几种情况：\n\n1. 如果无符号类型不小于带符号类型，则有符号类型转换成无符号类型，如int需要转换成unsigned int。如果有符号是负数，则取模运算\n2. 如果带符号大于无符号且带符号类型可以容纳所有无符号值，则转换成带符号，否则转换成无符号。比如long和unsigned int，如果int和long大小相同，则long类型转换成unsigned int。\n\n## 其他隐式转换\n\n数组转换成指针，比如如下代码：\n\n```cpp\nint ia[10];\nint *ip = ia; //ia转换成指向数组首元素的指针\n```\n\n当数组被用作decltype或者取址&、sizeof以及typeid等运算符时，上述转换不会发生。\n\n常量整型和字面值nullptr能转换成任意的指针类型，任意非常量指针能转换成void \\*指针，指向任意对象的指针能转换成const void\\*。\n\n\n## 显式转换\n\n在C++中，有四种命名的强制类型转换关键字，分别为static_cast、dynamic_cast、const_cast、reinterpret_cast。基本使用格式为cast-name<type>(expression)，其中cast-name是上述四种转换类型，type为需要转换的类型，expression是要转换的值。现分别介绍如下：[文字来源](http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html)\n\n### static_cast\n\n类似于C风格的强制转换。无条件转换，静态类型转换。用于：\n\n1. 基类和子类之间转换：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的。(基类和子类之间的动态类型转换建议用dynamic_cast)\n2. 基本数据类型转换。enum, struct, int, char, float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。\n3. 把空指针转换成目标类型的空指针。\n4. static_cast不能去掉类型的const、volitale属性(用const_cast)。\n\n### dynamic_cast\n\n有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：\n\n1. 安全的基类和子类之间转换。\n2. 必须要有虚函数。\n3. 相同基类不同子类之间的交叉转换。但结果是NULL\n\n### const_cast\n\n去掉类型的const或volatile属性。\n\n### reinterpret_cast\n\n仅仅重新解释类型，但没有进行二进制的转换：\n\n1. 转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。\n2. 在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。\n3. 最普通的用途就是在函数指针类型之间进行转换。\n4. 很难保证移植性。\n\n用法可以总结如下：\n\n1. 去const属性用const_cast。\n2. 基本类型转换用static_cast。\n3. 多态类之间的类型转换用daynamic_cast。\n4. 不同类型的指针类型转换用reinterpret_cast。\n\n## 参考文章\n\n[有符号数和无符号数的转换及思考](http://blog.csdn.net/gatieme/article/details/52557546)\n\n[C++类型转换总结](http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html)\n\n[c++数据类型转换：static_cast dynamic_cast reinterpret_cast const_cast](http://www.cnblogs.com/TenosDoIt/p/3175217.html)\n\n[C++ - 隐式转换与四种强制类型转换](http://cuckootan.me/2016/05/28/C/C++/C++%20-%20隐式转换与四种强制类型转换/)\n\n[c++ 四种强制类型转换介绍](http://blog.csdn.net/ydar95/article/details/69822540)","source":"_posts/C++/C-C++类型转换总结.md","raw":"---\ntitle: C/C++类型转换总结\nurlname: cpp-type-convert\ndate: 2018-03-13 10:40:43\ncopyright: true\nmathjax: true\ntags:\n- C++\ncategories:\n- C++\n---\n\n## 类型转换基础\n\n对象的类型定义了对象能包含的数据和能够参与的运算，如果在表达式中混杂了多种不同的类型，编译器可能（有些类型转换非法则编译错误）会帮我们进行隐式的类型转换。如果两种类型能够进行相互转换则称两种类型是关联的。类型在进行隐式转换总体规则向上提升，即转换成精度和表达范围更广的数据类型。类型转换按照是否为自动可分为隐式转换和显式转换。隐式转换是由编译器自动完成的，无需编程人员的介入，显示转换是编程人员希望进行类型转换而显式要求编译器进行类型转换的过程。\n\n## 隐式转换\n\n在表达式中，如果我们在不同类型之间进行赋值，其根据类型不同得到不同的结果，如下为基本的转换规则\n\n1. 非布尔->布尔：0->false; 非0->true\n2. 布尔->非布尔：false->0; true->1\n3. 浮点->整数：近似处理，保留浮点数小数点之前的部分\n4. 整数->浮点数：小数部分记为0，如果整数所占空间超过浮点类型容量，精度会产生损失\n5. 给无符号类型一个超过其表示范围的值时，结果是初始值对无符号类型表示数值的总数取模以后的余数。例如unsigned char(8 bit) 可以表示0-255，如果赋一个区间以外的值，则实际结果为该值对256取模所得的余数。unsigned char x = -1; // x = 255\n6. 当赋给带符号类型一个超过其表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃，也可能产生垃圾数据（未定义）\n7. 无符号数转换为更大的数据类型时, 只需简单地在开头添加0，这种运算称为0扩展\n8. 将有符号数转换为更大的数据类型需要执行符号扩展，规则是将当前数符号位扩展至所需要的位数\n9. 当数据类型转换时，同时需要在不同数据大小，以及无符号和有符号之间转换时，C语言标准要求先进行数据大小的转换，之后再进行无符号和有符号之间的转换。C语言中的强制类型转换保持二进制位值不变，只是改变解释位的方式。\n10. 将一个大的数据类型转换为小的数据类型时，不管是无符号数还是有符号数都是简单地进行位截断\n11. 进行整数的算术运算时，当结果变量的位数不足以存放实际实际结果的位数时，运算的结果就会因截断而产生溢出\n\n如下图所示为一段测试代码：\n\n```cpp\n#include <iostream>\n#include <limits>\nusing namespace std;\n\nint main()\n{\n\tbool bValue = true;\n\tchar cValue = numeric_limits<char>::max();\n\tshort sValue = numeric_limits<short>::max();\n\tint iValue = numeric_limits<int>::max();\n\tlong lValue = numeric_limits<long>::max();\n\tlong long llValue = numeric_limits<long long>::max();\n\tfloat fValue = numeric_limits<float>::max();\n\tdouble dValue = numeric_limits<double>::max();\n\tlong double ldValue = numeric_limits<long double>::max();\n\n\t//测试开始\n\tcout << (bValue=cValue) << \" \" << (bValue=sValue) << \" \" << (bValue=iValue) <<endl;\n\tcout << (bValue=lValue) << \" \" << (bValue=llValue) << \" \" << (bValue=fValue) <<endl;\n\tcout << (bValue=dValue) << \" \" << (bValue=ldValue) << endl;\n}\n```\n\n以上输出为全1。在进行未定义转换时，可能不同的编译器结果不一致。由于无符号与有符号之间的转换往往出乎意料，一般避免进行转换。\n\n隐式转换主要发生在以下情况中：\n\n        1. 在大多数表达式中，比int类型小的整型值提升为较大的整数类型\n        2. 在条件中，非布尔值转换为布尔类型\n        3. 初始化或者赋值语句，右侧转变为左侧类型\n        4. 如果算数运算表达式有多种类型，需要转换成同一种类型\n        5. 函数调用\n\n## 整型提升\n\n整型提升负责把小整数装换成较大的整数类型，对于bool、char、signed char、unsigned char、short、unisned short等类型，只要他们所有可能的值都能存在int类型中，就会提升为int，否则提升为unsigned int。wchar_t、char16_t、char32_6提升成int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种，前提是能容纳原始类型所有可能的值\n\n无符号与有符号之间的转换有几种情况：\n\n1. 如果无符号类型不小于带符号类型，则有符号类型转换成无符号类型，如int需要转换成unsigned int。如果有符号是负数，则取模运算\n2. 如果带符号大于无符号且带符号类型可以容纳所有无符号值，则转换成带符号，否则转换成无符号。比如long和unsigned int，如果int和long大小相同，则long类型转换成unsigned int。\n\n## 其他隐式转换\n\n数组转换成指针，比如如下代码：\n\n```cpp\nint ia[10];\nint *ip = ia; //ia转换成指向数组首元素的指针\n```\n\n当数组被用作decltype或者取址&、sizeof以及typeid等运算符时，上述转换不会发生。\n\n常量整型和字面值nullptr能转换成任意的指针类型，任意非常量指针能转换成void \\*指针，指向任意对象的指针能转换成const void\\*。\n\n\n## 显式转换\n\n在C++中，有四种命名的强制类型转换关键字，分别为static_cast、dynamic_cast、const_cast、reinterpret_cast。基本使用格式为cast-name<type>(expression)，其中cast-name是上述四种转换类型，type为需要转换的类型，expression是要转换的值。现分别介绍如下：[文字来源](http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html)\n\n### static_cast\n\n类似于C风格的强制转换。无条件转换，静态类型转换。用于：\n\n1. 基类和子类之间转换：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的。(基类和子类之间的动态类型转换建议用dynamic_cast)\n2. 基本数据类型转换。enum, struct, int, char, float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。\n3. 把空指针转换成目标类型的空指针。\n4. static_cast不能去掉类型的const、volitale属性(用const_cast)。\n\n### dynamic_cast\n\n有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：\n\n1. 安全的基类和子类之间转换。\n2. 必须要有虚函数。\n3. 相同基类不同子类之间的交叉转换。但结果是NULL\n\n### const_cast\n\n去掉类型的const或volatile属性。\n\n### reinterpret_cast\n\n仅仅重新解释类型，但没有进行二进制的转换：\n\n1. 转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。\n2. 在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。\n3. 最普通的用途就是在函数指针类型之间进行转换。\n4. 很难保证移植性。\n\n用法可以总结如下：\n\n1. 去const属性用const_cast。\n2. 基本类型转换用static_cast。\n3. 多态类之间的类型转换用daynamic_cast。\n4. 不同类型的指针类型转换用reinterpret_cast。\n\n## 参考文章\n\n[有符号数和无符号数的转换及思考](http://blog.csdn.net/gatieme/article/details/52557546)\n\n[C++类型转换总结](http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html)\n\n[c++数据类型转换：static_cast dynamic_cast reinterpret_cast const_cast](http://www.cnblogs.com/TenosDoIt/p/3175217.html)\n\n[C++ - 隐式转换与四种强制类型转换](http://cuckootan.me/2016/05/28/C/C++/C++%20-%20隐式转换与四种强制类型转换/)\n\n[c++ 四种强制类型转换介绍](http://blog.csdn.net/ydar95/article/details/69822540)","slug":"C++/C-C++类型转换总结","published":1,"updated":"2018-06-13T14:22:08.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x2n0003gsvn7aqx9rxu","content":"<h2 id=\"类型转换基础\"><a href=\"#类型转换基础\" class=\"headerlink\" title=\"类型转换基础\"></a>类型转换基础</h2><p>对象的类型定义了对象能包含的数据和能够参与的运算，如果在表达式中混杂了多种不同的类型，编译器可能（有些类型转换非法则编译错误）会帮我们进行隐式的类型转换。如果两种类型能够进行相互转换则称两种类型是关联的。类型在进行隐式转换总体规则向上提升，即转换成精度和表达范围更广的数据类型。类型转换按照是否为自动可分为隐式转换和显式转换。隐式转换是由编译器自动完成的，无需编程人员的介入，显示转换是编程人员希望进行类型转换而显式要求编译器进行类型转换的过程。</p>\n<h2 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h2><p>在表达式中，如果我们在不同类型之间进行赋值，其根据类型不同得到不同的结果，如下为基本的转换规则</p>\n<ol>\n<li>非布尔-&gt;布尔：0-&gt;false; 非0-&gt;true</li>\n<li>布尔-&gt;非布尔：false-&gt;0; true-&gt;1</li>\n<li>浮点-&gt;整数：近似处理，保留浮点数小数点之前的部分</li>\n<li>整数-&gt;浮点数：小数部分记为0，如果整数所占空间超过浮点类型容量，精度会产生损失</li>\n<li>给无符号类型一个超过其表示范围的值时，结果是初始值对无符号类型表示数值的总数取模以后的余数。例如unsigned char(8 bit) 可以表示0-255，如果赋一个区间以外的值，则实际结果为该值对256取模所得的余数。unsigned char x = -1; // x = 255</li>\n<li>当赋给带符号类型一个超过其表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃，也可能产生垃圾数据（未定义）</li>\n<li>无符号数转换为更大的数据类型时, 只需简单地在开头添加0，这种运算称为0扩展</li>\n<li>将有符号数转换为更大的数据类型需要执行符号扩展，规则是将当前数符号位扩展至所需要的位数</li>\n<li>当数据类型转换时，同时需要在不同数据大小，以及无符号和有符号之间转换时，C语言标准要求先进行数据大小的转换，之后再进行无符号和有符号之间的转换。C语言中的强制类型转换保持二进制位值不变，只是改变解释位的方式。</li>\n<li>将一个大的数据类型转换为小的数据类型时，不管是无符号数还是有符号数都是简单地进行位截断</li>\n<li>进行整数的算术运算时，当结果变量的位数不足以存放实际实际结果的位数时，运算的结果就会因截断而产生溢出</li>\n</ol>\n<p>如下图所示为一段测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;limits&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> bValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cValue = numeric_limits&lt;<span class=\"keyword\">char</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">short</span> sValue = numeric_limits&lt;<span class=\"keyword\">short</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> iValue = numeric_limits&lt;<span class=\"keyword\">int</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> lValue = numeric_limits&lt;<span class=\"keyword\">long</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> llValue = numeric_limits&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> fValue = numeric_limits&lt;<span class=\"keyword\">float</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> dValue = numeric_limits&lt;<span class=\"keyword\">double</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">double</span> ldValue = numeric_limits&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">double</span>&gt;::max();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//测试开始</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; (bValue=cValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=sValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=iValue) &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; (bValue=lValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=llValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=fValue) &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; (bValue=dValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=ldValue) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上输出为全1。在进行未定义转换时，可能不同的编译器结果不一致。由于无符号与有符号之间的转换往往出乎意料，一般避免进行转换。</p>\n<p>隐式转换主要发生在以下情况中：</p>\n<pre><code>1. 在大多数表达式中，比int类型小的整型值提升为较大的整数类型\n2. 在条件中，非布尔值转换为布尔类型\n3. 初始化或者赋值语句，右侧转变为左侧类型\n4. 如果算数运算表达式有多种类型，需要转换成同一种类型\n5. 函数调用\n</code></pre><h2 id=\"整型提升\"><a href=\"#整型提升\" class=\"headerlink\" title=\"整型提升\"></a>整型提升</h2><p>整型提升负责把小整数装换成较大的整数类型，对于bool、char、signed char、unsigned char、short、unisned short等类型，只要他们所有可能的值都能存在int类型中，就会提升为int，否则提升为unsigned int。wchar_t、char16_t、char32_6提升成int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种，前提是能容纳原始类型所有可能的值</p>\n<p>无符号与有符号之间的转换有几种情况：</p>\n<ol>\n<li>如果无符号类型不小于带符号类型，则有符号类型转换成无符号类型，如int需要转换成unsigned int。如果有符号是负数，则取模运算</li>\n<li>如果带符号大于无符号且带符号类型可以容纳所有无符号值，则转换成带符号，否则转换成无符号。比如long和unsigned int，如果int和long大小相同，则long类型转换成unsigned int。</li>\n</ol>\n<h2 id=\"其他隐式转换\"><a href=\"#其他隐式转换\" class=\"headerlink\" title=\"其他隐式转换\"></a>其他隐式转换</h2><p>数组转换成指针，比如如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ia[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> *ip = ia; <span class=\"comment\">//ia转换成指向数组首元素的指针</span></span><br></pre></td></tr></table></figure>\n<p>当数组被用作decltype或者取址&amp;、sizeof以及typeid等运算符时，上述转换不会发生。</p>\n<p>常量整型和字面值nullptr能转换成任意的指针类型，任意非常量指针能转换成void *指针，指向任意对象的指针能转换成const void*。</p>\n<h2 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"显式转换\"></a>显式转换</h2><p>在C++中，有四种命名的强制类型转换关键字，分别为static_cast、dynamic_cast、const_cast、reinterpret_cast。基本使用格式为cast-name<type>(expression)，其中cast-name是上述四种转换类型，type为需要转换的类型，expression是要转换的值。现分别介绍如下：<a href=\"http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html\" target=\"_blank\" rel=\"noopener\">文字来源</a></type></p>\n<h3 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h3><p>类似于C风格的强制转换。无条件转换，静态类型转换。用于：</p>\n<ol>\n<li>基类和子类之间转换：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的。(基类和子类之间的动态类型转换建议用dynamic_cast)</li>\n<li>基本数据类型转换。enum, struct, int, char, float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。</li>\n<li>把空指针转换成目标类型的空指针。</li>\n<li>static_cast不能去掉类型的const、volitale属性(用const_cast)。</li>\n</ol>\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：</p>\n<ol>\n<li>安全的基类和子类之间转换。</li>\n<li>必须要有虚函数。</li>\n<li>相同基类不同子类之间的交叉转换。但结果是NULL</li>\n</ol>\n<h3 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h3><p>去掉类型的const或volatile属性。</p>\n<h3 id=\"reinterpret-cast\"><a href=\"#reinterpret-cast\" class=\"headerlink\" title=\"reinterpret_cast\"></a>reinterpret_cast</h3><p>仅仅重新解释类型，但没有进行二进制的转换：</p>\n<ol>\n<li>转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。</li>\n<li>在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。</li>\n<li>最普通的用途就是在函数指针类型之间进行转换。</li>\n<li>很难保证移植性。</li>\n</ol>\n<p>用法可以总结如下：</p>\n<ol>\n<li>去const属性用const_cast。</li>\n<li>基本类型转换用static_cast。</li>\n<li>多态类之间的类型转换用daynamic_cast。</li>\n<li>不同类型的指针类型转换用reinterpret_cast。</li>\n</ol>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://blog.csdn.net/gatieme/article/details/52557546\" target=\"_blank\" rel=\"noopener\">有符号数和无符号数的转换及思考</a></p>\n<p><a href=\"http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html\" target=\"_blank\" rel=\"noopener\">C++类型转换总结</a></p>\n<p><a href=\"http://www.cnblogs.com/TenosDoIt/p/3175217.html\" target=\"_blank\" rel=\"noopener\">c++数据类型转换：static_cast dynamic_cast reinterpret_cast const_cast</a></p>\n<p><a href=\"http://cuckootan.me/2016/05/28/C/C++/C++%20-%20隐式转换与四种强制类型转换/\" target=\"_blank\" rel=\"noopener\">C++ - 隐式转换与四种强制类型转换</a></p>\n<p><a href=\"http://blog.csdn.net/ydar95/article/details/69822540\" target=\"_blank\" rel=\"noopener\">c++ 四种强制类型转换介绍</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"类型转换基础\"><a href=\"#类型转换基础\" class=\"headerlink\" title=\"类型转换基础\"></a>类型转换基础</h2><p>对象的类型定义了对象能包含的数据和能够参与的运算，如果在表达式中混杂了多种不同的类型，编译器可能（有些类型转换非法则编译错误）会帮我们进行隐式的类型转换。如果两种类型能够进行相互转换则称两种类型是关联的。类型在进行隐式转换总体规则向上提升，即转换成精度和表达范围更广的数据类型。类型转换按照是否为自动可分为隐式转换和显式转换。隐式转换是由编译器自动完成的，无需编程人员的介入，显示转换是编程人员希望进行类型转换而显式要求编译器进行类型转换的过程。</p>\n<h2 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h2><p>在表达式中，如果我们在不同类型之间进行赋值，其根据类型不同得到不同的结果，如下为基本的转换规则</p>\n<ol>\n<li>非布尔-&gt;布尔：0-&gt;false; 非0-&gt;true</li>\n<li>布尔-&gt;非布尔：false-&gt;0; true-&gt;1</li>\n<li>浮点-&gt;整数：近似处理，保留浮点数小数点之前的部分</li>\n<li>整数-&gt;浮点数：小数部分记为0，如果整数所占空间超过浮点类型容量，精度会产生损失</li>\n<li>给无符号类型一个超过其表示范围的值时，结果是初始值对无符号类型表示数值的总数取模以后的余数。例如unsigned char(8 bit) 可以表示0-255，如果赋一个区间以外的值，则实际结果为该值对256取模所得的余数。unsigned char x = -1; // x = 255</li>\n<li>当赋给带符号类型一个超过其表示范围的值时，结果是未定义的。此时程序可能继续工作、可能崩溃，也可能产生垃圾数据（未定义）</li>\n<li>无符号数转换为更大的数据类型时, 只需简单地在开头添加0，这种运算称为0扩展</li>\n<li>将有符号数转换为更大的数据类型需要执行符号扩展，规则是将当前数符号位扩展至所需要的位数</li>\n<li>当数据类型转换时，同时需要在不同数据大小，以及无符号和有符号之间转换时，C语言标准要求先进行数据大小的转换，之后再进行无符号和有符号之间的转换。C语言中的强制类型转换保持二进制位值不变，只是改变解释位的方式。</li>\n<li>将一个大的数据类型转换为小的数据类型时，不管是无符号数还是有符号数都是简单地进行位截断</li>\n<li>进行整数的算术运算时，当结果变量的位数不足以存放实际实际结果的位数时，运算的结果就会因截断而产生溢出</li>\n</ol>\n<p>如下图所示为一段测试代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;limits&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> bValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cValue = numeric_limits&lt;<span class=\"keyword\">char</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">short</span> sValue = numeric_limits&lt;<span class=\"keyword\">short</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> iValue = numeric_limits&lt;<span class=\"keyword\">int</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> lValue = numeric_limits&lt;<span class=\"keyword\">long</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> llValue = numeric_limits&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> fValue = numeric_limits&lt;<span class=\"keyword\">float</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> dValue = numeric_limits&lt;<span class=\"keyword\">double</span>&gt;::max();</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> <span class=\"keyword\">double</span> ldValue = numeric_limits&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">double</span>&gt;::max();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//测试开始</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; (bValue=cValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=sValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=iValue) &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; (bValue=lValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=llValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=fValue) &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; (bValue=dValue) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; (bValue=ldValue) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上输出为全1。在进行未定义转换时，可能不同的编译器结果不一致。由于无符号与有符号之间的转换往往出乎意料，一般避免进行转换。</p>\n<p>隐式转换主要发生在以下情况中：</p>\n<pre><code>1. 在大多数表达式中，比int类型小的整型值提升为较大的整数类型\n2. 在条件中，非布尔值转换为布尔类型\n3. 初始化或者赋值语句，右侧转变为左侧类型\n4. 如果算数运算表达式有多种类型，需要转换成同一种类型\n5. 函数调用\n</code></pre><h2 id=\"整型提升\"><a href=\"#整型提升\" class=\"headerlink\" title=\"整型提升\"></a>整型提升</h2><p>整型提升负责把小整数装换成较大的整数类型，对于bool、char、signed char、unsigned char、short、unisned short等类型，只要他们所有可能的值都能存在int类型中，就会提升为int，否则提升为unsigned int。wchar_t、char16_t、char32_6提升成int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种，前提是能容纳原始类型所有可能的值</p>\n<p>无符号与有符号之间的转换有几种情况：</p>\n<ol>\n<li>如果无符号类型不小于带符号类型，则有符号类型转换成无符号类型，如int需要转换成unsigned int。如果有符号是负数，则取模运算</li>\n<li>如果带符号大于无符号且带符号类型可以容纳所有无符号值，则转换成带符号，否则转换成无符号。比如long和unsigned int，如果int和long大小相同，则long类型转换成unsigned int。</li>\n</ol>\n<h2 id=\"其他隐式转换\"><a href=\"#其他隐式转换\" class=\"headerlink\" title=\"其他隐式转换\"></a>其他隐式转换</h2><p>数组转换成指针，比如如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ia[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> *ip = ia; <span class=\"comment\">//ia转换成指向数组首元素的指针</span></span><br></pre></td></tr></table></figure>\n<p>当数组被用作decltype或者取址&amp;、sizeof以及typeid等运算符时，上述转换不会发生。</p>\n<p>常量整型和字面值nullptr能转换成任意的指针类型，任意非常量指针能转换成void *指针，指向任意对象的指针能转换成const void*。</p>\n<h2 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"显式转换\"></a>显式转换</h2><p>在C++中，有四种命名的强制类型转换关键字，分别为static_cast、dynamic_cast、const_cast、reinterpret_cast。基本使用格式为cast-name<type>(expression)，其中cast-name是上述四种转换类型，type为需要转换的类型，expression是要转换的值。现分别介绍如下：<a href=\"http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html\" target=\"_blank\" rel=\"noopener\">文字来源</a></type></p>\n<h3 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h3><p>类似于C风格的强制转换。无条件转换，静态类型转换。用于：</p>\n<ol>\n<li>基类和子类之间转换：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的。(基类和子类之间的动态类型转换建议用dynamic_cast)</li>\n<li>基本数据类型转换。enum, struct, int, char, float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。</li>\n<li>把空指针转换成目标类型的空指针。</li>\n<li>static_cast不能去掉类型的const、volitale属性(用const_cast)。</li>\n</ol>\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：</p>\n<ol>\n<li>安全的基类和子类之间转换。</li>\n<li>必须要有虚函数。</li>\n<li>相同基类不同子类之间的交叉转换。但结果是NULL</li>\n</ol>\n<h3 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h3><p>去掉类型的const或volatile属性。</p>\n<h3 id=\"reinterpret-cast\"><a href=\"#reinterpret-cast\" class=\"headerlink\" title=\"reinterpret_cast\"></a>reinterpret_cast</h3><p>仅仅重新解释类型，但没有进行二进制的转换：</p>\n<ol>\n<li>转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。</li>\n<li>在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。</li>\n<li>最普通的用途就是在函数指针类型之间进行转换。</li>\n<li>很难保证移植性。</li>\n</ol>\n<p>用法可以总结如下：</p>\n<ol>\n<li>去const属性用const_cast。</li>\n<li>基本类型转换用static_cast。</li>\n<li>多态类之间的类型转换用daynamic_cast。</li>\n<li>不同类型的指针类型转换用reinterpret_cast。</li>\n</ol>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://blog.csdn.net/gatieme/article/details/52557546\" target=\"_blank\" rel=\"noopener\">有符号数和无符号数的转换及思考</a></p>\n<p><a href=\"http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html\" target=\"_blank\" rel=\"noopener\">C++类型转换总结</a></p>\n<p><a href=\"http://www.cnblogs.com/TenosDoIt/p/3175217.html\" target=\"_blank\" rel=\"noopener\">c++数据类型转换：static_cast dynamic_cast reinterpret_cast const_cast</a></p>\n<p><a href=\"http://cuckootan.me/2016/05/28/C/C++/C++%20-%20隐式转换与四种强制类型转换/\" target=\"_blank\" rel=\"noopener\">C++ - 隐式转换与四种强制类型转换</a></p>\n<p><a href=\"http://blog.csdn.net/ydar95/article/details/69822540\" target=\"_blank\" rel=\"noopener\">c++ 四种强制类型转换介绍</a></p>\n"},{"title":"STL基础概述","urlname":"stl-foundation","date":"2018-03-13T13:59:43.000Z","copyright":true,"mathjax":true,"_content":"\n## STL基础知识\n\nSTL全称标准模板库（Standard Template Library），是一套程序库，采用了模板编程技术。STL并不是C++标准库的一部分，其由六大组件组成\n\n1. 容器（containers）：各种数据结构，有vector（动态数组），list（双向链表），dequeue（双端队列），set（红黑树），map（红黑树）。\n2. 算法（algorithm）：常用的算法如排序、搜索、复制、删除等\n3. 迭代器（iterator）：算法和容器之间的桥梁，是一种泛型指针，主要有五种类型，重载了一些运算符。\n4. 仿函数（functor）：重载了operator()的类或者类模板，行为和函数类似\n5. 配接器（adapter）：一种用来修饰容器或仿函数或迭代器的结构，比如stack和queue，行为和容器类似，不过底层操作采用其他容器实现。\n6. 配置器（allocator）：负责进行空间配置与管理\n\n六大组件交互过程如下：容器通过配置器获取存储空间，算法通过迭代器存取容器的内容，仿函数协助算法完成不同策略的操作，配接器可以修饰或套接仿函数，通过适配器接受一种已有的事物而表现起来像另外一种事物。\n\n盗用一张交互图：[图片来源](http://blog.csdn.net/u010275850/article/details/51935404)\n\n![六大组件交互图](/images/stl-components.jpg)\n\n\n## STL语法\n\nSTL有一些使用语法并不是非常常规，主要有如下几点：\n\n- 临时对象\n\n临时对象是一种无名对象，如果临时对象的产生并不是编程人员刻意为之，那么一般意味着程序效率存在一种损失。在某些时候如果刻意使用临时对象则可以使程序非常简洁。其方法为在类型名称后直接加一括号并可指定初值，如int(8)定义了一个值为8的临时对象。STL常将这种操作应用于仿函数上。代码示例如下：\n\n```cpp\ntemplate <typename T>\nclass print\n{\npublic:\n\tvoid operator() (const T&ele) { cout << ele << endl;}\n};\n\nint main()\n{\n\tvector<int> ia{0, 1, 2, 3, 4, 5, 6, 7};\n\tfor_each(ia.begin(), ia.end(), print<int>()); //STL函数\n\treturn 0;\n}\n```\n\n在调用for_each()函数时传入一个无名对象。\n\n- 静态常量整数成员在class内部直接初始化\n\nC++11中，静态常成员可以直接在类内初始化，代码示例如下：\n\n```cpp\ntemplate <typename T>\nclass print\n{\npublic:\n\tvoid operator() (const T&ele) { cout << ele << endl;}\nprivate:\n\tstatic const int iVal = 2;\n\tstatic const char cVal = 'g';\n};\n```\n\n- ++或\\-\\-以及解引用运算符\n\n++与\\-\\-运算符在迭代器上的运用十分广泛，基本迭代器都需要实现上述操作。这是示例代码：\n\n```cpp\ntemplate <typename T>\nclass INT\n{\npublic:\n\tINT() : iVal(0) {}\n\tINT &operator++(); //前置++\n\tconst INT operator++(int); //后置++\n\tint &operator*() const; //解引用\nprivate:\n\tint iVal;\n};\n\ntemplate <typename T>\nINT<T> & INT<T>::operator++()\n{\n\t++(this->iVal);\n\treturn *this;\n}\n\ntemplate <typename T>\nconst INT<T> INT<T>::operator++(int)\n{\n\tINT tmp = *this;\n\t++(this->iVal);\n\treturn tmp;\n}\n\ntemplate <typename T>\nint &INT<T>::operator*() const //const不能丢\n{\n\treturn (int&)this->iVal;\n}\n```\n\n- 前闭后开区间表示\n\nSTL里面的算法需要获取一对迭代器表示操作的范围，STL规定该区间为左闭右开，即[first, end)区间。实际需要操作元素的位置为first到end-1。左闭右开区间带来了许多方便，比如在去换判断终止时可以采用iter != end的形式，示例代码如下：\n\n```cpp\ntemplate <class InputIterator, class T>\nInputIterator fin(InputIterator first, InputIterator end, const T&key)\n{\n\tfor ( ; first != end && *first != key; ++first);\n\treturn first;\n}\n```\n\n- 函数调用\n\nSTL算法大多提供两个版本，一个针对普通情况，一个针对特殊情况。比如对于排序算法，可能默认按照递增顺序排列，如果想要按照用户自己的意愿进行排列，则可以由用户指定策略，而这可以通过函数调用完成。比如考虑以下实例：\n\n```cpp\nint fcmp(const void *in1, const void *in2)\n{\n\tconst int *iP1 = (const int*)in1;\n\tconst int *iP2 = (const int*)in2;\n\tif (*iP1 < *iP2) return -1;\n\tif (*iP1 > *iP2) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tint ia[] = {1,5,6,2,4,5,7};\n\tqsort(ia, sizeof(ia)/sizeof(ia[0]), sizeof(ia[0]), fcmp); //使用用户定义的排序策略\n\treturn 0;\n}\n```\n上示代码中函数指针无法持有自身的状态（即每次调用状态不会发生变化，仿函数由于是一个对象，实际可以携带自己的数据）。\n\n## STL常见容器或配接器\n\n1. vector：底层数据结构为数组 ，序列容器，支持快速随机访问\n2. list：底层数据结构为双向链表，序列容器，支持快速增删\n3. dequeue：底层数据结构为一个中央控制器和多个缓冲区，序列容器，支持首尾（中间不能）快速增删，也支持随机访问\n4. stack：底层一般用list或deque实现，封闭一端即可\n5. queue：和stack类似底层一般用list或deque实现\n6. priority_queue：底层数据结构一般为vector为底层容器，使用数据结构堆\n7. set：底层数据结构为红黑树，有序关联容器，关键字不重复\n8. multiset：底层数据结构为红黑树，有序关联容器，关键字允许重复\n9. map：底层数据结构为红黑树，有序关联容器，关键字不重复\n10. multimap：底层数据结构为红黑树，有序关联容器，关键字允许重复\n11. unordered_set：底层数据结构为hash表，无序，关键字不重复\n12. unordered_multiset：底层数据结构为hash表，无序，关键字允许重复\n13. unordered_map：底层数据结构为hash表，无序，关键字不重复\n14. unordered_multimap：底层数据结构为hash表，无序，关关键字允许重复\n15. bitset：存储系列位类似的固定大小的布尔向量。实现按位运算，没有迭代器，不是序列\n16. valarray：数值类型的std::vector。牺牲泛型能力而专为数值计算做了优化。\n17. forward_list：单向链表，只支持单向顺序访问，在链表任何位置进行插入和删除速度都很快\n\n\n## 参考文章\n\n[STL底层数据结构实现](http://www.cnblogs.com/hustlijian/p/3611424.html)\n\n[标准模板库](https://zh.wikipedia.org/wiki/标准模板库)\n\n[容器库](http://zh.cppreference.com/w/cpp/container)\n","source":"_posts/C++/STL概述.md","raw":"---\ntitle: STL基础概述\nurlname: stl-foundation\ndate: 2018-03-13 21:59:43\ncopyright: true\nmathjax: true\ntags:\n- C++\n- STL\ncategories:\n- C++\n---\n\n## STL基础知识\n\nSTL全称标准模板库（Standard Template Library），是一套程序库，采用了模板编程技术。STL并不是C++标准库的一部分，其由六大组件组成\n\n1. 容器（containers）：各种数据结构，有vector（动态数组），list（双向链表），dequeue（双端队列），set（红黑树），map（红黑树）。\n2. 算法（algorithm）：常用的算法如排序、搜索、复制、删除等\n3. 迭代器（iterator）：算法和容器之间的桥梁，是一种泛型指针，主要有五种类型，重载了一些运算符。\n4. 仿函数（functor）：重载了operator()的类或者类模板，行为和函数类似\n5. 配接器（adapter）：一种用来修饰容器或仿函数或迭代器的结构，比如stack和queue，行为和容器类似，不过底层操作采用其他容器实现。\n6. 配置器（allocator）：负责进行空间配置与管理\n\n六大组件交互过程如下：容器通过配置器获取存储空间，算法通过迭代器存取容器的内容，仿函数协助算法完成不同策略的操作，配接器可以修饰或套接仿函数，通过适配器接受一种已有的事物而表现起来像另外一种事物。\n\n盗用一张交互图：[图片来源](http://blog.csdn.net/u010275850/article/details/51935404)\n\n![六大组件交互图](/images/stl-components.jpg)\n\n\n## STL语法\n\nSTL有一些使用语法并不是非常常规，主要有如下几点：\n\n- 临时对象\n\n临时对象是一种无名对象，如果临时对象的产生并不是编程人员刻意为之，那么一般意味着程序效率存在一种损失。在某些时候如果刻意使用临时对象则可以使程序非常简洁。其方法为在类型名称后直接加一括号并可指定初值，如int(8)定义了一个值为8的临时对象。STL常将这种操作应用于仿函数上。代码示例如下：\n\n```cpp\ntemplate <typename T>\nclass print\n{\npublic:\n\tvoid operator() (const T&ele) { cout << ele << endl;}\n};\n\nint main()\n{\n\tvector<int> ia{0, 1, 2, 3, 4, 5, 6, 7};\n\tfor_each(ia.begin(), ia.end(), print<int>()); //STL函数\n\treturn 0;\n}\n```\n\n在调用for_each()函数时传入一个无名对象。\n\n- 静态常量整数成员在class内部直接初始化\n\nC++11中，静态常成员可以直接在类内初始化，代码示例如下：\n\n```cpp\ntemplate <typename T>\nclass print\n{\npublic:\n\tvoid operator() (const T&ele) { cout << ele << endl;}\nprivate:\n\tstatic const int iVal = 2;\n\tstatic const char cVal = 'g';\n};\n```\n\n- ++或\\-\\-以及解引用运算符\n\n++与\\-\\-运算符在迭代器上的运用十分广泛，基本迭代器都需要实现上述操作。这是示例代码：\n\n```cpp\ntemplate <typename T>\nclass INT\n{\npublic:\n\tINT() : iVal(0) {}\n\tINT &operator++(); //前置++\n\tconst INT operator++(int); //后置++\n\tint &operator*() const; //解引用\nprivate:\n\tint iVal;\n};\n\ntemplate <typename T>\nINT<T> & INT<T>::operator++()\n{\n\t++(this->iVal);\n\treturn *this;\n}\n\ntemplate <typename T>\nconst INT<T> INT<T>::operator++(int)\n{\n\tINT tmp = *this;\n\t++(this->iVal);\n\treturn tmp;\n}\n\ntemplate <typename T>\nint &INT<T>::operator*() const //const不能丢\n{\n\treturn (int&)this->iVal;\n}\n```\n\n- 前闭后开区间表示\n\nSTL里面的算法需要获取一对迭代器表示操作的范围，STL规定该区间为左闭右开，即[first, end)区间。实际需要操作元素的位置为first到end-1。左闭右开区间带来了许多方便，比如在去换判断终止时可以采用iter != end的形式，示例代码如下：\n\n```cpp\ntemplate <class InputIterator, class T>\nInputIterator fin(InputIterator first, InputIterator end, const T&key)\n{\n\tfor ( ; first != end && *first != key; ++first);\n\treturn first;\n}\n```\n\n- 函数调用\n\nSTL算法大多提供两个版本，一个针对普通情况，一个针对特殊情况。比如对于排序算法，可能默认按照递增顺序排列，如果想要按照用户自己的意愿进行排列，则可以由用户指定策略，而这可以通过函数调用完成。比如考虑以下实例：\n\n```cpp\nint fcmp(const void *in1, const void *in2)\n{\n\tconst int *iP1 = (const int*)in1;\n\tconst int *iP2 = (const int*)in2;\n\tif (*iP1 < *iP2) return -1;\n\tif (*iP1 > *iP2) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tint ia[] = {1,5,6,2,4,5,7};\n\tqsort(ia, sizeof(ia)/sizeof(ia[0]), sizeof(ia[0]), fcmp); //使用用户定义的排序策略\n\treturn 0;\n}\n```\n上示代码中函数指针无法持有自身的状态（即每次调用状态不会发生变化，仿函数由于是一个对象，实际可以携带自己的数据）。\n\n## STL常见容器或配接器\n\n1. vector：底层数据结构为数组 ，序列容器，支持快速随机访问\n2. list：底层数据结构为双向链表，序列容器，支持快速增删\n3. dequeue：底层数据结构为一个中央控制器和多个缓冲区，序列容器，支持首尾（中间不能）快速增删，也支持随机访问\n4. stack：底层一般用list或deque实现，封闭一端即可\n5. queue：和stack类似底层一般用list或deque实现\n6. priority_queue：底层数据结构一般为vector为底层容器，使用数据结构堆\n7. set：底层数据结构为红黑树，有序关联容器，关键字不重复\n8. multiset：底层数据结构为红黑树，有序关联容器，关键字允许重复\n9. map：底层数据结构为红黑树，有序关联容器，关键字不重复\n10. multimap：底层数据结构为红黑树，有序关联容器，关键字允许重复\n11. unordered_set：底层数据结构为hash表，无序，关键字不重复\n12. unordered_multiset：底层数据结构为hash表，无序，关键字允许重复\n13. unordered_map：底层数据结构为hash表，无序，关键字不重复\n14. unordered_multimap：底层数据结构为hash表，无序，关关键字允许重复\n15. bitset：存储系列位类似的固定大小的布尔向量。实现按位运算，没有迭代器，不是序列\n16. valarray：数值类型的std::vector。牺牲泛型能力而专为数值计算做了优化。\n17. forward_list：单向链表，只支持单向顺序访问，在链表任何位置进行插入和删除速度都很快\n\n\n## 参考文章\n\n[STL底层数据结构实现](http://www.cnblogs.com/hustlijian/p/3611424.html)\n\n[标准模板库](https://zh.wikipedia.org/wiki/标准模板库)\n\n[容器库](http://zh.cppreference.com/w/cpp/container)\n","slug":"C++/STL概述","published":1,"updated":"2018-06-13T14:22:03.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x2p0004gsvncq76vdyx","content":"<h2 id=\"STL基础知识\"><a href=\"#STL基础知识\" class=\"headerlink\" title=\"STL基础知识\"></a>STL基础知识</h2><p>STL全称标准模板库（Standard Template Library），是一套程序库，采用了模板编程技术。STL并不是C++标准库的一部分，其由六大组件组成</p>\n<ol>\n<li>容器（containers）：各种数据结构，有vector（动态数组），list（双向链表），dequeue（双端队列），set（红黑树），map（红黑树）。</li>\n<li>算法（algorithm）：常用的算法如排序、搜索、复制、删除等</li>\n<li>迭代器（iterator）：算法和容器之间的桥梁，是一种泛型指针，主要有五种类型，重载了一些运算符。</li>\n<li>仿函数（functor）：重载了operator()的类或者类模板，行为和函数类似</li>\n<li>配接器（adapter）：一种用来修饰容器或仿函数或迭代器的结构，比如stack和queue，行为和容器类似，不过底层操作采用其他容器实现。</li>\n<li>配置器（allocator）：负责进行空间配置与管理</li>\n</ol>\n<p>六大组件交互过程如下：容器通过配置器获取存储空间，算法通过迭代器存取容器的内容，仿函数协助算法完成不同策略的操作，配接器可以修饰或套接仿函数，通过适配器接受一种已有的事物而表现起来像另外一种事物。</p>\n<p>盗用一张交互图：<a href=\"http://blog.csdn.net/u010275850/article/details/51935404\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/stl-components.jpg\" alt=\"六大组件交互图\"></p>\n<h2 id=\"STL语法\"><a href=\"#STL语法\" class=\"headerlink\" title=\"STL语法\"></a>STL语法</h2><p>STL有一些使用语法并不是非常常规，主要有如下几点：</p>\n<ul>\n<li>临时对象</li>\n</ul>\n<p>临时对象是一种无名对象，如果临时对象的产生并不是编程人员刻意为之，那么一般意味着程序效率存在一种损失。在某些时候如果刻意使用临时对象则可以使程序非常简洁。其方法为在类型名称后直接加一括号并可指定初值，如int(8)定义了一个值为8的临时对象。STL常将这种操作应用于仿函数上。代码示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">print</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">const</span> T&amp;ele)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; ele &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ia&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">\tfor_each(ia.begin(), ia.end(), print&lt;<span class=\"keyword\">int</span>&gt;()); <span class=\"comment\">//STL函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在调用for_each()函数时传入一个无名对象。</p>\n<ul>\n<li>静态常量整数成员在class内部直接初始化</li>\n</ul>\n<p>C++11中，静态常成员可以直接在类内初始化，代码示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">print</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">const</span> T&amp;ele)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; ele &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> iVal = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> cVal = <span class=\"string\">'g'</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>++或--以及解引用运算符</li>\n</ul>\n<p>++与--运算符在迭代器上的运用十分广泛，基本迭代器都需要实现上述操作。这是示例代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">INT</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tINT() : iVal(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\tINT &amp;<span class=\"keyword\">operator</span>++(); <span class=\"comment\">//前置++</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> INT <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>); <span class=\"comment\">//后置++</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp;<span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span>; <span class=\"comment\">//解引用</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> iVal;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">INT&lt;T&gt; &amp; INT&lt;T&gt;::<span class=\"keyword\">operator</span>++()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t++(<span class=\"keyword\">this</span>-&gt;iVal);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> INT&lt;T&gt; INT&lt;T&gt;::<span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tINT tmp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t++(<span class=\"keyword\">this</span>-&gt;iVal);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;INT&lt;T&gt;::<span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> <span class=\"comment\">//const不能丢</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>&amp;)<span class=\"keyword\">this</span>-&gt;iVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>前闭后开区间表示</li>\n</ul>\n<p>STL里面的算法需要获取一对迭代器表示操作的范围，STL规定该区间为左闭右开，即[first, end)区间。实际需要操作元素的位置为first到end-1。左闭右开区间带来了许多方便，比如在去换判断终止时可以采用iter != end的形式，示例代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>, <span class=\"title\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">InputIterator</span> <span class=\"title\">fin</span>(<span class=\"title\">InputIterator</span> <span class=\"title\">first</span>, <span class=\"title\">InputIterator</span> <span class=\"title\">end</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>&amp;<span class=\"title\">key</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( ; first != end &amp;&amp; *first != key; ++first);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数调用</li>\n</ul>\n<p>STL算法大多提供两个版本，一个针对普通情况，一个针对特殊情况。比如对于排序算法，可能默认按照递增顺序排列，如果想要按照用户自己的意愿进行排列，则可以由用户指定策略，而这可以通过函数调用完成。比如考虑以下实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fcmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *in1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *in2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *iP1 = (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>*)in1;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *iP2 = (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>*)in2;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*iP1 &lt; *iP2) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*iP1 &gt; *iP2) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">\tqsort(ia, <span class=\"keyword\">sizeof</span>(ia)/<span class=\"keyword\">sizeof</span>(ia[<span class=\"number\">0</span>]), <span class=\"keyword\">sizeof</span>(ia[<span class=\"number\">0</span>]), fcmp); <span class=\"comment\">//使用用户定义的排序策略</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上示代码中函数指针无法持有自身的状态（即每次调用状态不会发生变化，仿函数由于是一个对象，实际可以携带自己的数据）。</p>\n<h2 id=\"STL常见容器或配接器\"><a href=\"#STL常见容器或配接器\" class=\"headerlink\" title=\"STL常见容器或配接器\"></a>STL常见容器或配接器</h2><ol>\n<li>vector：底层数据结构为数组 ，序列容器，支持快速随机访问</li>\n<li>list：底层数据结构为双向链表，序列容器，支持快速增删</li>\n<li>dequeue：底层数据结构为一个中央控制器和多个缓冲区，序列容器，支持首尾（中间不能）快速增删，也支持随机访问</li>\n<li>stack：底层一般用list或deque实现，封闭一端即可</li>\n<li>queue：和stack类似底层一般用list或deque实现</li>\n<li>priority_queue：底层数据结构一般为vector为底层容器，使用数据结构堆</li>\n<li>set：底层数据结构为红黑树，有序关联容器，关键字不重复</li>\n<li>multiset：底层数据结构为红黑树，有序关联容器，关键字允许重复</li>\n<li>map：底层数据结构为红黑树，有序关联容器，关键字不重复</li>\n<li>multimap：底层数据结构为红黑树，有序关联容器，关键字允许重复</li>\n<li>unordered_set：底层数据结构为hash表，无序，关键字不重复</li>\n<li>unordered_multiset：底层数据结构为hash表，无序，关键字允许重复</li>\n<li>unordered_map：底层数据结构为hash表，无序，关键字不重复</li>\n<li>unordered_multimap：底层数据结构为hash表，无序，关关键字允许重复</li>\n<li>bitset：存储系列位类似的固定大小的布尔向量。实现按位运算，没有迭代器，不是序列</li>\n<li>valarray：数值类型的std::vector。牺牲泛型能力而专为数值计算做了优化。</li>\n<li>forward_list：单向链表，只支持单向顺序访问，在链表任何位置进行插入和删除速度都很快</li>\n</ol>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.cnblogs.com/hustlijian/p/3611424.html\" target=\"_blank\" rel=\"noopener\">STL底层数据结构实现</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/标准模板库\" target=\"_blank\" rel=\"noopener\">标准模板库</a></p>\n<p><a href=\"http://zh.cppreference.com/w/cpp/container\" target=\"_blank\" rel=\"noopener\">容器库</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"STL基础知识\"><a href=\"#STL基础知识\" class=\"headerlink\" title=\"STL基础知识\"></a>STL基础知识</h2><p>STL全称标准模板库（Standard Template Library），是一套程序库，采用了模板编程技术。STL并不是C++标准库的一部分，其由六大组件组成</p>\n<ol>\n<li>容器（containers）：各种数据结构，有vector（动态数组），list（双向链表），dequeue（双端队列），set（红黑树），map（红黑树）。</li>\n<li>算法（algorithm）：常用的算法如排序、搜索、复制、删除等</li>\n<li>迭代器（iterator）：算法和容器之间的桥梁，是一种泛型指针，主要有五种类型，重载了一些运算符。</li>\n<li>仿函数（functor）：重载了operator()的类或者类模板，行为和函数类似</li>\n<li>配接器（adapter）：一种用来修饰容器或仿函数或迭代器的结构，比如stack和queue，行为和容器类似，不过底层操作采用其他容器实现。</li>\n<li>配置器（allocator）：负责进行空间配置与管理</li>\n</ol>\n<p>六大组件交互过程如下：容器通过配置器获取存储空间，算法通过迭代器存取容器的内容，仿函数协助算法完成不同策略的操作，配接器可以修饰或套接仿函数，通过适配器接受一种已有的事物而表现起来像另外一种事物。</p>\n<p>盗用一张交互图：<a href=\"http://blog.csdn.net/u010275850/article/details/51935404\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/stl-components.jpg\" alt=\"六大组件交互图\"></p>\n<h2 id=\"STL语法\"><a href=\"#STL语法\" class=\"headerlink\" title=\"STL语法\"></a>STL语法</h2><p>STL有一些使用语法并不是非常常规，主要有如下几点：</p>\n<ul>\n<li>临时对象</li>\n</ul>\n<p>临时对象是一种无名对象，如果临时对象的产生并不是编程人员刻意为之，那么一般意味着程序效率存在一种损失。在某些时候如果刻意使用临时对象则可以使程序非常简洁。其方法为在类型名称后直接加一括号并可指定初值，如int(8)定义了一个值为8的临时对象。STL常将这种操作应用于仿函数上。代码示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">print</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">const</span> T&amp;ele)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; ele &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ia&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">\tfor_each(ia.begin(), ia.end(), print&lt;<span class=\"keyword\">int</span>&gt;()); <span class=\"comment\">//STL函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在调用for_each()函数时传入一个无名对象。</p>\n<ul>\n<li>静态常量整数成员在class内部直接初始化</li>\n</ul>\n<p>C++11中，静态常成员可以直接在类内初始化，代码示例如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">print</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">const</span> T&amp;ele)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; ele &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> iVal = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> cVal = <span class=\"string\">'g'</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>++或--以及解引用运算符</li>\n</ul>\n<p>++与--运算符在迭代器上的运用十分广泛，基本迭代器都需要实现上述操作。这是示例代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">INT</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tINT() : iVal(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\tINT &amp;<span class=\"keyword\">operator</span>++(); <span class=\"comment\">//前置++</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> INT <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>); <span class=\"comment\">//后置++</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> &amp;<span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span>; <span class=\"comment\">//解引用</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> iVal;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">INT&lt;T&gt; &amp; INT&lt;T&gt;::<span class=\"keyword\">operator</span>++()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t++(<span class=\"keyword\">this</span>-&gt;iVal);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> INT&lt;T&gt; INT&lt;T&gt;::<span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tINT tmp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t++(<span class=\"keyword\">this</span>-&gt;iVal);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;INT&lt;T&gt;::<span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> <span class=\"comment\">//const不能丢</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>&amp;)<span class=\"keyword\">this</span>-&gt;iVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>前闭后开区间表示</li>\n</ul>\n<p>STL里面的算法需要获取一对迭代器表示操作的范围，STL规定该区间为左闭右开，即[first, end)区间。实际需要操作元素的位置为first到end-1。左闭右开区间带来了许多方便，比如在去换判断终止时可以采用iter != end的形式，示例代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>, <span class=\"title\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">InputIterator</span> <span class=\"title\">fin</span>(<span class=\"title\">InputIterator</span> <span class=\"title\">first</span>, <span class=\"title\">InputIterator</span> <span class=\"title\">end</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>&amp;<span class=\"title\">key</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( ; first != end &amp;&amp; *first != key; ++first);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数调用</li>\n</ul>\n<p>STL算法大多提供两个版本，一个针对普通情况，一个针对特殊情况。比如对于排序算法，可能默认按照递增顺序排列，如果想要按照用户自己的意愿进行排列，则可以由用户指定策略，而这可以通过函数调用完成。比如考虑以下实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fcmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *in1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *in2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *iP1 = (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>*)in1;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *iP2 = (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>*)in2;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*iP1 &lt; *iP2) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*iP1 &gt; *iP2) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">\tqsort(ia, <span class=\"keyword\">sizeof</span>(ia)/<span class=\"keyword\">sizeof</span>(ia[<span class=\"number\">0</span>]), <span class=\"keyword\">sizeof</span>(ia[<span class=\"number\">0</span>]), fcmp); <span class=\"comment\">//使用用户定义的排序策略</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上示代码中函数指针无法持有自身的状态（即每次调用状态不会发生变化，仿函数由于是一个对象，实际可以携带自己的数据）。</p>\n<h2 id=\"STL常见容器或配接器\"><a href=\"#STL常见容器或配接器\" class=\"headerlink\" title=\"STL常见容器或配接器\"></a>STL常见容器或配接器</h2><ol>\n<li>vector：底层数据结构为数组 ，序列容器，支持快速随机访问</li>\n<li>list：底层数据结构为双向链表，序列容器，支持快速增删</li>\n<li>dequeue：底层数据结构为一个中央控制器和多个缓冲区，序列容器，支持首尾（中间不能）快速增删，也支持随机访问</li>\n<li>stack：底层一般用list或deque实现，封闭一端即可</li>\n<li>queue：和stack类似底层一般用list或deque实现</li>\n<li>priority_queue：底层数据结构一般为vector为底层容器，使用数据结构堆</li>\n<li>set：底层数据结构为红黑树，有序关联容器，关键字不重复</li>\n<li>multiset：底层数据结构为红黑树，有序关联容器，关键字允许重复</li>\n<li>map：底层数据结构为红黑树，有序关联容器，关键字不重复</li>\n<li>multimap：底层数据结构为红黑树，有序关联容器，关键字允许重复</li>\n<li>unordered_set：底层数据结构为hash表，无序，关键字不重复</li>\n<li>unordered_multiset：底层数据结构为hash表，无序，关键字允许重复</li>\n<li>unordered_map：底层数据结构为hash表，无序，关键字不重复</li>\n<li>unordered_multimap：底层数据结构为hash表，无序，关关键字允许重复</li>\n<li>bitset：存储系列位类似的固定大小的布尔向量。实现按位运算，没有迭代器，不是序列</li>\n<li>valarray：数值类型的std::vector。牺牲泛型能力而专为数值计算做了优化。</li>\n<li>forward_list：单向链表，只支持单向顺序访问，在链表任何位置进行插入和删除速度都很快</li>\n</ol>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://www.cnblogs.com/hustlijian/p/3611424.html\" target=\"_blank\" rel=\"noopener\">STL底层数据结构实现</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/标准模板库\" target=\"_blank\" rel=\"noopener\">标准模板库</a></p>\n<p><a href=\"http://zh.cppreference.com/w/cpp/container\" target=\"_blank\" rel=\"noopener\">容器库</a></p>\n"},{"title":"结构体struct与类class的关系和区别","urlname":"struct-class","date":"2018-03-12T07:47:43.000Z","copyright":true,"mathjax":true,"_content":"\n## struct与class基础\n\n在C中，struct是用来定义自定义类型的，通过基本数据类型组合成一种新的抽象数据类型，其只能定义成员变量而不能定义函数。而C++中的struct有较大的变化，C++极大地扩充了struct的含义，C++中的struct可以定义函数，可以定义构造函数、析构函数，可以继承，C++中的struct和class基本可以混用（除泛型编程替代typename），除此之外两者唯一的区别就是默认的访问控制权限和默认的继承权限不同。\n\n在C++中，struct默认的访问权限和继承权限是public，而class是private。而且struct可以继承于class，而默认的继承权限取决于子类是struct还是class。\n\n\n## strcut与class实验\n\n在C++环境下，有如下代码：\n\n```cpp\nstruct S1\n{\n\tint x;\n};\n\nstruct S2 : S1\n{\n\tint y;\n};\n\nclass C1\n{\n\tint m;\n};\n\nclass C2 : C1\n{\n\tint n;\n};\n\nstruct S3 : C1\n{\n\t\n};\n\nclass C3 : S1\n{\n\n};\n\nint main()\n{\n\tS1 S_S1 ;\n\tS_S1.x = 0; //合法，因为数据访问权限为public\n\tS2 S_S2 ;\n\tS_S2.x = S_S2.y = 0; //合法，因为默认继承权限为public且数据访问权限为public\n\tS3 S_S3 ;\n\t//S_S3.m = 0; //非法，因为默认继承权限为public但数据访问权限为private\n\tC1 C_C1 ; \n\t//C_C1.m = 0; //非法，因为数据访问权限为private\n\tC2 C_C2 ;\n\t//C_C2.n = 0; //非法，因为默认继承权限为private\n\tC3 C_C3 ;\n\t//C_C3.x = 0; //非法，因为默认继承权限为private\n\treturn 0;\n}\n```\n\n\n## 参考文章\n\n[Struct和Class的区别](http://blog.csdn.net/yuliu0552/article/details/6717915)\n\n[c++ 结构体和类的区别](http://blog.csdn.net/fengxinziyang/article/details/5909237)\n\n[C++类class和结构体struct区别](http://www.weixueyuan.net/view/6337.html)","source":"_posts/C++/结构体struct与类class的关系和区别.md","raw":"---\ntitle: 结构体struct与类class的关系和区别\nurlname: struct-class\ndate: 2018-03-12 15:47:43\ncopyright: true\nmathjax: true\ntags:\n- C++\ncategories:\n- C++\n---\n\n## struct与class基础\n\n在C中，struct是用来定义自定义类型的，通过基本数据类型组合成一种新的抽象数据类型，其只能定义成员变量而不能定义函数。而C++中的struct有较大的变化，C++极大地扩充了struct的含义，C++中的struct可以定义函数，可以定义构造函数、析构函数，可以继承，C++中的struct和class基本可以混用（除泛型编程替代typename），除此之外两者唯一的区别就是默认的访问控制权限和默认的继承权限不同。\n\n在C++中，struct默认的访问权限和继承权限是public，而class是private。而且struct可以继承于class，而默认的继承权限取决于子类是struct还是class。\n\n\n## strcut与class实验\n\n在C++环境下，有如下代码：\n\n```cpp\nstruct S1\n{\n\tint x;\n};\n\nstruct S2 : S1\n{\n\tint y;\n};\n\nclass C1\n{\n\tint m;\n};\n\nclass C2 : C1\n{\n\tint n;\n};\n\nstruct S3 : C1\n{\n\t\n};\n\nclass C3 : S1\n{\n\n};\n\nint main()\n{\n\tS1 S_S1 ;\n\tS_S1.x = 0; //合法，因为数据访问权限为public\n\tS2 S_S2 ;\n\tS_S2.x = S_S2.y = 0; //合法，因为默认继承权限为public且数据访问权限为public\n\tS3 S_S3 ;\n\t//S_S3.m = 0; //非法，因为默认继承权限为public但数据访问权限为private\n\tC1 C_C1 ; \n\t//C_C1.m = 0; //非法，因为数据访问权限为private\n\tC2 C_C2 ;\n\t//C_C2.n = 0; //非法，因为默认继承权限为private\n\tC3 C_C3 ;\n\t//C_C3.x = 0; //非法，因为默认继承权限为private\n\treturn 0;\n}\n```\n\n\n## 参考文章\n\n[Struct和Class的区别](http://blog.csdn.net/yuliu0552/article/details/6717915)\n\n[c++ 结构体和类的区别](http://blog.csdn.net/fengxinziyang/article/details/5909237)\n\n[C++类class和结构体struct区别](http://www.weixueyuan.net/view/6337.html)","slug":"C++/结构体struct与类class的关系和区别","published":1,"updated":"2018-06-13T14:22:20.687Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x2r0006gsvn6vp1iajj","content":"<h2 id=\"struct与class基础\"><a href=\"#struct与class基础\" class=\"headerlink\" title=\"struct与class基础\"></a>struct与class基础</h2><p>在C中，struct是用来定义自定义类型的，通过基本数据类型组合成一种新的抽象数据类型，其只能定义成员变量而不能定义函数。而C++中的struct有较大的变化，C++极大地扩充了struct的含义，C++中的struct可以定义函数，可以定义构造函数、析构函数，可以继承，C++中的struct和class基本可以混用（除泛型编程替代typename），除此之外两者唯一的区别就是默认的访问控制权限和默认的继承权限不同。</p>\n<p>在C++中，struct默认的访问权限和继承权限是public，而class是private。而且struct可以继承于class，而默认的继承权限取决于子类是struct还是class。</p>\n<h2 id=\"strcut与class实验\"><a href=\"#strcut与class实验\" class=\"headerlink\" title=\"strcut与class实验\"></a>strcut与class实验</h2><p>在C++环境下，有如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S1</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S2</span> :</span> S1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C2</span> :</span> C1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span> :</span> C1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C3</span> :</span> S1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tS1 S_S1 ;</span><br><span class=\"line\">\tS_S1.x = <span class=\"number\">0</span>; <span class=\"comment\">//合法，因为数据访问权限为public</span></span><br><span class=\"line\">\tS2 S_S2 ;</span><br><span class=\"line\">\tS_S2.x = S_S2.y = <span class=\"number\">0</span>; <span class=\"comment\">//合法，因为默认继承权限为public且数据访问权限为public</span></span><br><span class=\"line\">\tS3 S_S3 ;</span><br><span class=\"line\">\t<span class=\"comment\">//S_S3.m = 0; //非法，因为默认继承权限为public但数据访问权限为private</span></span><br><span class=\"line\">\tC1 C_C1 ; </span><br><span class=\"line\">\t<span class=\"comment\">//C_C1.m = 0; //非法，因为数据访问权限为private</span></span><br><span class=\"line\">\tC2 C_C2 ;</span><br><span class=\"line\">\t<span class=\"comment\">//C_C2.n = 0; //非法，因为默认继承权限为private</span></span><br><span class=\"line\">\tC3 C_C3 ;</span><br><span class=\"line\">\t<span class=\"comment\">//C_C3.x = 0; //非法，因为默认继承权限为private</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://blog.csdn.net/yuliu0552/article/details/6717915\" target=\"_blank\" rel=\"noopener\">Struct和Class的区别</a></p>\n<p><a href=\"http://blog.csdn.net/fengxinziyang/article/details/5909237\" target=\"_blank\" rel=\"noopener\">c++ 结构体和类的区别</a></p>\n<p><a href=\"http://www.weixueyuan.net/view/6337.html\" target=\"_blank\" rel=\"noopener\">C++类class和结构体struct区别</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"struct与class基础\"><a href=\"#struct与class基础\" class=\"headerlink\" title=\"struct与class基础\"></a>struct与class基础</h2><p>在C中，struct是用来定义自定义类型的，通过基本数据类型组合成一种新的抽象数据类型，其只能定义成员变量而不能定义函数。而C++中的struct有较大的变化，C++极大地扩充了struct的含义，C++中的struct可以定义函数，可以定义构造函数、析构函数，可以继承，C++中的struct和class基本可以混用（除泛型编程替代typename），除此之外两者唯一的区别就是默认的访问控制权限和默认的继承权限不同。</p>\n<p>在C++中，struct默认的访问权限和继承权限是public，而class是private。而且struct可以继承于class，而默认的继承权限取决于子类是struct还是class。</p>\n<h2 id=\"strcut与class实验\"><a href=\"#strcut与class实验\" class=\"headerlink\" title=\"strcut与class实验\"></a>strcut与class实验</h2><p>在C++环境下，有如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S1</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S2</span> :</span> S1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C2</span> :</span> C1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span> :</span> C1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C3</span> :</span> S1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tS1 S_S1 ;</span><br><span class=\"line\">\tS_S1.x = <span class=\"number\">0</span>; <span class=\"comment\">//合法，因为数据访问权限为public</span></span><br><span class=\"line\">\tS2 S_S2 ;</span><br><span class=\"line\">\tS_S2.x = S_S2.y = <span class=\"number\">0</span>; <span class=\"comment\">//合法，因为默认继承权限为public且数据访问权限为public</span></span><br><span class=\"line\">\tS3 S_S3 ;</span><br><span class=\"line\">\t<span class=\"comment\">//S_S3.m = 0; //非法，因为默认继承权限为public但数据访问权限为private</span></span><br><span class=\"line\">\tC1 C_C1 ; </span><br><span class=\"line\">\t<span class=\"comment\">//C_C1.m = 0; //非法，因为数据访问权限为private</span></span><br><span class=\"line\">\tC2 C_C2 ;</span><br><span class=\"line\">\t<span class=\"comment\">//C_C2.n = 0; //非法，因为默认继承权限为private</span></span><br><span class=\"line\">\tC3 C_C3 ;</span><br><span class=\"line\">\t<span class=\"comment\">//C_C3.x = 0; //非法，因为默认继承权限为private</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://blog.csdn.net/yuliu0552/article/details/6717915\" target=\"_blank\" rel=\"noopener\">Struct和Class的区别</a></p>\n<p><a href=\"http://blog.csdn.net/fengxinziyang/article/details/5909237\" target=\"_blank\" rel=\"noopener\">c++ 结构体和类的区别</a></p>\n<p><a href=\"http://www.weixueyuan.net/view/6337.html\" target=\"_blank\" rel=\"noopener\">C++类class和结构体struct区别</a></p>\n"},{"title":"struct位段和字节对齐原理及其计算法则","urlname":"struct-byte-alignment","date":"2018-03-12T09:04:21.000Z","copyright":true,"mathjax":true,"_content":"\n## 位段基础知识\n\n在实际编程过程中有些数据存储可能只需要1位或者几个比特位就可以，如果为了几位数据而定义一个完整字节将会浪费大量内存，正是由于这个原因，C语言提供一种称为位段（又称为位域）的数据结构。位段基本定义如下：\n\n```cpp\nstruct pidTag\n{\n\tunsigned int inactive : 1;\n\tunsigned int          : 1; /*1个位的填充*/\n\tunsigned int refcount : 6;\n\tunsigned int          : 0; /*填充到下一个字边界*/\n\tshort pidID;\n\tstruct pidTag *link;\n};\n```\n\n位段的声明和struct类似，成员是一个或多个位的字段，这些字段在实际存储可能存储在一个或多个整型变量中。在声明时，位段成员必须是整形或枚举类型（通常是无符号类型），且在成员名的后面是一个冒号和一个整数，整数规定了成员所占用的位数。位域不能是静态类型。不能使用&对位域做取地址运算。如果位域的定义没有给出标识符名字，那么这是无名位域，无法被初始化。无名位域用于填充（padding）内存布局。只有无名位域的比特数可以为0。这种占0比特的无名位域，用于强迫下一个位域在内存分配边界对齐。而且位段在定义时，其最大长度不能超过依附类型的长度。\n\n位段在存储时有自己的对齐规则：\n\n1. 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；\n2. 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；\n3. 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；\n4. 如果位域字段之间穿插着非位域字段，则不进行压缩；\n5. 整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。\n\n位段在存储时有多种实现，一般可分为两种[文字来源](https://zh.wikipedia.org/wiki/位段)：\n\n### 大小端系统\n\n通常在大端序系统（如PowerPC），安排位域从最重要字节（most-significant byte）到最不重要位（least-significant byte），在一个字节内部从最重要位（most-significant bit）到最不重要位（least-significant bit）；而在小端序系统（如x86），安排位域从最不重要位（least-significant byte）到最重要字节（most-significant byte），在一个字节内部从最不重要位（least-significant bit）到最重要位（most-significant bit）。<font color=red>共同遵从的原则是内存字节地址从低到高，内存内部的比特编号从低到高。</font>\n\n### Microsoft Visual C++实现\n\n在一个整数（integer）内的位域从最不重要位（least-significant）向最重要位（most-significant）依次分配。相邻的两个位域如果基类型（underlying type）的长度相同，在后的位域适合当前内存分配单元且没有跨内存分配边界，那么这两个位域分配到同一个（1、2或4字节的）分配单元。这可以通俗理解为：具有相同的基类型（underlying type）长度的相邻位域尽量装入基类型的同一个对象，如果装得下的话。\n\n注：Most Significant Bit/Byte是指在一个字节序列中对序列取值影响最大那个字节，而Least Significant Bit/Byte则是取值影响最小的字节。\n\n## 只含基本类型结构体字节对齐\n\n在现代计算机中，受限于CPU寻址特点，每次CPU读取内存总是一次性读取多个字节，在32位计算机中一次性读取4个字节的数据，因此数据在内存中放置的位置并不是任意的，字节对齐后可以加快内存的访问速度。\n\n在分析字节对齐时，需要有以下基本概念：\n\n1. 数据类型自身的对齐值：char自对齐字节为1，short为2，int/float为4，double为8，指针根据平台不同略有差异，32位为4字节而64为8字节。\n2. 结构体或者类的自身对齐值：成员中自对齐值最大的那个\n3. 指定对齐值：使用#pragma pack(value)时指定对齐值为value\n4. 数据成员、结构体、类有效对齐值：自身对齐值和指定对齐值的较小一个，即min(value,自身对齐值)\n\n接下来分析一个具体实例，代码如下：\n\n前提条件：int-4字节，char-1字节，short-2字节\n\n```cpp\nstruct A{\n\tint    a;\n\tchar   b;\n\tshort  c;\n};\nstruct B{\n\tchar   b;\n\tint    a;\n\tshort  c;\n};\n```\n\n上述结构体中，sizeof(A)=8，sizeof(B)=12。假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为 2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000~0x0009=10字节，(10＋2)％4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)=12。之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。\n\n\n根据以上分析，字节对齐时一般需要遵循以下原则：\n\n1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除\n2. 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)\n3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节(trailing padding)\n\n以上规则解释如下：\n\n- 第1条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。\n- 第2条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。\n- 第3条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第3条，否则就必须在最后填充几个字节以达到本条要求。\n\n自定义对齐字节采用`#pragma pack(value)`和`#pragma pack()`成对使用，分别表示设定和复位。\n\n## 结构体与联合体互相内嵌的情况\n\n此处的结构体均是C中的struct和union，由于C++中结构体可以包含虚函数，使得分析更为复杂，故只以C中为准。\n\n前提条件为：double-8字节，int-4字节，char-1字节，short-2字节\n\n先定义一个结构体和一个联合体：\n\n```\nstruct SData\n{\n        double dVal;\n        int iVal1;\n        short sVal;\n        int iVal2;\n        char cVal;\n};\n\nunion UData\n{\n        int iArray[3];\n        short sVal;\n        char cVal;\n};\n```\n\n### 结构体内嵌结构体\n\n案例如下：\n\n```\nstruct SWithS\n{\n        int iVal;\n        SData sdVal;\n        char cVal;\n};\n```\n\n首先分析SData的基本情况。在SData中最长成员为8字节，因此其大小应该为8字节的整数倍。根据前面的规则分析有： \n \n`sizeof(SData) = 8(dVal) + 8(iVal1+sVal+padding)+8(iVal2+cVal+padding)=24。` \n\n对于整个结构体类型而言其自身的对齐值是内部最宽的数据类型即8字节，因此可以得出：  \n\n`sizeof(SWithS)=8(iVal+padding)+24(sdVal)+8(cVal+padding)=40。`\n\n将上述结构体在VS2017-64位平台以及g++7.3.0-64位测试结果为：\n\n```\n/*VS2017-64位平台*/\nsizeof(SData)=24\nsizeof(SWithS)=40\n\n/*g++7.3.0-64位平台*/\nsizeof(SData)=24\nsizeof(SWithS)=40\n```\n\n### 结构体内嵌联合体\n\n案例如下：\n\n```\nstruct SWithU\n{\n        int iVal;\n        UData udVal;\n        char cVal;\n};\n```\n\n首先分析UData的基本情况，由于UData中最长成员为4字节，因此其按照4字节对齐，由于iArray成员内存最大，因此：\n\n`sizeof(UData)=12。`\n\n联合体自身的对齐值是和结构体类似，因此：\n\n`sizeof(SWithU)=4(ival)+12(udVal)+4(cVal+padding)=20。`\n\n分别在两个平台测试，测试结果如下：\n\n```\n/*VS2017-64位平台*/\nsizeof(UData)=12\nsizeof(SWithU)=20\n\n/*g++7.3.0-64位平台*/\nsizeof(UData)=12\nsizeof(SWithU)=20\n```\n\n### 联合体内嵌联合体\n\n案例如下：\n\n```\nunion UWithU\n{\n        int iVal;\n        UData udVal;\n        char cArray[13];\n};\n```\n\n由于联合体内部的udVal成员对齐值为4，因此整个UWithU联合体对齐值为4。取最大成员同时对齐到4字节，由此：\n\n`sizeof(UWithU)=16(cArray+padding)=16。`\n\n分别在两个平台测试，测试结果如下：\n\n```\n/*VS2017-64位平台*/\nsizeof(UWithU)=16\n\n/*g++7.3.0-64位平台*/\nsizeof(UWithU)=16\n```\n\n### 联合体内嵌结构体\n\n案例如下：\n\n```\nunion UWithS\n{\n        int iVal;\n        SData sdVal; /*24*/\n        char cArray[25];\n};\n```\n\n由于联合体内部的sdVal成员对齐值为8，因此整个sdVal联合体对齐值为8。取最大成员同时对齐到8字节，由此：\n\n`sizeof(UWithS)=32(cArray+padding)=32。`\n\n分别在两个平台测试，测试结果如下：\n\n```\n/*VS2017-64位平台*/\nsizeof(UWithS)=32\n\n/*g++7.3.0-64位平台*/\nsizeof(UWithS)=32\n```\n\n## 判断机器是大端或小端\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\t//定义一个两字节类型，一定要是两个字节，否则失效\n\tshort x = 0x1234; \n\tchar *p = (char *)&x;\n\tif (*p == 0x34) {\n\t\tcout << \"Little-Endian\" << endl;\n\t}\n\telse if (*p == 0x12) {\n\t\tcout << \"Big-Endian\" << endl;\n\t}\n\telse {\n\t\tcout << \"Unable to judge\" << endl;\n\t}\n\treturn 0;\n}\n```\n在上述代码中，如果大端机器，则内存低位到高位依次存储12--34，小端则依次为34--12，因此通过判断低地址一个字节的值就可以判断大小端机器。\n\n\n\n## 参考文章\n\n[C专家编程](https://book.douban.com/subject/2377310/)\n\n[失传的C结构体打包技艺](https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing)\n\n[struct/class等内存字节对齐问题详解](http://www.cnblogs.com/webary/p/4721017.html)\n\n[C语言字节对齐问题详解](http://www.cnblogs.com/clover-toeic/p/3853132.html)\n\n[C语言位域](http://c.biancheng.net/cpp/html/102.html)\n\n[每个程序员都应当知道的“大小端”](https://www.jianshu.com/p/05aac833eacd)\n\n[C结构体之位域（位段）](http://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html)\n\n[字节对齐](https://www.jianshu.com/p/5cdf12b32222)\n\n[详解大端模式和小端模式](https://blog.csdn.net/ce123_zhouwei/article/details/6971544)\n","source":"_posts/C++/struct位段和字节对齐原理及其计算法则.md","raw":"---\ntitle: struct位段和字节对齐原理及其计算法则\nurlname: struct-byte-alignment\ndate: 2018-03-12 17:04:21\ncopyright: true\nmathjax: true\ntags:\n- C++\ncategories:\n- C++\n---\n\n## 位段基础知识\n\n在实际编程过程中有些数据存储可能只需要1位或者几个比特位就可以，如果为了几位数据而定义一个完整字节将会浪费大量内存，正是由于这个原因，C语言提供一种称为位段（又称为位域）的数据结构。位段基本定义如下：\n\n```cpp\nstruct pidTag\n{\n\tunsigned int inactive : 1;\n\tunsigned int          : 1; /*1个位的填充*/\n\tunsigned int refcount : 6;\n\tunsigned int          : 0; /*填充到下一个字边界*/\n\tshort pidID;\n\tstruct pidTag *link;\n};\n```\n\n位段的声明和struct类似，成员是一个或多个位的字段，这些字段在实际存储可能存储在一个或多个整型变量中。在声明时，位段成员必须是整形或枚举类型（通常是无符号类型），且在成员名的后面是一个冒号和一个整数，整数规定了成员所占用的位数。位域不能是静态类型。不能使用&对位域做取地址运算。如果位域的定义没有给出标识符名字，那么这是无名位域，无法被初始化。无名位域用于填充（padding）内存布局。只有无名位域的比特数可以为0。这种占0比特的无名位域，用于强迫下一个位域在内存分配边界对齐。而且位段在定义时，其最大长度不能超过依附类型的长度。\n\n位段在存储时有自己的对齐规则：\n\n1. 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；\n2. 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；\n3. 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；\n4. 如果位域字段之间穿插着非位域字段，则不进行压缩；\n5. 整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。\n\n位段在存储时有多种实现，一般可分为两种[文字来源](https://zh.wikipedia.org/wiki/位段)：\n\n### 大小端系统\n\n通常在大端序系统（如PowerPC），安排位域从最重要字节（most-significant byte）到最不重要位（least-significant byte），在一个字节内部从最重要位（most-significant bit）到最不重要位（least-significant bit）；而在小端序系统（如x86），安排位域从最不重要位（least-significant byte）到最重要字节（most-significant byte），在一个字节内部从最不重要位（least-significant bit）到最重要位（most-significant bit）。<font color=red>共同遵从的原则是内存字节地址从低到高，内存内部的比特编号从低到高。</font>\n\n### Microsoft Visual C++实现\n\n在一个整数（integer）内的位域从最不重要位（least-significant）向最重要位（most-significant）依次分配。相邻的两个位域如果基类型（underlying type）的长度相同，在后的位域适合当前内存分配单元且没有跨内存分配边界，那么这两个位域分配到同一个（1、2或4字节的）分配单元。这可以通俗理解为：具有相同的基类型（underlying type）长度的相邻位域尽量装入基类型的同一个对象，如果装得下的话。\n\n注：Most Significant Bit/Byte是指在一个字节序列中对序列取值影响最大那个字节，而Least Significant Bit/Byte则是取值影响最小的字节。\n\n## 只含基本类型结构体字节对齐\n\n在现代计算机中，受限于CPU寻址特点，每次CPU读取内存总是一次性读取多个字节，在32位计算机中一次性读取4个字节的数据，因此数据在内存中放置的位置并不是任意的，字节对齐后可以加快内存的访问速度。\n\n在分析字节对齐时，需要有以下基本概念：\n\n1. 数据类型自身的对齐值：char自对齐字节为1，short为2，int/float为4，double为8，指针根据平台不同略有差异，32位为4字节而64为8字节。\n2. 结构体或者类的自身对齐值：成员中自对齐值最大的那个\n3. 指定对齐值：使用#pragma pack(value)时指定对齐值为value\n4. 数据成员、结构体、类有效对齐值：自身对齐值和指定对齐值的较小一个，即min(value,自身对齐值)\n\n接下来分析一个具体实例，代码如下：\n\n前提条件：int-4字节，char-1字节，short-2字节\n\n```cpp\nstruct A{\n\tint    a;\n\tchar   b;\n\tshort  c;\n};\nstruct B{\n\tchar   b;\n\tint    a;\n\tshort  c;\n};\n```\n\n上述结构体中，sizeof(A)=8，sizeof(B)=12。假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为 2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000~0x0009=10字节，(10＋2)％4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)=12。之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。\n\n\n根据以上分析，字节对齐时一般需要遵循以下原则：\n\n1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除\n2. 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)\n3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节(trailing padding)\n\n以上规则解释如下：\n\n- 第1条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。\n- 第2条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。\n- 第3条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第3条，否则就必须在最后填充几个字节以达到本条要求。\n\n自定义对齐字节采用`#pragma pack(value)`和`#pragma pack()`成对使用，分别表示设定和复位。\n\n## 结构体与联合体互相内嵌的情况\n\n此处的结构体均是C中的struct和union，由于C++中结构体可以包含虚函数，使得分析更为复杂，故只以C中为准。\n\n前提条件为：double-8字节，int-4字节，char-1字节，short-2字节\n\n先定义一个结构体和一个联合体：\n\n```\nstruct SData\n{\n        double dVal;\n        int iVal1;\n        short sVal;\n        int iVal2;\n        char cVal;\n};\n\nunion UData\n{\n        int iArray[3];\n        short sVal;\n        char cVal;\n};\n```\n\n### 结构体内嵌结构体\n\n案例如下：\n\n```\nstruct SWithS\n{\n        int iVal;\n        SData sdVal;\n        char cVal;\n};\n```\n\n首先分析SData的基本情况。在SData中最长成员为8字节，因此其大小应该为8字节的整数倍。根据前面的规则分析有： \n \n`sizeof(SData) = 8(dVal) + 8(iVal1+sVal+padding)+8(iVal2+cVal+padding)=24。` \n\n对于整个结构体类型而言其自身的对齐值是内部最宽的数据类型即8字节，因此可以得出：  \n\n`sizeof(SWithS)=8(iVal+padding)+24(sdVal)+8(cVal+padding)=40。`\n\n将上述结构体在VS2017-64位平台以及g++7.3.0-64位测试结果为：\n\n```\n/*VS2017-64位平台*/\nsizeof(SData)=24\nsizeof(SWithS)=40\n\n/*g++7.3.0-64位平台*/\nsizeof(SData)=24\nsizeof(SWithS)=40\n```\n\n### 结构体内嵌联合体\n\n案例如下：\n\n```\nstruct SWithU\n{\n        int iVal;\n        UData udVal;\n        char cVal;\n};\n```\n\n首先分析UData的基本情况，由于UData中最长成员为4字节，因此其按照4字节对齐，由于iArray成员内存最大，因此：\n\n`sizeof(UData)=12。`\n\n联合体自身的对齐值是和结构体类似，因此：\n\n`sizeof(SWithU)=4(ival)+12(udVal)+4(cVal+padding)=20。`\n\n分别在两个平台测试，测试结果如下：\n\n```\n/*VS2017-64位平台*/\nsizeof(UData)=12\nsizeof(SWithU)=20\n\n/*g++7.3.0-64位平台*/\nsizeof(UData)=12\nsizeof(SWithU)=20\n```\n\n### 联合体内嵌联合体\n\n案例如下：\n\n```\nunion UWithU\n{\n        int iVal;\n        UData udVal;\n        char cArray[13];\n};\n```\n\n由于联合体内部的udVal成员对齐值为4，因此整个UWithU联合体对齐值为4。取最大成员同时对齐到4字节，由此：\n\n`sizeof(UWithU)=16(cArray+padding)=16。`\n\n分别在两个平台测试，测试结果如下：\n\n```\n/*VS2017-64位平台*/\nsizeof(UWithU)=16\n\n/*g++7.3.0-64位平台*/\nsizeof(UWithU)=16\n```\n\n### 联合体内嵌结构体\n\n案例如下：\n\n```\nunion UWithS\n{\n        int iVal;\n        SData sdVal; /*24*/\n        char cArray[25];\n};\n```\n\n由于联合体内部的sdVal成员对齐值为8，因此整个sdVal联合体对齐值为8。取最大成员同时对齐到8字节，由此：\n\n`sizeof(UWithS)=32(cArray+padding)=32。`\n\n分别在两个平台测试，测试结果如下：\n\n```\n/*VS2017-64位平台*/\nsizeof(UWithS)=32\n\n/*g++7.3.0-64位平台*/\nsizeof(UWithS)=32\n```\n\n## 判断机器是大端或小端\n\n```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\t//定义一个两字节类型，一定要是两个字节，否则失效\n\tshort x = 0x1234; \n\tchar *p = (char *)&x;\n\tif (*p == 0x34) {\n\t\tcout << \"Little-Endian\" << endl;\n\t}\n\telse if (*p == 0x12) {\n\t\tcout << \"Big-Endian\" << endl;\n\t}\n\telse {\n\t\tcout << \"Unable to judge\" << endl;\n\t}\n\treturn 0;\n}\n```\n在上述代码中，如果大端机器，则内存低位到高位依次存储12--34，小端则依次为34--12，因此通过判断低地址一个字节的值就可以判断大小端机器。\n\n\n\n## 参考文章\n\n[C专家编程](https://book.douban.com/subject/2377310/)\n\n[失传的C结构体打包技艺](https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing)\n\n[struct/class等内存字节对齐问题详解](http://www.cnblogs.com/webary/p/4721017.html)\n\n[C语言字节对齐问题详解](http://www.cnblogs.com/clover-toeic/p/3853132.html)\n\n[C语言位域](http://c.biancheng.net/cpp/html/102.html)\n\n[每个程序员都应当知道的“大小端”](https://www.jianshu.com/p/05aac833eacd)\n\n[C结构体之位域（位段）](http://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html)\n\n[字节对齐](https://www.jianshu.com/p/5cdf12b32222)\n\n[详解大端模式和小端模式](https://blog.csdn.net/ce123_zhouwei/article/details/6971544)\n","slug":"C++/struct位段和字节对齐原理及其计算法则","published":1,"updated":"2018-06-13T14:21:59.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x2y000agsvnnt3e923e","content":"<h2 id=\"位段基础知识\"><a href=\"#位段基础知识\" class=\"headerlink\" title=\"位段基础知识\"></a>位段基础知识</h2><p>在实际编程过程中有些数据存储可能只需要1位或者几个比特位就可以，如果为了几位数据而定义一个完整字节将会浪费大量内存，正是由于这个原因，C语言提供一种称为位段（又称为位域）的数据结构。位段基本定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pidTag</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> inactive : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>          : <span class=\"number\">1</span>; <span class=\"comment\">/*1个位的填充*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> refcount : <span class=\"number\">6</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>          : <span class=\"number\">0</span>; <span class=\"comment\">/*填充到下一个字边界*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">short</span> pidID;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pidTag</span> *<span class=\"title\">link</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>位段的声明和struct类似，成员是一个或多个位的字段，这些字段在实际存储可能存储在一个或多个整型变量中。在声明时，位段成员必须是整形或枚举类型（通常是无符号类型），且在成员名的后面是一个冒号和一个整数，整数规定了成员所占用的位数。位域不能是静态类型。不能使用&amp;对位域做取地址运算。如果位域的定义没有给出标识符名字，那么这是无名位域，无法被初始化。无名位域用于填充（padding）内存布局。只有无名位域的比特数可以为0。这种占0比特的无名位域，用于强迫下一个位域在内存分配边界对齐。而且位段在定义时，其最大长度不能超过依附类型的长度。</p>\n<p>位段在存储时有自己的对齐规则：</p>\n<ol>\n<li>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</li>\n<li>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</li>\n<li>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；</li>\n<li>如果位域字段之间穿插着非位域字段，则不进行压缩；</li>\n<li>整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。</li>\n</ol>\n<p>位段在存储时有多种实现，一般可分为两种<a href=\"https://zh.wikipedia.org/wiki/位段\" target=\"_blank\" rel=\"noopener\">文字来源</a>：</p>\n<h3 id=\"大小端系统\"><a href=\"#大小端系统\" class=\"headerlink\" title=\"大小端系统\"></a>大小端系统</h3><p>通常在大端序系统（如PowerPC），安排位域从最重要字节（most-significant byte）到最不重要位（least-significant byte），在一个字节内部从最重要位（most-significant bit）到最不重要位（least-significant bit）；而在小端序系统（如x86），安排位域从最不重要位（least-significant byte）到最重要字节（most-significant byte），在一个字节内部从最不重要位（least-significant bit）到最重要位（most-significant bit）。<font color=\"red\">共同遵从的原则是内存字节地址从低到高，内存内部的比特编号从低到高。</font></p>\n<h3 id=\"Microsoft-Visual-C-实现\"><a href=\"#Microsoft-Visual-C-实现\" class=\"headerlink\" title=\"Microsoft Visual C++实现\"></a>Microsoft Visual C++实现</h3><p>在一个整数（integer）内的位域从最不重要位（least-significant）向最重要位（most-significant）依次分配。相邻的两个位域如果基类型（underlying type）的长度相同，在后的位域适合当前内存分配单元且没有跨内存分配边界，那么这两个位域分配到同一个（1、2或4字节的）分配单元。这可以通俗理解为：具有相同的基类型（underlying type）长度的相邻位域尽量装入基类型的同一个对象，如果装得下的话。</p>\n<p>注：Most Significant Bit/Byte是指在一个字节序列中对序列取值影响最大那个字节，而Least Significant Bit/Byte则是取值影响最小的字节。</p>\n<h2 id=\"只含基本类型结构体字节对齐\"><a href=\"#只含基本类型结构体字节对齐\" class=\"headerlink\" title=\"只含基本类型结构体字节对齐\"></a>只含基本类型结构体字节对齐</h2><p>在现代计算机中，受限于CPU寻址特点，每次CPU读取内存总是一次性读取多个字节，在32位计算机中一次性读取4个字节的数据，因此数据在内存中放置的位置并不是任意的，字节对齐后可以加快内存的访问速度。</p>\n<p>在分析字节对齐时，需要有以下基本概念：</p>\n<ol>\n<li>数据类型自身的对齐值：char自对齐字节为1，short为2，int/float为4，double为8，指针根据平台不同略有差异，32位为4字节而64为8字节。</li>\n<li>结构体或者类的自身对齐值：成员中自对齐值最大的那个</li>\n<li>指定对齐值：使用#pragma pack(value)时指定对齐值为value</li>\n<li>数据成员、结构体、类有效对齐值：自身对齐值和指定对齐值的较小一个，即min(value,自身对齐值)</li>\n</ol>\n<p>接下来分析一个具体实例，代码如下：</p>\n<p>前提条件：int-4字节，char-1字节，short-2字节</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>    a;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>   b;</span><br><span class=\"line\">\t<span class=\"keyword\">short</span>  c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>   b;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>    a;</span><br><span class=\"line\">\t<span class=\"keyword\">short</span>  c;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述结构体中，sizeof(A)=8，sizeof(B)=12。假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为 2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000~0x0009=10字节，(10＋2)％4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)=12。之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。</p>\n<p>根据以上分析，字节对齐时一般需要遵循以下原则：</p>\n<ol>\n<li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除</li>\n<li>结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)</li>\n<li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节(trailing padding)</li>\n</ol>\n<p>以上规则解释如下：</p>\n<ul>\n<li>第1条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</li>\n<li>第2条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</li>\n<li>第3条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第3条，否则就必须在最后填充几个字节以达到本条要求。</li>\n</ul>\n<p>自定义对齐字节采用<code>#pragma pack(value)</code>和<code>#pragma pack()</code>成对使用，分别表示设定和复位。</p>\n<h2 id=\"结构体与联合体互相内嵌的情况\"><a href=\"#结构体与联合体互相内嵌的情况\" class=\"headerlink\" title=\"结构体与联合体互相内嵌的情况\"></a>结构体与联合体互相内嵌的情况</h2><p>此处的结构体均是C中的struct和union，由于C++中结构体可以包含虚函数，使得分析更为复杂，故只以C中为准。</p>\n<p>前提条件为：double-8字节，int-4字节，char-1字节，short-2字节</p>\n<p>先定义一个结构体和一个联合体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct SData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        double dVal;</span><br><span class=\"line\">        int iVal1;</span><br><span class=\"line\">        short sVal;</span><br><span class=\"line\">        int iVal2;</span><br><span class=\"line\">        char cVal;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">union UData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iArray[3];</span><br><span class=\"line\">        short sVal;</span><br><span class=\"line\">        char cVal;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结构体内嵌结构体\"><a href=\"#结构体内嵌结构体\" class=\"headerlink\" title=\"结构体内嵌结构体\"></a>结构体内嵌结构体</h3><p>案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct SWithS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iVal;</span><br><span class=\"line\">        SData sdVal;</span><br><span class=\"line\">        char cVal;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>首先分析SData的基本情况。在SData中最长成员为8字节，因此其大小应该为8字节的整数倍。根据前面的规则分析有： </p>\n<p><code>sizeof(SData) = 8(dVal) + 8(iVal1+sVal+padding)+8(iVal2+cVal+padding)=24。</code> </p>\n<p>对于整个结构体类型而言其自身的对齐值是内部最宽的数据类型即8字节，因此可以得出：  </p>\n<p><code>sizeof(SWithS)=8(iVal+padding)+24(sdVal)+8(cVal+padding)=40。</code></p>\n<p>将上述结构体在VS2017-64位平台以及g++7.3.0-64位测试结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*VS2017-64位平台*/</span><br><span class=\"line\">sizeof(SData)=24</span><br><span class=\"line\">sizeof(SWithS)=40</span><br><span class=\"line\"></span><br><span class=\"line\">/*g++7.3.0-64位平台*/</span><br><span class=\"line\">sizeof(SData)=24</span><br><span class=\"line\">sizeof(SWithS)=40</span><br></pre></td></tr></table></figure>\n<h3 id=\"结构体内嵌联合体\"><a href=\"#结构体内嵌联合体\" class=\"headerlink\" title=\"结构体内嵌联合体\"></a>结构体内嵌联合体</h3><p>案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct SWithU</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iVal;</span><br><span class=\"line\">        UData udVal;</span><br><span class=\"line\">        char cVal;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>首先分析UData的基本情况，由于UData中最长成员为4字节，因此其按照4字节对齐，由于iArray成员内存最大，因此：</p>\n<p><code>sizeof(UData)=12。</code></p>\n<p>联合体自身的对齐值是和结构体类似，因此：</p>\n<p><code>sizeof(SWithU)=4(ival)+12(udVal)+4(cVal+padding)=20。</code></p>\n<p>分别在两个平台测试，测试结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*VS2017-64位平台*/</span><br><span class=\"line\">sizeof(UData)=12</span><br><span class=\"line\">sizeof(SWithU)=20</span><br><span class=\"line\"></span><br><span class=\"line\">/*g++7.3.0-64位平台*/</span><br><span class=\"line\">sizeof(UData)=12</span><br><span class=\"line\">sizeof(SWithU)=20</span><br></pre></td></tr></table></figure>\n<h3 id=\"联合体内嵌联合体\"><a href=\"#联合体内嵌联合体\" class=\"headerlink\" title=\"联合体内嵌联合体\"></a>联合体内嵌联合体</h3><p>案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union UWithU</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iVal;</span><br><span class=\"line\">        UData udVal;</span><br><span class=\"line\">        char cArray[13];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由于联合体内部的udVal成员对齐值为4，因此整个UWithU联合体对齐值为4。取最大成员同时对齐到4字节，由此：</p>\n<p><code>sizeof(UWithU)=16(cArray+padding)=16。</code></p>\n<p>分别在两个平台测试，测试结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*VS2017-64位平台*/</span><br><span class=\"line\">sizeof(UWithU)=16</span><br><span class=\"line\"></span><br><span class=\"line\">/*g++7.3.0-64位平台*/</span><br><span class=\"line\">sizeof(UWithU)=16</span><br></pre></td></tr></table></figure>\n<h3 id=\"联合体内嵌结构体\"><a href=\"#联合体内嵌结构体\" class=\"headerlink\" title=\"联合体内嵌结构体\"></a>联合体内嵌结构体</h3><p>案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union UWithS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iVal;</span><br><span class=\"line\">        SData sdVal; /*24*/</span><br><span class=\"line\">        char cArray[25];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由于联合体内部的sdVal成员对齐值为8，因此整个sdVal联合体对齐值为8。取最大成员同时对齐到8字节，由此：</p>\n<p><code>sizeof(UWithS)=32(cArray+padding)=32。</code></p>\n<p>分别在两个平台测试，测试结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*VS2017-64位平台*/</span><br><span class=\"line\">sizeof(UWithS)=32</span><br><span class=\"line\"></span><br><span class=\"line\">/*g++7.3.0-64位平台*/</span><br><span class=\"line\">sizeof(UWithS)=32</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断机器是大端或小端\"><a href=\"#判断机器是大端或小端\" class=\"headerlink\" title=\"判断机器是大端或小端\"></a>判断机器是大端或小端</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//定义一个两字节类型，一定要是两个字节，否则失效</span></span><br><span class=\"line\">\t<span class=\"keyword\">short</span> x = <span class=\"number\">0x1234</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *p = (<span class=\"keyword\">char</span> *)&amp;x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*p == <span class=\"number\">0x34</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Little-Endian\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*p == <span class=\"number\">0x12</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Big-Endian\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Unable to judge\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，如果大端机器，则内存低位到高位依次存储12–34，小端则依次为34–12，因此通过判断低地址一个字节的值就可以判断大小端机器。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/2377310/\" target=\"_blank\" rel=\"noopener\">C专家编程</a></p>\n<p><a href=\"https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing\" target=\"_blank\" rel=\"noopener\">失传的C结构体打包技艺</a></p>\n<p><a href=\"http://www.cnblogs.com/webary/p/4721017.html\" target=\"_blank\" rel=\"noopener\">struct/class等内存字节对齐问题详解</a></p>\n<p><a href=\"http://www.cnblogs.com/clover-toeic/p/3853132.html\" target=\"_blank\" rel=\"noopener\">C语言字节对齐问题详解</a></p>\n<p><a href=\"http://c.biancheng.net/cpp/html/102.html\" target=\"_blank\" rel=\"noopener\">C语言位域</a></p>\n<p><a href=\"https://www.jianshu.com/p/05aac833eacd\" target=\"_blank\" rel=\"noopener\">每个程序员都应当知道的“大小端”</a></p>\n<p><a href=\"http://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html\" target=\"_blank\" rel=\"noopener\">C结构体之位域（位段）</a></p>\n<p><a href=\"https://www.jianshu.com/p/5cdf12b32222\" target=\"_blank\" rel=\"noopener\">字节对齐</a></p>\n<p><a href=\"https://blog.csdn.net/ce123_zhouwei/article/details/6971544\" target=\"_blank\" rel=\"noopener\">详解大端模式和小端模式</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"位段基础知识\"><a href=\"#位段基础知识\" class=\"headerlink\" title=\"位段基础知识\"></a>位段基础知识</h2><p>在实际编程过程中有些数据存储可能只需要1位或者几个比特位就可以，如果为了几位数据而定义一个完整字节将会浪费大量内存，正是由于这个原因，C语言提供一种称为位段（又称为位域）的数据结构。位段基本定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pidTag</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> inactive : <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>          : <span class=\"number\">1</span>; <span class=\"comment\">/*1个位的填充*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> refcount : <span class=\"number\">6</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>          : <span class=\"number\">0</span>; <span class=\"comment\">/*填充到下一个字边界*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">short</span> pidID;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pidTag</span> *<span class=\"title\">link</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>位段的声明和struct类似，成员是一个或多个位的字段，这些字段在实际存储可能存储在一个或多个整型变量中。在声明时，位段成员必须是整形或枚举类型（通常是无符号类型），且在成员名的后面是一个冒号和一个整数，整数规定了成员所占用的位数。位域不能是静态类型。不能使用&amp;对位域做取地址运算。如果位域的定义没有给出标识符名字，那么这是无名位域，无法被初始化。无名位域用于填充（padding）内存布局。只有无名位域的比特数可以为0。这种占0比特的无名位域，用于强迫下一个位域在内存分配边界对齐。而且位段在定义时，其最大长度不能超过依附类型的长度。</p>\n<p>位段在存储时有自己的对齐规则：</p>\n<ol>\n<li>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</li>\n<li>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</li>\n<li>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；</li>\n<li>如果位域字段之间穿插着非位域字段，则不进行压缩；</li>\n<li>整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。</li>\n</ol>\n<p>位段在存储时有多种实现，一般可分为两种<a href=\"https://zh.wikipedia.org/wiki/位段\" target=\"_blank\" rel=\"noopener\">文字来源</a>：</p>\n<h3 id=\"大小端系统\"><a href=\"#大小端系统\" class=\"headerlink\" title=\"大小端系统\"></a>大小端系统</h3><p>通常在大端序系统（如PowerPC），安排位域从最重要字节（most-significant byte）到最不重要位（least-significant byte），在一个字节内部从最重要位（most-significant bit）到最不重要位（least-significant bit）；而在小端序系统（如x86），安排位域从最不重要位（least-significant byte）到最重要字节（most-significant byte），在一个字节内部从最不重要位（least-significant bit）到最重要位（most-significant bit）。<font color=\"red\">共同遵从的原则是内存字节地址从低到高，内存内部的比特编号从低到高。</font></p>\n<h3 id=\"Microsoft-Visual-C-实现\"><a href=\"#Microsoft-Visual-C-实现\" class=\"headerlink\" title=\"Microsoft Visual C++实现\"></a>Microsoft Visual C++实现</h3><p>在一个整数（integer）内的位域从最不重要位（least-significant）向最重要位（most-significant）依次分配。相邻的两个位域如果基类型（underlying type）的长度相同，在后的位域适合当前内存分配单元且没有跨内存分配边界，那么这两个位域分配到同一个（1、2或4字节的）分配单元。这可以通俗理解为：具有相同的基类型（underlying type）长度的相邻位域尽量装入基类型的同一个对象，如果装得下的话。</p>\n<p>注：Most Significant Bit/Byte是指在一个字节序列中对序列取值影响最大那个字节，而Least Significant Bit/Byte则是取值影响最小的字节。</p>\n<h2 id=\"只含基本类型结构体字节对齐\"><a href=\"#只含基本类型结构体字节对齐\" class=\"headerlink\" title=\"只含基本类型结构体字节对齐\"></a>只含基本类型结构体字节对齐</h2><p>在现代计算机中，受限于CPU寻址特点，每次CPU读取内存总是一次性读取多个字节，在32位计算机中一次性读取4个字节的数据，因此数据在内存中放置的位置并不是任意的，字节对齐后可以加快内存的访问速度。</p>\n<p>在分析字节对齐时，需要有以下基本概念：</p>\n<ol>\n<li>数据类型自身的对齐值：char自对齐字节为1，short为2，int/float为4，double为8，指针根据平台不同略有差异，32位为4字节而64为8字节。</li>\n<li>结构体或者类的自身对齐值：成员中自对齐值最大的那个</li>\n<li>指定对齐值：使用#pragma pack(value)时指定对齐值为value</li>\n<li>数据成员、结构体、类有效对齐值：自身对齐值和指定对齐值的较小一个，即min(value,自身对齐值)</li>\n</ol>\n<p>接下来分析一个具体实例，代码如下：</p>\n<p>前提条件：int-4字节，char-1字节，short-2字节</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>    a;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>   b;</span><br><span class=\"line\">\t<span class=\"keyword\">short</span>  c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>   b;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>    a;</span><br><span class=\"line\">\t<span class=\"keyword\">short</span>  c;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述结构体中，sizeof(A)=8，sizeof(B)=12。假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为 2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000~0x0009=10字节，(10＋2)％4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)=12。之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。</p>\n<p>根据以上分析，字节对齐时一般需要遵循以下原则：</p>\n<ol>\n<li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除</li>\n<li>结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)</li>\n<li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节(trailing padding)</li>\n</ol>\n<p>以上规则解释如下：</p>\n<ul>\n<li>第1条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</li>\n<li>第2条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</li>\n<li>第3条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第3条，否则就必须在最后填充几个字节以达到本条要求。</li>\n</ul>\n<p>自定义对齐字节采用<code>#pragma pack(value)</code>和<code>#pragma pack()</code>成对使用，分别表示设定和复位。</p>\n<h2 id=\"结构体与联合体互相内嵌的情况\"><a href=\"#结构体与联合体互相内嵌的情况\" class=\"headerlink\" title=\"结构体与联合体互相内嵌的情况\"></a>结构体与联合体互相内嵌的情况</h2><p>此处的结构体均是C中的struct和union，由于C++中结构体可以包含虚函数，使得分析更为复杂，故只以C中为准。</p>\n<p>前提条件为：double-8字节，int-4字节，char-1字节，short-2字节</p>\n<p>先定义一个结构体和一个联合体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct SData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        double dVal;</span><br><span class=\"line\">        int iVal1;</span><br><span class=\"line\">        short sVal;</span><br><span class=\"line\">        int iVal2;</span><br><span class=\"line\">        char cVal;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">union UData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iArray[3];</span><br><span class=\"line\">        short sVal;</span><br><span class=\"line\">        char cVal;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结构体内嵌结构体\"><a href=\"#结构体内嵌结构体\" class=\"headerlink\" title=\"结构体内嵌结构体\"></a>结构体内嵌结构体</h3><p>案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct SWithS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iVal;</span><br><span class=\"line\">        SData sdVal;</span><br><span class=\"line\">        char cVal;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>首先分析SData的基本情况。在SData中最长成员为8字节，因此其大小应该为8字节的整数倍。根据前面的规则分析有： </p>\n<p><code>sizeof(SData) = 8(dVal) + 8(iVal1+sVal+padding)+8(iVal2+cVal+padding)=24。</code> </p>\n<p>对于整个结构体类型而言其自身的对齐值是内部最宽的数据类型即8字节，因此可以得出：  </p>\n<p><code>sizeof(SWithS)=8(iVal+padding)+24(sdVal)+8(cVal+padding)=40。</code></p>\n<p>将上述结构体在VS2017-64位平台以及g++7.3.0-64位测试结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*VS2017-64位平台*/</span><br><span class=\"line\">sizeof(SData)=24</span><br><span class=\"line\">sizeof(SWithS)=40</span><br><span class=\"line\"></span><br><span class=\"line\">/*g++7.3.0-64位平台*/</span><br><span class=\"line\">sizeof(SData)=24</span><br><span class=\"line\">sizeof(SWithS)=40</span><br></pre></td></tr></table></figure>\n<h3 id=\"结构体内嵌联合体\"><a href=\"#结构体内嵌联合体\" class=\"headerlink\" title=\"结构体内嵌联合体\"></a>结构体内嵌联合体</h3><p>案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct SWithU</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iVal;</span><br><span class=\"line\">        UData udVal;</span><br><span class=\"line\">        char cVal;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>首先分析UData的基本情况，由于UData中最长成员为4字节，因此其按照4字节对齐，由于iArray成员内存最大，因此：</p>\n<p><code>sizeof(UData)=12。</code></p>\n<p>联合体自身的对齐值是和结构体类似，因此：</p>\n<p><code>sizeof(SWithU)=4(ival)+12(udVal)+4(cVal+padding)=20。</code></p>\n<p>分别在两个平台测试，测试结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*VS2017-64位平台*/</span><br><span class=\"line\">sizeof(UData)=12</span><br><span class=\"line\">sizeof(SWithU)=20</span><br><span class=\"line\"></span><br><span class=\"line\">/*g++7.3.0-64位平台*/</span><br><span class=\"line\">sizeof(UData)=12</span><br><span class=\"line\">sizeof(SWithU)=20</span><br></pre></td></tr></table></figure>\n<h3 id=\"联合体内嵌联合体\"><a href=\"#联合体内嵌联合体\" class=\"headerlink\" title=\"联合体内嵌联合体\"></a>联合体内嵌联合体</h3><p>案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union UWithU</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iVal;</span><br><span class=\"line\">        UData udVal;</span><br><span class=\"line\">        char cArray[13];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由于联合体内部的udVal成员对齐值为4，因此整个UWithU联合体对齐值为4。取最大成员同时对齐到4字节，由此：</p>\n<p><code>sizeof(UWithU)=16(cArray+padding)=16。</code></p>\n<p>分别在两个平台测试，测试结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*VS2017-64位平台*/</span><br><span class=\"line\">sizeof(UWithU)=16</span><br><span class=\"line\"></span><br><span class=\"line\">/*g++7.3.0-64位平台*/</span><br><span class=\"line\">sizeof(UWithU)=16</span><br></pre></td></tr></table></figure>\n<h3 id=\"联合体内嵌结构体\"><a href=\"#联合体内嵌结构体\" class=\"headerlink\" title=\"联合体内嵌结构体\"></a>联合体内嵌结构体</h3><p>案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union UWithS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        int iVal;</span><br><span class=\"line\">        SData sdVal; /*24*/</span><br><span class=\"line\">        char cArray[25];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由于联合体内部的sdVal成员对齐值为8，因此整个sdVal联合体对齐值为8。取最大成员同时对齐到8字节，由此：</p>\n<p><code>sizeof(UWithS)=32(cArray+padding)=32。</code></p>\n<p>分别在两个平台测试，测试结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*VS2017-64位平台*/</span><br><span class=\"line\">sizeof(UWithS)=32</span><br><span class=\"line\"></span><br><span class=\"line\">/*g++7.3.0-64位平台*/</span><br><span class=\"line\">sizeof(UWithS)=32</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断机器是大端或小端\"><a href=\"#判断机器是大端或小端\" class=\"headerlink\" title=\"判断机器是大端或小端\"></a>判断机器是大端或小端</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//定义一个两字节类型，一定要是两个字节，否则失效</span></span><br><span class=\"line\">\t<span class=\"keyword\">short</span> x = <span class=\"number\">0x1234</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *p = (<span class=\"keyword\">char</span> *)&amp;x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*p == <span class=\"number\">0x34</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Little-Endian\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*p == <span class=\"number\">0x12</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Big-Endian\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Unable to judge\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，如果大端机器，则内存低位到高位依次存储12–34，小端则依次为34–12，因此通过判断低地址一个字节的值就可以判断大小端机器。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/2377310/\" target=\"_blank\" rel=\"noopener\">C专家编程</a></p>\n<p><a href=\"https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing\" target=\"_blank\" rel=\"noopener\">失传的C结构体打包技艺</a></p>\n<p><a href=\"http://www.cnblogs.com/webary/p/4721017.html\" target=\"_blank\" rel=\"noopener\">struct/class等内存字节对齐问题详解</a></p>\n<p><a href=\"http://www.cnblogs.com/clover-toeic/p/3853132.html\" target=\"_blank\" rel=\"noopener\">C语言字节对齐问题详解</a></p>\n<p><a href=\"http://c.biancheng.net/cpp/html/102.html\" target=\"_blank\" rel=\"noopener\">C语言位域</a></p>\n<p><a href=\"https://www.jianshu.com/p/05aac833eacd\" target=\"_blank\" rel=\"noopener\">每个程序员都应当知道的“大小端”</a></p>\n<p><a href=\"http://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html\" target=\"_blank\" rel=\"noopener\">C结构体之位域（位段）</a></p>\n<p><a href=\"https://www.jianshu.com/p/5cdf12b32222\" target=\"_blank\" rel=\"noopener\">字节对齐</a></p>\n<p><a href=\"https://blog.csdn.net/ce123_zhouwei/article/details/6971544\" target=\"_blank\" rel=\"noopener\">详解大端模式和小端模式</a></p>\n"},{"title":"GitHub+Hexo搭建个人博客站及备份原始网站数据过程记录","urlname":"build-blog-website","date":"2018-02-28T11:56:13.000Z","copyright":true,"mathjax":true,"_content":"\n万事开头难，大约在一年前我就想着架个属于自己的博客站，但是由于各种原因多次准备架站时又不得不中途放弃，这次总算是上线了，写下这篇文章作为最终成功上线博客的留念。\n## Hexo快速安装\n\n### 注册Github账号\n\n如果你已经有了账号可略过该步，传送门：（[注册GitHub传送门](https://github.com)）\n\n### 创建repository\n点击头像左边的+号（[新建repository传送门](https://github.com/new)），新建一个repository，“Repository name”格式必须为：username.github.io，username为你注册的用户名。设置完名字建议勾选“Initialize this repository with a README”，便于新建一个用于保存原始网站文件的分支（branch）。点击“Create repository”创建repository完毕。<br>\n创建repository后项目下会有一个默认的master分支，该分支用来保存Hexo生成的网页文件。接着新建分支用来存放Hexo原始网站数据方便自己更换电脑时同步。比如创建一个名为backup的分支，并设置为默认分支（这步一定要做）。\n\n### 安装Git工具\nGit是开源的分布式的版本控制系统，具体见（[Git是什么传送门](http://www.runoob.com/git/git-tutorial.html)）。Git软件下载地址见（[Git下载传送门](https://git-scm.com/download/)）。安装过程和Windows常用软件相似。\n\n### 绑定Git和你的GitHub账号\nGit安装完毕后打开“Git Bash\"，使用命令行界面绑定GitHub账号。输入以下命令：\n\n``` \ngit config --global user.name “你GitHub注册用户名”\n```\n\n``` \ngit config --global user.email “你GitHub注册的邮箱账号”\n```\n\n以上便完成Git和你的GitHub账号的绑定\n### 注册密钥\n在“Git Bash”中输入\n\n``` \nssh-keygen -t rsa -C “你GitHub注册的邮箱账号”\n```\n\n会在Windows系统安装盘“C:\\Users\\你的电脑名称\\\\.ssh”目录下生成一个名为“id\\_rsa.pub”的文件，用任何文本处理软件打开，推荐使用NotePad++打开。（[NotePad++下载传送门](https://notepad-plus-plus.org/download/v7.5.5.html)）<br>\n打开GitHub用户设置界面，切换到“SSH and GPG keys”下（[添加SSH key传送门](https://github.com/settings/ssh/new)）。将“id_rsa.pub”文件内容复制的“Key”文本框中，“Title”文本框随便填写一些信息，比如阐明Key的用途。最后点击“Add SSH Key”按钮完成密钥的注册。\n\n### 安装Node.js\n由于Hexo基于Node.js，因此需要安装Node.js。（[下载传送门](https://nodejs.org/en/download/)）<br>\n和普通Windows软件一样安装，安装结束后打开cmd或者PowerShell输入\n``` \nnode -v\n```\n如果输出版本号则证明安装成功。\n\n### 克隆repository到本地\n由于我们需要在另外一个分支备份网站的原始数据，为了避免上传原始网站数据到GitHub仓库的出现各种错误，在你本地新建一个文件夹，进入该文件夹后按住Shift键右击鼠标打开“Git Bash”，输入：\n\n``` \ngit clone git@github.com:你GitHub注册用户名/你GitHub注册用户名.github.io.git\n```\n\n结束后本地会新建一个名为“你GitHub注册用户名.github.io”的文件夹。\n\n### 本地安装Hexo\n进入上步“你GitHub注册用户名.github.io”的文件夹，按住Shift键右击鼠标打开“Git Bash”，输入：\n\n``` \nnpm install -g hexo-cli \n```\n\n这是安装Hexo，需要一点时间下载。\n\n然后输入：\n\n``` \nhexo init blog\n```\n\n会在当前目录创建一个blog文件夹，所有的建站文件均在该文件夹下，将文件夹下的所有文件剪切到上级目录即“你GitHub注册用户名.github.io”文件夹，在该文件夹下按住Shift键右击鼠标打开cmd或者PowerShell输入：\n\n``` \nhexo g\n```\n\n``` \nhexo s\n```\n\n然后在浏览器中输入\n``` \nlocalhost:4000\n```\n便可以打开刚刚建好的博客站了。\n\n### 推送博客站到GitHub上\n上一步创建好的博客站只能在本地电脑中打开，需要推送到GitHub中才能通过“你GitHub注册用户名.github.io”域名方式被网友访问。\n\n首先在“你GitHub注册用户名.github.io”本地文件夹下有一个名为“\\_config.yml”的配置文件，这个称为站点配置文件，使用NotePad++打开并拉到文件最后，填入以下文字：\n\n``` \ndeploy:\n  type: git \n  repo: https://github.com/你GitHub注册用户名/你GitHub注册用户名.github.io.git \n  branch: master\n```\n\n如果出现下面的问题可尝试使用如下配置格式：\n> bash: /dev/tty: No such device or address  \nerror: failed to execute prompt script (exit code 1)  \nfatal: could not read Username for 'https://github.com': No error \n\n\n``` \ndeploy:\n  type: git  \n  repo: git@github.com:你GitHub注册用户名/你GitHub注册用户名.github.io.git  \n  branch: master  \n```\n\n注意deploy下面需要缩进，冒号之后有空格。\n\n接着进入“你GitHub注册用户名.github.io”本地文件下，在该文件夹下按住Shift键右击鼠标打开“Git Bash”依次输入以下命令：\n\n```\nnpm install hexo-deployer-git --save  \nhexo g -d\n```\n\n然后在浏览器中输入“你GitHub注册用户名.github.io”就可以打开刚才建的博客站了。至此建站部分全部完成。\n\n### 备份网站原始数据到GitHub上\n进入“你GitHub注册用户名.github.io”本地文件下，在该文件夹下按住Shift键右击鼠标打开“Git Bash”依次输入以下命令：\n\n```\ngit add .  \ngit commit -m “你为该次备份提供的说明信息”\ngit push origin “你在repository中创建的另外一个分支名”\n```\n\n如果你以后新增修改文件，可以把上述三条命令全部运行一遍即可备份当前修改\n\n至此本次GitHub安装Hexo及备份原始数据全部完成，享受你的个人博客时光吧！\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Hexo/GitHub+Hexo搭建个人博客站及备份原始网站数据过程记录.md","raw":"---\ntitle: GitHub+Hexo搭建个人博客站及备份原始网站数据过程记录\nurlname: build-blog-website\ndate: 2018-02-28 19:56:13\ncopyright: true\nmathjax: true\ntags:\n- Hexo\ncategories:\n- Hexo\n---\n\n万事开头难，大约在一年前我就想着架个属于自己的博客站，但是由于各种原因多次准备架站时又不得不中途放弃，这次总算是上线了，写下这篇文章作为最终成功上线博客的留念。\n## Hexo快速安装\n\n### 注册Github账号\n\n如果你已经有了账号可略过该步，传送门：（[注册GitHub传送门](https://github.com)）\n\n### 创建repository\n点击头像左边的+号（[新建repository传送门](https://github.com/new)），新建一个repository，“Repository name”格式必须为：username.github.io，username为你注册的用户名。设置完名字建议勾选“Initialize this repository with a README”，便于新建一个用于保存原始网站文件的分支（branch）。点击“Create repository”创建repository完毕。<br>\n创建repository后项目下会有一个默认的master分支，该分支用来保存Hexo生成的网页文件。接着新建分支用来存放Hexo原始网站数据方便自己更换电脑时同步。比如创建一个名为backup的分支，并设置为默认分支（这步一定要做）。\n\n### 安装Git工具\nGit是开源的分布式的版本控制系统，具体见（[Git是什么传送门](http://www.runoob.com/git/git-tutorial.html)）。Git软件下载地址见（[Git下载传送门](https://git-scm.com/download/)）。安装过程和Windows常用软件相似。\n\n### 绑定Git和你的GitHub账号\nGit安装完毕后打开“Git Bash\"，使用命令行界面绑定GitHub账号。输入以下命令：\n\n``` \ngit config --global user.name “你GitHub注册用户名”\n```\n\n``` \ngit config --global user.email “你GitHub注册的邮箱账号”\n```\n\n以上便完成Git和你的GitHub账号的绑定\n### 注册密钥\n在“Git Bash”中输入\n\n``` \nssh-keygen -t rsa -C “你GitHub注册的邮箱账号”\n```\n\n会在Windows系统安装盘“C:\\Users\\你的电脑名称\\\\.ssh”目录下生成一个名为“id\\_rsa.pub”的文件，用任何文本处理软件打开，推荐使用NotePad++打开。（[NotePad++下载传送门](https://notepad-plus-plus.org/download/v7.5.5.html)）<br>\n打开GitHub用户设置界面，切换到“SSH and GPG keys”下（[添加SSH key传送门](https://github.com/settings/ssh/new)）。将“id_rsa.pub”文件内容复制的“Key”文本框中，“Title”文本框随便填写一些信息，比如阐明Key的用途。最后点击“Add SSH Key”按钮完成密钥的注册。\n\n### 安装Node.js\n由于Hexo基于Node.js，因此需要安装Node.js。（[下载传送门](https://nodejs.org/en/download/)）<br>\n和普通Windows软件一样安装，安装结束后打开cmd或者PowerShell输入\n``` \nnode -v\n```\n如果输出版本号则证明安装成功。\n\n### 克隆repository到本地\n由于我们需要在另外一个分支备份网站的原始数据，为了避免上传原始网站数据到GitHub仓库的出现各种错误，在你本地新建一个文件夹，进入该文件夹后按住Shift键右击鼠标打开“Git Bash”，输入：\n\n``` \ngit clone git@github.com:你GitHub注册用户名/你GitHub注册用户名.github.io.git\n```\n\n结束后本地会新建一个名为“你GitHub注册用户名.github.io”的文件夹。\n\n### 本地安装Hexo\n进入上步“你GitHub注册用户名.github.io”的文件夹，按住Shift键右击鼠标打开“Git Bash”，输入：\n\n``` \nnpm install -g hexo-cli \n```\n\n这是安装Hexo，需要一点时间下载。\n\n然后输入：\n\n``` \nhexo init blog\n```\n\n会在当前目录创建一个blog文件夹，所有的建站文件均在该文件夹下，将文件夹下的所有文件剪切到上级目录即“你GitHub注册用户名.github.io”文件夹，在该文件夹下按住Shift键右击鼠标打开cmd或者PowerShell输入：\n\n``` \nhexo g\n```\n\n``` \nhexo s\n```\n\n然后在浏览器中输入\n``` \nlocalhost:4000\n```\n便可以打开刚刚建好的博客站了。\n\n### 推送博客站到GitHub上\n上一步创建好的博客站只能在本地电脑中打开，需要推送到GitHub中才能通过“你GitHub注册用户名.github.io”域名方式被网友访问。\n\n首先在“你GitHub注册用户名.github.io”本地文件夹下有一个名为“\\_config.yml”的配置文件，这个称为站点配置文件，使用NotePad++打开并拉到文件最后，填入以下文字：\n\n``` \ndeploy:\n  type: git \n  repo: https://github.com/你GitHub注册用户名/你GitHub注册用户名.github.io.git \n  branch: master\n```\n\n如果出现下面的问题可尝试使用如下配置格式：\n> bash: /dev/tty: No such device or address  \nerror: failed to execute prompt script (exit code 1)  \nfatal: could not read Username for 'https://github.com': No error \n\n\n``` \ndeploy:\n  type: git  \n  repo: git@github.com:你GitHub注册用户名/你GitHub注册用户名.github.io.git  \n  branch: master  \n```\n\n注意deploy下面需要缩进，冒号之后有空格。\n\n接着进入“你GitHub注册用户名.github.io”本地文件下，在该文件夹下按住Shift键右击鼠标打开“Git Bash”依次输入以下命令：\n\n```\nnpm install hexo-deployer-git --save  \nhexo g -d\n```\n\n然后在浏览器中输入“你GitHub注册用户名.github.io”就可以打开刚才建的博客站了。至此建站部分全部完成。\n\n### 备份网站原始数据到GitHub上\n进入“你GitHub注册用户名.github.io”本地文件下，在该文件夹下按住Shift键右击鼠标打开“Git Bash”依次输入以下命令：\n\n```\ngit add .  \ngit commit -m “你为该次备份提供的说明信息”\ngit push origin “你在repository中创建的另外一个分支名”\n```\n\n如果你以后新增修改文件，可以把上述三条命令全部运行一遍即可备份当前修改\n\n至此本次GitHub安装Hexo及备份原始数据全部完成，享受你的个人博客时光吧！\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Hexo/GitHub+Hexo搭建个人博客站及备份原始网站数据过程记录","published":1,"updated":"2018-06-13T14:21:48.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x2z000dgsvnq38fdhk3","content":"<p>万事开头难，大约在一年前我就想着架个属于自己的博客站，但是由于各种原因多次准备架站时又不得不中途放弃，这次总算是上线了，写下这篇文章作为最终成功上线博客的留念。</p>\n<h2 id=\"Hexo快速安装\"><a href=\"#Hexo快速安装\" class=\"headerlink\" title=\"Hexo快速安装\"></a>Hexo快速安装</h2><h3 id=\"注册Github账号\"><a href=\"#注册Github账号\" class=\"headerlink\" title=\"注册Github账号\"></a>注册Github账号</h3><p>如果你已经有了账号可略过该步，传送门：（<a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">注册GitHub传送门</a>）</p>\n<h3 id=\"创建repository\"><a href=\"#创建repository\" class=\"headerlink\" title=\"创建repository\"></a>创建repository</h3><p>点击头像左边的+号（<a href=\"https://github.com/new\" target=\"_blank\" rel=\"noopener\">新建repository传送门</a>），新建一个repository，“Repository name”格式必须为：username.github.io，username为你注册的用户名。设置完名字建议勾选“Initialize this repository with a README”，便于新建一个用于保存原始网站文件的分支（branch）。点击“Create repository”创建repository完毕。<br><br>创建repository后项目下会有一个默认的master分支，该分支用来保存Hexo生成的网页文件。接着新建分支用来存放Hexo原始网站数据方便自己更换电脑时同步。比如创建一个名为backup的分支，并设置为默认分支（这步一定要做）。</p>\n<h3 id=\"安装Git工具\"><a href=\"#安装Git工具\" class=\"headerlink\" title=\"安装Git工具\"></a>安装Git工具</h3><p>Git是开源的分布式的版本控制系统，具体见（<a href=\"http://www.runoob.com/git/git-tutorial.html\" target=\"_blank\" rel=\"noopener\">Git是什么传送门</a>）。Git软件下载地址见（<a href=\"https://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">Git下载传送门</a>）。安装过程和Windows常用软件相似。</p>\n<h3 id=\"绑定Git和你的GitHub账号\"><a href=\"#绑定Git和你的GitHub账号\" class=\"headerlink\" title=\"绑定Git和你的GitHub账号\"></a>绑定Git和你的GitHub账号</h3><p>Git安装完毕后打开“Git Bash”，使用命令行界面绑定GitHub账号。输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name “你GitHub注册用户名”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.email “你GitHub注册的邮箱账号”</span><br></pre></td></tr></table></figure>\n<p>以上便完成Git和你的GitHub账号的绑定</p>\n<h3 id=\"注册密钥\"><a href=\"#注册密钥\" class=\"headerlink\" title=\"注册密钥\"></a>注册密钥</h3><p>在“Git Bash”中输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C “你GitHub注册的邮箱账号”</span><br></pre></td></tr></table></figure>\n<p>会在Windows系统安装盘“C:\\Users\\你的电脑名称\\.ssh”目录下生成一个名为“id_rsa.pub”的文件，用任何文本处理软件打开，推荐使用NotePad++打开。（<a href=\"https://notepad-plus-plus.org/download/v7.5.5.html\" target=\"_blank\" rel=\"noopener\">NotePad++下载传送门</a>）<br><br>打开GitHub用户设置界面，切换到“SSH and GPG keys”下（<a href=\"https://github.com/settings/ssh/new\" target=\"_blank\" rel=\"noopener\">添加SSH key传送门</a>）。将“id_rsa.pub”文件内容复制的“Key”文本框中，“Title”文本框随便填写一些信息，比如阐明Key的用途。最后点击“Add SSH Key”按钮完成密钥的注册。</p>\n<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><p>由于Hexo基于Node.js，因此需要安装Node.js。（<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">下载传送门</a>）<br><br>和普通Windows软件一样安装，安装结束后打开cmd或者PowerShell输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure></p>\n<p>如果输出版本号则证明安装成功。</p>\n<h3 id=\"克隆repository到本地\"><a href=\"#克隆repository到本地\" class=\"headerlink\" title=\"克隆repository到本地\"></a>克隆repository到本地</h3><p>由于我们需要在另外一个分支备份网站的原始数据，为了避免上传原始网站数据到GitHub仓库的出现各种错误，在你本地新建一个文件夹，进入该文件夹后按住Shift键右击鼠标打开“Git Bash”，输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:你GitHub注册用户名/你GitHub注册用户名.github.io.git</span><br></pre></td></tr></table></figure>\n<p>结束后本地会新建一个名为“你GitHub注册用户名.github.io”的文件夹。</p>\n<h3 id=\"本地安装Hexo\"><a href=\"#本地安装Hexo\" class=\"headerlink\" title=\"本地安装Hexo\"></a>本地安装Hexo</h3><p>进入上步“你GitHub注册用户名.github.io”的文件夹，按住Shift键右击鼠标打开“Git Bash”，输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>这是安装Hexo，需要一点时间下载。</p>\n<p>然后输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n<p>会在当前目录创建一个blog文件夹，所有的建站文件均在该文件夹下，将文件夹下的所有文件剪切到上级目录即“你GitHub注册用户名.github.io”文件夹，在该文件夹下按住Shift键右击鼠标打开cmd或者PowerShell输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p>然后在浏览器中输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localhost:4000</span><br></pre></td></tr></table></figure></p>\n<p>便可以打开刚刚建好的博客站了。</p>\n<h3 id=\"推送博客站到GitHub上\"><a href=\"#推送博客站到GitHub上\" class=\"headerlink\" title=\"推送博客站到GitHub上\"></a>推送博客站到GitHub上</h3><p>上一步创建好的博客站只能在本地电脑中打开，需要推送到GitHub中才能通过“你GitHub注册用户名.github.io”域名方式被网友访问。</p>\n<p>首先在“你GitHub注册用户名.github.io”本地文件夹下有一个名为“_config.yml”的配置文件，这个称为站点配置文件，使用NotePad++打开并拉到文件最后，填入以下文字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git </span><br><span class=\"line\">  repo: https://github.com/你GitHub注册用户名/你GitHub注册用户名.github.io.git </span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>如果出现下面的问题可尝试使用如下配置格式：</p>\n<blockquote>\n<p>bash: /dev/tty: No such device or address<br>error: failed to execute prompt script (exit code 1)<br>fatal: could not read Username for ‘<a href=\"https://github.com&#39;\" target=\"_blank\" rel=\"noopener\">https://github.com&#39;</a>: No error </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git  </span><br><span class=\"line\">  repo: git@github.com:你GitHub注册用户名/你GitHub注册用户名.github.io.git  </span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>注意deploy下面需要缩进，冒号之后有空格。</p>\n<p>接着进入“你GitHub注册用户名.github.io”本地文件下，在该文件夹下按住Shift键右击鼠标打开“Git Bash”依次输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save  </span><br><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n<p>然后在浏览器中输入“你GitHub注册用户名.github.io”就可以打开刚才建的博客站了。至此建站部分全部完成。</p>\n<h3 id=\"备份网站原始数据到GitHub上\"><a href=\"#备份网站原始数据到GitHub上\" class=\"headerlink\" title=\"备份网站原始数据到GitHub上\"></a>备份网站原始数据到GitHub上</h3><p>进入“你GitHub注册用户名.github.io”本地文件下，在该文件夹下按住Shift键右击鼠标打开“Git Bash”依次输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .  </span><br><span class=\"line\">git commit -m “你为该次备份提供的说明信息”</span><br><span class=\"line\">git push origin “你在repository中创建的另外一个分支名”</span><br></pre></td></tr></table></figure>\n<p>如果你以后新增修改文件，可以把上述三条命令全部运行一遍即可备份当前修改</p>\n<p>至此本次GitHub安装Hexo及备份原始数据全部完成，享受你的个人博客时光吧！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>万事开头难，大约在一年前我就想着架个属于自己的博客站，但是由于各种原因多次准备架站时又不得不中途放弃，这次总算是上线了，写下这篇文章作为最终成功上线博客的留念。</p>\n<h2 id=\"Hexo快速安装\"><a href=\"#Hexo快速安装\" class=\"headerlink\" title=\"Hexo快速安装\"></a>Hexo快速安装</h2><h3 id=\"注册Github账号\"><a href=\"#注册Github账号\" class=\"headerlink\" title=\"注册Github账号\"></a>注册Github账号</h3><p>如果你已经有了账号可略过该步，传送门：（<a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">注册GitHub传送门</a>）</p>\n<h3 id=\"创建repository\"><a href=\"#创建repository\" class=\"headerlink\" title=\"创建repository\"></a>创建repository</h3><p>点击头像左边的+号（<a href=\"https://github.com/new\" target=\"_blank\" rel=\"noopener\">新建repository传送门</a>），新建一个repository，“Repository name”格式必须为：username.github.io，username为你注册的用户名。设置完名字建议勾选“Initialize this repository with a README”，便于新建一个用于保存原始网站文件的分支（branch）。点击“Create repository”创建repository完毕。<br><br>创建repository后项目下会有一个默认的master分支，该分支用来保存Hexo生成的网页文件。接着新建分支用来存放Hexo原始网站数据方便自己更换电脑时同步。比如创建一个名为backup的分支，并设置为默认分支（这步一定要做）。</p>\n<h3 id=\"安装Git工具\"><a href=\"#安装Git工具\" class=\"headerlink\" title=\"安装Git工具\"></a>安装Git工具</h3><p>Git是开源的分布式的版本控制系统，具体见（<a href=\"http://www.runoob.com/git/git-tutorial.html\" target=\"_blank\" rel=\"noopener\">Git是什么传送门</a>）。Git软件下载地址见（<a href=\"https://git-scm.com/download/\" target=\"_blank\" rel=\"noopener\">Git下载传送门</a>）。安装过程和Windows常用软件相似。</p>\n<h3 id=\"绑定Git和你的GitHub账号\"><a href=\"#绑定Git和你的GitHub账号\" class=\"headerlink\" title=\"绑定Git和你的GitHub账号\"></a>绑定Git和你的GitHub账号</h3><p>Git安装完毕后打开“Git Bash”，使用命令行界面绑定GitHub账号。输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name “你GitHub注册用户名”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.email “你GitHub注册的邮箱账号”</span><br></pre></td></tr></table></figure>\n<p>以上便完成Git和你的GitHub账号的绑定</p>\n<h3 id=\"注册密钥\"><a href=\"#注册密钥\" class=\"headerlink\" title=\"注册密钥\"></a>注册密钥</h3><p>在“Git Bash”中输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C “你GitHub注册的邮箱账号”</span><br></pre></td></tr></table></figure>\n<p>会在Windows系统安装盘“C:\\Users\\你的电脑名称\\.ssh”目录下生成一个名为“id_rsa.pub”的文件，用任何文本处理软件打开，推荐使用NotePad++打开。（<a href=\"https://notepad-plus-plus.org/download/v7.5.5.html\" target=\"_blank\" rel=\"noopener\">NotePad++下载传送门</a>）<br><br>打开GitHub用户设置界面，切换到“SSH and GPG keys”下（<a href=\"https://github.com/settings/ssh/new\" target=\"_blank\" rel=\"noopener\">添加SSH key传送门</a>）。将“id_rsa.pub”文件内容复制的“Key”文本框中，“Title”文本框随便填写一些信息，比如阐明Key的用途。最后点击“Add SSH Key”按钮完成密钥的注册。</p>\n<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><p>由于Hexo基于Node.js，因此需要安装Node.js。（<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">下载传送门</a>）<br><br>和普通Windows软件一样安装，安装结束后打开cmd或者PowerShell输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure></p>\n<p>如果输出版本号则证明安装成功。</p>\n<h3 id=\"克隆repository到本地\"><a href=\"#克隆repository到本地\" class=\"headerlink\" title=\"克隆repository到本地\"></a>克隆repository到本地</h3><p>由于我们需要在另外一个分支备份网站的原始数据，为了避免上传原始网站数据到GitHub仓库的出现各种错误，在你本地新建一个文件夹，进入该文件夹后按住Shift键右击鼠标打开“Git Bash”，输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:你GitHub注册用户名/你GitHub注册用户名.github.io.git</span><br></pre></td></tr></table></figure>\n<p>结束后本地会新建一个名为“你GitHub注册用户名.github.io”的文件夹。</p>\n<h3 id=\"本地安装Hexo\"><a href=\"#本地安装Hexo\" class=\"headerlink\" title=\"本地安装Hexo\"></a>本地安装Hexo</h3><p>进入上步“你GitHub注册用户名.github.io”的文件夹，按住Shift键右击鼠标打开“Git Bash”，输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>这是安装Hexo，需要一点时间下载。</p>\n<p>然后输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n<p>会在当前目录创建一个blog文件夹，所有的建站文件均在该文件夹下，将文件夹下的所有文件剪切到上级目录即“你GitHub注册用户名.github.io”文件夹，在该文件夹下按住Shift键右击鼠标打开cmd或者PowerShell输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p>然后在浏览器中输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localhost:4000</span><br></pre></td></tr></table></figure></p>\n<p>便可以打开刚刚建好的博客站了。</p>\n<h3 id=\"推送博客站到GitHub上\"><a href=\"#推送博客站到GitHub上\" class=\"headerlink\" title=\"推送博客站到GitHub上\"></a>推送博客站到GitHub上</h3><p>上一步创建好的博客站只能在本地电脑中打开，需要推送到GitHub中才能通过“你GitHub注册用户名.github.io”域名方式被网友访问。</p>\n<p>首先在“你GitHub注册用户名.github.io”本地文件夹下有一个名为“_config.yml”的配置文件，这个称为站点配置文件，使用NotePad++打开并拉到文件最后，填入以下文字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git </span><br><span class=\"line\">  repo: https://github.com/你GitHub注册用户名/你GitHub注册用户名.github.io.git </span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>如果出现下面的问题可尝试使用如下配置格式：</p>\n<blockquote>\n<p>bash: /dev/tty: No such device or address<br>error: failed to execute prompt script (exit code 1)<br>fatal: could not read Username for ‘<a href=\"https://github.com&#39;\" target=\"_blank\" rel=\"noopener\">https://github.com&#39;</a>: No error </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git  </span><br><span class=\"line\">  repo: git@github.com:你GitHub注册用户名/你GitHub注册用户名.github.io.git  </span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>注意deploy下面需要缩进，冒号之后有空格。</p>\n<p>接着进入“你GitHub注册用户名.github.io”本地文件下，在该文件夹下按住Shift键右击鼠标打开“Git Bash”依次输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save  </span><br><span class=\"line\">hexo g -d</span><br></pre></td></tr></table></figure>\n<p>然后在浏览器中输入“你GitHub注册用户名.github.io”就可以打开刚才建的博客站了。至此建站部分全部完成。</p>\n<h3 id=\"备份网站原始数据到GitHub上\"><a href=\"#备份网站原始数据到GitHub上\" class=\"headerlink\" title=\"备份网站原始数据到GitHub上\"></a>备份网站原始数据到GitHub上</h3><p>进入“你GitHub注册用户名.github.io”本地文件下，在该文件夹下按住Shift键右击鼠标打开“Git Bash”依次输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .  </span><br><span class=\"line\">git commit -m “你为该次备份提供的说明信息”</span><br><span class=\"line\">git push origin “你在repository中创建的另外一个分支名”</span><br></pre></td></tr></table></figure>\n<p>如果你以后新增修改文件，可以把上述三条命令全部运行一遍即可备份当前修改</p>\n<p>至此本次GitHub安装Hexo及备份原始数据全部完成，享受你的个人博客时光吧！</p>\n"},{"title":"Hello World","urlname":"hello-world","date":"2018-02-28T04:56:11.000Z","copyright":true,"mathjax":true,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/Hexo/hello-world.md","raw":"---\ntitle: Hello World\nurlname: hello-world\ndate: 2018-02-28 12:56:11\ncopyright: true\nmathjax: true\ntags:\n- Hexo\ncategories:\n- Hexo\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"Hexo/hello-world","published":1,"updated":"2018-06-13T14:21:43.816Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x32000hgsvn92stff1o","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"二叉树的前序遍历、中序遍历、后序遍历的递归实现以及非递归实现","urlname":"binary-tree-traversal","date":"2018-03-07T04:07:39.000Z","mathjax":true,"copyright":true,"_content":"\n## 二叉树遍历的基本原理\n\n先上一张前、中、后序遍历的路径图：[图片来源](http://blog.csdn.net/zyq522376829/article/details/46945505)\n\n![二叉树遍历流程图](/images/binary-tree-traversal.jpg)\n\n\n\n如上图二叉树的遍历结果为：\n\n- 前序遍历为：ABDEFGC\n- 中序遍历为：DBFEGAC\n- 后序遍历为：DFGEBCA\n\n由于树的定义是递归定义，因此自然而然遍历思路也是从递归遍历入手。二叉树的递归定义如下：\n\n1. 二叉树是由n个有限节点构成的集合\n2. n=0时为空树，n>0时二叉树由两个互不相交的的左右子树组成\n3. 左右子树也是一颗二叉树\n\n二叉树的存储方式有链式存储和顺序存储，在链式存储中，除了保存数据外，需要两个指针分别指向左子树根节点和右子树根节点（有时为了方便会增加指向父节点的指针），基本结构如下：\n\n```cpp\ntemplate <typename DataType>\nstruct TreeNode\n{\n\tDataType data; //存储的数据\n\tTreeNode *left; //指向左子树根节点\n\tTreeNode *right; //指向右子树根节点\n\t//TreeNode * parent; /*指向父节点，如果需要的话*/\n\tTreeNode(DataType inData): data(inData), right(nullptr), left(nullptr) {}\n};\n```\n\n在顺序存储中，二叉树节点的存储顺序为由上到下、由左到右的顺序，顺序存储主要用来存储满二叉树或完全二叉树，和顺序存储有关的排序有堆排序。在顺序存储中，父节点与子节点有如下关系：\n\n- 下标从1开始，如果父节点下标为i，则左子节点的下标为2i，右子节点的下标为2i+1\n- 下标从0开始，如果父节点下标为i，则左子节点的下标为2i+1，右子节点的下标为2i+2\n\n对于一个层数为k的二叉树，如果采用顺序存储的方式，则至少需要2<sup>k</sup>-1个存储单元，因此对于非满二叉树或者非完全二叉树有许多存储单元被浪费。\n\n广义而言，二叉树的每一个节点都为根节点。二叉树的遍历主要是指采用链式存储方式下的遍历，由于二叉树的递归定义，最简单的遍历算法采用递归遍历，基本结构如下所示：\n\n```cpp\ntemplate <typename DataType>\nvoid Traverse(TreeNode<DataType> * inNode)\n{\n\tif (inNode == nullptr) {\n\t\treturn;\n\t}\n\t//cout << inNode->data << \";\"; /*如果在这里访问即为先序遍历*/\n\tTraverse(inNode->left);\n\t//cout << inNode->data << \";\"; /*如果在这里访问即为中序遍历*/\n\tTraverse(inNode->right);\n\t//cout << inNode->data << \";\"; /*如果在这里访问即为后序遍历*/\n\treturn;\n}\n```\n\n- 先序遍历又称为先根遍历，可以理解为先访问根节点，再递归先序遍历左子树，最后先序遍历右子树\n- 中序遍历又可称为中根遍历，可以理解为中间再访问根节点，因此访问顺序是先中序遍历左子树，接着访问根节点，最后中序访问右子树\n- 后序遍历又可称为后根遍历，可以理解为根节点最后访问，因此访问顺序是先后序遍历左子树，接着后序遍历右子树，最后访问根节点\n- 层序遍历，是一种层次遍历，逐层遍历，每一层从左到右到右的顺序，该遍历方式需要借助于辅助空间（队列）\n\n下图为遍历时的递归栈：\n\n![遍历时的递归栈](/images/recursive-stack.png)\n\n上图中ln代表左子节点为空指针，rn代表右子节点为空。如图所示，先序遍历就是第一次遇到节点时便输出，中序遍历则是第二次遇到时输出，既是上图中凹点处（左右两边栈高度均比当前栈高），后序遍历则是在栈即将该节点弹出时（最后一次访问）输出。\n\n\n## 非递归实现遍历\n\n- 二叉树前序与中序遍历的非递归实现\n\n非递归意味着无法让编译器帮助我们通过递归函数调用压栈和函数返回的方式记忆遍历线路，因此需要使用辅助栈空间来模拟函数调用返回过程。我们结合开始pou的图分析二叉树递归遍历的特点：首先访问左子树直到最左，然后再返回访问右子节点，再重复访问右子节点的左子树直到最左，因此我们在编写非递归实现时，可按照以下步骤来进行\n\t1. 不断访问某一结的左子节点并压栈直到最左子节点\n\t2. 弹出最后一个节点，访问该节点的右子节点并压入栈\n\t3. 以该右子节点作为下一轮访问起点（根节点），重复1、2步\n\n在递归遍历中，前序遍历是在将左子节点压栈之前输出，中序遍历是在节点的全部左子节点压入栈之后返回压入右子节点之前访问\n\n\n上述思路的代码表现如下：\n\n```cpp\n#include <stack>\nusing std::stack;\n\ntemplate <typename DataType>\nvoid NonRecursiveTraverse(TreeNode<DataType> * inNode)\n{\n\tstack<TreeNode<DataType> *> nodeStack;\n\tTreeNode<DataType> *cycleNode = inNode;\n\twhile (inNode != nullptr || !nodeStack.empty()) {\n\t\t//不断访问某一结的左子节点并压栈直到最左子节点\n\t\twhile (cycleNode != nullptr) {\n\t\t\t//cout << cycleNode->data << \";\"; /*在此处访问即为先序遍历*/\n\t\t\tnodeStack.push(cycleNode);\n\t\t\tcycleNode = cycleNode->left;\n\t\t}\n\t\t//到这里说明所有左子节点全部入栈\n\t\t//弹出最后一个节点，访问该节点的右子节点并作为下一轮遍历根节点\n\t\tif (!nodeStack.empty()) {\n\t\t\tcycleNode = nodeStack.top();\n\t\t\t//在此处访问即为中序遍历，时机为压入右子节点之前\n\t\t\t//cout << cycleNode->data << \";\";\n\t\t\t//以该右子节点作为下一轮访问起点，重复外层while\n\t\t\tcycleNode = cycleNode->right;\n\t\t\tnodeStack.pop(); //立即弹出，否则不断访问同一个节点的右子树，形成死循环\n\t\t}\n\t}\n}\n```\n\n在上述的代码中，压栈情况见下图：\n\n![非递归压栈](/images/nonrecursive-stack.png)\n\n由于辅助压栈，我们并没有将null压入栈中，如果发现左子节点为null则在保存右子节点地址后直接弹出该节点，并使用右子节点作为下一论访问起始节点，如果右子节点为null则表示该节点左右子树均遍历完毕，则继续弹出直至出现第一个右子树不为空的节点，重复递归。\n\n压栈图中，在前序遍历时，只要遇到节点（压栈过程）就直接输出就可以保证根节点首先被输出，而中序遍历由于需要在左子树输出完毕后才能输出，因此只要保证在压栈返回时（出栈时）且准备遍历右子树时输出即可。\n\n- 二叉树后序遍历的非递归实现\n\n\n根据递归遍历的调用栈，我们可以发现后序遍历在弹出栈之前输出即可完成后序遍历，在后序遍历中，由于需要先访问左右子节点后才能访问根节点，不能直接在上述代码中插入输出代码完成，因为在后序遍历中无法确定右子节点是否是叶节点或者已经访问过，因此需要保留访问标记，如果此时右子节点已经访问则可以输出当前右子节点的父节点\n\n```cpp\n#include <stack>\nusing std::stack;\n\ntemplate <typename DataType>\nvoid NonRecursivePostTraverse(TreeNode<DataType> * inNode)\n{\n\tstack<TreeNode<DataType> *> nodeStack;\n\tTreeNode<DataType> *cycleNode = inNode;\n\tTreeNode<DataType> * hasCycle = nullptr; /*模拟递归调用返回点*/\n\twhile (inNode != nullptr || !nodeStack.empty()) {\n\t\t/*不断访问某一结的左子节点并压栈直到最左子节点*/\n\t\twhile (cycleNode != nullptr) {\n\t\t\tnodeStack.push(cycleNode);\n\t\t\tcycleNode = cycleNode->left;\n\t\t}\n\n\t\t//到这里说明所有左子节点全部入栈\n\t\t//弹出最后一个节点，访问该节点的右子节点并作为下一轮遍历根节点\n\t\tif (!nodeStack.empty()) {\n\t\t\tcycleNode = nodeStack.top();\n        \t        //如果右子节点为null，说明右子树已经遍历结束，可以输出根节点\n\t\t\tif (cycleNode->right == nullptr) {\n\t\t\t\thasCycle = cycleNode; //保存已经访问的节点\n\t\t\t\tcout << cycleNode->data << \";\";\n\t\t\t\tnodeStack.pop();\n\t\t\t}\n\t\t\t//如果右子节点已经访问，则也可以输出根节点\n\t\t\telse if (hasCycle == cycleNode->right) {\n\t\t\t\thasCycle = cycleNode; //保存已经访问的节点\n\t\t\t\tcout << cycleNode->data << \";\";\n\t\t\t\tnodeStack.pop();\n\t\t\t}\n\t\t\t//如果右子树还没有访问，则访问，否则置为nullptr继续出栈\n\t\t\tcycleNode = nullptr;\n\t\t\tif (!nodeStack.empty() && nodeStack.top()->right != hasCycle) {\n\t\t\t\tcycleNode = nodeStack.top()->right;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n根据上述代码，压栈情况下图：\n\n![后序非递归压栈](/images/nonrecursive-post-stack.png)\n\n最上面一行是当前保留的访问过的节点(n表示null节点)，由于右子节点被访问后该右子节点的父节点立刻可以被访问，因此只要发现右子树根节点被访问就可以立刻访问当前节点。\n\n## 代码测试\n\n简单地手动实现文中第一张图中的树，测试代码如下：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tTreeNode<char> testNode[7] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};\n\n\ttestNode[0].left = &testNode[1];\n\ttestNode[0].right = &testNode[2];\n\n\ttestNode[1].left = &testNode[3];\n\ttestNode[1].right = &testNode[4];\n\n\ttestNode[4].left = &testNode[5];\n\ttestNode[4].right = &testNode[6];\n\n\tauto startTime = system_clock::now();\n\n\tTraverse(testNode); /*调用具体的遍历算法*/\n\n\tauto endTime = system_clock::now();\n\n\tauto duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n\treturn 0;\n}\n```\n\n## 参考\n\n[二叉树前序、中序、后序遍历非递归写法的透彻解析](http://blog.csdn.net/zhangxiangdavaid/article/details/37115355)\n\n[二叉树前序、中序、后序遍历的迭代实现](https://www.jianshu.com/p/e0a8bbee76a9)\n","source":"_posts/数据结构/二叉树的前序遍历_中序遍历_后序遍历的递归实现以及非递归实现.md","raw":"---\ntitle: 二叉树的前序遍历、中序遍历、后序遍历的递归实现以及非递归实现\nurlname: binary-tree-traversal\ndate: 2018-03-7 12:07:39\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 二叉树遍历的基本原理\n\n先上一张前、中、后序遍历的路径图：[图片来源](http://blog.csdn.net/zyq522376829/article/details/46945505)\n\n![二叉树遍历流程图](/images/binary-tree-traversal.jpg)\n\n\n\n如上图二叉树的遍历结果为：\n\n- 前序遍历为：ABDEFGC\n- 中序遍历为：DBFEGAC\n- 后序遍历为：DFGEBCA\n\n由于树的定义是递归定义，因此自然而然遍历思路也是从递归遍历入手。二叉树的递归定义如下：\n\n1. 二叉树是由n个有限节点构成的集合\n2. n=0时为空树，n>0时二叉树由两个互不相交的的左右子树组成\n3. 左右子树也是一颗二叉树\n\n二叉树的存储方式有链式存储和顺序存储，在链式存储中，除了保存数据外，需要两个指针分别指向左子树根节点和右子树根节点（有时为了方便会增加指向父节点的指针），基本结构如下：\n\n```cpp\ntemplate <typename DataType>\nstruct TreeNode\n{\n\tDataType data; //存储的数据\n\tTreeNode *left; //指向左子树根节点\n\tTreeNode *right; //指向右子树根节点\n\t//TreeNode * parent; /*指向父节点，如果需要的话*/\n\tTreeNode(DataType inData): data(inData), right(nullptr), left(nullptr) {}\n};\n```\n\n在顺序存储中，二叉树节点的存储顺序为由上到下、由左到右的顺序，顺序存储主要用来存储满二叉树或完全二叉树，和顺序存储有关的排序有堆排序。在顺序存储中，父节点与子节点有如下关系：\n\n- 下标从1开始，如果父节点下标为i，则左子节点的下标为2i，右子节点的下标为2i+1\n- 下标从0开始，如果父节点下标为i，则左子节点的下标为2i+1，右子节点的下标为2i+2\n\n对于一个层数为k的二叉树，如果采用顺序存储的方式，则至少需要2<sup>k</sup>-1个存储单元，因此对于非满二叉树或者非完全二叉树有许多存储单元被浪费。\n\n广义而言，二叉树的每一个节点都为根节点。二叉树的遍历主要是指采用链式存储方式下的遍历，由于二叉树的递归定义，最简单的遍历算法采用递归遍历，基本结构如下所示：\n\n```cpp\ntemplate <typename DataType>\nvoid Traverse(TreeNode<DataType> * inNode)\n{\n\tif (inNode == nullptr) {\n\t\treturn;\n\t}\n\t//cout << inNode->data << \";\"; /*如果在这里访问即为先序遍历*/\n\tTraverse(inNode->left);\n\t//cout << inNode->data << \";\"; /*如果在这里访问即为中序遍历*/\n\tTraverse(inNode->right);\n\t//cout << inNode->data << \";\"; /*如果在这里访问即为后序遍历*/\n\treturn;\n}\n```\n\n- 先序遍历又称为先根遍历，可以理解为先访问根节点，再递归先序遍历左子树，最后先序遍历右子树\n- 中序遍历又可称为中根遍历，可以理解为中间再访问根节点，因此访问顺序是先中序遍历左子树，接着访问根节点，最后中序访问右子树\n- 后序遍历又可称为后根遍历，可以理解为根节点最后访问，因此访问顺序是先后序遍历左子树，接着后序遍历右子树，最后访问根节点\n- 层序遍历，是一种层次遍历，逐层遍历，每一层从左到右到右的顺序，该遍历方式需要借助于辅助空间（队列）\n\n下图为遍历时的递归栈：\n\n![遍历时的递归栈](/images/recursive-stack.png)\n\n上图中ln代表左子节点为空指针，rn代表右子节点为空。如图所示，先序遍历就是第一次遇到节点时便输出，中序遍历则是第二次遇到时输出，既是上图中凹点处（左右两边栈高度均比当前栈高），后序遍历则是在栈即将该节点弹出时（最后一次访问）输出。\n\n\n## 非递归实现遍历\n\n- 二叉树前序与中序遍历的非递归实现\n\n非递归意味着无法让编译器帮助我们通过递归函数调用压栈和函数返回的方式记忆遍历线路，因此需要使用辅助栈空间来模拟函数调用返回过程。我们结合开始pou的图分析二叉树递归遍历的特点：首先访问左子树直到最左，然后再返回访问右子节点，再重复访问右子节点的左子树直到最左，因此我们在编写非递归实现时，可按照以下步骤来进行\n\t1. 不断访问某一结的左子节点并压栈直到最左子节点\n\t2. 弹出最后一个节点，访问该节点的右子节点并压入栈\n\t3. 以该右子节点作为下一轮访问起点（根节点），重复1、2步\n\n在递归遍历中，前序遍历是在将左子节点压栈之前输出，中序遍历是在节点的全部左子节点压入栈之后返回压入右子节点之前访问\n\n\n上述思路的代码表现如下：\n\n```cpp\n#include <stack>\nusing std::stack;\n\ntemplate <typename DataType>\nvoid NonRecursiveTraverse(TreeNode<DataType> * inNode)\n{\n\tstack<TreeNode<DataType> *> nodeStack;\n\tTreeNode<DataType> *cycleNode = inNode;\n\twhile (inNode != nullptr || !nodeStack.empty()) {\n\t\t//不断访问某一结的左子节点并压栈直到最左子节点\n\t\twhile (cycleNode != nullptr) {\n\t\t\t//cout << cycleNode->data << \";\"; /*在此处访问即为先序遍历*/\n\t\t\tnodeStack.push(cycleNode);\n\t\t\tcycleNode = cycleNode->left;\n\t\t}\n\t\t//到这里说明所有左子节点全部入栈\n\t\t//弹出最后一个节点，访问该节点的右子节点并作为下一轮遍历根节点\n\t\tif (!nodeStack.empty()) {\n\t\t\tcycleNode = nodeStack.top();\n\t\t\t//在此处访问即为中序遍历，时机为压入右子节点之前\n\t\t\t//cout << cycleNode->data << \";\";\n\t\t\t//以该右子节点作为下一轮访问起点，重复外层while\n\t\t\tcycleNode = cycleNode->right;\n\t\t\tnodeStack.pop(); //立即弹出，否则不断访问同一个节点的右子树，形成死循环\n\t\t}\n\t}\n}\n```\n\n在上述的代码中，压栈情况见下图：\n\n![非递归压栈](/images/nonrecursive-stack.png)\n\n由于辅助压栈，我们并没有将null压入栈中，如果发现左子节点为null则在保存右子节点地址后直接弹出该节点，并使用右子节点作为下一论访问起始节点，如果右子节点为null则表示该节点左右子树均遍历完毕，则继续弹出直至出现第一个右子树不为空的节点，重复递归。\n\n压栈图中，在前序遍历时，只要遇到节点（压栈过程）就直接输出就可以保证根节点首先被输出，而中序遍历由于需要在左子树输出完毕后才能输出，因此只要保证在压栈返回时（出栈时）且准备遍历右子树时输出即可。\n\n- 二叉树后序遍历的非递归实现\n\n\n根据递归遍历的调用栈，我们可以发现后序遍历在弹出栈之前输出即可完成后序遍历，在后序遍历中，由于需要先访问左右子节点后才能访问根节点，不能直接在上述代码中插入输出代码完成，因为在后序遍历中无法确定右子节点是否是叶节点或者已经访问过，因此需要保留访问标记，如果此时右子节点已经访问则可以输出当前右子节点的父节点\n\n```cpp\n#include <stack>\nusing std::stack;\n\ntemplate <typename DataType>\nvoid NonRecursivePostTraverse(TreeNode<DataType> * inNode)\n{\n\tstack<TreeNode<DataType> *> nodeStack;\n\tTreeNode<DataType> *cycleNode = inNode;\n\tTreeNode<DataType> * hasCycle = nullptr; /*模拟递归调用返回点*/\n\twhile (inNode != nullptr || !nodeStack.empty()) {\n\t\t/*不断访问某一结的左子节点并压栈直到最左子节点*/\n\t\twhile (cycleNode != nullptr) {\n\t\t\tnodeStack.push(cycleNode);\n\t\t\tcycleNode = cycleNode->left;\n\t\t}\n\n\t\t//到这里说明所有左子节点全部入栈\n\t\t//弹出最后一个节点，访问该节点的右子节点并作为下一轮遍历根节点\n\t\tif (!nodeStack.empty()) {\n\t\t\tcycleNode = nodeStack.top();\n        \t        //如果右子节点为null，说明右子树已经遍历结束，可以输出根节点\n\t\t\tif (cycleNode->right == nullptr) {\n\t\t\t\thasCycle = cycleNode; //保存已经访问的节点\n\t\t\t\tcout << cycleNode->data << \";\";\n\t\t\t\tnodeStack.pop();\n\t\t\t}\n\t\t\t//如果右子节点已经访问，则也可以输出根节点\n\t\t\telse if (hasCycle == cycleNode->right) {\n\t\t\t\thasCycle = cycleNode; //保存已经访问的节点\n\t\t\t\tcout << cycleNode->data << \";\";\n\t\t\t\tnodeStack.pop();\n\t\t\t}\n\t\t\t//如果右子树还没有访问，则访问，否则置为nullptr继续出栈\n\t\t\tcycleNode = nullptr;\n\t\t\tif (!nodeStack.empty() && nodeStack.top()->right != hasCycle) {\n\t\t\t\tcycleNode = nodeStack.top()->right;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n根据上述代码，压栈情况下图：\n\n![后序非递归压栈](/images/nonrecursive-post-stack.png)\n\n最上面一行是当前保留的访问过的节点(n表示null节点)，由于右子节点被访问后该右子节点的父节点立刻可以被访问，因此只要发现右子树根节点被访问就可以立刻访问当前节点。\n\n## 代码测试\n\n简单地手动实现文中第一张图中的树，测试代码如下：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tTreeNode<char> testNode[7] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};\n\n\ttestNode[0].left = &testNode[1];\n\ttestNode[0].right = &testNode[2];\n\n\ttestNode[1].left = &testNode[3];\n\ttestNode[1].right = &testNode[4];\n\n\ttestNode[4].left = &testNode[5];\n\ttestNode[4].right = &testNode[6];\n\n\tauto startTime = system_clock::now();\n\n\tTraverse(testNode); /*调用具体的遍历算法*/\n\n\tauto endTime = system_clock::now();\n\n\tauto duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n\treturn 0;\n}\n```\n\n## 参考\n\n[二叉树前序、中序、后序遍历非递归写法的透彻解析](http://blog.csdn.net/zhangxiangdavaid/article/details/37115355)\n\n[二叉树前序、中序、后序遍历的迭代实现](https://www.jianshu.com/p/e0a8bbee76a9)\n","slug":"数据结构/二叉树的前序遍历_中序遍历_后序遍历的递归实现以及非递归实现","published":1,"updated":"2018-06-24T09:52:28.533Z","_id":"cjida4x38000kgsvneju6p6un","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"二叉树遍历的基本原理\"><a href=\"#二叉树遍历的基本原理\" class=\"headerlink\" title=\"二叉树遍历的基本原理\"></a>二叉树遍历的基本原理</h2><p>先上一张前、中、后序遍历的路径图：<a href=\"http://blog.csdn.net/zyq522376829/article/details/46945505\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binary-tree-traversal.jpg\" alt=\"二叉树遍历流程图\"></p>\n<p>如上图二叉树的遍历结果为：</p>\n<ul>\n<li>前序遍历为：ABDEFGC</li>\n<li>中序遍历为：DBFEGAC</li>\n<li>后序遍历为：DFGEBCA</li>\n</ul>\n<p>由于树的定义是递归定义，因此自然而然遍历思路也是从递归遍历入手。二叉树的递归定义如下：</p>\n<ol>\n<li>二叉树是由n个有限节点构成的集合</li>\n<li>n=0时为空树，n&gt;0时二叉树由两个互不相交的的左右子树组成</li>\n<li>左右子树也是一颗二叉树</li>\n</ol>\n<p>二叉树的存储方式有链式存储和顺序存储，在链式存储中，除了保存数据外，需要两个指针分别指向左子树根节点和右子树根节点（有时为了方便会增加指向父节点的指针），基本结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//存储的数据</span></span><br><span class=\"line\">\tTreeNode *left; <span class=\"comment\">//指向左子树根节点</span></span><br><span class=\"line\">\tTreeNode *right; <span class=\"comment\">//指向右子树根节点</span></span><br><span class=\"line\">\t<span class=\"comment\">//TreeNode * parent; /*指向父节点，如果需要的话*/</span></span><br><span class=\"line\">\tTreeNode(DataType inData): data(inData), right(<span class=\"literal\">nullptr</span>), left(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在顺序存储中，二叉树节点的存储顺序为由上到下、由左到右的顺序，顺序存储主要用来存储满二叉树或完全二叉树，和顺序存储有关的排序有堆排序。在顺序存储中，父节点与子节点有如下关系：</p>\n<ul>\n<li>下标从1开始，如果父节点下标为i，则左子节点的下标为2i，右子节点的下标为2i+1</li>\n<li>下标从0开始，如果父节点下标为i，则左子节点的下标为2i+1，右子节点的下标为2i+2</li>\n</ul>\n<p>对于一个层数为k的二叉树，如果采用顺序存储的方式，则至少需要2<sup>k</sup>-1个存储单元，因此对于非满二叉树或者非完全二叉树有许多存储单元被浪费。</p>\n<p>广义而言，二叉树的每一个节点都为根节点。二叉树的遍历主要是指采用链式存储方式下的遍历，由于二叉树的递归定义，最简单的遍历算法采用递归遍历，基本结构如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Traverse</span><span class=\"params\">(TreeNode&lt;DataType&gt; * inNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; inNode-&gt;data &lt;&lt; \";\"; /*如果在这里访问即为先序遍历*/</span></span><br><span class=\"line\">\tTraverse(inNode-&gt;left);</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; inNode-&gt;data &lt;&lt; \";\"; /*如果在这里访问即为中序遍历*/</span></span><br><span class=\"line\">\tTraverse(inNode-&gt;right);</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; inNode-&gt;data &lt;&lt; \";\"; /*如果在这里访问即为后序遍历*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>先序遍历又称为先根遍历，可以理解为先访问根节点，再递归先序遍历左子树，最后先序遍历右子树</li>\n<li>中序遍历又可称为中根遍历，可以理解为中间再访问根节点，因此访问顺序是先中序遍历左子树，接着访问根节点，最后中序访问右子树</li>\n<li>后序遍历又可称为后根遍历，可以理解为根节点最后访问，因此访问顺序是先后序遍历左子树，接着后序遍历右子树，最后访问根节点</li>\n<li>层序遍历，是一种层次遍历，逐层遍历，每一层从左到右到右的顺序，该遍历方式需要借助于辅助空间（队列）</li>\n</ul>\n<p>下图为遍历时的递归栈：</p>\n<p><img src=\"/images/recursive-stack.png\" alt=\"遍历时的递归栈\"></p>\n<p>上图中ln代表左子节点为空指针，rn代表右子节点为空。如图所示，先序遍历就是第一次遇到节点时便输出，中序遍历则是第二次遇到时输出，既是上图中凹点处（左右两边栈高度均比当前栈高），后序遍历则是在栈即将该节点弹出时（最后一次访问）输出。</p>\n<h2 id=\"非递归实现遍历\"><a href=\"#非递归实现遍历\" class=\"headerlink\" title=\"非递归实现遍历\"></a>非递归实现遍历</h2><ul>\n<li>二叉树前序与中序遍历的非递归实现</li>\n</ul>\n<p>非递归意味着无法让编译器帮助我们通过递归函数调用压栈和函数返回的方式记忆遍历线路，因此需要使用辅助栈空间来模拟函数调用返回过程。我们结合开始pou的图分析二叉树递归遍历的特点：首先访问左子树直到最左，然后再返回访问右子节点，再重复访问右子节点的左子树直到最左，因此我们在编写非递归实现时，可按照以下步骤来进行</p>\n<pre><code>1. 不断访问某一结的左子节点并压栈直到最左子节点\n2. 弹出最后一个节点，访问该节点的右子节点并压入栈\n3. 以该右子节点作为下一轮访问起点（根节点），重复1、2步\n</code></pre><p>在递归遍历中，前序遍历是在将左子节点压栈之前输出，中序遍历是在节点的全部左子节点压入栈之后返回压入右子节点之前访问</p>\n<p>上述思路的代码表现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NonRecursiveTraverse</span><span class=\"params\">(TreeNode&lt;DataType&gt; * inNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\tTreeNode&lt;DataType&gt; *cycleNode = inNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (inNode != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//不断访问某一结的左子节点并压栈直到最左子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleNode != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//cout &lt;&lt; cycleNode-&gt;data &lt;&lt; \";\"; /*在此处访问即为先序遍历*/</span></span><br><span class=\"line\">\t\t\tnodeStack.push(cycleNode);</span><br><span class=\"line\">\t\t\tcycleNode = cycleNode-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//到这里说明所有左子节点全部入栈</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//弹出最后一个节点，访问该节点的右子节点并作为下一轮遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tcycleNode = nodeStack.top();</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//在此处访问即为中序遍历，时机为压入右子节点之前</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//cout &lt;&lt; cycleNode-&gt;data &lt;&lt; \";\";</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//以该右子节点作为下一轮访问起点，重复外层while</span></span><br><span class=\"line\">\t\t\tcycleNode = cycleNode-&gt;right;</span><br><span class=\"line\">\t\t\tnodeStack.pop(); <span class=\"comment\">//立即弹出，否则不断访问同一个节点的右子树，形成死循环</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述的代码中，压栈情况见下图：</p>\n<p><img src=\"/images/nonrecursive-stack.png\" alt=\"非递归压栈\"></p>\n<p>由于辅助压栈，我们并没有将null压入栈中，如果发现左子节点为null则在保存右子节点地址后直接弹出该节点，并使用右子节点作为下一论访问起始节点，如果右子节点为null则表示该节点左右子树均遍历完毕，则继续弹出直至出现第一个右子树不为空的节点，重复递归。</p>\n<p>压栈图中，在前序遍历时，只要遇到节点（压栈过程）就直接输出就可以保证根节点首先被输出，而中序遍历由于需要在左子树输出完毕后才能输出，因此只要保证在压栈返回时（出栈时）且准备遍历右子树时输出即可。</p>\n<ul>\n<li>二叉树后序遍历的非递归实现</li>\n</ul>\n<p>根据递归遍历的调用栈，我们可以发现后序遍历在弹出栈之前输出即可完成后序遍历，在后序遍历中，由于需要先访问左右子节点后才能访问根节点，不能直接在上述代码中插入输出代码完成，因为在后序遍历中无法确定右子节点是否是叶节点或者已经访问过，因此需要保留访问标记，如果此时右子节点已经访问则可以输出当前右子节点的父节点</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NonRecursivePostTraverse</span><span class=\"params\">(TreeNode&lt;DataType&gt; * inNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\tTreeNode&lt;DataType&gt; *cycleNode = inNode;</span><br><span class=\"line\">\tTreeNode&lt;DataType&gt; * hasCycle = <span class=\"literal\">nullptr</span>; <span class=\"comment\">/*模拟递归调用返回点*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (inNode != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*不断访问某一结的左子节点并压栈直到最左子节点*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleNode != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tnodeStack.push(cycleNode);</span><br><span class=\"line\">\t\t\tcycleNode = cycleNode-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//到这里说明所有左子节点全部入栈</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//弹出最后一个节点，访问该节点的右子节点并作为下一轮遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tcycleNode = nodeStack.top();</span><br><span class=\"line\">        \t        <span class=\"comment\">//如果右子节点为null，说明右子树已经遍历结束，可以输出根节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cycleNode-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\thasCycle = cycleNode; <span class=\"comment\">//保存已经访问的节点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; cycleNode-&gt;data &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">\t\t\t\tnodeStack.pop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果右子节点已经访问，则也可以输出根节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hasCycle == cycleNode-&gt;right) &#123;</span><br><span class=\"line\">\t\t\t\thasCycle = cycleNode; <span class=\"comment\">//保存已经访问的节点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; cycleNode-&gt;data &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">\t\t\t\tnodeStack.pop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果右子树还没有访问，则访问，否则置为nullptr继续出栈</span></span><br><span class=\"line\">\t\t\tcycleNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!nodeStack.empty() &amp;&amp; nodeStack.top()-&gt;right != hasCycle) &#123;</span><br><span class=\"line\">\t\t\t\tcycleNode = nodeStack.top()-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上述代码，压栈情况下图：</p>\n<p><img src=\"/images/nonrecursive-post-stack.png\" alt=\"后序非递归压栈\"></p>\n<p>最上面一行是当前保留的访问过的节点(n表示null节点)，由于右子节点被访问后该右子节点的父节点立刻可以被访问，因此只要发现右子树根节点被访问就可以立刻访问当前节点。</p>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>简单地手动实现文中第一张图中的树，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tTreeNode&lt;<span class=\"keyword\">char</span>&gt; testNode[<span class=\"number\">7</span>] = &#123;<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">0</span>].left = &amp;testNode[<span class=\"number\">1</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">0</span>].right = &amp;testNode[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">1</span>].left = &amp;testNode[<span class=\"number\">3</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">1</span>].right = &amp;testNode[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">4</span>].left = &amp;testNode[<span class=\"number\">5</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">4</span>].right = &amp;testNode[<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\tTraverse(testNode); <span class=\"comment\">/*调用具体的遍历算法*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.csdn.net/zhangxiangdavaid/article/details/37115355\" target=\"_blank\" rel=\"noopener\">二叉树前序、中序、后序遍历非递归写法的透彻解析</a></p>\n<p><a href=\"https://www.jianshu.com/p/e0a8bbee76a9\" target=\"_blank\" rel=\"noopener\">二叉树前序、中序、后序遍历的迭代实现</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"二叉树遍历的基本原理\"><a href=\"#二叉树遍历的基本原理\" class=\"headerlink\" title=\"二叉树遍历的基本原理\"></a>二叉树遍历的基本原理</h2><p>先上一张前、中、后序遍历的路径图：<a href=\"http://blog.csdn.net/zyq522376829/article/details/46945505\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binary-tree-traversal.jpg\" alt=\"二叉树遍历流程图\"></p>\n<p>如上图二叉树的遍历结果为：</p>\n<ul>\n<li>前序遍历为：ABDEFGC</li>\n<li>中序遍历为：DBFEGAC</li>\n<li>后序遍历为：DFGEBCA</li>\n</ul>\n<p>由于树的定义是递归定义，因此自然而然遍历思路也是从递归遍历入手。二叉树的递归定义如下：</p>\n<ol>\n<li>二叉树是由n个有限节点构成的集合</li>\n<li>n=0时为空树，n&gt;0时二叉树由两个互不相交的的左右子树组成</li>\n<li>左右子树也是一颗二叉树</li>\n</ol>\n<p>二叉树的存储方式有链式存储和顺序存储，在链式存储中，除了保存数据外，需要两个指针分别指向左子树根节点和右子树根节点（有时为了方便会增加指向父节点的指针），基本结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//存储的数据</span></span><br><span class=\"line\">\tTreeNode *left; <span class=\"comment\">//指向左子树根节点</span></span><br><span class=\"line\">\tTreeNode *right; <span class=\"comment\">//指向右子树根节点</span></span><br><span class=\"line\">\t<span class=\"comment\">//TreeNode * parent; /*指向父节点，如果需要的话*/</span></span><br><span class=\"line\">\tTreeNode(DataType inData): data(inData), right(<span class=\"literal\">nullptr</span>), left(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在顺序存储中，二叉树节点的存储顺序为由上到下、由左到右的顺序，顺序存储主要用来存储满二叉树或完全二叉树，和顺序存储有关的排序有堆排序。在顺序存储中，父节点与子节点有如下关系：</p>\n<ul>\n<li>下标从1开始，如果父节点下标为i，则左子节点的下标为2i，右子节点的下标为2i+1</li>\n<li>下标从0开始，如果父节点下标为i，则左子节点的下标为2i+1，右子节点的下标为2i+2</li>\n</ul>\n<p>对于一个层数为k的二叉树，如果采用顺序存储的方式，则至少需要2<sup>k</sup>-1个存储单元，因此对于非满二叉树或者非完全二叉树有许多存储单元被浪费。</p>\n<p>广义而言，二叉树的每一个节点都为根节点。二叉树的遍历主要是指采用链式存储方式下的遍历，由于二叉树的递归定义，最简单的遍历算法采用递归遍历，基本结构如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Traverse</span><span class=\"params\">(TreeNode&lt;DataType&gt; * inNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; inNode-&gt;data &lt;&lt; \";\"; /*如果在这里访问即为先序遍历*/</span></span><br><span class=\"line\">\tTraverse(inNode-&gt;left);</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; inNode-&gt;data &lt;&lt; \";\"; /*如果在这里访问即为中序遍历*/</span></span><br><span class=\"line\">\tTraverse(inNode-&gt;right);</span><br><span class=\"line\">\t<span class=\"comment\">//cout &lt;&lt; inNode-&gt;data &lt;&lt; \";\"; /*如果在这里访问即为后序遍历*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>先序遍历又称为先根遍历，可以理解为先访问根节点，再递归先序遍历左子树，最后先序遍历右子树</li>\n<li>中序遍历又可称为中根遍历，可以理解为中间再访问根节点，因此访问顺序是先中序遍历左子树，接着访问根节点，最后中序访问右子树</li>\n<li>后序遍历又可称为后根遍历，可以理解为根节点最后访问，因此访问顺序是先后序遍历左子树，接着后序遍历右子树，最后访问根节点</li>\n<li>层序遍历，是一种层次遍历，逐层遍历，每一层从左到右到右的顺序，该遍历方式需要借助于辅助空间（队列）</li>\n</ul>\n<p>下图为遍历时的递归栈：</p>\n<p><img src=\"/images/recursive-stack.png\" alt=\"遍历时的递归栈\"></p>\n<p>上图中ln代表左子节点为空指针，rn代表右子节点为空。如图所示，先序遍历就是第一次遇到节点时便输出，中序遍历则是第二次遇到时输出，既是上图中凹点处（左右两边栈高度均比当前栈高），后序遍历则是在栈即将该节点弹出时（最后一次访问）输出。</p>\n<h2 id=\"非递归实现遍历\"><a href=\"#非递归实现遍历\" class=\"headerlink\" title=\"非递归实现遍历\"></a>非递归实现遍历</h2><ul>\n<li>二叉树前序与中序遍历的非递归实现</li>\n</ul>\n<p>非递归意味着无法让编译器帮助我们通过递归函数调用压栈和函数返回的方式记忆遍历线路，因此需要使用辅助栈空间来模拟函数调用返回过程。我们结合开始pou的图分析二叉树递归遍历的特点：首先访问左子树直到最左，然后再返回访问右子节点，再重复访问右子节点的左子树直到最左，因此我们在编写非递归实现时，可按照以下步骤来进行</p>\n<pre><code>1. 不断访问某一结的左子节点并压栈直到最左子节点\n2. 弹出最后一个节点，访问该节点的右子节点并压入栈\n3. 以该右子节点作为下一轮访问起点（根节点），重复1、2步\n</code></pre><p>在递归遍历中，前序遍历是在将左子节点压栈之前输出，中序遍历是在节点的全部左子节点压入栈之后返回压入右子节点之前访问</p>\n<p>上述思路的代码表现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NonRecursiveTraverse</span><span class=\"params\">(TreeNode&lt;DataType&gt; * inNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\tTreeNode&lt;DataType&gt; *cycleNode = inNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (inNode != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//不断访问某一结的左子节点并压栈直到最左子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleNode != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//cout &lt;&lt; cycleNode-&gt;data &lt;&lt; \";\"; /*在此处访问即为先序遍历*/</span></span><br><span class=\"line\">\t\t\tnodeStack.push(cycleNode);</span><br><span class=\"line\">\t\t\tcycleNode = cycleNode-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//到这里说明所有左子节点全部入栈</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//弹出最后一个节点，访问该节点的右子节点并作为下一轮遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tcycleNode = nodeStack.top();</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//在此处访问即为中序遍历，时机为压入右子节点之前</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//cout &lt;&lt; cycleNode-&gt;data &lt;&lt; \";\";</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//以该右子节点作为下一轮访问起点，重复外层while</span></span><br><span class=\"line\">\t\t\tcycleNode = cycleNode-&gt;right;</span><br><span class=\"line\">\t\t\tnodeStack.pop(); <span class=\"comment\">//立即弹出，否则不断访问同一个节点的右子树，形成死循环</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述的代码中，压栈情况见下图：</p>\n<p><img src=\"/images/nonrecursive-stack.png\" alt=\"非递归压栈\"></p>\n<p>由于辅助压栈，我们并没有将null压入栈中，如果发现左子节点为null则在保存右子节点地址后直接弹出该节点，并使用右子节点作为下一论访问起始节点，如果右子节点为null则表示该节点左右子树均遍历完毕，则继续弹出直至出现第一个右子树不为空的节点，重复递归。</p>\n<p>压栈图中，在前序遍历时，只要遇到节点（压栈过程）就直接输出就可以保证根节点首先被输出，而中序遍历由于需要在左子树输出完毕后才能输出，因此只要保证在压栈返回时（出栈时）且准备遍历右子树时输出即可。</p>\n<ul>\n<li>二叉树后序遍历的非递归实现</li>\n</ul>\n<p>根据递归遍历的调用栈，我们可以发现后序遍历在弹出栈之前输出即可完成后序遍历，在后序遍历中，由于需要先访问左右子节点后才能访问根节点，不能直接在上述代码中插入输出代码完成，因为在后序遍历中无法确定右子节点是否是叶节点或者已经访问过，因此需要保留访问标记，如果此时右子节点已经访问则可以输出当前右子节点的父节点</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NonRecursivePostTraverse</span><span class=\"params\">(TreeNode&lt;DataType&gt; * inNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\tTreeNode&lt;DataType&gt; *cycleNode = inNode;</span><br><span class=\"line\">\tTreeNode&lt;DataType&gt; * hasCycle = <span class=\"literal\">nullptr</span>; <span class=\"comment\">/*模拟递归调用返回点*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (inNode != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*不断访问某一结的左子节点并压栈直到最左子节点*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleNode != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tnodeStack.push(cycleNode);</span><br><span class=\"line\">\t\t\tcycleNode = cycleNode-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//到这里说明所有左子节点全部入栈</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//弹出最后一个节点，访问该节点的右子节点并作为下一轮遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tcycleNode = nodeStack.top();</span><br><span class=\"line\">        \t        <span class=\"comment\">//如果右子节点为null，说明右子树已经遍历结束，可以输出根节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cycleNode-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\thasCycle = cycleNode; <span class=\"comment\">//保存已经访问的节点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; cycleNode-&gt;data &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">\t\t\t\tnodeStack.pop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果右子节点已经访问，则也可以输出根节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hasCycle == cycleNode-&gt;right) &#123;</span><br><span class=\"line\">\t\t\t\thasCycle = cycleNode; <span class=\"comment\">//保存已经访问的节点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; cycleNode-&gt;data &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">\t\t\t\tnodeStack.pop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果右子树还没有访问，则访问，否则置为nullptr继续出栈</span></span><br><span class=\"line\">\t\t\tcycleNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!nodeStack.empty() &amp;&amp; nodeStack.top()-&gt;right != hasCycle) &#123;</span><br><span class=\"line\">\t\t\t\tcycleNode = nodeStack.top()-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上述代码，压栈情况下图：</p>\n<p><img src=\"/images/nonrecursive-post-stack.png\" alt=\"后序非递归压栈\"></p>\n<p>最上面一行是当前保留的访问过的节点(n表示null节点)，由于右子节点被访问后该右子节点的父节点立刻可以被访问，因此只要发现右子树根节点被访问就可以立刻访问当前节点。</p>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>简单地手动实现文中第一张图中的树，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tTreeNode&lt;<span class=\"keyword\">char</span>&gt; testNode[<span class=\"number\">7</span>] = &#123;<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">0</span>].left = &amp;testNode[<span class=\"number\">1</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">0</span>].right = &amp;testNode[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">1</span>].left = &amp;testNode[<span class=\"number\">3</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">1</span>].right = &amp;testNode[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">4</span>].left = &amp;testNode[<span class=\"number\">5</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">4</span>].right = &amp;testNode[<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\tTraverse(testNode); <span class=\"comment\">/*调用具体的遍历算法*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.csdn.net/zhangxiangdavaid/article/details/37115355\" target=\"_blank\" rel=\"noopener\">二叉树前序、中序、后序遍历非递归写法的透彻解析</a></p>\n<p><a href=\"https://www.jianshu.com/p/e0a8bbee76a9\" target=\"_blank\" rel=\"noopener\">二叉树前序、中序、后序遍历的迭代实现</a></p>\n"},{"title":"优先队列的定义与二叉堆实现","urlname":"priority-queue","date":"2018-03-09T01:45:11.000Z","mathjax":true,"copyright":true,"_content":"\n## 优先队列基础\n\n优先队列是指一种数据结构，其每个元素都有各自的优先级，出队顺序由元素的优先级决定。优先队列一般使用堆来实现。优先队列一般至少需要支持如下操作：\n\n1. 插入带优先级的元素\n2. 取出最高优先级的元素\n3. 查看最高优先级的元素\n\n优先队列有多种实现方式，分别简述如下：\n\n1. 无序顺序表：在表尾插入，删除时遍历找到优先级最高的元素，因此插入时间复杂度O(1)而删除O(n)\n2. 无序链表：在头节点插入，删除时时遍历找到优先级最高的元素，因此插入时间复杂度O(1)而删除O(n)\n3. 有序线性表：保持插入后的线性表有序，因此插入时间复杂度O(n)，删除时间复杂度O(1)\n4. 有序链表：保持插入后的线性表有序，因此插入时间复杂度O(n)，删除时间复杂度O(1)\n5. 二叉查找树：插入操作O(log<sub>2</sub>n)，而删除时间复杂度也为O(log<sub>2</sub>n)\n6. 二叉堆：插入与删除均为O(log<sub>2</sub>n)，构造时间复杂度为O(n)\n\n## 二叉堆基础知识\n\n二叉堆有两个性质，即结构性和堆序性。结构性是指二叉堆是一棵完全被填满的二叉树，只在底层存在例外，即倒数第二层也可能存在叶节点。而堆序性是指对于每一个节点X，X的父亲中的关键字小于（或等于）X中的关键字（根节点除外）。由于堆序性的原因，在插入和删除节点后需要调整二叉堆使得其保持堆序性。在插入时，可以先将带插入的节点放入下一个空闲位置，然后采用称为上滤策略的二叉堆调整方法，不断和父节点比较，如果不满足堆序性就交换，直到满足堆序性或者成为根节点。而删除最小元时，先把堆中最后一个元素填入原来最小元素的空穴，然后采用称为下滤的策略调整二叉堆，其不断和左右子节点比较，和较小的子节点交换，不断重复该过程直到满足堆序性为止。\n\n## 二叉堆的实现\n\n根据上节的分析，二叉堆主要有如下操作：\n\n- 插入或者称为入队：Enqueue\n- 删除或者说称为出队：Dequeue\n- 查看当前队首元素（即最小元素）：Front\n- 清空队列：MakeEmpty\n- 建立二叉堆：BuildHeap\n\n在STL中，优先队列priority_queue底层采用vector实现，优先队列定义如下：\n\n\n```cpp\ntemplate <typename DataType>\nclass PriorityQueue\n{\npublic:\n\tPriorityQueue(int inSize);\n\t~PriorityQueue();\n\tvoid Enqueue(DataType inData);\n\tvoid Dequeue();\n\tDataType Front();\n\tbool isEmpty();\n\tvoid MakeEmpty();\n\tint QueueSize();\n\tvoid BuildHeap(vector<DataType> &inArray);\nprivate:\n\tint capacity;\n\tint queueSize;\n\tDataType *queuePtr;\n};\n```\n\n如上所示，数据成员主要有二叉堆容量，二叉堆大小以及二叉堆实际元素指针，采用动态分配的方式，以下依次实现各函数（最小堆）。\n\n- 构造函数，初始化空间并设置数据成员初始值\n\n```cpp\ntemplate <typename DataType>\nPriorityQueue<DataType>::PriorityQueue(int inSize):capacity(inSize), queueSize(0),queuePtr(nullptr)\n{\n\tqueuePtr = new DataType[inSize];\n}\n```\n\n- 入队函数，采用上滤策略调整二叉堆，如果堆已满则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid PriorityQueue<DataType>::Enqueue(DataType inData)\n{\n\tif (queueSize >= capacity) {\n\t\tthrow \"Priority queue is full!\";\n\t}\n\tint i = queueSize;\n\twhile (i > 0 && inData < queuePtr[(i-1)/2]) {\n\t\tqueuePtr[i] = queuePtr[(i-1)/2];\n\t\ti= (i-1)/2;\n\t}\n\tqueuePtr[i] = inData; ++queueSize;\n}\n```\n\n- 出队函数，采用下滤策略调整二叉堆\n\n```cpp\ntemplate <typename DataType>\nvoid PriorityQueue<DataType>::Dequeue()\n{\n\tif (queueSize <= 0) {\n\t\tthrow \"Priority queue is empty!\";\n\t}\n\tDataType lastElement =  queuePtr[queueSize-1];\n\tint i = 0;\n\tfor (i = 0; 2*i+1 < queueSize;) {\n\t\tint minChild = 2*i+1;\n\t\tif (minChild+1 < queueSize && queuePtr[minChild] > queuePtr[minChild+1]) {\n\t\t\tminChild += 1;\n\t\t}\n\t\tif (lastElement > queuePtr[minChild]) {\n\t\t\tqueuePtr[i] = queuePtr[minChild];\n\t\t\ti = minChild;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\tqueuePtr[i] = lastElement; --queueSize;\n}\n```\n\n- 查看队首元素\n\n```cpp\ntemplate <typename DataType>\nDataType PriorityQueue<DataType>::Front()\n{\n\tif (queueSize <= 0) {\n\t\tthrow \"Priority queue is empty!\";\n\t}\n\treturn queuePtr[0];\n}\n```\n- 判断是否为空\n\n```cpp\ntemplate <typename DataType>\nbool PriorityQueue<DataType>::isEmpty()\n{\n\treturn queueSize <= 0;\n}\n```\n\n- 清空优先队列\n\n```cpp\ntemplate <typename DataType>\nvoid PriorityQueue<DataType>::MakeEmpty()\n{\n\tqueueSize = 0;\n}\n```\n\n- 返回优先队列大小\n\n```cpp\ntemplate <typename DataType>\nint PriorityQueue<DataType>::QueueSize()\n{\n\treturn queueSize;\n}\n```\n\n- 建堆，可以直接循环调用Enqueue函数（时间复杂度O(N)），本文采用另外一种方法，算法思路如下：\n\n\t二叉堆的左右子树也是一个二叉堆，因此从最后一个非叶节点开始，调整该子树成为二叉堆，依次往前推进，循环调整直到根节点即完成二叉堆的构建。\n\n```cpp\ntemplate <typename DataType>\nvoid PriorityQueue<DataType>::BuildHeap(vector<DataType> &inArray)\n{\n\tif (inArray.size() > capacity) {\n\t\tthrow \"Out of space!\";\n\t}\n\tqueueSize = 0;\n\tfor (size_t i = 0; i < inArray.size(); i++) {\n\t\tqueuePtr[queueSize++] = inArray.at(i);\n\t}\n\tfor (int i = (queueSize-1)/2; i >= 0; i--) {\n\t\tint tmpElement = queuePtr[i];\n\t\tint j = i;\n\t\twhile (2*j+1 < queueSize) {\n\t\t\tint miniChild = 2*j+1;\n\t\t\tif (miniChild+1 < queueSize && queuePtr[miniChild] > queuePtr[miniChild+1]) {\n\t\t\t\tminiChild += 1;\n\t\t\t}\n\t\t\tif (tmpElement > queuePtr[miniChild]) {\n\t\t\t\tqueuePtr[j] = queuePtr[miniChild];\n\t\t\t\tj = miniChild;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueuePtr[j] = tmpElement;\n\t}\n}\n```\n\n- 析构函数，释放内存\n\n```cpp\ntemplate <typename DataType>\nPriorityQueue<DataType>::~PriorityQueue()\n{\n\tMakeEmpty();\n\tdelete [] queuePtr; \n\tqueuePtr = nullptr;\n}\n```\n二叉堆除了上述操作以外，还可以有降低某位置关键字的值，增加某位置关键字的值以及删除某个位置的关键字，各操作的基本思路如下：\n\n- 降低某位置关键字值：采用上滤（最小堆）策略调整二叉堆使其保持堆序性\n- 增加某位置关键字的值：采用下滤策略（最小堆）策略调整二叉堆使其保持堆序性\n- 删除某个位置的关键字：将该位置值设为比最小值还小（最小堆），然后上滤并调用出队函数即可\n- 合并：调用插入函数依次插入\n\n## 二叉堆的相关定理\n\n- 包含2<sup>h+1</sup>个节点高为h的理想二叉树的节点的高度的和为2<sup>h+1</sup>-1-(h+1)\n\n证明：根据二叉树的定义，在高为h的层上总共有1个节点，高为h-1的曾是上有1\\*2个节点，即每层节点个数是上一层的两倍，故高为h-i层节点数量为2<sup>i</sup>个。则所有节点高的和为∑<sub>i=0~h</sub>2<sup>i</sup>\\*(h-i)。求解该式便可得出上述结论。将h=logN代入便可得出建堆的时间复杂度为O(N)\n\n## 二叉堆扩展-d堆\n\nd堆是二叉堆的简单推广，其节点有d个子节点，因此二叉堆是d=2的情况。d堆由于子节点数多，其高度比较浅，插入操作时间复杂度为O(log<sub>d</sub>N)，删除时间复杂度为dO(log<sub>d</sub>N)。下图为一个3-堆。[图片来源](http://mingnote.com/d-heap-algorithm-in-c.html)\n\n![3堆](/images/d-heap.png)\n\n\n\n\n\n\n","source":"_posts/数据结构/优先队列的定义与二叉堆实现.md","raw":"---\ntitle: 优先队列的定义与二叉堆实现\nurlname: priority-queue\ndate: 2018-03-9 9:45:11\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 优先队列基础\n\n优先队列是指一种数据结构，其每个元素都有各自的优先级，出队顺序由元素的优先级决定。优先队列一般使用堆来实现。优先队列一般至少需要支持如下操作：\n\n1. 插入带优先级的元素\n2. 取出最高优先级的元素\n3. 查看最高优先级的元素\n\n优先队列有多种实现方式，分别简述如下：\n\n1. 无序顺序表：在表尾插入，删除时遍历找到优先级最高的元素，因此插入时间复杂度O(1)而删除O(n)\n2. 无序链表：在头节点插入，删除时时遍历找到优先级最高的元素，因此插入时间复杂度O(1)而删除O(n)\n3. 有序线性表：保持插入后的线性表有序，因此插入时间复杂度O(n)，删除时间复杂度O(1)\n4. 有序链表：保持插入后的线性表有序，因此插入时间复杂度O(n)，删除时间复杂度O(1)\n5. 二叉查找树：插入操作O(log<sub>2</sub>n)，而删除时间复杂度也为O(log<sub>2</sub>n)\n6. 二叉堆：插入与删除均为O(log<sub>2</sub>n)，构造时间复杂度为O(n)\n\n## 二叉堆基础知识\n\n二叉堆有两个性质，即结构性和堆序性。结构性是指二叉堆是一棵完全被填满的二叉树，只在底层存在例外，即倒数第二层也可能存在叶节点。而堆序性是指对于每一个节点X，X的父亲中的关键字小于（或等于）X中的关键字（根节点除外）。由于堆序性的原因，在插入和删除节点后需要调整二叉堆使得其保持堆序性。在插入时，可以先将带插入的节点放入下一个空闲位置，然后采用称为上滤策略的二叉堆调整方法，不断和父节点比较，如果不满足堆序性就交换，直到满足堆序性或者成为根节点。而删除最小元时，先把堆中最后一个元素填入原来最小元素的空穴，然后采用称为下滤的策略调整二叉堆，其不断和左右子节点比较，和较小的子节点交换，不断重复该过程直到满足堆序性为止。\n\n## 二叉堆的实现\n\n根据上节的分析，二叉堆主要有如下操作：\n\n- 插入或者称为入队：Enqueue\n- 删除或者说称为出队：Dequeue\n- 查看当前队首元素（即最小元素）：Front\n- 清空队列：MakeEmpty\n- 建立二叉堆：BuildHeap\n\n在STL中，优先队列priority_queue底层采用vector实现，优先队列定义如下：\n\n\n```cpp\ntemplate <typename DataType>\nclass PriorityQueue\n{\npublic:\n\tPriorityQueue(int inSize);\n\t~PriorityQueue();\n\tvoid Enqueue(DataType inData);\n\tvoid Dequeue();\n\tDataType Front();\n\tbool isEmpty();\n\tvoid MakeEmpty();\n\tint QueueSize();\n\tvoid BuildHeap(vector<DataType> &inArray);\nprivate:\n\tint capacity;\n\tint queueSize;\n\tDataType *queuePtr;\n};\n```\n\n如上所示，数据成员主要有二叉堆容量，二叉堆大小以及二叉堆实际元素指针，采用动态分配的方式，以下依次实现各函数（最小堆）。\n\n- 构造函数，初始化空间并设置数据成员初始值\n\n```cpp\ntemplate <typename DataType>\nPriorityQueue<DataType>::PriorityQueue(int inSize):capacity(inSize), queueSize(0),queuePtr(nullptr)\n{\n\tqueuePtr = new DataType[inSize];\n}\n```\n\n- 入队函数，采用上滤策略调整二叉堆，如果堆已满则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid PriorityQueue<DataType>::Enqueue(DataType inData)\n{\n\tif (queueSize >= capacity) {\n\t\tthrow \"Priority queue is full!\";\n\t}\n\tint i = queueSize;\n\twhile (i > 0 && inData < queuePtr[(i-1)/2]) {\n\t\tqueuePtr[i] = queuePtr[(i-1)/2];\n\t\ti= (i-1)/2;\n\t}\n\tqueuePtr[i] = inData; ++queueSize;\n}\n```\n\n- 出队函数，采用下滤策略调整二叉堆\n\n```cpp\ntemplate <typename DataType>\nvoid PriorityQueue<DataType>::Dequeue()\n{\n\tif (queueSize <= 0) {\n\t\tthrow \"Priority queue is empty!\";\n\t}\n\tDataType lastElement =  queuePtr[queueSize-1];\n\tint i = 0;\n\tfor (i = 0; 2*i+1 < queueSize;) {\n\t\tint minChild = 2*i+1;\n\t\tif (minChild+1 < queueSize && queuePtr[minChild] > queuePtr[minChild+1]) {\n\t\t\tminChild += 1;\n\t\t}\n\t\tif (lastElement > queuePtr[minChild]) {\n\t\t\tqueuePtr[i] = queuePtr[minChild];\n\t\t\ti = minChild;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\tqueuePtr[i] = lastElement; --queueSize;\n}\n```\n\n- 查看队首元素\n\n```cpp\ntemplate <typename DataType>\nDataType PriorityQueue<DataType>::Front()\n{\n\tif (queueSize <= 0) {\n\t\tthrow \"Priority queue is empty!\";\n\t}\n\treturn queuePtr[0];\n}\n```\n- 判断是否为空\n\n```cpp\ntemplate <typename DataType>\nbool PriorityQueue<DataType>::isEmpty()\n{\n\treturn queueSize <= 0;\n}\n```\n\n- 清空优先队列\n\n```cpp\ntemplate <typename DataType>\nvoid PriorityQueue<DataType>::MakeEmpty()\n{\n\tqueueSize = 0;\n}\n```\n\n- 返回优先队列大小\n\n```cpp\ntemplate <typename DataType>\nint PriorityQueue<DataType>::QueueSize()\n{\n\treturn queueSize;\n}\n```\n\n- 建堆，可以直接循环调用Enqueue函数（时间复杂度O(N)），本文采用另外一种方法，算法思路如下：\n\n\t二叉堆的左右子树也是一个二叉堆，因此从最后一个非叶节点开始，调整该子树成为二叉堆，依次往前推进，循环调整直到根节点即完成二叉堆的构建。\n\n```cpp\ntemplate <typename DataType>\nvoid PriorityQueue<DataType>::BuildHeap(vector<DataType> &inArray)\n{\n\tif (inArray.size() > capacity) {\n\t\tthrow \"Out of space!\";\n\t}\n\tqueueSize = 0;\n\tfor (size_t i = 0; i < inArray.size(); i++) {\n\t\tqueuePtr[queueSize++] = inArray.at(i);\n\t}\n\tfor (int i = (queueSize-1)/2; i >= 0; i--) {\n\t\tint tmpElement = queuePtr[i];\n\t\tint j = i;\n\t\twhile (2*j+1 < queueSize) {\n\t\t\tint miniChild = 2*j+1;\n\t\t\tif (miniChild+1 < queueSize && queuePtr[miniChild] > queuePtr[miniChild+1]) {\n\t\t\t\tminiChild += 1;\n\t\t\t}\n\t\t\tif (tmpElement > queuePtr[miniChild]) {\n\t\t\t\tqueuePtr[j] = queuePtr[miniChild];\n\t\t\t\tj = miniChild;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueuePtr[j] = tmpElement;\n\t}\n}\n```\n\n- 析构函数，释放内存\n\n```cpp\ntemplate <typename DataType>\nPriorityQueue<DataType>::~PriorityQueue()\n{\n\tMakeEmpty();\n\tdelete [] queuePtr; \n\tqueuePtr = nullptr;\n}\n```\n二叉堆除了上述操作以外，还可以有降低某位置关键字的值，增加某位置关键字的值以及删除某个位置的关键字，各操作的基本思路如下：\n\n- 降低某位置关键字值：采用上滤（最小堆）策略调整二叉堆使其保持堆序性\n- 增加某位置关键字的值：采用下滤策略（最小堆）策略调整二叉堆使其保持堆序性\n- 删除某个位置的关键字：将该位置值设为比最小值还小（最小堆），然后上滤并调用出队函数即可\n- 合并：调用插入函数依次插入\n\n## 二叉堆的相关定理\n\n- 包含2<sup>h+1</sup>个节点高为h的理想二叉树的节点的高度的和为2<sup>h+1</sup>-1-(h+1)\n\n证明：根据二叉树的定义，在高为h的层上总共有1个节点，高为h-1的曾是上有1\\*2个节点，即每层节点个数是上一层的两倍，故高为h-i层节点数量为2<sup>i</sup>个。则所有节点高的和为∑<sub>i=0~h</sub>2<sup>i</sup>\\*(h-i)。求解该式便可得出上述结论。将h=logN代入便可得出建堆的时间复杂度为O(N)\n\n## 二叉堆扩展-d堆\n\nd堆是二叉堆的简单推广，其节点有d个子节点，因此二叉堆是d=2的情况。d堆由于子节点数多，其高度比较浅，插入操作时间复杂度为O(log<sub>d</sub>N)，删除时间复杂度为dO(log<sub>d</sub>N)。下图为一个3-堆。[图片来源](http://mingnote.com/d-heap-algorithm-in-c.html)\n\n![3堆](/images/d-heap.png)\n\n\n\n\n\n\n","slug":"数据结构/优先队列的定义与二叉堆实现","published":1,"updated":"2018-06-13T14:06:42.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3a000ogsvnxt84m1n9","content":"<h2 id=\"优先队列基础\"><a href=\"#优先队列基础\" class=\"headerlink\" title=\"优先队列基础\"></a>优先队列基础</h2><p>优先队列是指一种数据结构，其每个元素都有各自的优先级，出队顺序由元素的优先级决定。优先队列一般使用堆来实现。优先队列一般至少需要支持如下操作：</p>\n<ol>\n<li>插入带优先级的元素</li>\n<li>取出最高优先级的元素</li>\n<li>查看最高优先级的元素</li>\n</ol>\n<p>优先队列有多种实现方式，分别简述如下：</p>\n<ol>\n<li>无序顺序表：在表尾插入，删除时遍历找到优先级最高的元素，因此插入时间复杂度O(1)而删除O(n)</li>\n<li>无序链表：在头节点插入，删除时时遍历找到优先级最高的元素，因此插入时间复杂度O(1)而删除O(n)</li>\n<li>有序线性表：保持插入后的线性表有序，因此插入时间复杂度O(n)，删除时间复杂度O(1)</li>\n<li>有序链表：保持插入后的线性表有序，因此插入时间复杂度O(n)，删除时间复杂度O(1)</li>\n<li>二叉查找树：插入操作O(log<sub>2</sub>n)，而删除时间复杂度也为O(log<sub>2</sub>n)</li>\n<li>二叉堆：插入与删除均为O(log<sub>2</sub>n)，构造时间复杂度为O(n)</li>\n</ol>\n<h2 id=\"二叉堆基础知识\"><a href=\"#二叉堆基础知识\" class=\"headerlink\" title=\"二叉堆基础知识\"></a>二叉堆基础知识</h2><p>二叉堆有两个性质，即结构性和堆序性。结构性是指二叉堆是一棵完全被填满的二叉树，只在底层存在例外，即倒数第二层也可能存在叶节点。而堆序性是指对于每一个节点X，X的父亲中的关键字小于（或等于）X中的关键字（根节点除外）。由于堆序性的原因，在插入和删除节点后需要调整二叉堆使得其保持堆序性。在插入时，可以先将带插入的节点放入下一个空闲位置，然后采用称为上滤策略的二叉堆调整方法，不断和父节点比较，如果不满足堆序性就交换，直到满足堆序性或者成为根节点。而删除最小元时，先把堆中最后一个元素填入原来最小元素的空穴，然后采用称为下滤的策略调整二叉堆，其不断和左右子节点比较，和较小的子节点交换，不断重复该过程直到满足堆序性为止。</p>\n<h2 id=\"二叉堆的实现\"><a href=\"#二叉堆的实现\" class=\"headerlink\" title=\"二叉堆的实现\"></a>二叉堆的实现</h2><p>根据上节的分析，二叉堆主要有如下操作：</p>\n<ul>\n<li>插入或者称为入队：Enqueue</li>\n<li>删除或者说称为出队：Dequeue</li>\n<li>查看当前队首元素（即最小元素）：Front</li>\n<li>清空队列：MakeEmpty</li>\n<li>建立二叉堆：BuildHeap</li>\n</ul>\n<p>在STL中，优先队列priority_queue底层采用vector实现，优先队列定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityQueue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tPriorityQueue(<span class=\"keyword\">int</span> inSize);</span><br><span class=\"line\">\t~PriorityQueue();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(DataType inData)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dequeue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Front</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">QueueSize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BuildHeap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inArray)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> queueSize;</span><br><span class=\"line\">\tDataType *queuePtr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，数据成员主要有二叉堆容量，二叉堆大小以及二叉堆实际元素指针，采用动态分配的方式，以下依次实现各函数（最小堆）。</p>\n<ul>\n<li>构造函数，初始化空间并设置数据成员初始值</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">PriorityQueue&lt;DataType&gt;::PriorityQueue(<span class=\"keyword\">int</span> inSize):capacity(inSize), queueSize(<span class=\"number\">0</span>),queuePtr(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueuePtr = <span class=\"keyword\">new</span> DataType[inSize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>入队函数，采用上滤策略调整二叉堆，如果堆已满则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> PriorityQueue&lt;DataType&gt;::Enqueue(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &gt;= capacity) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Priority queue is full!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = queueSize;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; inData &lt; queuePtr[(i<span class=\"number\">-1</span>)/<span class=\"number\">2</span>]) &#123;</span><br><span class=\"line\">\t\tqueuePtr[i] = queuePtr[(i<span class=\"number\">-1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\ti= (i<span class=\"number\">-1</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tqueuePtr[i] = inData; ++queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出队函数，采用下滤策略调整二叉堆</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> PriorityQueue&lt;DataType&gt;::Dequeue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Priority queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tDataType lastElement =  queuePtr[queueSize<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; <span class=\"number\">2</span>*i+<span class=\"number\">1</span> &lt; queueSize;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> minChild = <span class=\"number\">2</span>*i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (minChild+<span class=\"number\">1</span> &lt; queueSize &amp;&amp; queuePtr[minChild] &gt; queuePtr[minChild+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\tminChild += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lastElement &gt; queuePtr[minChild]) &#123;</span><br><span class=\"line\">\t\t\tqueuePtr[i] = queuePtr[minChild];</span><br><span class=\"line\">\t\t\ti = minChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tqueuePtr[i] = lastElement; --queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看队首元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType PriorityQueue&lt;DataType&gt;::Front()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Priority queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queuePtr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> PriorityQueue&lt;DataType&gt;::isEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空优先队列</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> PriorityQueue&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueueSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回优先队列大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> PriorityQueue&lt;DataType&gt;::QueueSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>建堆，可以直接循环调用Enqueue函数（时间复杂度O(N)），本文采用另外一种方法，算法思路如下：</p>\n<p>  二叉堆的左右子树也是一个二叉堆，因此从最后一个非叶节点开始，调整该子树成为二叉堆，依次往前推进，循环调整直到根节点即完成二叉堆的构建。</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> PriorityQueue&lt;DataType&gt;::BuildHeap(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inArray)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inArray.size() &gt; capacity) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Out of space!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tqueueSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tqueuePtr[queueSize++] = inArray.at(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (queueSize<span class=\"number\">-1</span>)/<span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmpElement = queuePtr[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> j = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">2</span>*j+<span class=\"number\">1</span> &lt; queueSize) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> miniChild = <span class=\"number\">2</span>*j+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (miniChild+<span class=\"number\">1</span> &lt; queueSize &amp;&amp; queuePtr[miniChild] &gt; queuePtr[miniChild+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\tminiChild += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmpElement &gt; queuePtr[miniChild]) &#123;</span><br><span class=\"line\">\t\t\t\tqueuePtr[j] = queuePtr[miniChild];</span><br><span class=\"line\">\t\t\t\tj = miniChild;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tqueuePtr[j] = tmpElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，释放内存</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">PriorityQueue&lt;DataType&gt;::~PriorityQueue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] queuePtr; </span><br><span class=\"line\">\tqueuePtr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二叉堆除了上述操作以外，还可以有降低某位置关键字的值，增加某位置关键字的值以及删除某个位置的关键字，各操作的基本思路如下：</p>\n<ul>\n<li>降低某位置关键字值：采用上滤（最小堆）策略调整二叉堆使其保持堆序性</li>\n<li>增加某位置关键字的值：采用下滤策略（最小堆）策略调整二叉堆使其保持堆序性</li>\n<li>删除某个位置的关键字：将该位置值设为比最小值还小（最小堆），然后上滤并调用出队函数即可</li>\n<li>合并：调用插入函数依次插入</li>\n</ul>\n<h2 id=\"二叉堆的相关定理\"><a href=\"#二叉堆的相关定理\" class=\"headerlink\" title=\"二叉堆的相关定理\"></a>二叉堆的相关定理</h2><ul>\n<li>包含2<sup>h+1</sup>个节点高为h的理想二叉树的节点的高度的和为2<sup>h+1</sup>-1-(h+1)</li>\n</ul>\n<p>证明：根据二叉树的定义，在高为h的层上总共有1个节点，高为h-1的曾是上有1*2个节点，即每层节点个数是上一层的两倍，故高为h-i层节点数量为2<sup>i</sup>个。则所有节点高的和为∑<sub>i=0~h</sub>2<sup>i</sup>*(h-i)。求解该式便可得出上述结论。将h=logN代入便可得出建堆的时间复杂度为O(N)</p>\n<h2 id=\"二叉堆扩展-d堆\"><a href=\"#二叉堆扩展-d堆\" class=\"headerlink\" title=\"二叉堆扩展-d堆\"></a>二叉堆扩展-d堆</h2><p>d堆是二叉堆的简单推广，其节点有d个子节点，因此二叉堆是d=2的情况。d堆由于子节点数多，其高度比较浅，插入操作时间复杂度为O(log<sub>d</sub>N)，删除时间复杂度为dO(log<sub>d</sub>N)。下图为一个3-堆。<a href=\"http://mingnote.com/d-heap-algorithm-in-c.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/d-heap.png\" alt=\"3堆\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"优先队列基础\"><a href=\"#优先队列基础\" class=\"headerlink\" title=\"优先队列基础\"></a>优先队列基础</h2><p>优先队列是指一种数据结构，其每个元素都有各自的优先级，出队顺序由元素的优先级决定。优先队列一般使用堆来实现。优先队列一般至少需要支持如下操作：</p>\n<ol>\n<li>插入带优先级的元素</li>\n<li>取出最高优先级的元素</li>\n<li>查看最高优先级的元素</li>\n</ol>\n<p>优先队列有多种实现方式，分别简述如下：</p>\n<ol>\n<li>无序顺序表：在表尾插入，删除时遍历找到优先级最高的元素，因此插入时间复杂度O(1)而删除O(n)</li>\n<li>无序链表：在头节点插入，删除时时遍历找到优先级最高的元素，因此插入时间复杂度O(1)而删除O(n)</li>\n<li>有序线性表：保持插入后的线性表有序，因此插入时间复杂度O(n)，删除时间复杂度O(1)</li>\n<li>有序链表：保持插入后的线性表有序，因此插入时间复杂度O(n)，删除时间复杂度O(1)</li>\n<li>二叉查找树：插入操作O(log<sub>2</sub>n)，而删除时间复杂度也为O(log<sub>2</sub>n)</li>\n<li>二叉堆：插入与删除均为O(log<sub>2</sub>n)，构造时间复杂度为O(n)</li>\n</ol>\n<h2 id=\"二叉堆基础知识\"><a href=\"#二叉堆基础知识\" class=\"headerlink\" title=\"二叉堆基础知识\"></a>二叉堆基础知识</h2><p>二叉堆有两个性质，即结构性和堆序性。结构性是指二叉堆是一棵完全被填满的二叉树，只在底层存在例外，即倒数第二层也可能存在叶节点。而堆序性是指对于每一个节点X，X的父亲中的关键字小于（或等于）X中的关键字（根节点除外）。由于堆序性的原因，在插入和删除节点后需要调整二叉堆使得其保持堆序性。在插入时，可以先将带插入的节点放入下一个空闲位置，然后采用称为上滤策略的二叉堆调整方法，不断和父节点比较，如果不满足堆序性就交换，直到满足堆序性或者成为根节点。而删除最小元时，先把堆中最后一个元素填入原来最小元素的空穴，然后采用称为下滤的策略调整二叉堆，其不断和左右子节点比较，和较小的子节点交换，不断重复该过程直到满足堆序性为止。</p>\n<h2 id=\"二叉堆的实现\"><a href=\"#二叉堆的实现\" class=\"headerlink\" title=\"二叉堆的实现\"></a>二叉堆的实现</h2><p>根据上节的分析，二叉堆主要有如下操作：</p>\n<ul>\n<li>插入或者称为入队：Enqueue</li>\n<li>删除或者说称为出队：Dequeue</li>\n<li>查看当前队首元素（即最小元素）：Front</li>\n<li>清空队列：MakeEmpty</li>\n<li>建立二叉堆：BuildHeap</li>\n</ul>\n<p>在STL中，优先队列priority_queue底层采用vector实现，优先队列定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityQueue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tPriorityQueue(<span class=\"keyword\">int</span> inSize);</span><br><span class=\"line\">\t~PriorityQueue();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(DataType inData)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dequeue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Front</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">QueueSize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BuildHeap</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inArray)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> queueSize;</span><br><span class=\"line\">\tDataType *queuePtr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，数据成员主要有二叉堆容量，二叉堆大小以及二叉堆实际元素指针，采用动态分配的方式，以下依次实现各函数（最小堆）。</p>\n<ul>\n<li>构造函数，初始化空间并设置数据成员初始值</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">PriorityQueue&lt;DataType&gt;::PriorityQueue(<span class=\"keyword\">int</span> inSize):capacity(inSize), queueSize(<span class=\"number\">0</span>),queuePtr(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueuePtr = <span class=\"keyword\">new</span> DataType[inSize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>入队函数，采用上滤策略调整二叉堆，如果堆已满则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> PriorityQueue&lt;DataType&gt;::Enqueue(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &gt;= capacity) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Priority queue is full!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = queueSize;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; inData &lt; queuePtr[(i<span class=\"number\">-1</span>)/<span class=\"number\">2</span>]) &#123;</span><br><span class=\"line\">\t\tqueuePtr[i] = queuePtr[(i<span class=\"number\">-1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\ti= (i<span class=\"number\">-1</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tqueuePtr[i] = inData; ++queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出队函数，采用下滤策略调整二叉堆</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> PriorityQueue&lt;DataType&gt;::Dequeue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Priority queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tDataType lastElement =  queuePtr[queueSize<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; <span class=\"number\">2</span>*i+<span class=\"number\">1</span> &lt; queueSize;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> minChild = <span class=\"number\">2</span>*i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (minChild+<span class=\"number\">1</span> &lt; queueSize &amp;&amp; queuePtr[minChild] &gt; queuePtr[minChild+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\tminChild += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lastElement &gt; queuePtr[minChild]) &#123;</span><br><span class=\"line\">\t\t\tqueuePtr[i] = queuePtr[minChild];</span><br><span class=\"line\">\t\t\ti = minChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tqueuePtr[i] = lastElement; --queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看队首元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType PriorityQueue&lt;DataType&gt;::Front()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Priority queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queuePtr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> PriorityQueue&lt;DataType&gt;::isEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空优先队列</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> PriorityQueue&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueueSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回优先队列大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> PriorityQueue&lt;DataType&gt;::QueueSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>建堆，可以直接循环调用Enqueue函数（时间复杂度O(N)），本文采用另外一种方法，算法思路如下：</p>\n<p>  二叉堆的左右子树也是一个二叉堆，因此从最后一个非叶节点开始，调整该子树成为二叉堆，依次往前推进，循环调整直到根节点即完成二叉堆的构建。</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> PriorityQueue&lt;DataType&gt;::BuildHeap(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inArray)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inArray.size() &gt; capacity) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Out of space!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tqueueSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tqueuePtr[queueSize++] = inArray.at(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (queueSize<span class=\"number\">-1</span>)/<span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmpElement = queuePtr[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> j = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">2</span>*j+<span class=\"number\">1</span> &lt; queueSize) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> miniChild = <span class=\"number\">2</span>*j+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (miniChild+<span class=\"number\">1</span> &lt; queueSize &amp;&amp; queuePtr[miniChild] &gt; queuePtr[miniChild+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\tminiChild += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmpElement &gt; queuePtr[miniChild]) &#123;</span><br><span class=\"line\">\t\t\t\tqueuePtr[j] = queuePtr[miniChild];</span><br><span class=\"line\">\t\t\t\tj = miniChild;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tqueuePtr[j] = tmpElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，释放内存</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">PriorityQueue&lt;DataType&gt;::~PriorityQueue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] queuePtr; </span><br><span class=\"line\">\tqueuePtr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二叉堆除了上述操作以外，还可以有降低某位置关键字的值，增加某位置关键字的值以及删除某个位置的关键字，各操作的基本思路如下：</p>\n<ul>\n<li>降低某位置关键字值：采用上滤（最小堆）策略调整二叉堆使其保持堆序性</li>\n<li>增加某位置关键字的值：采用下滤策略（最小堆）策略调整二叉堆使其保持堆序性</li>\n<li>删除某个位置的关键字：将该位置值设为比最小值还小（最小堆），然后上滤并调用出队函数即可</li>\n<li>合并：调用插入函数依次插入</li>\n</ul>\n<h2 id=\"二叉堆的相关定理\"><a href=\"#二叉堆的相关定理\" class=\"headerlink\" title=\"二叉堆的相关定理\"></a>二叉堆的相关定理</h2><ul>\n<li>包含2<sup>h+1</sup>个节点高为h的理想二叉树的节点的高度的和为2<sup>h+1</sup>-1-(h+1)</li>\n</ul>\n<p>证明：根据二叉树的定义，在高为h的层上总共有1个节点，高为h-1的曾是上有1*2个节点，即每层节点个数是上一层的两倍，故高为h-i层节点数量为2<sup>i</sup>个。则所有节点高的和为∑<sub>i=0~h</sub>2<sup>i</sup>*(h-i)。求解该式便可得出上述结论。将h=logN代入便可得出建堆的时间复杂度为O(N)</p>\n<h2 id=\"二叉堆扩展-d堆\"><a href=\"#二叉堆扩展-d堆\" class=\"headerlink\" title=\"二叉堆扩展-d堆\"></a>二叉堆扩展-d堆</h2><p>d堆是二叉堆的简单推广，其节点有d个子节点，因此二叉堆是d=2的情况。d堆由于子节点数多，其高度比较浅，插入操作时间复杂度为O(log<sub>d</sub>N)，删除时间复杂度为dO(log<sub>d</sub>N)。下图为一个3-堆。<a href=\"http://mingnote.com/d-heap-algorithm-in-c.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/d-heap.png\" alt=\"3堆\"></p>\n"},{"title":"二叉树的非递归前、中、后、层序遍历的不同实现","urlname":"binary-tree-traversal-non-recursive","date":"2018-06-04T09:56:39.000Z","mathjax":true,"copyright":true,"_content":"\n## 前言\n\n由于二叉树是一种递归定义的数据结构，采用递归的方式去遍历是一种非常简洁方便的做法，但是如果要求使用非递归的方式去遍历整棵二叉树则必须使用辅助的空间。以下分别实现二叉树的前序、中序、后序以及层序的遍历算法。约定二叉树的基本结构如下：\n\n```cpp\ntemplate <typename DataType>\nstruct TreeNode\n{\n\tDataType data; //存储的数据\n\tTreeNode *left; /*指向左子树根节点*/\n\tTreeNode *right; /*指向右子树根节点*/\n\tTreeNode(DataType inData): data(inData), right(nullptr), left(nullptr) {}\n};\n```\n## 前序非递归遍历\n\n前序遍历的顺序为根->左->右，因此在使用辅助栈时，结合栈的先进后出特性，为了让左子树能在右子树之前弹出，我们可以先把右子节点先压入栈中，然后就可以保证左子节点先弹出，实现代码如下所示：\n\n```cpp\n#include <stack>\nusing std::stack;\n\ntemplate <typename DataType>\nvector<DataType> PreorderTraverse(TreeNode<DataType> *root)\n{\n        vector<DataType> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        stack<TreeNode<DataType> *> nodeStack;\n        nodeStack.push(root);\n        while (!nodeStack.empty()) {\n                /*弹出根节点并访问之*/\n                TreeNode<DataType> *tmp = nodeStack.top();\n                result.push_back(tmp->data);\n                nodeStack.pop();\n\n                /*先压右子节点再压左子节点*/\n                if (tmp->right != nullptr) {\n                        nodeStack.push(tmp->right);\n                }\n                if (tmp->left != nullptr) {\n                        nodeStack.push(tmp->left);\n                }\n        }\n        return result;\n}\n```\n\n## 中序非递归遍历\n\n中序遍历的顺序为左->根->右，因此在左子树被访问前根才能被访问，因此需要一直压栈最左，然后弹栈压入栈顶的右子节点，代码实现如下：\n\n```cpp\n#include <stack>\nusing std::stack;\n\ntemplate <typename DataType>\nvector<DataType> InorderTraverse(TreeNode<DataType> *root)\n{\n        vector<DataType> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        stack<TreeNode<DataType> *> nodeStack;\n        TreeNode<DataType> *cycleIter = root;\n        while (cycleIter != nullptr || !nodeStack.empty()) {\n                /*一直压左子节点*/\n                if (cycleIter != nullptr) {\n                        nodeStack.push(cycleIter);\n                        cycleIter = cycleIter->left;\n                }\n                else {\n                        /*压到最左了*/\n                        result.push_back(nodeStack.top()->data);\n                        cycleIter = nodeStack.top()->right;\n                        nodeStack.pop();\n                }\n        }\n        return result;\n}\n```\n\n## 后序非递归遍历\n\n后序遍历的顺序为左->右->根，由于根是最后访问，我们可以考虑前序遍历的思路，最后镜像结果即可。后序遍历的镜像访问顺序为根->右->左，和前序遍历的顺序只是访问左右的结果不同，因此可以将前序代码稍作调整即可用于后序遍历，代码如下：\n\n```cpp\n#include <stack>\n#include <algorithm>\nusing std::stack;\n\ntemplate <typename DataType>\nvector<DataType> PostorderTraverse(TreeNode<DataType> *root)\n{\n        vector<DataType> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        stack<TreeNode<DataType> *> nodeStack;\n        nodeStack.push(root);\n        while (!nodeStack.empty()) {\n                /*弹出根节点并访问之*/\n                TreeNode<DataType> *tmp = nodeStack.top();\n                result.push_back(tmp->data);\n                nodeStack.pop();\n\n                /*和前序相反*/\n                if (tmp->left != nullptr) {\n                        nodeStack.push(tmp->left);\n                }\n                if (tmp->right != nullptr) {\n                        nodeStack.push(tmp->right);\n                }\n        }\n        reverse(result.begin(), result.end());\n        return result;\n}\n```\n\n## 层序遍历\n\n层序遍历类似于广度优先搜索(BFS)，此时一般使用队列来辅助存储，其思路可以借鉴前序遍历思路，只是弹出(出队)顺序略有不同，只需对前序代码稍作修改即可，具体代码见下：\n\n```cpp\n#include <queue>\nusing std::queue;\n\ntemplate <typename DataType>\nvector<DataType> BFSTraverse(TreeNode<DataType> *root)\n{\n        vector<DataType> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        queue<TreeNode<DataType> *> nodeQueue;\n        nodeQueue.push(root);\n        while (!nodeQueue.empty()) {\n                /*弹出根节点并访问之*/\n                TreeNode<DataType> *tmp = nodeQueue.front();\n                result.push_back(tmp->data);\n                nodeQueue.pop();\n\n                /*先压左子节点再压右子节点*/\n                if (tmp->left != nullptr) {\n                        nodeQueue.push(tmp->left);\n                }\n                if (tmp->right != nullptr) {\n                        nodeQueue.push(tmp->right);\n                }\n\n        }\n        return result;\n}\n```\n\n如果要考虑分层输出的问题，则需要增加几个标识变量用来标识某一层的结束。由于已知第一层只有一个根节点，通过这个已知条件就可以推算下一层结束节点，换句话来说是一层最后的一个节点的右子节点是下一层的最后一个节点。将上述层序代码稍作变形就可以得到支持分层的代码：\n\n```cpp\n#include <queue>\nusing std::queue;\n\ntemplate <typename DataType>\nvector<vector<DataType>> BFSTraverseWithLevel(TreeNode<DataType> *root)\n{\n        vector<vector<DataType>> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        queue<TreeNode<DataType> *> nodeQueue;\n        TreeNode<DataType> *lastNode = root;\n        TreeNode<DataType> *nextLevelLastNode = nullptr;\n        nodeQueue.push(root);\n        vector<DataType> oneLevelData;\n        while (!nodeQueue.empty()) {\n                /*弹出根节点并访问之*/\n                TreeNode<DataType> *tmp = nodeQueue.front();\n                oneLevelData.push_back(tmp->data);\n                nodeQueue.pop();\n\n                /*先压左子节点再压右子节点*/\n                if (tmp->left != nullptr) {\n                        nodeQueue.push(tmp->left);\n                        nextLevelLastNode = tmp->left;\n                }\n                if (tmp->right != nullptr) {\n                        nodeQueue.push(tmp->right);\n                        nextLevelLastNode = tmp->right;\n                }\n                if (tmp == lastNode) {\n                        result.push_back(oneLevelData);\n                        oneLevelData.clear();\n                        lastNode = nextLevelLastNode;\n                }\n\n        }\n        return result;\n}\n```\n\n## 代码测试\n\n手动做出如下图的一棵二叉树：[图片来源](http://www.jzsyz.jzedu.cn/xxjs/datastructure/basic/binary_tree/chapter5_1.htm)\n![二叉树测试案例](/images/binary-tree-test.png)\n\n测试代码如下所示：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tTreeNode<char> testNode[17] = {'A', 'B', 'C', 'D', 'E',\n                                       'F', 'G', 'H', 'I', 'J',\n                                       'K', 'L', 'M', 'N', 'O',\n                                       'P', 'Q'};\n\n\ttestNode[0].left = &testNode[1];\n\ttestNode[0].right = &testNode[2];\n\n\ttestNode[1].left = &testNode[3];\n\ttestNode[1].right = &testNode[4];\n\n        testNode[2].left = &testNode[5];\n\ttestNode[2].right = &testNode[6];\n\n        testNode[3].left = &testNode[7];\n\ttestNode[3].right = &testNode[8];\n\n\ttestNode[4].left = &testNode[9];\n\ttestNode[4].right = &testNode[10];\n\n        testNode[5].left = &testNode[11];\n\ttestNode[5].right = &testNode[12];\n\n        testNode[6].left = &testNode[13];\n\ttestNode[6].right = &testNode[14];\n\n        testNode[7].left = &testNode[15];\n\ttestNode[7].right = &testNode[16];\n\n\n\n        cout << \"---------------前序--------------\" << endl;\n\n        auto startTime = system_clock::now();\n\n\tvector<char> result1 = PreorderTraverse(testNode);\n\n        auto endTime = system_clock::now();\n\n        for (size_t i = 0; i < result1.size(); i++) {\n                cout << result1[i] << \";\";\n        }\n        cout << endl;\n\n        auto duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n        cout << \"---------------中序--------------\" << endl;\n\n        startTime = system_clock::now();\n\n\tvector<char> result2 = InorderTraverse(testNode);\n\n        endTime = system_clock::now();\n\n        for (size_t i = 0; i < result2.size(); i++) {\n                cout << result2[i] << \";\";\n        }\n        cout << endl;\n\n        duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n        cout << \"---------------后序--------------\" << endl;\n\n        startTime = system_clock::now();\n\n\tvector<char> result3 = PostorderTraverse(testNode);\n\n        endTime = system_clock::now();\n\n        for (size_t i = 0; i < result3.size(); i++) {\n                cout << result3[i] << \";\";\n        }\n        cout << endl;\n\n        duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n        cout << \"---------------层序--------------\" << endl;\n\n        startTime = system_clock::now();\n\n\tvector<char> result4 = BFSTraverse(testNode);\n\n        endTime = system_clock::now();\n\n        for (size_t i = 0; i < result4.size(); i++) {\n                cout << result4[i] << \";\";\n        }\n        cout << endl;\n\n        duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n        cout << \"---------------层序（分层）--------------\" << endl;\n\n        startTime = system_clock::now();\n\n\tvector<vector<char>> result5 = BFSTraverseWithLevel(testNode);\n\n        endTime = system_clock::now();\n\n        for (size_t i = 0; i < result5.size(); i++) {\n                for (size_t j = 0; j < result5[i].size(); j++) {\n                        cout << result5[i][j] << \";\";\n                }\n                cout << endl;\n        }\n\n        duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n\treturn 0;\n}\n```\n\n## 参考文章\n\n[二叉树遍历之非递归算法](https://blog.csdn.net/sgbfblog/article/details/7773103)\n\n[更简单的非递归遍历二叉树的方法](https://www.jianshu.com/p/49c8cfd07410)\n\n[广度优先搜索](https://zh.wikipedia.org/zh/广度优先搜索)\n","source":"_posts/数据结构/二叉树非递归前_中_后_层序遍历的不同实现.md","raw":"---\ntitle: 二叉树的非递归前、中、后、层序遍历的不同实现\nurlname: binary-tree-traversal-non-recursive\ndate: 2018-06-04 17:56:39\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 前言\n\n由于二叉树是一种递归定义的数据结构，采用递归的方式去遍历是一种非常简洁方便的做法，但是如果要求使用非递归的方式去遍历整棵二叉树则必须使用辅助的空间。以下分别实现二叉树的前序、中序、后序以及层序的遍历算法。约定二叉树的基本结构如下：\n\n```cpp\ntemplate <typename DataType>\nstruct TreeNode\n{\n\tDataType data; //存储的数据\n\tTreeNode *left; /*指向左子树根节点*/\n\tTreeNode *right; /*指向右子树根节点*/\n\tTreeNode(DataType inData): data(inData), right(nullptr), left(nullptr) {}\n};\n```\n## 前序非递归遍历\n\n前序遍历的顺序为根->左->右，因此在使用辅助栈时，结合栈的先进后出特性，为了让左子树能在右子树之前弹出，我们可以先把右子节点先压入栈中，然后就可以保证左子节点先弹出，实现代码如下所示：\n\n```cpp\n#include <stack>\nusing std::stack;\n\ntemplate <typename DataType>\nvector<DataType> PreorderTraverse(TreeNode<DataType> *root)\n{\n        vector<DataType> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        stack<TreeNode<DataType> *> nodeStack;\n        nodeStack.push(root);\n        while (!nodeStack.empty()) {\n                /*弹出根节点并访问之*/\n                TreeNode<DataType> *tmp = nodeStack.top();\n                result.push_back(tmp->data);\n                nodeStack.pop();\n\n                /*先压右子节点再压左子节点*/\n                if (tmp->right != nullptr) {\n                        nodeStack.push(tmp->right);\n                }\n                if (tmp->left != nullptr) {\n                        nodeStack.push(tmp->left);\n                }\n        }\n        return result;\n}\n```\n\n## 中序非递归遍历\n\n中序遍历的顺序为左->根->右，因此在左子树被访问前根才能被访问，因此需要一直压栈最左，然后弹栈压入栈顶的右子节点，代码实现如下：\n\n```cpp\n#include <stack>\nusing std::stack;\n\ntemplate <typename DataType>\nvector<DataType> InorderTraverse(TreeNode<DataType> *root)\n{\n        vector<DataType> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        stack<TreeNode<DataType> *> nodeStack;\n        TreeNode<DataType> *cycleIter = root;\n        while (cycleIter != nullptr || !nodeStack.empty()) {\n                /*一直压左子节点*/\n                if (cycleIter != nullptr) {\n                        nodeStack.push(cycleIter);\n                        cycleIter = cycleIter->left;\n                }\n                else {\n                        /*压到最左了*/\n                        result.push_back(nodeStack.top()->data);\n                        cycleIter = nodeStack.top()->right;\n                        nodeStack.pop();\n                }\n        }\n        return result;\n}\n```\n\n## 后序非递归遍历\n\n后序遍历的顺序为左->右->根，由于根是最后访问，我们可以考虑前序遍历的思路，最后镜像结果即可。后序遍历的镜像访问顺序为根->右->左，和前序遍历的顺序只是访问左右的结果不同，因此可以将前序代码稍作调整即可用于后序遍历，代码如下：\n\n```cpp\n#include <stack>\n#include <algorithm>\nusing std::stack;\n\ntemplate <typename DataType>\nvector<DataType> PostorderTraverse(TreeNode<DataType> *root)\n{\n        vector<DataType> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        stack<TreeNode<DataType> *> nodeStack;\n        nodeStack.push(root);\n        while (!nodeStack.empty()) {\n                /*弹出根节点并访问之*/\n                TreeNode<DataType> *tmp = nodeStack.top();\n                result.push_back(tmp->data);\n                nodeStack.pop();\n\n                /*和前序相反*/\n                if (tmp->left != nullptr) {\n                        nodeStack.push(tmp->left);\n                }\n                if (tmp->right != nullptr) {\n                        nodeStack.push(tmp->right);\n                }\n        }\n        reverse(result.begin(), result.end());\n        return result;\n}\n```\n\n## 层序遍历\n\n层序遍历类似于广度优先搜索(BFS)，此时一般使用队列来辅助存储，其思路可以借鉴前序遍历思路，只是弹出(出队)顺序略有不同，只需对前序代码稍作修改即可，具体代码见下：\n\n```cpp\n#include <queue>\nusing std::queue;\n\ntemplate <typename DataType>\nvector<DataType> BFSTraverse(TreeNode<DataType> *root)\n{\n        vector<DataType> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        queue<TreeNode<DataType> *> nodeQueue;\n        nodeQueue.push(root);\n        while (!nodeQueue.empty()) {\n                /*弹出根节点并访问之*/\n                TreeNode<DataType> *tmp = nodeQueue.front();\n                result.push_back(tmp->data);\n                nodeQueue.pop();\n\n                /*先压左子节点再压右子节点*/\n                if (tmp->left != nullptr) {\n                        nodeQueue.push(tmp->left);\n                }\n                if (tmp->right != nullptr) {\n                        nodeQueue.push(tmp->right);\n                }\n\n        }\n        return result;\n}\n```\n\n如果要考虑分层输出的问题，则需要增加几个标识变量用来标识某一层的结束。由于已知第一层只有一个根节点，通过这个已知条件就可以推算下一层结束节点，换句话来说是一层最后的一个节点的右子节点是下一层的最后一个节点。将上述层序代码稍作变形就可以得到支持分层的代码：\n\n```cpp\n#include <queue>\nusing std::queue;\n\ntemplate <typename DataType>\nvector<vector<DataType>> BFSTraverseWithLevel(TreeNode<DataType> *root)\n{\n        vector<vector<DataType>> result;\n        if (root == nullptr) {\n                return result;\n        }\n\n        queue<TreeNode<DataType> *> nodeQueue;\n        TreeNode<DataType> *lastNode = root;\n        TreeNode<DataType> *nextLevelLastNode = nullptr;\n        nodeQueue.push(root);\n        vector<DataType> oneLevelData;\n        while (!nodeQueue.empty()) {\n                /*弹出根节点并访问之*/\n                TreeNode<DataType> *tmp = nodeQueue.front();\n                oneLevelData.push_back(tmp->data);\n                nodeQueue.pop();\n\n                /*先压左子节点再压右子节点*/\n                if (tmp->left != nullptr) {\n                        nodeQueue.push(tmp->left);\n                        nextLevelLastNode = tmp->left;\n                }\n                if (tmp->right != nullptr) {\n                        nodeQueue.push(tmp->right);\n                        nextLevelLastNode = tmp->right;\n                }\n                if (tmp == lastNode) {\n                        result.push_back(oneLevelData);\n                        oneLevelData.clear();\n                        lastNode = nextLevelLastNode;\n                }\n\n        }\n        return result;\n}\n```\n\n## 代码测试\n\n手动做出如下图的一棵二叉树：[图片来源](http://www.jzsyz.jzedu.cn/xxjs/datastructure/basic/binary_tree/chapter5_1.htm)\n![二叉树测试案例](/images/binary-tree-test.png)\n\n测试代码如下所示：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tTreeNode<char> testNode[17] = {'A', 'B', 'C', 'D', 'E',\n                                       'F', 'G', 'H', 'I', 'J',\n                                       'K', 'L', 'M', 'N', 'O',\n                                       'P', 'Q'};\n\n\ttestNode[0].left = &testNode[1];\n\ttestNode[0].right = &testNode[2];\n\n\ttestNode[1].left = &testNode[3];\n\ttestNode[1].right = &testNode[4];\n\n        testNode[2].left = &testNode[5];\n\ttestNode[2].right = &testNode[6];\n\n        testNode[3].left = &testNode[7];\n\ttestNode[3].right = &testNode[8];\n\n\ttestNode[4].left = &testNode[9];\n\ttestNode[4].right = &testNode[10];\n\n        testNode[5].left = &testNode[11];\n\ttestNode[5].right = &testNode[12];\n\n        testNode[6].left = &testNode[13];\n\ttestNode[6].right = &testNode[14];\n\n        testNode[7].left = &testNode[15];\n\ttestNode[7].right = &testNode[16];\n\n\n\n        cout << \"---------------前序--------------\" << endl;\n\n        auto startTime = system_clock::now();\n\n\tvector<char> result1 = PreorderTraverse(testNode);\n\n        auto endTime = system_clock::now();\n\n        for (size_t i = 0; i < result1.size(); i++) {\n                cout << result1[i] << \";\";\n        }\n        cout << endl;\n\n        auto duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n        cout << \"---------------中序--------------\" << endl;\n\n        startTime = system_clock::now();\n\n\tvector<char> result2 = InorderTraverse(testNode);\n\n        endTime = system_clock::now();\n\n        for (size_t i = 0; i < result2.size(); i++) {\n                cout << result2[i] << \";\";\n        }\n        cout << endl;\n\n        duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n        cout << \"---------------后序--------------\" << endl;\n\n        startTime = system_clock::now();\n\n\tvector<char> result3 = PostorderTraverse(testNode);\n\n        endTime = system_clock::now();\n\n        for (size_t i = 0; i < result3.size(); i++) {\n                cout << result3[i] << \";\";\n        }\n        cout << endl;\n\n        duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n        cout << \"---------------层序--------------\" << endl;\n\n        startTime = system_clock::now();\n\n\tvector<char> result4 = BFSTraverse(testNode);\n\n        endTime = system_clock::now();\n\n        for (size_t i = 0; i < result4.size(); i++) {\n                cout << result4[i] << \";\";\n        }\n        cout << endl;\n\n        duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n        cout << \"---------------层序（分层）--------------\" << endl;\n\n        startTime = system_clock::now();\n\n\tvector<vector<char>> result5 = BFSTraverseWithLevel(testNode);\n\n        endTime = system_clock::now();\n\n        for (size_t i = 0; i < result5.size(); i++) {\n                for (size_t j = 0; j < result5[i].size(); j++) {\n                        cout << result5[i][j] << \";\";\n                }\n                cout << endl;\n        }\n\n        duration = duration_cast<microseconds>(endTime - startTime);\n\tcout << \"TimeCost:\" << duration.count() << endl;\n\n\treturn 0;\n}\n```\n\n## 参考文章\n\n[二叉树遍历之非递归算法](https://blog.csdn.net/sgbfblog/article/details/7773103)\n\n[更简单的非递归遍历二叉树的方法](https://www.jianshu.com/p/49c8cfd07410)\n\n[广度优先搜索](https://zh.wikipedia.org/zh/广度优先搜索)\n","slug":"数据结构/二叉树非递归前_中_后_层序遍历的不同实现","published":1,"updated":"2018-06-13T14:05:42.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3c000qgsvn5dfewo0r","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于二叉树是一种递归定义的数据结构，采用递归的方式去遍历是一种非常简洁方便的做法，但是如果要求使用非递归的方式去遍历整棵二叉树则必须使用辅助的空间。以下分别实现二叉树的前序、中序、后序以及层序的遍历算法。约定二叉树的基本结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//存储的数据</span></span><br><span class=\"line\">\tTreeNode *left; <span class=\"comment\">/*指向左子树根节点*/</span></span><br><span class=\"line\">\tTreeNode *right; <span class=\"comment\">/*指向右子树根节点*/</span></span><br><span class=\"line\">\tTreeNode(DataType inData): data(inData), right(<span class=\"literal\">nullptr</span>), left(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前序非递归遍历\"><a href=\"#前序非递归遍历\" class=\"headerlink\" title=\"前序非递归遍历\"></a>前序非递归遍历</h2><p>前序遍历的顺序为根-&gt;左-&gt;右，因此在使用辅助栈时，结合栈的先进后出特性，为了让左子树能在右子树之前弹出，我们可以先把右子节点先压入栈中，然后就可以保证左子节点先弹出，实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;DataType&gt; PreorderTraverse(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">        nodeStack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*弹出根节点并访问之*/</span></span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">                result.push_back(tmp-&gt;data);</span><br><span class=\"line\">                nodeStack.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*先压右子节点再压左子节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(tmp-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(tmp-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中序非递归遍历\"><a href=\"#中序非递归遍历\" class=\"headerlink\" title=\"中序非递归遍历\"></a>中序非递归遍历</h2><p>中序遍历的顺序为左-&gt;根-&gt;右，因此在左子树被访问前根才能被访问，因此需要一直压栈最左，然后弹栈压入栈顶的右子节点，代码实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;DataType&gt; InorderTraverse(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*一直压左子节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(cycleIter);</span><br><span class=\"line\">                        cycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*压到最左了*/</span></span><br><span class=\"line\">                        result.push_back(nodeStack.top()-&gt;data);</span><br><span class=\"line\">                        cycleIter = nodeStack.top()-&gt;right;</span><br><span class=\"line\">                        nodeStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后序非递归遍历\"><a href=\"#后序非递归遍历\" class=\"headerlink\" title=\"后序非递归遍历\"></a>后序非递归遍历</h2><p>后序遍历的顺序为左-&gt;右-&gt;根，由于根是最后访问，我们可以考虑前序遍历的思路，最后镜像结果即可。后序遍历的镜像访问顺序为根-&gt;右-&gt;左，和前序遍历的顺序只是访问左右的结果不同，因此可以将前序代码稍作调整即可用于后序遍历，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;DataType&gt; PostorderTraverse(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">        nodeStack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*弹出根节点并访问之*/</span></span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">                result.push_back(tmp-&gt;data);</span><br><span class=\"line\">                nodeStack.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*和前序相反*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(tmp-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(tmp-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(result.begin(), result.end());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h2><p>层序遍历类似于广度优先搜索(BFS)，此时一般使用队列来辅助存储，其思路可以借鉴前序遍历思路，只是弹出(出队)顺序略有不同，只需对前序代码稍作修改即可，具体代码见下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;DataType&gt; BFSTraverse(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeQueue;</span><br><span class=\"line\">        nodeQueue.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*弹出根节点并访问之*/</span></span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *tmp = nodeQueue.front();</span><br><span class=\"line\">                result.push_back(tmp-&gt;data);</span><br><span class=\"line\">                nodeQueue.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*先压左子节点再压右子节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeQueue.push(tmp-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeQueue.push(tmp-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要考虑分层输出的问题，则需要增加几个标识变量用来标识某一层的结束。由于已知第一层只有一个根节点，通过这个已知条件就可以推算下一层结束节点，换句话来说是一层最后的一个节点的右子节点是下一层的最后一个节点。将上述层序代码稍作变形就可以得到支持分层的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; BFSTraverseWithLevel(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeQueue;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *lastNode = root;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *nextLevelLastNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        nodeQueue.push(root);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; oneLevelData;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*弹出根节点并访问之*/</span></span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *tmp = nodeQueue.front();</span><br><span class=\"line\">                oneLevelData.push_back(tmp-&gt;data);</span><br><span class=\"line\">                nodeQueue.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*先压左子节点再压右子节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeQueue.push(tmp-&gt;left);</span><br><span class=\"line\">                        nextLevelLastNode = tmp-&gt;left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeQueue.push(tmp-&gt;right);</span><br><span class=\"line\">                        nextLevelLastNode = tmp-&gt;right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp == lastNode) &#123;</span><br><span class=\"line\">                        result.push_back(oneLevelData);</span><br><span class=\"line\">                        oneLevelData.clear();</span><br><span class=\"line\">                        lastNode = nextLevelLastNode;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>手动做出如下图的一棵二叉树：<a href=\"http://www.jzsyz.jzedu.cn/xxjs/datastructure/basic/binary_tree/chapter5_1.htm\" target=\"_blank\" rel=\"noopener\">图片来源</a><br><img src=\"/images/binary-tree-test.png\" alt=\"二叉树测试案例\"></p>\n<p>测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tTreeNode&lt;<span class=\"keyword\">char</span>&gt; testNode[<span class=\"number\">17</span>] = &#123;<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>,</span><br><span class=\"line\">                                       <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>, <span class=\"string\">'I'</span>, <span class=\"string\">'J'</span>,</span><br><span class=\"line\">                                       <span class=\"string\">'K'</span>, <span class=\"string\">'L'</span>, <span class=\"string\">'M'</span>, <span class=\"string\">'N'</span>, <span class=\"string\">'O'</span>,</span><br><span class=\"line\">                                       <span class=\"string\">'P'</span>, <span class=\"string\">'Q'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">0</span>].left = &amp;testNode[<span class=\"number\">1</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">0</span>].right = &amp;testNode[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">1</span>].left = &amp;testNode[<span class=\"number\">3</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">1</span>].right = &amp;testNode[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">2</span>].left = &amp;testNode[<span class=\"number\">5</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">2</span>].right = &amp;testNode[<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">3</span>].left = &amp;testNode[<span class=\"number\">7</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">3</span>].right = &amp;testNode[<span class=\"number\">8</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">4</span>].left = &amp;testNode[<span class=\"number\">9</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">4</span>].right = &amp;testNode[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">5</span>].left = &amp;testNode[<span class=\"number\">11</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">5</span>].right = &amp;testNode[<span class=\"number\">12</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">6</span>].left = &amp;testNode[<span class=\"number\">13</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">6</span>].right = &amp;testNode[<span class=\"number\">14</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">7</span>].left = &amp;testNode[<span class=\"number\">15</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">7</span>].right = &amp;testNode[<span class=\"number\">16</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------前序--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; result1 = PreorderTraverse(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result1.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; result1[i] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------中序--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; result2 = InorderTraverse(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result2.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; result2[i] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------后序--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; result3 = PostorderTraverse(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result3.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; result3[i] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------层序--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; result4 = BFSTraverse(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result4.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; result4[i] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------层序（分层）--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt;&gt; result5 = BFSTraverseWithLevel(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result5.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; result5[i].size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; result5[i][j] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://blog.csdn.net/sgbfblog/article/details/7773103\" target=\"_blank\" rel=\"noopener\">二叉树遍历之非递归算法</a></p>\n<p><a href=\"https://www.jianshu.com/p/49c8cfd07410\" target=\"_blank\" rel=\"noopener\">更简单的非递归遍历二叉树的方法</a></p>\n<p><a href=\"https://zh.wikipedia.org/zh/广度优先搜索\" target=\"_blank\" rel=\"noopener\">广度优先搜索</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于二叉树是一种递归定义的数据结构，采用递归的方式去遍历是一种非常简洁方便的做法，但是如果要求使用非递归的方式去遍历整棵二叉树则必须使用辅助的空间。以下分别实现二叉树的前序、中序、后序以及层序的遍历算法。约定二叉树的基本结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//存储的数据</span></span><br><span class=\"line\">\tTreeNode *left; <span class=\"comment\">/*指向左子树根节点*/</span></span><br><span class=\"line\">\tTreeNode *right; <span class=\"comment\">/*指向右子树根节点*/</span></span><br><span class=\"line\">\tTreeNode(DataType inData): data(inData), right(<span class=\"literal\">nullptr</span>), left(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前序非递归遍历\"><a href=\"#前序非递归遍历\" class=\"headerlink\" title=\"前序非递归遍历\"></a>前序非递归遍历</h2><p>前序遍历的顺序为根-&gt;左-&gt;右，因此在使用辅助栈时，结合栈的先进后出特性，为了让左子树能在右子树之前弹出，我们可以先把右子节点先压入栈中，然后就可以保证左子节点先弹出，实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;DataType&gt; PreorderTraverse(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">        nodeStack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*弹出根节点并访问之*/</span></span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">                result.push_back(tmp-&gt;data);</span><br><span class=\"line\">                nodeStack.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*先压右子节点再压左子节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(tmp-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(tmp-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中序非递归遍历\"><a href=\"#中序非递归遍历\" class=\"headerlink\" title=\"中序非递归遍历\"></a>中序非递归遍历</h2><p>中序遍历的顺序为左-&gt;根-&gt;右，因此在左子树被访问前根才能被访问，因此需要一直压栈最左，然后弹栈压入栈顶的右子节点，代码实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;DataType&gt; InorderTraverse(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*一直压左子节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(cycleIter);</span><br><span class=\"line\">                        cycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*压到最左了*/</span></span><br><span class=\"line\">                        result.push_back(nodeStack.top()-&gt;data);</span><br><span class=\"line\">                        cycleIter = nodeStack.top()-&gt;right;</span><br><span class=\"line\">                        nodeStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后序非递归遍历\"><a href=\"#后序非递归遍历\" class=\"headerlink\" title=\"后序非递归遍历\"></a>后序非递归遍历</h2><p>后序遍历的顺序为左-&gt;右-&gt;根，由于根是最后访问，我们可以考虑前序遍历的思路，最后镜像结果即可。后序遍历的镜像访问顺序为根-&gt;右-&gt;左，和前序遍历的顺序只是访问左右的结果不同，因此可以将前序代码稍作调整即可用于后序遍历，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;DataType&gt; PostorderTraverse(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">        nodeStack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*弹出根节点并访问之*/</span></span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">                result.push_back(tmp-&gt;data);</span><br><span class=\"line\">                nodeStack.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*和前序相反*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(tmp-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeStack.push(tmp-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(result.begin(), result.end());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h2><p>层序遍历类似于广度优先搜索(BFS)，此时一般使用队列来辅助存储，其思路可以借鉴前序遍历思路，只是弹出(出队)顺序略有不同，只需对前序代码稍作修改即可，具体代码见下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;DataType&gt; BFSTraverse(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeQueue;</span><br><span class=\"line\">        nodeQueue.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*弹出根节点并访问之*/</span></span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *tmp = nodeQueue.front();</span><br><span class=\"line\">                result.push_back(tmp-&gt;data);</span><br><span class=\"line\">                nodeQueue.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*先压左子节点再压右子节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeQueue.push(tmp-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeQueue.push(tmp-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要考虑分层输出的问题，则需要增加几个标识变量用来标识某一层的结束。由于已知第一层只有一个根节点，通过这个已知条件就可以推算下一层结束节点，换句话来说是一层最后的一个节点的右子节点是下一层的最后一个节点。将上述层序代码稍作变形就可以得到支持分层的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; BFSTraverseWithLevel(TreeNode&lt;DataType&gt; *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeQueue;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *lastNode = root;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *nextLevelLastNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        nodeQueue.push(root);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; oneLevelData;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!nodeQueue.empty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*弹出根节点并访问之*/</span></span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *tmp = nodeQueue.front();</span><br><span class=\"line\">                oneLevelData.push_back(tmp-&gt;data);</span><br><span class=\"line\">                nodeQueue.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*先压左子节点再压右子节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeQueue.push(tmp-&gt;left);</span><br><span class=\"line\">                        nextLevelLastNode = tmp-&gt;left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        nodeQueue.push(tmp-&gt;right);</span><br><span class=\"line\">                        nextLevelLastNode = tmp-&gt;right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp == lastNode) &#123;</span><br><span class=\"line\">                        result.push_back(oneLevelData);</span><br><span class=\"line\">                        oneLevelData.clear();</span><br><span class=\"line\">                        lastNode = nextLevelLastNode;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>手动做出如下图的一棵二叉树：<a href=\"http://www.jzsyz.jzedu.cn/xxjs/datastructure/basic/binary_tree/chapter5_1.htm\" target=\"_blank\" rel=\"noopener\">图片来源</a><br><img src=\"/images/binary-tree-test.png\" alt=\"二叉树测试案例\"></p>\n<p>测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tTreeNode&lt;<span class=\"keyword\">char</span>&gt; testNode[<span class=\"number\">17</span>] = &#123;<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>,</span><br><span class=\"line\">                                       <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>, <span class=\"string\">'H'</span>, <span class=\"string\">'I'</span>, <span class=\"string\">'J'</span>,</span><br><span class=\"line\">                                       <span class=\"string\">'K'</span>, <span class=\"string\">'L'</span>, <span class=\"string\">'M'</span>, <span class=\"string\">'N'</span>, <span class=\"string\">'O'</span>,</span><br><span class=\"line\">                                       <span class=\"string\">'P'</span>, <span class=\"string\">'Q'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">0</span>].left = &amp;testNode[<span class=\"number\">1</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">0</span>].right = &amp;testNode[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">1</span>].left = &amp;testNode[<span class=\"number\">3</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">1</span>].right = &amp;testNode[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">2</span>].left = &amp;testNode[<span class=\"number\">5</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">2</span>].right = &amp;testNode[<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">3</span>].left = &amp;testNode[<span class=\"number\">7</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">3</span>].right = &amp;testNode[<span class=\"number\">8</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestNode[<span class=\"number\">4</span>].left = &amp;testNode[<span class=\"number\">9</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">4</span>].right = &amp;testNode[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">5</span>].left = &amp;testNode[<span class=\"number\">11</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">5</span>].right = &amp;testNode[<span class=\"number\">12</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">6</span>].left = &amp;testNode[<span class=\"number\">13</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">6</span>].right = &amp;testNode[<span class=\"number\">14</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        testNode[<span class=\"number\">7</span>].left = &amp;testNode[<span class=\"number\">15</span>];</span><br><span class=\"line\">\ttestNode[<span class=\"number\">7</span>].right = &amp;testNode[<span class=\"number\">16</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------前序--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; result1 = PreorderTraverse(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result1.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; result1[i] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------中序--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; result2 = InorderTraverse(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result2.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; result2[i] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------后序--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; result3 = PostorderTraverse(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result3.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; result3[i] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------层序--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; result4 = BFSTraverse(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result4.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; result4[i] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---------------层序（分层）--------------\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt;&gt; result5 = BFSTraverseWithLevel(testNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result5.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; result5[i].size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; result5[i][j] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://blog.csdn.net/sgbfblog/article/details/7773103\" target=\"_blank\" rel=\"noopener\">二叉树遍历之非递归算法</a></p>\n<p><a href=\"https://www.jianshu.com/p/49c8cfd07410\" target=\"_blank\" rel=\"noopener\">更简单的非递归遍历二叉树的方法</a></p>\n<p><a href=\"https://zh.wikipedia.org/zh/广度优先搜索\" target=\"_blank\" rel=\"noopener\">广度优先搜索</a></p>\n"},{"title":"散列表的定义与实现","urlname":"hash-table","date":"2018-03-09T01:45:11.000Z","mathjax":true,"copyright":true,"_content":"\n## 散列基础知识\n\n散列（hashing）是指散列表的实现，散列是一种用于以常数平均时间进行插入、删除、查找的的数据结构。但是散列表并不包含任何元素之间的排序信息，因此散列表不支持诸如查找最大元素、最小元素等需要排序的操作。散列表一般的实现中是采用一个固定大小的数组以及一个散列函数将关键字映射到数组的某一个位置，由于数组的大小是有限的而关键字数量却无限制，因此自然会发生多个关键字经过散列函数的映射到同一位置，此时就需要解决这种称为冲突的情况，因此可以认为散列是一种由散列函数和一系列冲突解决方案组成的抽像数据结构。\n\n散列表中有一个概念称为装填因子λ，其定义为散列表元素的个数除以散列表大小的比值。\n\n## 散列函数\n\n散列函数又称为哈希函数（Hash Function），散列函数具有如下性质：\n\n- 同一散列函数计算出的散列值不同，则原始输出必定不同，称为散列函数的确定性\n- 散列函数的输入输出不一定是唯一对应关系，如果两个输入散列值相同，两个输入可能不同，称为散列碰撞\n\n散列函数的选取将会极大影响散列的性能，如果散列函数选取失败，不能将大量的关键字均匀地进行分配，则会产生大量的冲突。使得散列性能下降。因此构建散列函数的目标就是均匀的分布在连续的内存空间中，常用的散列函数构造方法有如下几种：\n\n### 直接定址法\n\n即以关键字加上某个常数作为散列值，比如对于26个小写字母的散列函数可以直接是H(X) = X - 'a'，这种哈希函数计算简单，一般适用于关键字值连续的情况，否则将会浪费大量的空间。\n\n### 数字分析法\n\n对于关键字中存在一定规律且分布比较均匀的数字作为计算散列值的依据，数据分析方法比较适用于关键字基本已知的情况，比如对于学生学号为关键字的散列函数，由于学号中一般包含学生编号序列，因此在计算学号的散列值可以提取出这部分编号计算出散列值。\n\n### 除留余数法\n\n用关键字除以某个不大于哈希表容量大小的数（一般直接关键字%散列表大小），余数作为散列值，即H(x) = X mod SizeOfTable。这种方法计算简单，通常适用于关键字分布均匀的情况\n\n### 分段叠加法\n\n根据散列表地址情况将关键字分为几个大小相同的段（最后一个段大小可较短），然后将这几部分叠加，丢弃进位部分，余下的即为散列值，分段叠加可以分为折叠发和位移法两种，折叠法是将奇数段正序偶数段逆序相加，位移法是将分割后的每部分地位对齐后相加。\n\n### 平方取中法\n\n如果关键字的各个部分分布不够均匀，可以先求出关键字的平方值然后按需求取中间的几位作为散列值，由于平方值和关键字的每一位都有关系，因此平方值的随机性比较高。\n\n### 伪随机数法\n\n在计算机中计算随机数时，得到的数不能称为正真的随机数，因为其值是通过一个确定性的算法计算出来，因此如果计算伪随机数的开始值不变的话，计算出的随机数也保持相同，这就是伪随机数法的基础。伪随机数散列函数结构为H(X) = random(X)。\n\n\n\n## 散列冲突解决\n\n一个好的散列函数尽量避免冲突的产生，但是一旦冲突发生，必须给予消除，一下为几种常用的冲突解决方法：\n\n### 分离链接法（又称链地址法、拉链法）\n\n其基本思想是把散列到同一个散列值的所有元素保存到一个链表中。在执行删除、插入查找时，需要遍历该表已确定元素是否在链表中，然后执行下一步操作。\n\n分离链接法有如下优缺点：\n\n\t- 优点\n\t\t1. 处理简单，无堆积现象\n\t\t2. 链表元素是动态申请内存的，因此对于无法事前了解散列表长度的情况非常合适\n\t\t3. 该方法对装填因子没有很高的要求，甚至装填因子λ可以大于1\n\t\t4. 删除操方便\n\t- 缺点\n\t\t1. 指针占用内存空间，导致空间利用率下降\n\n### 开放定址法\n\n在分离链接法中，需要增加一个指针，同时可能需要分配新的单元，因此分离链接法的速度会受到申请内存开销的影响，而开放定址法则在发生冲突时尝试选择其他的单元直到找到一个空闲单元，在寻找空闲单元时，h<sub>i</sub>(X)=(Hash(X)+F(i)) mod SizeOfTable, i=0,1,2...依次被尝试，由于开放定址的特点，其不能进行标准的删除操作，只能采用惰性删除，否则可能将使查找操作失败，既元素已存在却返回不存在。开放定址法装填因子应该低于0.5。根据F(i)计算方式的不同开放定址法可分为：\n\n- 线性探测法：在该方法中，F(i)是i的线性函数，一般取F(i)=i，即出现冲突则依次探测下一个单元（可回绕）。在该冲突解决方法中，因为依次探测下一个，在散列表比较空的时候占据的单元会开始形成区块，称为一次聚集，导致散列到区块中的元素需要进行多次探测才能找到合适的空闲单元。使用线性探测方法预期的探测次数对于插入和不成功的查找为1/2\\*（1+(1/(1-λ)<sup>2</sup>))，对于成功的查找则为1/2\\*（1+(1/(1-λ))。线性探测法插入平均时间可用1/λ\\*ln(1/(1-λ))，计算方法为对1/(1-λ)从0~λ积分。\n\n- 平方探测：F(i)是i的二次函数，常用F(i)=i<sup>2</sup>，在使用平方探测时，如果表的大小是一个素数，当表至少有一半是空闲时，保证总能够插入一个新元素。如果表有比一半多一个的位置被填满，则插入操作可能失败。平方探测存在二次聚集的情况.\n\n- 双散列：双散列F(i)=i\\*hash<sub>2</sub>(X)。第二个散列函数值不能为0，否则原地死循环。另外尽量保证所有的单元都能被探测到。\n\n### 再散列法\n\n如果表的元素天的过满，则直接新建一个是原来约两倍的表，同时采用一个新的散列函数并把原始数据移入新表中，这既是再散列的含义。再散列可以用平方探测以多种方式实现，主要有以下做法：\n\n\t1. 表满一半就再散列\n\t2. 插入失败立刻再散列，这种方式比较极端\n\t3. 即途中策略，当表装填因子达到某一值再散列\n\n\n\n## 分离链接法的实现\n\n根据分离链接法的基本定义，该ADT可以包含以下操作：\n\n- 插入一个元素InsertElement\n- 删除一个元素DeleteElement\n- 查找一个元素Find\n- 清空所有元素MakeEmpty\n\n仿照《数据结构与算法分析-C语言描述》，有如下数据结构：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *next;\n\tNode(): next(nullptr) {}\n};\n\ntemplate <typename DataType>\nclass HashTable\n{\npublic:\n\tHashTable(int inTableSize);\n\t~HashTable();\n\tvoid InsertElement(DataType inKey);\n\tvoid DeleteElement(DataType inKey);\n\tDataType *Find(DataType inKey);\n\tvoid MakeEmpty();\nprivate:\n\tint Hash(DataType inKey); //具体的哈希函数，采用除余留法\n\tint tableSize; //哈希表大小\n\tNode<DataType> *tableArray; //哈希表指针\n};\n```\n\n如上所示，tableSize用来保存使用者指定的下一个素数，tableArray用来保存元素，采用哑节点的方式方便进行删除操作，以下为具体实现。\n\n- 构造函数\n\n```cpp\ntemplate <typename DataType>\nHashTable<DataType>::HashTable(int inTableSize): tableSize(inTableSize), tableArray(nullptr) \n{\n\ttableArray = new Node<DataType>[inTableSize];\n}\n```\n\n- 插入节点函数，采用头插法实现\n\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::InsertElement(DataType inKey)\n{\n\tint position = Hash(inKey);\n\tNode<DataType> *cycleIter = tableArray[position].next;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == inKey) {\n\t\t\treturn;\n\t\t}\n\t\tcycleIter = cycleIter->next;\n\t}\n\tNode<DataType> *newNode = new Node<DataType>;\n\tnewNode->next =  tableArray[position].next;\n\tnewNode->data = inKey;\n\ttableArray[position].next = newNode;\n}\n```\n\n- 删除一个元素\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::DeleteElement(DataType inKey)\n{\n\tint position = Hash(inKey);\n\tNode<DataType> *preCycleIter = &tableArray[position];\n\n\twhile (preCycleIter->next != nullptr && preCycleIter->next->data !=inKey) {\n\t\tpreCycleIter = preCycleIter->next;\n\t}\n\n\tif (preCycleIter->next == nullptr) {\n\t\treturn;\n\t}\n\n\tNode<DataType> * toBeDelete = preCycleIter->next;\n\tpreCycleIter->next = toBeDelete->next;\n\tdelete toBeDelete;\n}\n```\n\n- 找到节点，返回该节点在内存中的地址\n\n```cpp\ntemplate <typename DataType>\nDataType * HashTable<DataType>::Find(DataType inKey)\n{\n\tint position = Hash(inKey);\n\tNode<DataType> *cycleIter = tableArray[position].next;\n\n\twhile (cycleIter != nullptr && cycleIter->data !=inKey) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\n\treturn cycleIter == nullptr ? nullptr : &cycleIter->data;\n}\n```\n\n- 清空散列表中的链表\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::MakeEmpty()\n{\n\tfor (int i = 0; i < tableSize; i++) {\n\t\tif (tableArray[i].next != nullptr) {\n\t\t\tNode<DataType> *pre = &tableArray[i];\n\t\t\twhile (pre->next != nullptr) {\n\t\t\t\tNode<DataType> *tmp = pre->next;\n\t\t\t\tpre->next = tmp->next;\n\t\t\t\tdelete tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n```\n\n- 析构函数，清空散列表\n\n```cpp\ntemplate <typename DataType>\nHashTable<DataType>::~HashTable()\n{\n\tMakeEmpty();\n\tdelete [] tableArray;\n\ttableArray = nullptr;\n}\n```\n\n- 散列函数，简单起见，直接除余留法，假设键值为数值类型\n\n```cpp\ntemplate <typename DataType>\nint HashTable<DataType>::Hash(DataType inKey)\n{\n\treturn int(inKey)%tableSize;\n}\n```\n\n## 开放定址法平方探测的实现\n\n开放地址法与分离链接法最大的区别就是在没找到位置时需要继续探测直到找到空位，而且可能会出现插入失败的情况，而且删除只能采用惰性删除，因此需要在节点域中添加标记当前节点状态，主要有三种状态空闲、占用、已删除。仿照《数据结构与算法分析-C语言描述》，有如下数据结构：\n\n```cpp\nenum State\n{\n\tEMPTY,\n\tDELETED,\n\tOCCUPY\n};\n\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tState nodeState;\n\tNode(): nodeState(State::EMPTY) {}\n};\n\ntemplate <typename DataType>\nclass HashTable\n{\npublic:\n\tHashTable(int inTableSize);\n\t~HashTable();\n\tvoid InsertElement(DataType inKey);\n\tvoid DeleteElement(DataType inKey);\n\tDataType *Find(DataType inKey);\nprivate:\n\tint Hash(DataType inKey); //具体的哈希函数，采用除余留法\n\tint FindCore(DataType inKey); //查找核心函数，如果没找到返回插入位置\n\tint tableSize; //哈希表大小\n\tNode<DataType> *tableArray; //哈希表指针\n};\n```\n\n以上数据成员和分离链接法基本类似，以下为各函数实现：\n\n- 构造函数\n\n```cpp\ntemplate <typename DataType>\nHashTable<DataType>::HashTable(int inTableSize): tableSize(inTableSize), tableArray(nullptr) \n{\n\ttableArray = new Node<DataType>[inTableSize];\n}\n```\n\n- 插入节点函数，调用核心查找函数，如果找到则不做任何处理，否则插入返回位置（如果可以插入）\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::InsertElement(DataType inKey)\n{\n\tint position = FindCore(inKey);\n\tif (tableArray[position].nodeState != State::OCCUPY) {\n\t\ttableArray[position].nodeState = State::OCCUPY;\n\t\ttableArray[position].data = inKey;\n\t}\n}\n```\n\n- 删除一个元素\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::DeleteElement(DataType inKey)\n{\n\tint position = FindCore(inKey);\n\tif (tableArray[position].nodeState == State::OCCUPY) {\n\t\ttableArray[position].nodeState = State::DELETED;\n\t}\n}\n```\n\n- 找到节点核心函数，如果找到则返回下标，否则返回下一个可供插入的位置\n\n```cpp\ntemplate <typename DataType>\nint HashTable<DataType>::FindCore(DataType inKey)\n{\n\tint position = Hash(inKey);\n\tint i = 1;\n\twhile (tableArray[position].nodeState != State::EMPTY \n\t\t\t&& tableArray[position].data != inKey) {\n\t\tposition += 2*i-1; ++i; //采用书上公式\n\t\tposition = position >= tableSize ? position - tableSize : position;\n\t}\n\treturn position;\n}\n```\n\n- 找到节点，返回该节点在内存中的地址\n\n```cpp\ntemplate <typename DataType>\nDataType * HashTable<DataType>::Find(DataType inKey)\n{\n\tint position = FindCore(inKey);\n\tif (tableArray[position].nodeState == State::OCCUPY) {\n\t\treturn &tableArray[position].data;\n\t}\n\treturn nullptr;\n}\n```\n\n\n- 析构函数，清空散列表\n\n```cpp\ntemplate <typename DataType>\nHashTable<DataType>::~HashTable()\n{\n\tdelete [] tableArray;\n\ttableArray = nullptr;\n}\n```\n\n- 散列函数，简单起见，直接除余留法，假设键值为数值类型\n\n```cpp\ntemplate <typename DataType>\nint HashTable<DataType>::Hash(DataType inKey)\n{\n\treturn int(inKey)%tableSize;\n}\n```\n\n以上代码没有进行错误检测，如果核心查找函数失败的话可能会陷入死循环，因此可添加一个计数值，循环次数大于该值就停止寻找。\n\n\n\n","source":"_posts/数据结构/散列的定义与实现.md","raw":"---\ntitle: 散列表的定义与实现\nurlname: hash-table\ndate: 2018-03-9 9:45:11\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 散列基础知识\n\n散列（hashing）是指散列表的实现，散列是一种用于以常数平均时间进行插入、删除、查找的的数据结构。但是散列表并不包含任何元素之间的排序信息，因此散列表不支持诸如查找最大元素、最小元素等需要排序的操作。散列表一般的实现中是采用一个固定大小的数组以及一个散列函数将关键字映射到数组的某一个位置，由于数组的大小是有限的而关键字数量却无限制，因此自然会发生多个关键字经过散列函数的映射到同一位置，此时就需要解决这种称为冲突的情况，因此可以认为散列是一种由散列函数和一系列冲突解决方案组成的抽像数据结构。\n\n散列表中有一个概念称为装填因子λ，其定义为散列表元素的个数除以散列表大小的比值。\n\n## 散列函数\n\n散列函数又称为哈希函数（Hash Function），散列函数具有如下性质：\n\n- 同一散列函数计算出的散列值不同，则原始输出必定不同，称为散列函数的确定性\n- 散列函数的输入输出不一定是唯一对应关系，如果两个输入散列值相同，两个输入可能不同，称为散列碰撞\n\n散列函数的选取将会极大影响散列的性能，如果散列函数选取失败，不能将大量的关键字均匀地进行分配，则会产生大量的冲突。使得散列性能下降。因此构建散列函数的目标就是均匀的分布在连续的内存空间中，常用的散列函数构造方法有如下几种：\n\n### 直接定址法\n\n即以关键字加上某个常数作为散列值，比如对于26个小写字母的散列函数可以直接是H(X) = X - 'a'，这种哈希函数计算简单，一般适用于关键字值连续的情况，否则将会浪费大量的空间。\n\n### 数字分析法\n\n对于关键字中存在一定规律且分布比较均匀的数字作为计算散列值的依据，数据分析方法比较适用于关键字基本已知的情况，比如对于学生学号为关键字的散列函数，由于学号中一般包含学生编号序列，因此在计算学号的散列值可以提取出这部分编号计算出散列值。\n\n### 除留余数法\n\n用关键字除以某个不大于哈希表容量大小的数（一般直接关键字%散列表大小），余数作为散列值，即H(x) = X mod SizeOfTable。这种方法计算简单，通常适用于关键字分布均匀的情况\n\n### 分段叠加法\n\n根据散列表地址情况将关键字分为几个大小相同的段（最后一个段大小可较短），然后将这几部分叠加，丢弃进位部分，余下的即为散列值，分段叠加可以分为折叠发和位移法两种，折叠法是将奇数段正序偶数段逆序相加，位移法是将分割后的每部分地位对齐后相加。\n\n### 平方取中法\n\n如果关键字的各个部分分布不够均匀，可以先求出关键字的平方值然后按需求取中间的几位作为散列值，由于平方值和关键字的每一位都有关系，因此平方值的随机性比较高。\n\n### 伪随机数法\n\n在计算机中计算随机数时，得到的数不能称为正真的随机数，因为其值是通过一个确定性的算法计算出来，因此如果计算伪随机数的开始值不变的话，计算出的随机数也保持相同，这就是伪随机数法的基础。伪随机数散列函数结构为H(X) = random(X)。\n\n\n\n## 散列冲突解决\n\n一个好的散列函数尽量避免冲突的产生，但是一旦冲突发生，必须给予消除，一下为几种常用的冲突解决方法：\n\n### 分离链接法（又称链地址法、拉链法）\n\n其基本思想是把散列到同一个散列值的所有元素保存到一个链表中。在执行删除、插入查找时，需要遍历该表已确定元素是否在链表中，然后执行下一步操作。\n\n分离链接法有如下优缺点：\n\n\t- 优点\n\t\t1. 处理简单，无堆积现象\n\t\t2. 链表元素是动态申请内存的，因此对于无法事前了解散列表长度的情况非常合适\n\t\t3. 该方法对装填因子没有很高的要求，甚至装填因子λ可以大于1\n\t\t4. 删除操方便\n\t- 缺点\n\t\t1. 指针占用内存空间，导致空间利用率下降\n\n### 开放定址法\n\n在分离链接法中，需要增加一个指针，同时可能需要分配新的单元，因此分离链接法的速度会受到申请内存开销的影响，而开放定址法则在发生冲突时尝试选择其他的单元直到找到一个空闲单元，在寻找空闲单元时，h<sub>i</sub>(X)=(Hash(X)+F(i)) mod SizeOfTable, i=0,1,2...依次被尝试，由于开放定址的特点，其不能进行标准的删除操作，只能采用惰性删除，否则可能将使查找操作失败，既元素已存在却返回不存在。开放定址法装填因子应该低于0.5。根据F(i)计算方式的不同开放定址法可分为：\n\n- 线性探测法：在该方法中，F(i)是i的线性函数，一般取F(i)=i，即出现冲突则依次探测下一个单元（可回绕）。在该冲突解决方法中，因为依次探测下一个，在散列表比较空的时候占据的单元会开始形成区块，称为一次聚集，导致散列到区块中的元素需要进行多次探测才能找到合适的空闲单元。使用线性探测方法预期的探测次数对于插入和不成功的查找为1/2\\*（1+(1/(1-λ)<sup>2</sup>))，对于成功的查找则为1/2\\*（1+(1/(1-λ))。线性探测法插入平均时间可用1/λ\\*ln(1/(1-λ))，计算方法为对1/(1-λ)从0~λ积分。\n\n- 平方探测：F(i)是i的二次函数，常用F(i)=i<sup>2</sup>，在使用平方探测时，如果表的大小是一个素数，当表至少有一半是空闲时，保证总能够插入一个新元素。如果表有比一半多一个的位置被填满，则插入操作可能失败。平方探测存在二次聚集的情况.\n\n- 双散列：双散列F(i)=i\\*hash<sub>2</sub>(X)。第二个散列函数值不能为0，否则原地死循环。另外尽量保证所有的单元都能被探测到。\n\n### 再散列法\n\n如果表的元素天的过满，则直接新建一个是原来约两倍的表，同时采用一个新的散列函数并把原始数据移入新表中，这既是再散列的含义。再散列可以用平方探测以多种方式实现，主要有以下做法：\n\n\t1. 表满一半就再散列\n\t2. 插入失败立刻再散列，这种方式比较极端\n\t3. 即途中策略，当表装填因子达到某一值再散列\n\n\n\n## 分离链接法的实现\n\n根据分离链接法的基本定义，该ADT可以包含以下操作：\n\n- 插入一个元素InsertElement\n- 删除一个元素DeleteElement\n- 查找一个元素Find\n- 清空所有元素MakeEmpty\n\n仿照《数据结构与算法分析-C语言描述》，有如下数据结构：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *next;\n\tNode(): next(nullptr) {}\n};\n\ntemplate <typename DataType>\nclass HashTable\n{\npublic:\n\tHashTable(int inTableSize);\n\t~HashTable();\n\tvoid InsertElement(DataType inKey);\n\tvoid DeleteElement(DataType inKey);\n\tDataType *Find(DataType inKey);\n\tvoid MakeEmpty();\nprivate:\n\tint Hash(DataType inKey); //具体的哈希函数，采用除余留法\n\tint tableSize; //哈希表大小\n\tNode<DataType> *tableArray; //哈希表指针\n};\n```\n\n如上所示，tableSize用来保存使用者指定的下一个素数，tableArray用来保存元素，采用哑节点的方式方便进行删除操作，以下为具体实现。\n\n- 构造函数\n\n```cpp\ntemplate <typename DataType>\nHashTable<DataType>::HashTable(int inTableSize): tableSize(inTableSize), tableArray(nullptr) \n{\n\ttableArray = new Node<DataType>[inTableSize];\n}\n```\n\n- 插入节点函数，采用头插法实现\n\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::InsertElement(DataType inKey)\n{\n\tint position = Hash(inKey);\n\tNode<DataType> *cycleIter = tableArray[position].next;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == inKey) {\n\t\t\treturn;\n\t\t}\n\t\tcycleIter = cycleIter->next;\n\t}\n\tNode<DataType> *newNode = new Node<DataType>;\n\tnewNode->next =  tableArray[position].next;\n\tnewNode->data = inKey;\n\ttableArray[position].next = newNode;\n}\n```\n\n- 删除一个元素\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::DeleteElement(DataType inKey)\n{\n\tint position = Hash(inKey);\n\tNode<DataType> *preCycleIter = &tableArray[position];\n\n\twhile (preCycleIter->next != nullptr && preCycleIter->next->data !=inKey) {\n\t\tpreCycleIter = preCycleIter->next;\n\t}\n\n\tif (preCycleIter->next == nullptr) {\n\t\treturn;\n\t}\n\n\tNode<DataType> * toBeDelete = preCycleIter->next;\n\tpreCycleIter->next = toBeDelete->next;\n\tdelete toBeDelete;\n}\n```\n\n- 找到节点，返回该节点在内存中的地址\n\n```cpp\ntemplate <typename DataType>\nDataType * HashTable<DataType>::Find(DataType inKey)\n{\n\tint position = Hash(inKey);\n\tNode<DataType> *cycleIter = tableArray[position].next;\n\n\twhile (cycleIter != nullptr && cycleIter->data !=inKey) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\n\treturn cycleIter == nullptr ? nullptr : &cycleIter->data;\n}\n```\n\n- 清空散列表中的链表\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::MakeEmpty()\n{\n\tfor (int i = 0; i < tableSize; i++) {\n\t\tif (tableArray[i].next != nullptr) {\n\t\t\tNode<DataType> *pre = &tableArray[i];\n\t\t\twhile (pre->next != nullptr) {\n\t\t\t\tNode<DataType> *tmp = pre->next;\n\t\t\t\tpre->next = tmp->next;\n\t\t\t\tdelete tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n```\n\n- 析构函数，清空散列表\n\n```cpp\ntemplate <typename DataType>\nHashTable<DataType>::~HashTable()\n{\n\tMakeEmpty();\n\tdelete [] tableArray;\n\ttableArray = nullptr;\n}\n```\n\n- 散列函数，简单起见，直接除余留法，假设键值为数值类型\n\n```cpp\ntemplate <typename DataType>\nint HashTable<DataType>::Hash(DataType inKey)\n{\n\treturn int(inKey)%tableSize;\n}\n```\n\n## 开放定址法平方探测的实现\n\n开放地址法与分离链接法最大的区别就是在没找到位置时需要继续探测直到找到空位，而且可能会出现插入失败的情况，而且删除只能采用惰性删除，因此需要在节点域中添加标记当前节点状态，主要有三种状态空闲、占用、已删除。仿照《数据结构与算法分析-C语言描述》，有如下数据结构：\n\n```cpp\nenum State\n{\n\tEMPTY,\n\tDELETED,\n\tOCCUPY\n};\n\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tState nodeState;\n\tNode(): nodeState(State::EMPTY) {}\n};\n\ntemplate <typename DataType>\nclass HashTable\n{\npublic:\n\tHashTable(int inTableSize);\n\t~HashTable();\n\tvoid InsertElement(DataType inKey);\n\tvoid DeleteElement(DataType inKey);\n\tDataType *Find(DataType inKey);\nprivate:\n\tint Hash(DataType inKey); //具体的哈希函数，采用除余留法\n\tint FindCore(DataType inKey); //查找核心函数，如果没找到返回插入位置\n\tint tableSize; //哈希表大小\n\tNode<DataType> *tableArray; //哈希表指针\n};\n```\n\n以上数据成员和分离链接法基本类似，以下为各函数实现：\n\n- 构造函数\n\n```cpp\ntemplate <typename DataType>\nHashTable<DataType>::HashTable(int inTableSize): tableSize(inTableSize), tableArray(nullptr) \n{\n\ttableArray = new Node<DataType>[inTableSize];\n}\n```\n\n- 插入节点函数，调用核心查找函数，如果找到则不做任何处理，否则插入返回位置（如果可以插入）\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::InsertElement(DataType inKey)\n{\n\tint position = FindCore(inKey);\n\tif (tableArray[position].nodeState != State::OCCUPY) {\n\t\ttableArray[position].nodeState = State::OCCUPY;\n\t\ttableArray[position].data = inKey;\n\t}\n}\n```\n\n- 删除一个元素\n\n```cpp\ntemplate <typename DataType>\nvoid HashTable<DataType>::DeleteElement(DataType inKey)\n{\n\tint position = FindCore(inKey);\n\tif (tableArray[position].nodeState == State::OCCUPY) {\n\t\ttableArray[position].nodeState = State::DELETED;\n\t}\n}\n```\n\n- 找到节点核心函数，如果找到则返回下标，否则返回下一个可供插入的位置\n\n```cpp\ntemplate <typename DataType>\nint HashTable<DataType>::FindCore(DataType inKey)\n{\n\tint position = Hash(inKey);\n\tint i = 1;\n\twhile (tableArray[position].nodeState != State::EMPTY \n\t\t\t&& tableArray[position].data != inKey) {\n\t\tposition += 2*i-1; ++i; //采用书上公式\n\t\tposition = position >= tableSize ? position - tableSize : position;\n\t}\n\treturn position;\n}\n```\n\n- 找到节点，返回该节点在内存中的地址\n\n```cpp\ntemplate <typename DataType>\nDataType * HashTable<DataType>::Find(DataType inKey)\n{\n\tint position = FindCore(inKey);\n\tif (tableArray[position].nodeState == State::OCCUPY) {\n\t\treturn &tableArray[position].data;\n\t}\n\treturn nullptr;\n}\n```\n\n\n- 析构函数，清空散列表\n\n```cpp\ntemplate <typename DataType>\nHashTable<DataType>::~HashTable()\n{\n\tdelete [] tableArray;\n\ttableArray = nullptr;\n}\n```\n\n- 散列函数，简单起见，直接除余留法，假设键值为数值类型\n\n```cpp\ntemplate <typename DataType>\nint HashTable<DataType>::Hash(DataType inKey)\n{\n\treturn int(inKey)%tableSize;\n}\n```\n\n以上代码没有进行错误检测，如果核心查找函数失败的话可能会陷入死循环，因此可添加一个计数值，循环次数大于该值就停止寻找。\n\n\n\n","slug":"数据结构/散列的定义与实现","published":1,"updated":"2018-06-13T14:07:38.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3d000tgsvn9hkuoiu8","content":"<h2 id=\"散列基础知识\"><a href=\"#散列基础知识\" class=\"headerlink\" title=\"散列基础知识\"></a>散列基础知识</h2><p>散列（hashing）是指散列表的实现，散列是一种用于以常数平均时间进行插入、删除、查找的的数据结构。但是散列表并不包含任何元素之间的排序信息，因此散列表不支持诸如查找最大元素、最小元素等需要排序的操作。散列表一般的实现中是采用一个固定大小的数组以及一个散列函数将关键字映射到数组的某一个位置，由于数组的大小是有限的而关键字数量却无限制，因此自然会发生多个关键字经过散列函数的映射到同一位置，此时就需要解决这种称为冲突的情况，因此可以认为散列是一种由散列函数和一系列冲突解决方案组成的抽像数据结构。</p>\n<p>散列表中有一个概念称为装填因子λ，其定义为散列表元素的个数除以散列表大小的比值。</p>\n<h2 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h2><p>散列函数又称为哈希函数（Hash Function），散列函数具有如下性质：</p>\n<ul>\n<li>同一散列函数计算出的散列值不同，则原始输出必定不同，称为散列函数的确定性</li>\n<li>散列函数的输入输出不一定是唯一对应关系，如果两个输入散列值相同，两个输入可能不同，称为散列碰撞</li>\n</ul>\n<p>散列函数的选取将会极大影响散列的性能，如果散列函数选取失败，不能将大量的关键字均匀地进行分配，则会产生大量的冲突。使得散列性能下降。因此构建散列函数的目标就是均匀的分布在连续的内存空间中，常用的散列函数构造方法有如下几种：</p>\n<h3 id=\"直接定址法\"><a href=\"#直接定址法\" class=\"headerlink\" title=\"直接定址法\"></a>直接定址法</h3><p>即以关键字加上某个常数作为散列值，比如对于26个小写字母的散列函数可以直接是H(X) = X - ‘a’，这种哈希函数计算简单，一般适用于关键字值连续的情况，否则将会浪费大量的空间。</p>\n<h3 id=\"数字分析法\"><a href=\"#数字分析法\" class=\"headerlink\" title=\"数字分析法\"></a>数字分析法</h3><p>对于关键字中存在一定规律且分布比较均匀的数字作为计算散列值的依据，数据分析方法比较适用于关键字基本已知的情况，比如对于学生学号为关键字的散列函数，由于学号中一般包含学生编号序列，因此在计算学号的散列值可以提取出这部分编号计算出散列值。</p>\n<h3 id=\"除留余数法\"><a href=\"#除留余数法\" class=\"headerlink\" title=\"除留余数法\"></a>除留余数法</h3><p>用关键字除以某个不大于哈希表容量大小的数（一般直接关键字%散列表大小），余数作为散列值，即H(x) = X mod SizeOfTable。这种方法计算简单，通常适用于关键字分布均匀的情况</p>\n<h3 id=\"分段叠加法\"><a href=\"#分段叠加法\" class=\"headerlink\" title=\"分段叠加法\"></a>分段叠加法</h3><p>根据散列表地址情况将关键字分为几个大小相同的段（最后一个段大小可较短），然后将这几部分叠加，丢弃进位部分，余下的即为散列值，分段叠加可以分为折叠发和位移法两种，折叠法是将奇数段正序偶数段逆序相加，位移法是将分割后的每部分地位对齐后相加。</p>\n<h3 id=\"平方取中法\"><a href=\"#平方取中法\" class=\"headerlink\" title=\"平方取中法\"></a>平方取中法</h3><p>如果关键字的各个部分分布不够均匀，可以先求出关键字的平方值然后按需求取中间的几位作为散列值，由于平方值和关键字的每一位都有关系，因此平方值的随机性比较高。</p>\n<h3 id=\"伪随机数法\"><a href=\"#伪随机数法\" class=\"headerlink\" title=\"伪随机数法\"></a>伪随机数法</h3><p>在计算机中计算随机数时，得到的数不能称为正真的随机数，因为其值是通过一个确定性的算法计算出来，因此如果计算伪随机数的开始值不变的话，计算出的随机数也保持相同，这就是伪随机数法的基础。伪随机数散列函数结构为H(X) = random(X)。</p>\n<h2 id=\"散列冲突解决\"><a href=\"#散列冲突解决\" class=\"headerlink\" title=\"散列冲突解决\"></a>散列冲突解决</h2><p>一个好的散列函数尽量避免冲突的产生，但是一旦冲突发生，必须给予消除，一下为几种常用的冲突解决方法：</p>\n<h3 id=\"分离链接法（又称链地址法、拉链法）\"><a href=\"#分离链接法（又称链地址法、拉链法）\" class=\"headerlink\" title=\"分离链接法（又称链地址法、拉链法）\"></a>分离链接法（又称链地址法、拉链法）</h3><p>其基本思想是把散列到同一个散列值的所有元素保存到一个链表中。在执行删除、插入查找时，需要遍历该表已确定元素是否在链表中，然后执行下一步操作。</p>\n<p>分离链接法有如下优缺点：</p>\n<pre><code>- 优点\n    1. 处理简单，无堆积现象\n    2. 链表元素是动态申请内存的，因此对于无法事前了解散列表长度的情况非常合适\n    3. 该方法对装填因子没有很高的要求，甚至装填因子λ可以大于1\n    4. 删除操方便\n- 缺点\n    1. 指针占用内存空间，导致空间利用率下降\n</code></pre><h3 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h3><p>在分离链接法中，需要增加一个指针，同时可能需要分配新的单元，因此分离链接法的速度会受到申请内存开销的影响，而开放定址法则在发生冲突时尝试选择其他的单元直到找到一个空闲单元，在寻找空闲单元时，h<sub>i</sub>(X)=(Hash(X)+F(i)) mod SizeOfTable, i=0,1,2…依次被尝试，由于开放定址的特点，其不能进行标准的删除操作，只能采用惰性删除，否则可能将使查找操作失败，既元素已存在却返回不存在。开放定址法装填因子应该低于0.5。根据F(i)计算方式的不同开放定址法可分为：</p>\n<ul>\n<li><p>线性探测法：在该方法中，F(i)是i的线性函数，一般取F(i)=i，即出现冲突则依次探测下一个单元（可回绕）。在该冲突解决方法中，因为依次探测下一个，在散列表比较空的时候占据的单元会开始形成区块，称为一次聚集，导致散列到区块中的元素需要进行多次探测才能找到合适的空闲单元。使用线性探测方法预期的探测次数对于插入和不成功的查找为1/2*（1+(1/(1-λ)<sup>2</sup>))，对于成功的查找则为1/2*（1+(1/(1-λ))。线性探测法插入平均时间可用1/λ*ln(1/(1-λ))，计算方法为对1/(1-λ)从0~λ积分。</p>\n</li>\n<li><p>平方探测：F(i)是i的二次函数，常用F(i)=i<sup>2</sup>，在使用平方探测时，如果表的大小是一个素数，当表至少有一半是空闲时，保证总能够插入一个新元素。如果表有比一半多一个的位置被填满，则插入操作可能失败。平方探测存在二次聚集的情况.</p>\n</li>\n<li><p>双散列：双散列F(i)=i*hash<sub>2</sub>(X)。第二个散列函数值不能为0，否则原地死循环。另外尽量保证所有的单元都能被探测到。</p>\n</li>\n</ul>\n<h3 id=\"再散列法\"><a href=\"#再散列法\" class=\"headerlink\" title=\"再散列法\"></a>再散列法</h3><p>如果表的元素天的过满，则直接新建一个是原来约两倍的表，同时采用一个新的散列函数并把原始数据移入新表中，这既是再散列的含义。再散列可以用平方探测以多种方式实现，主要有以下做法：</p>\n<pre><code>1. 表满一半就再散列\n2. 插入失败立刻再散列，这种方式比较极端\n3. 即途中策略，当表装填因子达到某一值再散列\n</code></pre><h2 id=\"分离链接法的实现\"><a href=\"#分离链接法的实现\" class=\"headerlink\" title=\"分离链接法的实现\"></a>分离链接法的实现</h2><p>根据分离链接法的基本定义，该ADT可以包含以下操作：</p>\n<ul>\n<li>插入一个元素InsertElement</li>\n<li>删除一个元素DeleteElement</li>\n<li>查找一个元素Find</li>\n<li>清空所有元素MakeEmpty</li>\n</ul>\n<p>仿照《数据结构与算法分析-C语言描述》，有如下数据结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">\tNode(): next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tHashTable(<span class=\"keyword\">int</span> inTableSize);</span><br><span class=\"line\">\t~HashTable();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">DataType *<span class=\"title\">Find</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Hash</span><span class=\"params\">(DataType inKey)</span></span>; <span class=\"comment\">//具体的哈希函数，采用除余留法</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tableSize; <span class=\"comment\">//哈希表大小</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *tableArray; <span class=\"comment\">//哈希表指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，tableSize用来保存使用者指定的下一个素数，tableArray用来保存元素，采用哑节点的方式方便进行删除操作，以下为具体实现。</p>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">HashTable&lt;DataType&gt;::HashTable(<span class=\"keyword\">int</span> inTableSize): tableSize(inTableSize), tableArray(<span class=\"literal\">nullptr</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ttableArray = <span class=\"keyword\">new</span> Node&lt;DataType&gt;[inTableSize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入节点函数，采用头插法实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::InsertElement(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = Hash(inKey);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = tableArray[position].next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inKey) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> Node&lt;DataType&gt;;</span><br><span class=\"line\">\tnewNode-&gt;next =  tableArray[position].next;</span><br><span class=\"line\">\tnewNode-&gt;data = inKey;</span><br><span class=\"line\">\ttableArray[position].next = newNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::DeleteElement(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = Hash(inKey);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *preCycleIter = &amp;tableArray[position];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (preCycleIter-&gt;next != <span class=\"literal\">nullptr</span> &amp;&amp; preCycleIter-&gt;next-&gt;data !=inKey) &#123;</span><br><span class=\"line\">\t\tpreCycleIter = preCycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (preCycleIter-&gt;next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tNode&lt;DataType&gt; * toBeDelete = preCycleIter-&gt;next;</span><br><span class=\"line\">\tpreCycleIter-&gt;next = toBeDelete-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>找到节点，返回该节点在内存中的地址</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType * HashTable&lt;DataType&gt;::Find(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = Hash(inKey);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = tableArray[position].next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> &amp;&amp; cycleIter-&gt;data !=inKey) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cycleIter == <span class=\"literal\">nullptr</span> ? <span class=\"literal\">nullptr</span> : &amp;cycleIter-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空散列表中的链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tableArray[i].next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *pre = &amp;tableArray[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (pre-&gt;next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tNode&lt;DataType&gt; *tmp = pre-&gt;next;</span><br><span class=\"line\">\t\t\t\tpre-&gt;next = tmp-&gt;next;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空散列表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">HashTable&lt;DataType&gt;::~HashTable()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] tableArray;</span><br><span class=\"line\">\ttableArray = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>散列函数，简单起见，直接除余留法，假设键值为数值类型</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> HashTable&lt;DataType&gt;::Hash(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int</span>(inKey)%tableSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开放定址法平方探测的实现\"><a href=\"#开放定址法平方探测的实现\" class=\"headerlink\" title=\"开放定址法平方探测的实现\"></a>开放定址法平方探测的实现</h2><p>开放地址法与分离链接法最大的区别就是在没找到位置时需要继续探测直到找到空位，而且可能会出现插入失败的情况，而且删除只能采用惰性删除，因此需要在节点域中添加标记当前节点状态，主要有三种状态空闲、占用、已删除。仿照《数据结构与算法分析-C语言描述》，有如下数据结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> State</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tEMPTY,</span><br><span class=\"line\">\tDELETED,</span><br><span class=\"line\">\tOCCUPY</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tState nodeState;</span><br><span class=\"line\">\tNode(): nodeState(State::EMPTY) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tHashTable(<span class=\"keyword\">int</span> inTableSize);</span><br><span class=\"line\">\t~HashTable();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">DataType *<span class=\"title\">Find</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Hash</span><span class=\"params\">(DataType inKey)</span></span>; <span class=\"comment\">//具体的哈希函数，采用除余留法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FindCore</span><span class=\"params\">(DataType inKey)</span></span>; <span class=\"comment\">//查找核心函数，如果没找到返回插入位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tableSize; <span class=\"comment\">//哈希表大小</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *tableArray; <span class=\"comment\">//哈希表指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上数据成员和分离链接法基本类似，以下为各函数实现：</p>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">HashTable&lt;DataType&gt;::HashTable(<span class=\"keyword\">int</span> inTableSize): tableSize(inTableSize), tableArray(<span class=\"literal\">nullptr</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ttableArray = <span class=\"keyword\">new</span> Node&lt;DataType&gt;[inTableSize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入节点函数，调用核心查找函数，如果找到则不做任何处理，否则插入返回位置（如果可以插入）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::InsertElement(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = FindCore(inKey);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tableArray[position].nodeState != State::OCCUPY) &#123;</span><br><span class=\"line\">\t\ttableArray[position].nodeState = State::OCCUPY;</span><br><span class=\"line\">\t\ttableArray[position].data = inKey;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::DeleteElement(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = FindCore(inKey);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tableArray[position].nodeState == State::OCCUPY) &#123;</span><br><span class=\"line\">\t\ttableArray[position].nodeState = State::DELETED;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>找到节点核心函数，如果找到则返回下标，否则返回下一个可供插入的位置</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> HashTable&lt;DataType&gt;::FindCore(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = Hash(inKey);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tableArray[position].nodeState != State::EMPTY </span><br><span class=\"line\">\t\t\t&amp;&amp; tableArray[position].data != inKey) &#123;</span><br><span class=\"line\">\t\tposition += <span class=\"number\">2</span>*i<span class=\"number\">-1</span>; ++i; <span class=\"comment\">//采用书上公式</span></span><br><span class=\"line\">\t\tposition = position &gt;= tableSize ? position - tableSize : position;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>找到节点，返回该节点在内存中的地址</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType * HashTable&lt;DataType&gt;::Find(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = FindCore(inKey);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tableArray[position].nodeState == State::OCCUPY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;tableArray[position].data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空散列表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">HashTable&lt;DataType&gt;::~HashTable()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] tableArray;</span><br><span class=\"line\">\ttableArray = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>散列函数，简单起见，直接除余留法，假设键值为数值类型</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> HashTable&lt;DataType&gt;::Hash(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int</span>(inKey)%tableSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码没有进行错误检测，如果核心查找函数失败的话可能会陷入死循环，因此可添加一个计数值，循环次数大于该值就停止寻找。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"散列基础知识\"><a href=\"#散列基础知识\" class=\"headerlink\" title=\"散列基础知识\"></a>散列基础知识</h2><p>散列（hashing）是指散列表的实现，散列是一种用于以常数平均时间进行插入、删除、查找的的数据结构。但是散列表并不包含任何元素之间的排序信息，因此散列表不支持诸如查找最大元素、最小元素等需要排序的操作。散列表一般的实现中是采用一个固定大小的数组以及一个散列函数将关键字映射到数组的某一个位置，由于数组的大小是有限的而关键字数量却无限制，因此自然会发生多个关键字经过散列函数的映射到同一位置，此时就需要解决这种称为冲突的情况，因此可以认为散列是一种由散列函数和一系列冲突解决方案组成的抽像数据结构。</p>\n<p>散列表中有一个概念称为装填因子λ，其定义为散列表元素的个数除以散列表大小的比值。</p>\n<h2 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h2><p>散列函数又称为哈希函数（Hash Function），散列函数具有如下性质：</p>\n<ul>\n<li>同一散列函数计算出的散列值不同，则原始输出必定不同，称为散列函数的确定性</li>\n<li>散列函数的输入输出不一定是唯一对应关系，如果两个输入散列值相同，两个输入可能不同，称为散列碰撞</li>\n</ul>\n<p>散列函数的选取将会极大影响散列的性能，如果散列函数选取失败，不能将大量的关键字均匀地进行分配，则会产生大量的冲突。使得散列性能下降。因此构建散列函数的目标就是均匀的分布在连续的内存空间中，常用的散列函数构造方法有如下几种：</p>\n<h3 id=\"直接定址法\"><a href=\"#直接定址法\" class=\"headerlink\" title=\"直接定址法\"></a>直接定址法</h3><p>即以关键字加上某个常数作为散列值，比如对于26个小写字母的散列函数可以直接是H(X) = X - ‘a’，这种哈希函数计算简单，一般适用于关键字值连续的情况，否则将会浪费大量的空间。</p>\n<h3 id=\"数字分析法\"><a href=\"#数字分析法\" class=\"headerlink\" title=\"数字分析法\"></a>数字分析法</h3><p>对于关键字中存在一定规律且分布比较均匀的数字作为计算散列值的依据，数据分析方法比较适用于关键字基本已知的情况，比如对于学生学号为关键字的散列函数，由于学号中一般包含学生编号序列，因此在计算学号的散列值可以提取出这部分编号计算出散列值。</p>\n<h3 id=\"除留余数法\"><a href=\"#除留余数法\" class=\"headerlink\" title=\"除留余数法\"></a>除留余数法</h3><p>用关键字除以某个不大于哈希表容量大小的数（一般直接关键字%散列表大小），余数作为散列值，即H(x) = X mod SizeOfTable。这种方法计算简单，通常适用于关键字分布均匀的情况</p>\n<h3 id=\"分段叠加法\"><a href=\"#分段叠加法\" class=\"headerlink\" title=\"分段叠加法\"></a>分段叠加法</h3><p>根据散列表地址情况将关键字分为几个大小相同的段（最后一个段大小可较短），然后将这几部分叠加，丢弃进位部分，余下的即为散列值，分段叠加可以分为折叠发和位移法两种，折叠法是将奇数段正序偶数段逆序相加，位移法是将分割后的每部分地位对齐后相加。</p>\n<h3 id=\"平方取中法\"><a href=\"#平方取中法\" class=\"headerlink\" title=\"平方取中法\"></a>平方取中法</h3><p>如果关键字的各个部分分布不够均匀，可以先求出关键字的平方值然后按需求取中间的几位作为散列值，由于平方值和关键字的每一位都有关系，因此平方值的随机性比较高。</p>\n<h3 id=\"伪随机数法\"><a href=\"#伪随机数法\" class=\"headerlink\" title=\"伪随机数法\"></a>伪随机数法</h3><p>在计算机中计算随机数时，得到的数不能称为正真的随机数，因为其值是通过一个确定性的算法计算出来，因此如果计算伪随机数的开始值不变的话，计算出的随机数也保持相同，这就是伪随机数法的基础。伪随机数散列函数结构为H(X) = random(X)。</p>\n<h2 id=\"散列冲突解决\"><a href=\"#散列冲突解决\" class=\"headerlink\" title=\"散列冲突解决\"></a>散列冲突解决</h2><p>一个好的散列函数尽量避免冲突的产生，但是一旦冲突发生，必须给予消除，一下为几种常用的冲突解决方法：</p>\n<h3 id=\"分离链接法（又称链地址法、拉链法）\"><a href=\"#分离链接法（又称链地址法、拉链法）\" class=\"headerlink\" title=\"分离链接法（又称链地址法、拉链法）\"></a>分离链接法（又称链地址法、拉链法）</h3><p>其基本思想是把散列到同一个散列值的所有元素保存到一个链表中。在执行删除、插入查找时，需要遍历该表已确定元素是否在链表中，然后执行下一步操作。</p>\n<p>分离链接法有如下优缺点：</p>\n<pre><code>- 优点\n    1. 处理简单，无堆积现象\n    2. 链表元素是动态申请内存的，因此对于无法事前了解散列表长度的情况非常合适\n    3. 该方法对装填因子没有很高的要求，甚至装填因子λ可以大于1\n    4. 删除操方便\n- 缺点\n    1. 指针占用内存空间，导致空间利用率下降\n</code></pre><h3 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h3><p>在分离链接法中，需要增加一个指针，同时可能需要分配新的单元，因此分离链接法的速度会受到申请内存开销的影响，而开放定址法则在发生冲突时尝试选择其他的单元直到找到一个空闲单元，在寻找空闲单元时，h<sub>i</sub>(X)=(Hash(X)+F(i)) mod SizeOfTable, i=0,1,2…依次被尝试，由于开放定址的特点，其不能进行标准的删除操作，只能采用惰性删除，否则可能将使查找操作失败，既元素已存在却返回不存在。开放定址法装填因子应该低于0.5。根据F(i)计算方式的不同开放定址法可分为：</p>\n<ul>\n<li><p>线性探测法：在该方法中，F(i)是i的线性函数，一般取F(i)=i，即出现冲突则依次探测下一个单元（可回绕）。在该冲突解决方法中，因为依次探测下一个，在散列表比较空的时候占据的单元会开始形成区块，称为一次聚集，导致散列到区块中的元素需要进行多次探测才能找到合适的空闲单元。使用线性探测方法预期的探测次数对于插入和不成功的查找为1/2*（1+(1/(1-λ)<sup>2</sup>))，对于成功的查找则为1/2*（1+(1/(1-λ))。线性探测法插入平均时间可用1/λ*ln(1/(1-λ))，计算方法为对1/(1-λ)从0~λ积分。</p>\n</li>\n<li><p>平方探测：F(i)是i的二次函数，常用F(i)=i<sup>2</sup>，在使用平方探测时，如果表的大小是一个素数，当表至少有一半是空闲时，保证总能够插入一个新元素。如果表有比一半多一个的位置被填满，则插入操作可能失败。平方探测存在二次聚集的情况.</p>\n</li>\n<li><p>双散列：双散列F(i)=i*hash<sub>2</sub>(X)。第二个散列函数值不能为0，否则原地死循环。另外尽量保证所有的单元都能被探测到。</p>\n</li>\n</ul>\n<h3 id=\"再散列法\"><a href=\"#再散列法\" class=\"headerlink\" title=\"再散列法\"></a>再散列法</h3><p>如果表的元素天的过满，则直接新建一个是原来约两倍的表，同时采用一个新的散列函数并把原始数据移入新表中，这既是再散列的含义。再散列可以用平方探测以多种方式实现，主要有以下做法：</p>\n<pre><code>1. 表满一半就再散列\n2. 插入失败立刻再散列，这种方式比较极端\n3. 即途中策略，当表装填因子达到某一值再散列\n</code></pre><h2 id=\"分离链接法的实现\"><a href=\"#分离链接法的实现\" class=\"headerlink\" title=\"分离链接法的实现\"></a>分离链接法的实现</h2><p>根据分离链接法的基本定义，该ADT可以包含以下操作：</p>\n<ul>\n<li>插入一个元素InsertElement</li>\n<li>删除一个元素DeleteElement</li>\n<li>查找一个元素Find</li>\n<li>清空所有元素MakeEmpty</li>\n</ul>\n<p>仿照《数据结构与算法分析-C语言描述》，有如下数据结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">\tNode(): next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tHashTable(<span class=\"keyword\">int</span> inTableSize);</span><br><span class=\"line\">\t~HashTable();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">DataType *<span class=\"title\">Find</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Hash</span><span class=\"params\">(DataType inKey)</span></span>; <span class=\"comment\">//具体的哈希函数，采用除余留法</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tableSize; <span class=\"comment\">//哈希表大小</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *tableArray; <span class=\"comment\">//哈希表指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，tableSize用来保存使用者指定的下一个素数，tableArray用来保存元素，采用哑节点的方式方便进行删除操作，以下为具体实现。</p>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">HashTable&lt;DataType&gt;::HashTable(<span class=\"keyword\">int</span> inTableSize): tableSize(inTableSize), tableArray(<span class=\"literal\">nullptr</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ttableArray = <span class=\"keyword\">new</span> Node&lt;DataType&gt;[inTableSize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入节点函数，采用头插法实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::InsertElement(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = Hash(inKey);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = tableArray[position].next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inKey) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> Node&lt;DataType&gt;;</span><br><span class=\"line\">\tnewNode-&gt;next =  tableArray[position].next;</span><br><span class=\"line\">\tnewNode-&gt;data = inKey;</span><br><span class=\"line\">\ttableArray[position].next = newNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::DeleteElement(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = Hash(inKey);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *preCycleIter = &amp;tableArray[position];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (preCycleIter-&gt;next != <span class=\"literal\">nullptr</span> &amp;&amp; preCycleIter-&gt;next-&gt;data !=inKey) &#123;</span><br><span class=\"line\">\t\tpreCycleIter = preCycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (preCycleIter-&gt;next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tNode&lt;DataType&gt; * toBeDelete = preCycleIter-&gt;next;</span><br><span class=\"line\">\tpreCycleIter-&gt;next = toBeDelete-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>找到节点，返回该节点在内存中的地址</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType * HashTable&lt;DataType&gt;::Find(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = Hash(inKey);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = tableArray[position].next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> &amp;&amp; cycleIter-&gt;data !=inKey) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cycleIter == <span class=\"literal\">nullptr</span> ? <span class=\"literal\">nullptr</span> : &amp;cycleIter-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空散列表中的链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tableSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tableArray[i].next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *pre = &amp;tableArray[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (pre-&gt;next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tNode&lt;DataType&gt; *tmp = pre-&gt;next;</span><br><span class=\"line\">\t\t\t\tpre-&gt;next = tmp-&gt;next;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空散列表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">HashTable&lt;DataType&gt;::~HashTable()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] tableArray;</span><br><span class=\"line\">\ttableArray = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>散列函数，简单起见，直接除余留法，假设键值为数值类型</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> HashTable&lt;DataType&gt;::Hash(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int</span>(inKey)%tableSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"开放定址法平方探测的实现\"><a href=\"#开放定址法平方探测的实现\" class=\"headerlink\" title=\"开放定址法平方探测的实现\"></a>开放定址法平方探测的实现</h2><p>开放地址法与分离链接法最大的区别就是在没找到位置时需要继续探测直到找到空位，而且可能会出现插入失败的情况，而且删除只能采用惰性删除，因此需要在节点域中添加标记当前节点状态，主要有三种状态空闲、占用、已删除。仿照《数据结构与算法分析-C语言描述》，有如下数据结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> State</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tEMPTY,</span><br><span class=\"line\">\tDELETED,</span><br><span class=\"line\">\tOCCUPY</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tState nodeState;</span><br><span class=\"line\">\tNode(): nodeState(State::EMPTY) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tHashTable(<span class=\"keyword\">int</span> inTableSize);</span><br><span class=\"line\">\t~HashTable();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">DataType *<span class=\"title\">Find</span><span class=\"params\">(DataType inKey)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Hash</span><span class=\"params\">(DataType inKey)</span></span>; <span class=\"comment\">//具体的哈希函数，采用除余留法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FindCore</span><span class=\"params\">(DataType inKey)</span></span>; <span class=\"comment\">//查找核心函数，如果没找到返回插入位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tableSize; <span class=\"comment\">//哈希表大小</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *tableArray; <span class=\"comment\">//哈希表指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上数据成员和分离链接法基本类似，以下为各函数实现：</p>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">HashTable&lt;DataType&gt;::HashTable(<span class=\"keyword\">int</span> inTableSize): tableSize(inTableSize), tableArray(<span class=\"literal\">nullptr</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ttableArray = <span class=\"keyword\">new</span> Node&lt;DataType&gt;[inTableSize];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入节点函数，调用核心查找函数，如果找到则不做任何处理，否则插入返回位置（如果可以插入）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::InsertElement(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = FindCore(inKey);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tableArray[position].nodeState != State::OCCUPY) &#123;</span><br><span class=\"line\">\t\ttableArray[position].nodeState = State::OCCUPY;</span><br><span class=\"line\">\t\ttableArray[position].data = inKey;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> HashTable&lt;DataType&gt;::DeleteElement(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = FindCore(inKey);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tableArray[position].nodeState == State::OCCUPY) &#123;</span><br><span class=\"line\">\t\ttableArray[position].nodeState = State::DELETED;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>找到节点核心函数，如果找到则返回下标，否则返回下一个可供插入的位置</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> HashTable&lt;DataType&gt;::FindCore(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = Hash(inKey);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tableArray[position].nodeState != State::EMPTY </span><br><span class=\"line\">\t\t\t&amp;&amp; tableArray[position].data != inKey) &#123;</span><br><span class=\"line\">\t\tposition += <span class=\"number\">2</span>*i<span class=\"number\">-1</span>; ++i; <span class=\"comment\">//采用书上公式</span></span><br><span class=\"line\">\t\tposition = position &gt;= tableSize ? position - tableSize : position;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>找到节点，返回该节点在内存中的地址</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType * HashTable&lt;DataType&gt;::Find(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> position = FindCore(inKey);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tableArray[position].nodeState == State::OCCUPY) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;tableArray[position].data;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空散列表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">HashTable&lt;DataType&gt;::~HashTable()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] tableArray;</span><br><span class=\"line\">\ttableArray = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>散列函数，简单起见，直接除余留法，假设键值为数值类型</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> HashTable&lt;DataType&gt;::Hash(DataType inKey)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int</span>(inKey)%tableSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码没有进行错误检测，如果核心查找函数失败的话可能会陷入死循环，因此可添加一个计数值，循环次数大于该值就停止寻找。</p>\n"},{"title":"数据结构之二叉查找树的定义与实现","urlname":"binary-search-tree","date":"2018-03-08T08:55:28.000Z","mathjax":true,"copyright":true,"_content":"\n## 二叉查找树基础\n\n二叉查找树是指一种满足以下性质的二叉树：\n\n\t1. 对于每个节点X，该节点的所有左子树节点关键字值小于该节点关键字值\n\t2. 该节点的所有右子树节点关键字值大于该节点关键字值\n\t3. 关键字需要支持“>”、“<”、“==”运算符\n\n对于二叉树ADT，一般需要提供如下操作：\n\n- 清空二叉查找树：MakeEmpty\n- 查找某个节点：Find\n- 删除某个节点：DeleteElement\n- 查找最大值：FindMax\n- 查找最小值：FindMin\n- 插入一个节点：InsertElement\n\n二叉查找树的平均深度为O(log(N))，不过如果插入元素序列递增或者递减，二叉查找树将退化成单链表。\n\n## 二叉查找树的实现\n\n由于二叉查找树是一种统一排序的查找树，在进行删除插入时需要保持排序关系，以下为二叉查找树的基本结构定义：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *left;\n\tNode *right;\n\tNode(DataType inData): data(inData), left(nullptr), right(nullptr) {}\n};\n\ntemplate <typename DataType>\nclass BinarySearchTree\n{\npublic:\n\tBinarySearchTree(): root(nullptr) {}\n\t~BinarySearchTree();\n\tvoid MakeEmpty(); //清空二叉查找树\n\tvoid MakeEmptyNon(); //非递归清空二叉树\n\tNode<DataType> * Find(DataType inElement); //查找某个元素\n\tNode<DataType> * FindNon(DataType inElement); //非递归查找\n\tvoid DeleteElement(DataType inElement); //删除一个节点\n\tNode<DataType> * FindMax(); //查找最大元素\n\tNode<DataType> * FindMaxNon(); //非递归查找最大元素\n\tNode<DataType> * FindMin(); //查找最小元素\n\tNode<DataType> * FindMinNon(); //非递归查找最小元素\n\tNode<DataType> * InsertElementNon(DataType inElement); //非递归插入一个元素\nprivate:\n\tvoid MakeEmptyCore(Node<DataType> *inNode);\n\tNode<DataType> *FindCore(Node<DataType> *inNode, DataType inElement);\n\t//删除一个节点\n\tNode<DataType> * DeleteElementCore(Node<DataType> *inNode, DataType inElement);\n\tNode<DataType> *FindMaxCore(Node<DataType> *inNode);\n\tNode<DataType> *FindMinCore(Node<DataType> *inNode);\n\tNode<DataType> *root;\n};\n```\n\n如上所示，二叉查找树的基本数据成员为根节点，初始化为空指针，通过插入节点函数建立二叉查找树，以下为各函数实现：\n\n- 递归清空核心函数\n\n```cpp\ntemplate <typename DataType>\nvoid BinarySearchTree<DataType>::MakeEmptyCore(Node<DataType> *inNode)\n{\n\tif (inNode == nullptr) {\n\t\treturn;\n\t}\n\tMakeEmptyCore(inNode->left);\n\tMakeEmptyCore(inNode->right);\n\tdelete inNode;\n}\n```\n\n- 递归清空入口函数，调用清空核心函数\n\n```cpp\ntemplate <typename DataType>\nvoid BinarySearchTree<DataType>::MakeEmpty()\n{\n\tMakeEmptyCore(root); root = nullptr;\n}\n```\n\n- 非递归清空函数，采用某种非递归遍历函数思想即可\n\n```cpp\ntemplate <typename DataType>\nvoid BinarySearchTree<DataType>::MakeEmptyNon()\n{\n\tstack<Node<DataType> *> nodeStack;\n\tNode<DataType> *cycleIter = root;\n\twhile (cycleIter != nullptr || !nodeStack.empty()) {\n\t\twhile (cycleIter != nullptr) {\n\t\t\tnodeStack.push(cycleIter);\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\t\n\t\tif (!nodeStack.empty()) {\n\t\t\tNode<DataType> * tmp = nodeStack.top();\n\t\t\tcycleIter = tmp->right;\n\t\t\tdelete tmp; nodeStack.pop();\n\t\t}\n\t}\n\troot = nullptr;\n}\n```\n\n- 递归查找核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> *BinarySearchTree<DataType>::FindCore(Node<DataType> *inNode, DataType inElement)\n{\n\tif (inNode == nullptr) {\n\t\treturn nullptr;\n\t}\n\tif (inNode->data == inElement) {\n\t\treturn inNode;\n\t}\n\telse if (inNode->data > inElement){\n\t\treturn FindCore(inNode->left, inElement);\n\t}\n\telse {\n\t\treturn FindCore(inNode->right, inElement);\n\t}\n\treturn nullptr;\n}\n```\n\n- 递归查找某个元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::Find(DataType inElement)\n{\n\treturn FindCore(root, inElement);\n}\n```\n\n- 非递归查找\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindNon(DataType inElement)\n{\n\tNode<DataType> *cycleIter = root;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == inElement) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\telse if (cycleIter->data > inElement){\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\telse {\n\t\t\tcycleIter = cycleIter->right;\n\t\t}\n\t}\n\treturn nullptr;\n}\n```\n\n\n- 递归删除节点函数核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::DeleteElementCore(Node<DataType> *inNode, DataType inElement)\n{\n\tif (inNode == nullptr) {\n\t\treturn nullptr;\n\t}\n\telse if (inNode->data > inElement) {\n\t\tinNode->left = DeleteElementCore(inNode->left, inElement);\n\t}\n\telse if (inNode->data < inElement) {\n\t\tinNode->right = DeleteElementCore(inNode->right, inElement);\n\t}\n\telse {\n\t\tif (inNode->left != nullptr && inNode->right != nullptr) {\n\t\t\tNode<DataType> *tmp = FindMinCore(inNode->right);\n\t\t\tinNode->data = tmp->data;\n\t\t\tinNode->right = DeleteElementCore(inNode->right, inNode->data);\n\t\t}\n\t\telse {\n\t\t\tNode<DataType> *tmp = inNode;\n\t\t\tif (inNode->left == nullptr) {\n\t\t\t\tinNode = inNode->right;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinNode = inNode->left;\n\t\t\t}\n\t\t\tdelete  tmp;\n\t\t}\n\t}\n\treturn inNode;\n}\n```\n\n\n- 删除一个节点，删除节点需要十分小心，删除需要分为几种情况讨论：\n\n\t1. 第一种，叶节点，直接删除即可\n\t2. 第二种，只有左子节点，直接父节点重新定向到左子节点\n\t3. 第三种，只有右子节点，也是直接父节点重定向到右子节点\n\t4. 第四种，有两个子节点，由于该节点值大于左子树而小于右子树，因此可以用左子树的最大值或者右子树的最小值交换，然后删除交换点，改点情况是1~3种情况的一种，即需要删除两次\n\n```cpp\ntemplate <typename DataType>\nvoid BinarySearchTree<DataType>::DeleteElement(DataType inElement)\n{\n\troot = DeleteElementCore(root, inElement);\n}\n```\n\n\n\n- 递归查找最大元素核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMaxCore(Node<DataType> *inNode)\n{\n\tif (inNode == nullptr) {\n\t\treturn nullptr;\n\t}\n\telse if (inNode->right == nullptr) {\n\t\treturn inNode;\n\t}\n\telse {\n\t\treturn FindMaxCore(inNode->right);\n\t}\n}\n```\n\n- 递归查找最大元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMax()\n{\n\tif (root == nullptr) {\n\t\treturn nullptr;\n\t}\n\treturn FindMaxCore(root);\n}\n```\n\n- 非递归查找最大元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMaxNon()\n{\n\tif (root == nullptr) {\n\t\treturn nullptr;\n\t}\n\tNode<DataType> *pre = root;\n\tNode<DataType> *cycleIter = pre->right;\n\twhile (cycleIter != nullptr) {\n\t\tpre = cycleIter;\n\t\tcycleIter = pre->right;\n\t}\n\treturn pre;\n}\n```\n\n- 递归查找最小元素核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMinCore(Node<DataType> *inNode)\n{\n\tif (inNode == nullptr) {\n\t\treturn nullptr;\n\t}\n\telse if (inNode->left == nullptr) {\n\t\treturn inNode;\n\t}\n\telse {\n\t\treturn FindMinCore(inNode->left);\n\t}\n}\n```\n- 递归查找最小元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMin()\n{\n\tif (root == nullptr) {\n\t\treturn nullptr;\n\t}\n\treturn FindMinCore(root);\n}\n```\n\n- 非递归查找最小元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMinNon()\n{\n\tif (root == nullptr) {\n\t\treturn nullptr;\n\t}\n\tNode<DataType> *pre = root;\n\tNode<DataType> *cycleIter = pre->left;\n\twhile (cycleIter != nullptr) {\n\t\tpre = cycleIter;\n\t\tcycleIter = pre->left;\n\t}\n\treturn pre;\n}\n```\n\n- 非递归插入一个元素，返回位置\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::InsertElementNon(DataType inElement)\n{\n\tif (root == nullptr) {\n\t\troot = new Node<DataType>(inElement);\n\t\treturn root;\n\t}\n\tNode<DataType> *cycleIter = root;\n\twhile (1) {\n\t\tif (cycleIter->data == inElement) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\telse if (cycleIter->data > inElement) {\n\t\t\tif (cycleIter->left == nullptr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\telse {\n\t\t\tif (cycleIter->right == nullptr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcycleIter = cycleIter->right;\n\t\t}\n\t}\n\tNode<DataType> *newNode = new Node<DataType>(inElement);\n\tif (cycleIter->data > inElement) {\n\t\tcycleIter->left = newNode;\n\t}\n\telse {\n\t\tcycleIter->right = newNode;\n\t}\n\treturn newNode;\n}\n```\n\n- 析构函数\n\n```cpp\ntemplate <typename DataType>\nBinarySearchTree<DataType>::~BinarySearchTree()\n{\n\tMakeEmpty();\n}\n```\n\n\n\n","source":"_posts/数据结构/数据结构之二叉查找树.md","raw":"---\ntitle: 数据结构之二叉查找树的定义与实现\nurlname: binary-search-tree\ndate: 2018-03-8 16:55:28\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 二叉查找树基础\n\n二叉查找树是指一种满足以下性质的二叉树：\n\n\t1. 对于每个节点X，该节点的所有左子树节点关键字值小于该节点关键字值\n\t2. 该节点的所有右子树节点关键字值大于该节点关键字值\n\t3. 关键字需要支持“>”、“<”、“==”运算符\n\n对于二叉树ADT，一般需要提供如下操作：\n\n- 清空二叉查找树：MakeEmpty\n- 查找某个节点：Find\n- 删除某个节点：DeleteElement\n- 查找最大值：FindMax\n- 查找最小值：FindMin\n- 插入一个节点：InsertElement\n\n二叉查找树的平均深度为O(log(N))，不过如果插入元素序列递增或者递减，二叉查找树将退化成单链表。\n\n## 二叉查找树的实现\n\n由于二叉查找树是一种统一排序的查找树，在进行删除插入时需要保持排序关系，以下为二叉查找树的基本结构定义：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *left;\n\tNode *right;\n\tNode(DataType inData): data(inData), left(nullptr), right(nullptr) {}\n};\n\ntemplate <typename DataType>\nclass BinarySearchTree\n{\npublic:\n\tBinarySearchTree(): root(nullptr) {}\n\t~BinarySearchTree();\n\tvoid MakeEmpty(); //清空二叉查找树\n\tvoid MakeEmptyNon(); //非递归清空二叉树\n\tNode<DataType> * Find(DataType inElement); //查找某个元素\n\tNode<DataType> * FindNon(DataType inElement); //非递归查找\n\tvoid DeleteElement(DataType inElement); //删除一个节点\n\tNode<DataType> * FindMax(); //查找最大元素\n\tNode<DataType> * FindMaxNon(); //非递归查找最大元素\n\tNode<DataType> * FindMin(); //查找最小元素\n\tNode<DataType> * FindMinNon(); //非递归查找最小元素\n\tNode<DataType> * InsertElementNon(DataType inElement); //非递归插入一个元素\nprivate:\n\tvoid MakeEmptyCore(Node<DataType> *inNode);\n\tNode<DataType> *FindCore(Node<DataType> *inNode, DataType inElement);\n\t//删除一个节点\n\tNode<DataType> * DeleteElementCore(Node<DataType> *inNode, DataType inElement);\n\tNode<DataType> *FindMaxCore(Node<DataType> *inNode);\n\tNode<DataType> *FindMinCore(Node<DataType> *inNode);\n\tNode<DataType> *root;\n};\n```\n\n如上所示，二叉查找树的基本数据成员为根节点，初始化为空指针，通过插入节点函数建立二叉查找树，以下为各函数实现：\n\n- 递归清空核心函数\n\n```cpp\ntemplate <typename DataType>\nvoid BinarySearchTree<DataType>::MakeEmptyCore(Node<DataType> *inNode)\n{\n\tif (inNode == nullptr) {\n\t\treturn;\n\t}\n\tMakeEmptyCore(inNode->left);\n\tMakeEmptyCore(inNode->right);\n\tdelete inNode;\n}\n```\n\n- 递归清空入口函数，调用清空核心函数\n\n```cpp\ntemplate <typename DataType>\nvoid BinarySearchTree<DataType>::MakeEmpty()\n{\n\tMakeEmptyCore(root); root = nullptr;\n}\n```\n\n- 非递归清空函数，采用某种非递归遍历函数思想即可\n\n```cpp\ntemplate <typename DataType>\nvoid BinarySearchTree<DataType>::MakeEmptyNon()\n{\n\tstack<Node<DataType> *> nodeStack;\n\tNode<DataType> *cycleIter = root;\n\twhile (cycleIter != nullptr || !nodeStack.empty()) {\n\t\twhile (cycleIter != nullptr) {\n\t\t\tnodeStack.push(cycleIter);\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\t\n\t\tif (!nodeStack.empty()) {\n\t\t\tNode<DataType> * tmp = nodeStack.top();\n\t\t\tcycleIter = tmp->right;\n\t\t\tdelete tmp; nodeStack.pop();\n\t\t}\n\t}\n\troot = nullptr;\n}\n```\n\n- 递归查找核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> *BinarySearchTree<DataType>::FindCore(Node<DataType> *inNode, DataType inElement)\n{\n\tif (inNode == nullptr) {\n\t\treturn nullptr;\n\t}\n\tif (inNode->data == inElement) {\n\t\treturn inNode;\n\t}\n\telse if (inNode->data > inElement){\n\t\treturn FindCore(inNode->left, inElement);\n\t}\n\telse {\n\t\treturn FindCore(inNode->right, inElement);\n\t}\n\treturn nullptr;\n}\n```\n\n- 递归查找某个元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::Find(DataType inElement)\n{\n\treturn FindCore(root, inElement);\n}\n```\n\n- 非递归查找\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindNon(DataType inElement)\n{\n\tNode<DataType> *cycleIter = root;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == inElement) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\telse if (cycleIter->data > inElement){\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\telse {\n\t\t\tcycleIter = cycleIter->right;\n\t\t}\n\t}\n\treturn nullptr;\n}\n```\n\n\n- 递归删除节点函数核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::DeleteElementCore(Node<DataType> *inNode, DataType inElement)\n{\n\tif (inNode == nullptr) {\n\t\treturn nullptr;\n\t}\n\telse if (inNode->data > inElement) {\n\t\tinNode->left = DeleteElementCore(inNode->left, inElement);\n\t}\n\telse if (inNode->data < inElement) {\n\t\tinNode->right = DeleteElementCore(inNode->right, inElement);\n\t}\n\telse {\n\t\tif (inNode->left != nullptr && inNode->right != nullptr) {\n\t\t\tNode<DataType> *tmp = FindMinCore(inNode->right);\n\t\t\tinNode->data = tmp->data;\n\t\t\tinNode->right = DeleteElementCore(inNode->right, inNode->data);\n\t\t}\n\t\telse {\n\t\t\tNode<DataType> *tmp = inNode;\n\t\t\tif (inNode->left == nullptr) {\n\t\t\t\tinNode = inNode->right;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinNode = inNode->left;\n\t\t\t}\n\t\t\tdelete  tmp;\n\t\t}\n\t}\n\treturn inNode;\n}\n```\n\n\n- 删除一个节点，删除节点需要十分小心，删除需要分为几种情况讨论：\n\n\t1. 第一种，叶节点，直接删除即可\n\t2. 第二种，只有左子节点，直接父节点重新定向到左子节点\n\t3. 第三种，只有右子节点，也是直接父节点重定向到右子节点\n\t4. 第四种，有两个子节点，由于该节点值大于左子树而小于右子树，因此可以用左子树的最大值或者右子树的最小值交换，然后删除交换点，改点情况是1~3种情况的一种，即需要删除两次\n\n```cpp\ntemplate <typename DataType>\nvoid BinarySearchTree<DataType>::DeleteElement(DataType inElement)\n{\n\troot = DeleteElementCore(root, inElement);\n}\n```\n\n\n\n- 递归查找最大元素核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMaxCore(Node<DataType> *inNode)\n{\n\tif (inNode == nullptr) {\n\t\treturn nullptr;\n\t}\n\telse if (inNode->right == nullptr) {\n\t\treturn inNode;\n\t}\n\telse {\n\t\treturn FindMaxCore(inNode->right);\n\t}\n}\n```\n\n- 递归查找最大元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMax()\n{\n\tif (root == nullptr) {\n\t\treturn nullptr;\n\t}\n\treturn FindMaxCore(root);\n}\n```\n\n- 非递归查找最大元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMaxNon()\n{\n\tif (root == nullptr) {\n\t\treturn nullptr;\n\t}\n\tNode<DataType> *pre = root;\n\tNode<DataType> *cycleIter = pre->right;\n\twhile (cycleIter != nullptr) {\n\t\tpre = cycleIter;\n\t\tcycleIter = pre->right;\n\t}\n\treturn pre;\n}\n```\n\n- 递归查找最小元素核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMinCore(Node<DataType> *inNode)\n{\n\tif (inNode == nullptr) {\n\t\treturn nullptr;\n\t}\n\telse if (inNode->left == nullptr) {\n\t\treturn inNode;\n\t}\n\telse {\n\t\treturn FindMinCore(inNode->left);\n\t}\n}\n```\n- 递归查找最小元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMin()\n{\n\tif (root == nullptr) {\n\t\treturn nullptr;\n\t}\n\treturn FindMinCore(root);\n}\n```\n\n- 非递归查找最小元素\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::FindMinNon()\n{\n\tif (root == nullptr) {\n\t\treturn nullptr;\n\t}\n\tNode<DataType> *pre = root;\n\tNode<DataType> *cycleIter = pre->left;\n\twhile (cycleIter != nullptr) {\n\t\tpre = cycleIter;\n\t\tcycleIter = pre->left;\n\t}\n\treturn pre;\n}\n```\n\n- 非递归插入一个元素，返回位置\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * BinarySearchTree<DataType>::InsertElementNon(DataType inElement)\n{\n\tif (root == nullptr) {\n\t\troot = new Node<DataType>(inElement);\n\t\treturn root;\n\t}\n\tNode<DataType> *cycleIter = root;\n\twhile (1) {\n\t\tif (cycleIter->data == inElement) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\telse if (cycleIter->data > inElement) {\n\t\t\tif (cycleIter->left == nullptr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\telse {\n\t\t\tif (cycleIter->right == nullptr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcycleIter = cycleIter->right;\n\t\t}\n\t}\n\tNode<DataType> *newNode = new Node<DataType>(inElement);\n\tif (cycleIter->data > inElement) {\n\t\tcycleIter->left = newNode;\n\t}\n\telse {\n\t\tcycleIter->right = newNode;\n\t}\n\treturn newNode;\n}\n```\n\n- 析构函数\n\n```cpp\ntemplate <typename DataType>\nBinarySearchTree<DataType>::~BinarySearchTree()\n{\n\tMakeEmpty();\n}\n```\n\n\n\n","slug":"数据结构/数据结构之二叉查找树","published":1,"updated":"2018-06-13T14:06:59.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3f000wgsvn743erqxu","content":"<h2 id=\"二叉查找树基础\"><a href=\"#二叉查找树基础\" class=\"headerlink\" title=\"二叉查找树基础\"></a>二叉查找树基础</h2><p>二叉查找树是指一种满足以下性质的二叉树：</p>\n<pre><code>1. 对于每个节点X，该节点的所有左子树节点关键字值小于该节点关键字值\n2. 该节点的所有右子树节点关键字值大于该节点关键字值\n3. 关键字需要支持“&gt;”、“&lt;”、“==”运算符\n</code></pre><p>对于二叉树ADT，一般需要提供如下操作：</p>\n<ul>\n<li>清空二叉查找树：MakeEmpty</li>\n<li>查找某个节点：Find</li>\n<li>删除某个节点：DeleteElement</li>\n<li>查找最大值：FindMax</li>\n<li>查找最小值：FindMin</li>\n<li>插入一个节点：InsertElement</li>\n</ul>\n<p>二叉查找树的平均深度为O(log(N))，不过如果插入元素序列递增或者递减，二叉查找树将退化成单链表。</p>\n<h2 id=\"二叉查找树的实现\"><a href=\"#二叉查找树的实现\" class=\"headerlink\" title=\"二叉查找树的实现\"></a>二叉查找树的实现</h2><p>由于二叉查找树是一种统一排序的查找树，在进行删除插入时需要保持排序关系，以下为二叉查找树的基本结构定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *left;</span><br><span class=\"line\">\tNode *right;</span><br><span class=\"line\">\tNode(DataType inData): data(inData), left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBinarySearchTree(): root(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~BinarySearchTree();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空二叉查找树</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmptyNon</span><span class=\"params\">()</span></span>; <span class=\"comment\">//非递归清空二叉树</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * Find(DataType inElement); <span class=\"comment\">//查找某个元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindNon(DataType inElement); <span class=\"comment\">//非递归查找</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inElement)</span></span>; <span class=\"comment\">//删除一个节点</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindMax(); <span class=\"comment\">//查找最大元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindMaxNon(); <span class=\"comment\">//非递归查找最大元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindMin(); <span class=\"comment\">//查找最小元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindMinNon(); <span class=\"comment\">//非递归查找最小元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * InsertElementNon(DataType inElement); <span class=\"comment\">//非递归插入一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmptyCore</span><span class=\"params\">(Node&lt;DataType&gt; *inNode)</span></span>;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindCore(Node&lt;DataType&gt; *inNode, DataType inElement);</span><br><span class=\"line\">\t<span class=\"comment\">//删除一个节点</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * DeleteElementCore(Node&lt;DataType&gt; *inNode, DataType inElement);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindMaxCore(Node&lt;DataType&gt; *inNode);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindMinCore(Node&lt;DataType&gt; *inNode);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，二叉查找树的基本数据成员为根节点，初始化为空指针，通过插入节点函数建立二叉查找树，以下为各函数实现：</p>\n<ul>\n<li>递归清空核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinarySearchTree&lt;DataType&gt;::MakeEmptyCore(Node&lt;DataType&gt; *inNode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMakeEmptyCore(inNode-&gt;left);</span><br><span class=\"line\">\tMakeEmptyCore(inNode-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> inNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归清空入口函数，调用清空核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinarySearchTree&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmptyCore(root); root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归清空函数，采用某种非递归遍历函数思想即可</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinarySearchTree&lt;DataType&gt;::MakeEmptyNon()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;Node&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tnodeStack.push(cycleIter);</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; * tmp = nodeStack.top();</span><br><span class=\"line\">\t\t\tcycleIter = tmp-&gt;right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; nodeStack.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\troot = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; *BinarySearchTree&lt;DataType&gt;::FindCore(Node&lt;DataType&gt; *inNode, DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode-&gt;data == inElement) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;data &gt; inElement)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FindCore(inNode-&gt;left, inElement);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FindCore(inNode-&gt;right, inElement);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找某个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::Find(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> FindCore(root, inElement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归查找</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindNon(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inElement) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cycleIter-&gt;data &gt; inElement)&#123;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归删除节点函数核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::DeleteElementCore(Node&lt;DataType&gt; *inNode, DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;data &gt; inElement) &#123;</span><br><span class=\"line\">\t\tinNode-&gt;left = DeleteElementCore(inNode-&gt;left, inElement);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;data &lt; inElement) &#123;</span><br><span class=\"line\">\t\tinNode-&gt;right = DeleteElementCore(inNode-&gt;right, inElement);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inNode-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; inNode-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *tmp = FindMinCore(inNode-&gt;right);</span><br><span class=\"line\">\t\t\tinNode-&gt;data = tmp-&gt;data;</span><br><span class=\"line\">\t\t\tinNode-&gt;right = DeleteElementCore(inNode-&gt;right, inNode-&gt;data);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *tmp = inNode;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inNode-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tinNode = inNode-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tinNode = inNode-&gt;left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>  tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>删除一个节点，删除节点需要十分小心，删除需要分为几种情况讨论：</p>\n<ol>\n<li>第一种，叶节点，直接删除即可</li>\n<li>第二种，只有左子节点，直接父节点重新定向到左子节点</li>\n<li>第三种，只有右子节点，也是直接父节点重定向到右子节点</li>\n<li>第四种，有两个子节点，由于该节点值大于左子树而小于右子树，因此可以用左子树的最大值或者右子树的最小值交换，然后删除交换点，改点情况是1~3种情况的一种，即需要删除两次</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinarySearchTree&lt;DataType&gt;::DeleteElement(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\troot = DeleteElementCore(root, inElement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找最大元素核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMaxCore(Node&lt;DataType&gt; *inNode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FindMaxCore(inNode-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找最大元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMax()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> FindMaxCore(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归查找最大元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMaxNon()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *pre = root;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = pre-&gt;right;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tpre = cycleIter;</span><br><span class=\"line\">\t\tcycleIter = pre-&gt;right;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找最小元素核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMinCore(Node&lt;DataType&gt; *inNode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FindMinCore(inNode-&gt;left);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找最小元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> FindMinCore(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归查找最小元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMinNon()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *pre = root;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = pre-&gt;left;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tpre = cycleIter;</span><br><span class=\"line\">\t\tcycleIter = pre-&gt;left;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归插入一个元素，返回位置</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::InsertElementNon(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\troot = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inElement);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inElement) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cycleIter-&gt;data &gt; inElement) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inElement);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cycleIter-&gt;data &gt; inElement) &#123;</span><br><span class=\"line\">\t\tcycleIter-&gt;left = newNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcycleIter-&gt;right = newNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">BinarySearchTree&lt;DataType&gt;::~BinarySearchTree()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"二叉查找树基础\"><a href=\"#二叉查找树基础\" class=\"headerlink\" title=\"二叉查找树基础\"></a>二叉查找树基础</h2><p>二叉查找树是指一种满足以下性质的二叉树：</p>\n<pre><code>1. 对于每个节点X，该节点的所有左子树节点关键字值小于该节点关键字值\n2. 该节点的所有右子树节点关键字值大于该节点关键字值\n3. 关键字需要支持“&gt;”、“&lt;”、“==”运算符\n</code></pre><p>对于二叉树ADT，一般需要提供如下操作：</p>\n<ul>\n<li>清空二叉查找树：MakeEmpty</li>\n<li>查找某个节点：Find</li>\n<li>删除某个节点：DeleteElement</li>\n<li>查找最大值：FindMax</li>\n<li>查找最小值：FindMin</li>\n<li>插入一个节点：InsertElement</li>\n</ul>\n<p>二叉查找树的平均深度为O(log(N))，不过如果插入元素序列递增或者递减，二叉查找树将退化成单链表。</p>\n<h2 id=\"二叉查找树的实现\"><a href=\"#二叉查找树的实现\" class=\"headerlink\" title=\"二叉查找树的实现\"></a>二叉查找树的实现</h2><p>由于二叉查找树是一种统一排序的查找树，在进行删除插入时需要保持排序关系，以下为二叉查找树的基本结构定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *left;</span><br><span class=\"line\">\tNode *right;</span><br><span class=\"line\">\tNode(DataType inData): data(inData), left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchTree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBinarySearchTree(): root(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~BinarySearchTree();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空二叉查找树</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmptyNon</span><span class=\"params\">()</span></span>; <span class=\"comment\">//非递归清空二叉树</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * Find(DataType inElement); <span class=\"comment\">//查找某个元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindNon(DataType inElement); <span class=\"comment\">//非递归查找</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inElement)</span></span>; <span class=\"comment\">//删除一个节点</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindMax(); <span class=\"comment\">//查找最大元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindMaxNon(); <span class=\"comment\">//非递归查找最大元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindMin(); <span class=\"comment\">//查找最小元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * FindMinNon(); <span class=\"comment\">//非递归查找最小元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * InsertElementNon(DataType inElement); <span class=\"comment\">//非递归插入一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmptyCore</span><span class=\"params\">(Node&lt;DataType&gt; *inNode)</span></span>;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindCore(Node&lt;DataType&gt; *inNode, DataType inElement);</span><br><span class=\"line\">\t<span class=\"comment\">//删除一个节点</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; * DeleteElementCore(Node&lt;DataType&gt; *inNode, DataType inElement);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindMaxCore(Node&lt;DataType&gt; *inNode);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindMinCore(Node&lt;DataType&gt; *inNode);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，二叉查找树的基本数据成员为根节点，初始化为空指针，通过插入节点函数建立二叉查找树，以下为各函数实现：</p>\n<ul>\n<li>递归清空核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinarySearchTree&lt;DataType&gt;::MakeEmptyCore(Node&lt;DataType&gt; *inNode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMakeEmptyCore(inNode-&gt;left);</span><br><span class=\"line\">\tMakeEmptyCore(inNode-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> inNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归清空入口函数，调用清空核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinarySearchTree&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmptyCore(root); root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归清空函数，采用某种非递归遍历函数思想即可</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinarySearchTree&lt;DataType&gt;::MakeEmptyNon()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;Node&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tnodeStack.push(cycleIter);</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; * tmp = nodeStack.top();</span><br><span class=\"line\">\t\t\tcycleIter = tmp-&gt;right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; nodeStack.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\troot = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; *BinarySearchTree&lt;DataType&gt;::FindCore(Node&lt;DataType&gt; *inNode, DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode-&gt;data == inElement) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;data &gt; inElement)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FindCore(inNode-&gt;left, inElement);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FindCore(inNode-&gt;right, inElement);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找某个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::Find(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> FindCore(root, inElement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归查找</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindNon(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inElement) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cycleIter-&gt;data &gt; inElement)&#123;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归删除节点函数核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::DeleteElementCore(Node&lt;DataType&gt; *inNode, DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;data &gt; inElement) &#123;</span><br><span class=\"line\">\t\tinNode-&gt;left = DeleteElementCore(inNode-&gt;left, inElement);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;data &lt; inElement) &#123;</span><br><span class=\"line\">\t\tinNode-&gt;right = DeleteElementCore(inNode-&gt;right, inElement);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inNode-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; inNode-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *tmp = FindMinCore(inNode-&gt;right);</span><br><span class=\"line\">\t\t\tinNode-&gt;data = tmp-&gt;data;</span><br><span class=\"line\">\t\t\tinNode-&gt;right = DeleteElementCore(inNode-&gt;right, inNode-&gt;data);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *tmp = inNode;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inNode-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tinNode = inNode-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tinNode = inNode-&gt;left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>  tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>删除一个节点，删除节点需要十分小心，删除需要分为几种情况讨论：</p>\n<ol>\n<li>第一种，叶节点，直接删除即可</li>\n<li>第二种，只有左子节点，直接父节点重新定向到左子节点</li>\n<li>第三种，只有右子节点，也是直接父节点重定向到右子节点</li>\n<li>第四种，有两个子节点，由于该节点值大于左子树而小于右子树，因此可以用左子树的最大值或者右子树的最小值交换，然后删除交换点，改点情况是1~3种情况的一种，即需要删除两次</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinarySearchTree&lt;DataType&gt;::DeleteElement(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\troot = DeleteElementCore(root, inElement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找最大元素核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMaxCore(Node&lt;DataType&gt; *inNode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FindMaxCore(inNode-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找最大元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMax()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> FindMaxCore(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归查找最大元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMaxNon()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *pre = root;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = pre-&gt;right;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tpre = cycleIter;</span><br><span class=\"line\">\t\tcycleIter = pre-&gt;right;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找最小元素核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMinCore(Node&lt;DataType&gt; *inNode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inNode-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> FindMinCore(inNode-&gt;left);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>递归查找最小元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> FindMinCore(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归查找最小元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::FindMinNon()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *pre = root;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = pre-&gt;left;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tpre = cycleIter;</span><br><span class=\"line\">\t\tcycleIter = pre-&gt;left;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非递归插入一个元素，返回位置</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * BinarySearchTree&lt;DataType&gt;::InsertElementNon(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\troot = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inElement);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inElement) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cycleIter-&gt;data &gt; inElement) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inElement);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cycleIter-&gt;data &gt; inElement) &#123;</span><br><span class=\"line\">\t\tcycleIter-&gt;left = newNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcycleIter-&gt;right = newNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">BinarySearchTree&lt;DataType&gt;::~BinarySearchTree()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构之二项队列的定义与实现","urlname":"binomial-queue","date":"2018-03-10T13:06:50.000Z","mathjax":true,"copyright":true,"_content":"\n## 二项队列基础知识\n\n二项队列不是一棵堆序的树，而是堆序树的集合，称为森林。堆序树中的每一棵树叫着二项式树，高度为0的二项树是一棵单节点树，高度为k的二项树B<sub>k</sub>的树通过将一棵二项树B<sub>k-1</sub>附接到另一棵B<sub>k-1</sub>的根上构成，如下图所示为二项式树：[图片来源](http://blog.csdn.net/anlian523/article/details/78147542)\n\n![二项式树](/images/binomial-tree.png)\n\n每项棵的节点个数按照高从0到k二进制表示为(1)(10)(100)(1000)(10000).....\n\n二项树的递归定义如下：\n\n- 度为0的二项树只有一个节点\n- 度数为k的二项树有一个根节点，根节点下有k个子女，每个子女度数分别为k-1、k-2.....2、1、0的二项树的根\n\n\n\n度数为k（或者说高度为k）的二项式树一共有2<sup>k</sup>个节点，深度为d处节点是[二项式系数](https://zh.wikipedia.org/wiki/二項式係數#計算二項式係數)（k/d）组合中的C(k,d)。一棵二叉树的秩为从为从根节点开始到其叶节点中最长的一条树链上结点的个数。\n\n## 二项队列的操作\n\n按照二项队列的定义，二项队列中的每棵树为堆序树，因此最小元素可以通过遍历所有树的根节点来得到。由于对于N个节点的二项队列总共有logN棵不同的树,因此通常查找时间复杂度为O(logN)。对于合并操作，只要存在相同度的二项式树，就把根节点值较大的一颗成为根节点值较小二项树根的子树，合并操作最坏时间复杂度为O(logN)。插入操作和左式堆类似，可以转化为合并操作，即单节点二项树的合并，最坏时间复杂度O(logN)。删除操作也类似，删除后二项树分裂成二项队列，此时只需和原始二项队列合并即可，最坏时间复杂度O(logN)。总而言之，二项式队列的操作最终都可以采用合并操作完成，和左式堆非常类似。一般而言，对于一个初始为空的二项队列进行N次插入最坏时间复杂度为O(N)。\n\n下图为队列H1和H2的合并过程：[图片来源](http://blog.csdn.net/changyuanchn/article/details/14648463)\n\n![二项队列合并过程](/images/binomial-queue-merge.jpg)\n\n合并过程类似于二进制加法。\n\n## 二项队列的实现\n\n根据二项式树的特点，其一个节点可能有多个子节点，因此在存储时可能需要采用孩子兄弟表示法来存储。而且子节点按照子树的节点数量从大到小排序，如下图所示：[图片来源](http://blog.csdn.net/changyuanchn/article/details/14648463)\n\n![二项队列存储](/images/binomial-queue-structure.jpg)\n\n二项树合并图解：\n\n![二项树合并指针变化](/images/binomial-queue-merge-process.jpg)\n\n二项队列的操作主要有：\n\n- 合并：Merge\n- 删除最小值：DeleteMin\n- 插入节点：InsertElement\n- 清空二项队列：MakeEmpty\n- 查找最小元素：FindMin\n\n根据以上分析，有如下数据结构定义：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode * leftChild;\n\tNode * nextSibling;\n\tNode() : data(-1), leftChild(nullptr), nextSibling(nullptr) {}\n};\n\ntemplate <typename DataType>\nclass BinomialQueue\n{\npublic:\n\tBinomialQueue(int inCapacity);\n\t~BinomialQueue();\n\tvoid Merge(BinomialQueue<DataType> &otherQueue);\n\tvoid DeleteMin();\n\tvoid InsertElement(DataType inElement);\n\tvoid MakeEmpty();\n\tDataType FindMin();\nprivate:\n\tNode<DataType> *MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2);\n\tint capacity; //此处容量是指可以容纳树的数量\n\tint currentSize; //当前容纳树度数最高+1\n\tNode<DataType> **queue;\n};\n```\n\n以下分别实现各函数\n\n- 构造函数，根据输入最大容量建立二项队列，动态分配\n\n```cpp\ntemplate <typename DataType>\nBinomialQueue<DataType>::BinomialQueue(int inCapacity) : capacity(inCapacity), currentSize(0), queue(nullptr)\n{\n\tqueue = new Node<DataType> *[inCapacity];\n\tfor (int i = 0; i < inCapacity; i++) {\n\t\tqueue[i] = nullptr;\n\t}\n}\n```\n\n- 合并核心函数，即切换指针操作\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> *BinomialQueue<DataType>::MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2)\n{\n\tif (inTree1 == nullptr) return inTree2;\n\tif (inTree2 == nullptr) return inTree1;\n\tif (inTree1->data > inTree2->data) swap(inTree1, inTree2);\n\n\tinTree2->nextSibling = inTree1->leftChild;\n\tinTree1->leftChild = inTree2;\n\treturn inTree1;\n}\n```\n\n\n- 合并函数，采用笨办法而不是《数据结构与算法分析-C语言描述》一书中非常巧妙的办法，分2\\*2\\*2=8种情况讨论\n\n```cpp\ntemplate <typename DataType>\nvoid BinomialQueue<DataType>::Merge(BinomialQueue<DataType> &otherQueue)\n{\n\tint maxSize = currentSize > otherQueue.currentSize ? currentSize : otherQueue.currentSize;\n\tNode<DataType> *carry = nullptr;\n\tNode<DataType> *tree1 = nullptr, *tree2 = nullptr; \n\tfor (int i = 0; i < maxSize+1; i++) {\n\t\ttree1 = queue[i]; tree2 = otherQueue.queue[i];\n\t\tif (carry == nullptr) {\n\t\t\tif (tree1 != nullptr && tree2 != nullptr) {\n\t\t\t\tcarry = MergeCore(tree1, tree2);\n\t\t\t\tqueue[i] =  otherQueue.queue[i] = nullptr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueue[i] = tree1 != nullptr ? tree1 :tree2;\n\t\t\t\totherQueue.queue[i] = nullptr;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (tree1 != nullptr && tree2 != nullptr) {\n\t\t\t\tqueue[i] = carry;\n\t\t\t\tcarry = MergeCore(tree1, tree2);\n\t\t\t\totherQueue.queue[i] = nullptr;\n\t\t\t}\n\t\t\telse if (tree1 == nullptr && tree2 == nullptr){\n\t\t\t\tqueue[i] = carry;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttree1 = tree1 != nullptr ? tree1 : tree2;\n\t\t\t\tcarry = MergeCore(tree1, carry);\n\t\t\t\tqueue[i] =  otherQueue.queue[i] = nullptr;\n\t\t\t}\n\t\t}\n\t}\n\tif (queue[currentSize] != nullptr) ++currentSize;\n}\n```\n\n- 删除最小元素，先遍历找到最小元素然后删除根几点，将剩下的子树组成一个新的二项队列然后调用合并函数\n\n```cpp\ntemplate <typename DataType>\nvoid BinomialQueue<DataType>::DeleteMin()\n{\n\tDataType minElement = numeric_limits<DataType>::max(); //库函数，当前类型最大值\n\tint miniTreeIndex = -1;\n\tfor (int i = 0; i < currentSize; i++) {\n\t\tif (queue[i] != nullptr && minElement > queue[i]->data) {\n\t\t\tminiTreeIndex = i; minElement = queue[i]->data;\n\t\t}\n\t}\n\tif (miniTreeIndex == -1) throw \"Queue is empty!\"; //没有元素\n\t\n\tBinomialQueue<DataType> remainQueue(currentSize+5); \n\tremainQueue.currentSize = miniTreeIndex;\n\tNode<DataType> *startTree = queue[miniTreeIndex]->leftChild;\n\tfor (int i = miniTreeIndex-1; i >= 0; --i) {\n\t\tremainQueue.queue[i] = startTree;\n\t\tstartTree = startTree->nextSibling;\n\t\tremainQueue.queue[i]->nextSibling = nullptr;\n\t}\n\tdelete queue[miniTreeIndex]; queue[miniTreeIndex] = nullptr;\n\tMerge(remainQueue);\n}\n```\n\n- 插入元素，新建一个单树队列，调用Merge函数\n\n```cpp\ntemplate <typename DataType>\nvoid BinomialQueue<DataType>::InsertElement(DataType inElement)\n{\n\tBinomialQueue<DataType> remainQueue(currentSize+5); \n\tremainQueue.queue[0] = new Node<DataType>;\n\tremainQueue.queue[0]->data = inElement;\n\tremainQueue.currentSize = 1;\n\tMerge(remainQueue);\n}\n```\n\n- 清空二项式队列，非递归遍历，采用类似于二叉树中序遍历的方式\n\n```cpp\ntemplate <typename DataType>\nvoid BinomialQueue<DataType>::MakeEmpty()\n{\n\tfor (int i = 0; i < currentSize; i++) {\n\t\tstack<Node<DataType> *> nodeStack;\n\t\tNode<DataType> *cycleIter = queue[i];\n\t\twhile (cycleIter != nullptr || !nodeStack.empty()) {\n\t\t\twhile (cycleIter != nullptr) {\n\t\t\t\tnodeStack.push(cycleIter); cycleIter = cycleIter->leftChild;\n\t\t\t}\n\t\t\tif (!nodeStack.empty()) {\n\t\t\t\tNode<DataType> *tmp = nodeStack.top();\n\t\t\t\tnodeStack.pop();\n\t\t\t\tcycleIter = tmp->nextSibling;\n\t\t\t\tdelete tmp;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < currentSize; i++) {\n\t\tqueue[i] = nullptr;\n\t}\n\tcurrentSize = 0;\n}\n```\n\n- 查找最小元素\n\n```cpp\ntemplate <typename DataType>\nDataType BinomialQueue<DataType>::FindMin()\n{\n\tDataType minElement = numeric_limits<DataType>::max(); //库函数，当前类型最大值\n\tint miniTreeIndex = -1;\n\tfor (int i = 0; i < currentSize; i++) {\n\t\tif (queue[i] != nullptr && minElement > queue[i]->data) {\n\t\t\tminiTreeIndex = i; minElement = queue[i]->data;\n\t\t}\n\t}\n\tif (miniTreeIndex == -1) throw \"Queue is empty!\"; //没有元素\n\treturn minElement;\n}\n```\n\n- 析构函数，清空内存\n\n\n```cpp\ntemplate <typename DataType>\nBinomialQueue<DataType>::~BinomialQueue()\n{\n\tMakeEmpty(); delete [] queue;\n}\n```\n\n\n## 参考文章\n\n[二项队列](http://blog.csdn.net/changyuanchn/article/details/14648463)\n\n[二项堆(一)之图文解析和C语言的实现](http://www.cnblogs.com/skywang12345/p/3655900.html)\n\n","source":"_posts/数据结构/数据结构之二项队列的定义与实现.md","raw":"---\ntitle: 数据结构之二项队列的定义与实现\nurlname: binomial-queue\ndate: 2018-03-10 21:06:50\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 二项队列基础知识\n\n二项队列不是一棵堆序的树，而是堆序树的集合，称为森林。堆序树中的每一棵树叫着二项式树，高度为0的二项树是一棵单节点树，高度为k的二项树B<sub>k</sub>的树通过将一棵二项树B<sub>k-1</sub>附接到另一棵B<sub>k-1</sub>的根上构成，如下图所示为二项式树：[图片来源](http://blog.csdn.net/anlian523/article/details/78147542)\n\n![二项式树](/images/binomial-tree.png)\n\n每项棵的节点个数按照高从0到k二进制表示为(1)(10)(100)(1000)(10000).....\n\n二项树的递归定义如下：\n\n- 度为0的二项树只有一个节点\n- 度数为k的二项树有一个根节点，根节点下有k个子女，每个子女度数分别为k-1、k-2.....2、1、0的二项树的根\n\n\n\n度数为k（或者说高度为k）的二项式树一共有2<sup>k</sup>个节点，深度为d处节点是[二项式系数](https://zh.wikipedia.org/wiki/二項式係數#計算二項式係數)（k/d）组合中的C(k,d)。一棵二叉树的秩为从为从根节点开始到其叶节点中最长的一条树链上结点的个数。\n\n## 二项队列的操作\n\n按照二项队列的定义，二项队列中的每棵树为堆序树，因此最小元素可以通过遍历所有树的根节点来得到。由于对于N个节点的二项队列总共有logN棵不同的树,因此通常查找时间复杂度为O(logN)。对于合并操作，只要存在相同度的二项式树，就把根节点值较大的一颗成为根节点值较小二项树根的子树，合并操作最坏时间复杂度为O(logN)。插入操作和左式堆类似，可以转化为合并操作，即单节点二项树的合并，最坏时间复杂度O(logN)。删除操作也类似，删除后二项树分裂成二项队列，此时只需和原始二项队列合并即可，最坏时间复杂度O(logN)。总而言之，二项式队列的操作最终都可以采用合并操作完成，和左式堆非常类似。一般而言，对于一个初始为空的二项队列进行N次插入最坏时间复杂度为O(N)。\n\n下图为队列H1和H2的合并过程：[图片来源](http://blog.csdn.net/changyuanchn/article/details/14648463)\n\n![二项队列合并过程](/images/binomial-queue-merge.jpg)\n\n合并过程类似于二进制加法。\n\n## 二项队列的实现\n\n根据二项式树的特点，其一个节点可能有多个子节点，因此在存储时可能需要采用孩子兄弟表示法来存储。而且子节点按照子树的节点数量从大到小排序，如下图所示：[图片来源](http://blog.csdn.net/changyuanchn/article/details/14648463)\n\n![二项队列存储](/images/binomial-queue-structure.jpg)\n\n二项树合并图解：\n\n![二项树合并指针变化](/images/binomial-queue-merge-process.jpg)\n\n二项队列的操作主要有：\n\n- 合并：Merge\n- 删除最小值：DeleteMin\n- 插入节点：InsertElement\n- 清空二项队列：MakeEmpty\n- 查找最小元素：FindMin\n\n根据以上分析，有如下数据结构定义：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode * leftChild;\n\tNode * nextSibling;\n\tNode() : data(-1), leftChild(nullptr), nextSibling(nullptr) {}\n};\n\ntemplate <typename DataType>\nclass BinomialQueue\n{\npublic:\n\tBinomialQueue(int inCapacity);\n\t~BinomialQueue();\n\tvoid Merge(BinomialQueue<DataType> &otherQueue);\n\tvoid DeleteMin();\n\tvoid InsertElement(DataType inElement);\n\tvoid MakeEmpty();\n\tDataType FindMin();\nprivate:\n\tNode<DataType> *MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2);\n\tint capacity; //此处容量是指可以容纳树的数量\n\tint currentSize; //当前容纳树度数最高+1\n\tNode<DataType> **queue;\n};\n```\n\n以下分别实现各函数\n\n- 构造函数，根据输入最大容量建立二项队列，动态分配\n\n```cpp\ntemplate <typename DataType>\nBinomialQueue<DataType>::BinomialQueue(int inCapacity) : capacity(inCapacity), currentSize(0), queue(nullptr)\n{\n\tqueue = new Node<DataType> *[inCapacity];\n\tfor (int i = 0; i < inCapacity; i++) {\n\t\tqueue[i] = nullptr;\n\t}\n}\n```\n\n- 合并核心函数，即切换指针操作\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> *BinomialQueue<DataType>::MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2)\n{\n\tif (inTree1 == nullptr) return inTree2;\n\tif (inTree2 == nullptr) return inTree1;\n\tif (inTree1->data > inTree2->data) swap(inTree1, inTree2);\n\n\tinTree2->nextSibling = inTree1->leftChild;\n\tinTree1->leftChild = inTree2;\n\treturn inTree1;\n}\n```\n\n\n- 合并函数，采用笨办法而不是《数据结构与算法分析-C语言描述》一书中非常巧妙的办法，分2\\*2\\*2=8种情况讨论\n\n```cpp\ntemplate <typename DataType>\nvoid BinomialQueue<DataType>::Merge(BinomialQueue<DataType> &otherQueue)\n{\n\tint maxSize = currentSize > otherQueue.currentSize ? currentSize : otherQueue.currentSize;\n\tNode<DataType> *carry = nullptr;\n\tNode<DataType> *tree1 = nullptr, *tree2 = nullptr; \n\tfor (int i = 0; i < maxSize+1; i++) {\n\t\ttree1 = queue[i]; tree2 = otherQueue.queue[i];\n\t\tif (carry == nullptr) {\n\t\t\tif (tree1 != nullptr && tree2 != nullptr) {\n\t\t\t\tcarry = MergeCore(tree1, tree2);\n\t\t\t\tqueue[i] =  otherQueue.queue[i] = nullptr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueue[i] = tree1 != nullptr ? tree1 :tree2;\n\t\t\t\totherQueue.queue[i] = nullptr;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (tree1 != nullptr && tree2 != nullptr) {\n\t\t\t\tqueue[i] = carry;\n\t\t\t\tcarry = MergeCore(tree1, tree2);\n\t\t\t\totherQueue.queue[i] = nullptr;\n\t\t\t}\n\t\t\telse if (tree1 == nullptr && tree2 == nullptr){\n\t\t\t\tqueue[i] = carry;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttree1 = tree1 != nullptr ? tree1 : tree2;\n\t\t\t\tcarry = MergeCore(tree1, carry);\n\t\t\t\tqueue[i] =  otherQueue.queue[i] = nullptr;\n\t\t\t}\n\t\t}\n\t}\n\tif (queue[currentSize] != nullptr) ++currentSize;\n}\n```\n\n- 删除最小元素，先遍历找到最小元素然后删除根几点，将剩下的子树组成一个新的二项队列然后调用合并函数\n\n```cpp\ntemplate <typename DataType>\nvoid BinomialQueue<DataType>::DeleteMin()\n{\n\tDataType minElement = numeric_limits<DataType>::max(); //库函数，当前类型最大值\n\tint miniTreeIndex = -1;\n\tfor (int i = 0; i < currentSize; i++) {\n\t\tif (queue[i] != nullptr && minElement > queue[i]->data) {\n\t\t\tminiTreeIndex = i; minElement = queue[i]->data;\n\t\t}\n\t}\n\tif (miniTreeIndex == -1) throw \"Queue is empty!\"; //没有元素\n\t\n\tBinomialQueue<DataType> remainQueue(currentSize+5); \n\tremainQueue.currentSize = miniTreeIndex;\n\tNode<DataType> *startTree = queue[miniTreeIndex]->leftChild;\n\tfor (int i = miniTreeIndex-1; i >= 0; --i) {\n\t\tremainQueue.queue[i] = startTree;\n\t\tstartTree = startTree->nextSibling;\n\t\tremainQueue.queue[i]->nextSibling = nullptr;\n\t}\n\tdelete queue[miniTreeIndex]; queue[miniTreeIndex] = nullptr;\n\tMerge(remainQueue);\n}\n```\n\n- 插入元素，新建一个单树队列，调用Merge函数\n\n```cpp\ntemplate <typename DataType>\nvoid BinomialQueue<DataType>::InsertElement(DataType inElement)\n{\n\tBinomialQueue<DataType> remainQueue(currentSize+5); \n\tremainQueue.queue[0] = new Node<DataType>;\n\tremainQueue.queue[0]->data = inElement;\n\tremainQueue.currentSize = 1;\n\tMerge(remainQueue);\n}\n```\n\n- 清空二项式队列，非递归遍历，采用类似于二叉树中序遍历的方式\n\n```cpp\ntemplate <typename DataType>\nvoid BinomialQueue<DataType>::MakeEmpty()\n{\n\tfor (int i = 0; i < currentSize; i++) {\n\t\tstack<Node<DataType> *> nodeStack;\n\t\tNode<DataType> *cycleIter = queue[i];\n\t\twhile (cycleIter != nullptr || !nodeStack.empty()) {\n\t\t\twhile (cycleIter != nullptr) {\n\t\t\t\tnodeStack.push(cycleIter); cycleIter = cycleIter->leftChild;\n\t\t\t}\n\t\t\tif (!nodeStack.empty()) {\n\t\t\t\tNode<DataType> *tmp = nodeStack.top();\n\t\t\t\tnodeStack.pop();\n\t\t\t\tcycleIter = tmp->nextSibling;\n\t\t\t\tdelete tmp;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < currentSize; i++) {\n\t\tqueue[i] = nullptr;\n\t}\n\tcurrentSize = 0;\n}\n```\n\n- 查找最小元素\n\n```cpp\ntemplate <typename DataType>\nDataType BinomialQueue<DataType>::FindMin()\n{\n\tDataType minElement = numeric_limits<DataType>::max(); //库函数，当前类型最大值\n\tint miniTreeIndex = -1;\n\tfor (int i = 0; i < currentSize; i++) {\n\t\tif (queue[i] != nullptr && minElement > queue[i]->data) {\n\t\t\tminiTreeIndex = i; minElement = queue[i]->data;\n\t\t}\n\t}\n\tif (miniTreeIndex == -1) throw \"Queue is empty!\"; //没有元素\n\treturn minElement;\n}\n```\n\n- 析构函数，清空内存\n\n\n```cpp\ntemplate <typename DataType>\nBinomialQueue<DataType>::~BinomialQueue()\n{\n\tMakeEmpty(); delete [] queue;\n}\n```\n\n\n## 参考文章\n\n[二项队列](http://blog.csdn.net/changyuanchn/article/details/14648463)\n\n[二项堆(一)之图文解析和C语言的实现](http://www.cnblogs.com/skywang12345/p/3655900.html)\n\n","slug":"数据结构/数据结构之二项队列的定义与实现","published":1,"updated":"2018-06-13T14:06:17.761Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3h0010gsvn334qdkgd","content":"<h2 id=\"二项队列基础知识\"><a href=\"#二项队列基础知识\" class=\"headerlink\" title=\"二项队列基础知识\"></a>二项队列基础知识</h2><p>二项队列不是一棵堆序的树，而是堆序树的集合，称为森林。堆序树中的每一棵树叫着二项式树，高度为0的二项树是一棵单节点树，高度为k的二项树B<sub>k</sub>的树通过将一棵二项树B<sub>k-1</sub>附接到另一棵B<sub>k-1</sub>的根上构成，如下图所示为二项式树：<a href=\"http://blog.csdn.net/anlian523/article/details/78147542\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binomial-tree.png\" alt=\"二项式树\"></p>\n<p>每项棵的节点个数按照高从0到k二进制表示为(1)(10)(100)(1000)(10000)…..</p>\n<p>二项树的递归定义如下：</p>\n<ul>\n<li>度为0的二项树只有一个节点</li>\n<li>度数为k的二项树有一个根节点，根节点下有k个子女，每个子女度数分别为k-1、k-2…..2、1、0的二项树的根</li>\n</ul>\n<p>度数为k（或者说高度为k）的二项式树一共有2<sup>k</sup>个节点，深度为d处节点是<a href=\"https://zh.wikipedia.org/wiki/二項式係數#計算二項式係數\" target=\"_blank\" rel=\"noopener\">二项式系数</a>（k/d）组合中的C(k,d)。一棵二叉树的秩为从为从根节点开始到其叶节点中最长的一条树链上结点的个数。</p>\n<h2 id=\"二项队列的操作\"><a href=\"#二项队列的操作\" class=\"headerlink\" title=\"二项队列的操作\"></a>二项队列的操作</h2><p>按照二项队列的定义，二项队列中的每棵树为堆序树，因此最小元素可以通过遍历所有树的根节点来得到。由于对于N个节点的二项队列总共有logN棵不同的树,因此通常查找时间复杂度为O(logN)。对于合并操作，只要存在相同度的二项式树，就把根节点值较大的一颗成为根节点值较小二项树根的子树，合并操作最坏时间复杂度为O(logN)。插入操作和左式堆类似，可以转化为合并操作，即单节点二项树的合并，最坏时间复杂度O(logN)。删除操作也类似，删除后二项树分裂成二项队列，此时只需和原始二项队列合并即可，最坏时间复杂度O(logN)。总而言之，二项式队列的操作最终都可以采用合并操作完成，和左式堆非常类似。一般而言，对于一个初始为空的二项队列进行N次插入最坏时间复杂度为O(N)。</p>\n<p>下图为队列H1和H2的合并过程：<a href=\"http://blog.csdn.net/changyuanchn/article/details/14648463\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binomial-queue-merge.jpg\" alt=\"二项队列合并过程\"></p>\n<p>合并过程类似于二进制加法。</p>\n<h2 id=\"二项队列的实现\"><a href=\"#二项队列的实现\" class=\"headerlink\" title=\"二项队列的实现\"></a>二项队列的实现</h2><p>根据二项式树的特点，其一个节点可能有多个子节点，因此在存储时可能需要采用孩子兄弟表示法来存储。而且子节点按照子树的节点数量从大到小排序，如下图所示：<a href=\"http://blog.csdn.net/changyuanchn/article/details/14648463\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binomial-queue-structure.jpg\" alt=\"二项队列存储\"></p>\n<p>二项树合并图解：</p>\n<p><img src=\"/images/binomial-queue-merge-process.jpg\" alt=\"二项树合并指针变化\"></p>\n<p>二项队列的操作主要有：</p>\n<ul>\n<li>合并：Merge</li>\n<li>删除最小值：DeleteMin</li>\n<li>插入节点：InsertElement</li>\n<li>清空二项队列：MakeEmpty</li>\n<li>查找最小元素：FindMin</li>\n</ul>\n<p>根据以上分析，有如下数据结构定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode * leftChild;</span><br><span class=\"line\">\tNode * nextSibling;</span><br><span class=\"line\">\tNode() : data(<span class=\"number\">-1</span>), leftChild(<span class=\"literal\">nullptr</span>), nextSibling(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinomialQueue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBinomialQueue(<span class=\"keyword\">int</span> inCapacity);</span><br><span class=\"line\">\t~BinomialQueue();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(BinomialQueue&lt;DataType&gt; &amp;otherQueue)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inElement)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">FindMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; *MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> capacity; <span class=\"comment\">//此处容量是指可以容纳树的数量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> currentSize; <span class=\"comment\">//当前容纳树度数最高+1</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; **<span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以下分别实现各函数</p>\n<ul>\n<li>构造函数，根据输入最大容量建立二项队列，动态分配</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">BinomialQueue&lt;DataType&gt;::BinomialQueue(<span class=\"keyword\">int</span> inCapacity) : capacity(inCapacity), currentSize(<span class=\"number\">0</span>), <span class=\"built_in\">queue</span>(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">queue</span> = <span class=\"keyword\">new</span> Node&lt;DataType&gt; *[inCapacity];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; inCapacity; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并核心函数，即切换指针操作</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; *BinomialQueue&lt;DataType&gt;::MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1 == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> inTree2;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree2 == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;data &gt; inTree2-&gt;data) swap(inTree1, inTree2);</span><br><span class=\"line\"></span><br><span class=\"line\">\tinTree2-&gt;nextSibling = inTree1-&gt;leftChild;</span><br><span class=\"line\">\tinTree1-&gt;leftChild = inTree2;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并函数，采用笨办法而不是《数据结构与算法分析-C语言描述》一书中非常巧妙的办法，分2*2*2=8种情况讨论</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinomialQueue&lt;DataType&gt;::Merge(BinomialQueue&lt;DataType&gt; &amp;otherQueue)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxSize = currentSize &gt; otherQueue.currentSize ? currentSize : otherQueue.currentSize;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *carry = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tree1 = <span class=\"literal\">nullptr</span>, *tree2 = <span class=\"literal\">nullptr</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxSize+<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\ttree1 = <span class=\"built_in\">queue</span>[i]; tree2 = otherQueue.<span class=\"built_in\">queue</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (carry == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tree1 != <span class=\"literal\">nullptr</span> &amp;&amp; tree2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tcarry = MergeCore(tree1, tree2);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] =  otherQueue.<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] = tree1 != <span class=\"literal\">nullptr</span> ? tree1 :tree2;</span><br><span class=\"line\">\t\t\t\totherQueue.<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tree1 != <span class=\"literal\">nullptr</span> &amp;&amp; tree2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] = carry;</span><br><span class=\"line\">\t\t\t\tcarry = MergeCore(tree1, tree2);</span><br><span class=\"line\">\t\t\t\totherQueue.<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tree1 == <span class=\"literal\">nullptr</span> &amp;&amp; tree2 == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] = carry;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\ttree1 = tree1 != <span class=\"literal\">nullptr</span> ? tree1 : tree2;</span><br><span class=\"line\">\t\t\t\tcarry = MergeCore(tree1, carry);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] =  otherQueue.<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[currentSize] != <span class=\"literal\">nullptr</span>) ++currentSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除最小元素，先遍历找到最小元素然后删除根几点，将剩下的子树组成一个新的二项队列然后调用合并函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinomialQueue&lt;DataType&gt;::DeleteMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDataType minElement = numeric_limits&lt;DataType&gt;::max(); <span class=\"comment\">//库函数，当前类型最大值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> miniTreeIndex = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[i] != <span class=\"literal\">nullptr</span> &amp;&amp; minElement &gt; <span class=\"built_in\">queue</span>[i]-&gt;data) &#123;</span><br><span class=\"line\">\t\t\tminiTreeIndex = i; minElement = <span class=\"built_in\">queue</span>[i]-&gt;data;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (miniTreeIndex == <span class=\"number\">-1</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>; <span class=\"comment\">//没有元素</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBinomialQueue&lt;DataType&gt; remainQueue(currentSize+<span class=\"number\">5</span>); </span><br><span class=\"line\">\tremainQueue.currentSize = miniTreeIndex;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *startTree = <span class=\"built_in\">queue</span>[miniTreeIndex]-&gt;leftChild;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = miniTreeIndex<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">\t\tremainQueue.<span class=\"built_in\">queue</span>[i] = startTree;</span><br><span class=\"line\">\t\tstartTree = startTree-&gt;nextSibling;</span><br><span class=\"line\">\t\tremainQueue.<span class=\"built_in\">queue</span>[i]-&gt;nextSibling = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> <span class=\"built_in\">queue</span>[miniTreeIndex]; <span class=\"built_in\">queue</span>[miniTreeIndex] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\tMerge(remainQueue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入元素，新建一个单树队列，调用Merge函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinomialQueue&lt;DataType&gt;::InsertElement(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinomialQueue&lt;DataType&gt; remainQueue(currentSize+<span class=\"number\">5</span>); </span><br><span class=\"line\">\tremainQueue.<span class=\"built_in\">queue</span>[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> Node&lt;DataType&gt;;</span><br><span class=\"line\">\tremainQueue.<span class=\"built_in\">queue</span>[<span class=\"number\">0</span>]-&gt;data = inElement;</span><br><span class=\"line\">\tremainQueue.currentSize = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tMerge(remainQueue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空二项式队列，非递归遍历，采用类似于二叉树中序遍历的方式</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinomialQueue&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">stack</span>&lt;Node&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\t\tNode&lt;DataType&gt; *cycleIter = <span class=\"built_in\">queue</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tnodeStack.push(cycleIter); cycleIter = cycleIter-&gt;leftChild;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\t\tNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">\t\t\t\tnodeStack.pop();</span><br><span class=\"line\">\t\t\t\tcycleIter = tmp-&gt;nextSibling;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcurrentSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找最小元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType BinomialQueue&lt;DataType&gt;::FindMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDataType minElement = numeric_limits&lt;DataType&gt;::max(); <span class=\"comment\">//库函数，当前类型最大值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> miniTreeIndex = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[i] != <span class=\"literal\">nullptr</span> &amp;&amp; minElement &gt; <span class=\"built_in\">queue</span>[i]-&gt;data) &#123;</span><br><span class=\"line\">\t\t\tminiTreeIndex = i; minElement = <span class=\"built_in\">queue</span>[i]-&gt;data;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (miniTreeIndex == <span class=\"number\">-1</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>; <span class=\"comment\">//没有元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> minElement;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空内存</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">BinomialQueue&lt;DataType&gt;::~BinomialQueue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty(); <span class=\"keyword\">delete</span> [] <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://blog.csdn.net/changyuanchn/article/details/14648463\" target=\"_blank\" rel=\"noopener\">二项队列</a></p>\n<p><a href=\"http://www.cnblogs.com/skywang12345/p/3655900.html\" target=\"_blank\" rel=\"noopener\">二项堆(一)之图文解析和C语言的实现</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"二项队列基础知识\"><a href=\"#二项队列基础知识\" class=\"headerlink\" title=\"二项队列基础知识\"></a>二项队列基础知识</h2><p>二项队列不是一棵堆序的树，而是堆序树的集合，称为森林。堆序树中的每一棵树叫着二项式树，高度为0的二项树是一棵单节点树，高度为k的二项树B<sub>k</sub>的树通过将一棵二项树B<sub>k-1</sub>附接到另一棵B<sub>k-1</sub>的根上构成，如下图所示为二项式树：<a href=\"http://blog.csdn.net/anlian523/article/details/78147542\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binomial-tree.png\" alt=\"二项式树\"></p>\n<p>每项棵的节点个数按照高从0到k二进制表示为(1)(10)(100)(1000)(10000)…..</p>\n<p>二项树的递归定义如下：</p>\n<ul>\n<li>度为0的二项树只有一个节点</li>\n<li>度数为k的二项树有一个根节点，根节点下有k个子女，每个子女度数分别为k-1、k-2…..2、1、0的二项树的根</li>\n</ul>\n<p>度数为k（或者说高度为k）的二项式树一共有2<sup>k</sup>个节点，深度为d处节点是<a href=\"https://zh.wikipedia.org/wiki/二項式係數#計算二項式係數\" target=\"_blank\" rel=\"noopener\">二项式系数</a>（k/d）组合中的C(k,d)。一棵二叉树的秩为从为从根节点开始到其叶节点中最长的一条树链上结点的个数。</p>\n<h2 id=\"二项队列的操作\"><a href=\"#二项队列的操作\" class=\"headerlink\" title=\"二项队列的操作\"></a>二项队列的操作</h2><p>按照二项队列的定义，二项队列中的每棵树为堆序树，因此最小元素可以通过遍历所有树的根节点来得到。由于对于N个节点的二项队列总共有logN棵不同的树,因此通常查找时间复杂度为O(logN)。对于合并操作，只要存在相同度的二项式树，就把根节点值较大的一颗成为根节点值较小二项树根的子树，合并操作最坏时间复杂度为O(logN)。插入操作和左式堆类似，可以转化为合并操作，即单节点二项树的合并，最坏时间复杂度O(logN)。删除操作也类似，删除后二项树分裂成二项队列，此时只需和原始二项队列合并即可，最坏时间复杂度O(logN)。总而言之，二项式队列的操作最终都可以采用合并操作完成，和左式堆非常类似。一般而言，对于一个初始为空的二项队列进行N次插入最坏时间复杂度为O(N)。</p>\n<p>下图为队列H1和H2的合并过程：<a href=\"http://blog.csdn.net/changyuanchn/article/details/14648463\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binomial-queue-merge.jpg\" alt=\"二项队列合并过程\"></p>\n<p>合并过程类似于二进制加法。</p>\n<h2 id=\"二项队列的实现\"><a href=\"#二项队列的实现\" class=\"headerlink\" title=\"二项队列的实现\"></a>二项队列的实现</h2><p>根据二项式树的特点，其一个节点可能有多个子节点，因此在存储时可能需要采用孩子兄弟表示法来存储。而且子节点按照子树的节点数量从大到小排序，如下图所示：<a href=\"http://blog.csdn.net/changyuanchn/article/details/14648463\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binomial-queue-structure.jpg\" alt=\"二项队列存储\"></p>\n<p>二项树合并图解：</p>\n<p><img src=\"/images/binomial-queue-merge-process.jpg\" alt=\"二项树合并指针变化\"></p>\n<p>二项队列的操作主要有：</p>\n<ul>\n<li>合并：Merge</li>\n<li>删除最小值：DeleteMin</li>\n<li>插入节点：InsertElement</li>\n<li>清空二项队列：MakeEmpty</li>\n<li>查找最小元素：FindMin</li>\n</ul>\n<p>根据以上分析，有如下数据结构定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode * leftChild;</span><br><span class=\"line\">\tNode * nextSibling;</span><br><span class=\"line\">\tNode() : data(<span class=\"number\">-1</span>), leftChild(<span class=\"literal\">nullptr</span>), nextSibling(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinomialQueue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBinomialQueue(<span class=\"keyword\">int</span> inCapacity);</span><br><span class=\"line\">\t~BinomialQueue();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(BinomialQueue&lt;DataType&gt; &amp;otherQueue)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inElement)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">FindMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; *MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> capacity; <span class=\"comment\">//此处容量是指可以容纳树的数量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> currentSize; <span class=\"comment\">//当前容纳树度数最高+1</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; **<span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以下分别实现各函数</p>\n<ul>\n<li>构造函数，根据输入最大容量建立二项队列，动态分配</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">BinomialQueue&lt;DataType&gt;::BinomialQueue(<span class=\"keyword\">int</span> inCapacity) : capacity(inCapacity), currentSize(<span class=\"number\">0</span>), <span class=\"built_in\">queue</span>(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">queue</span> = <span class=\"keyword\">new</span> Node&lt;DataType&gt; *[inCapacity];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; inCapacity; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并核心函数，即切换指针操作</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; *BinomialQueue&lt;DataType&gt;::MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1 == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> inTree2;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree2 == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;data &gt; inTree2-&gt;data) swap(inTree1, inTree2);</span><br><span class=\"line\"></span><br><span class=\"line\">\tinTree2-&gt;nextSibling = inTree1-&gt;leftChild;</span><br><span class=\"line\">\tinTree1-&gt;leftChild = inTree2;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并函数，采用笨办法而不是《数据结构与算法分析-C语言描述》一书中非常巧妙的办法，分2*2*2=8种情况讨论</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinomialQueue&lt;DataType&gt;::Merge(BinomialQueue&lt;DataType&gt; &amp;otherQueue)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxSize = currentSize &gt; otherQueue.currentSize ? currentSize : otherQueue.currentSize;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *carry = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tree1 = <span class=\"literal\">nullptr</span>, *tree2 = <span class=\"literal\">nullptr</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxSize+<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\ttree1 = <span class=\"built_in\">queue</span>[i]; tree2 = otherQueue.<span class=\"built_in\">queue</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (carry == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tree1 != <span class=\"literal\">nullptr</span> &amp;&amp; tree2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tcarry = MergeCore(tree1, tree2);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] =  otherQueue.<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] = tree1 != <span class=\"literal\">nullptr</span> ? tree1 :tree2;</span><br><span class=\"line\">\t\t\t\totherQueue.<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tree1 != <span class=\"literal\">nullptr</span> &amp;&amp; tree2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] = carry;</span><br><span class=\"line\">\t\t\t\tcarry = MergeCore(tree1, tree2);</span><br><span class=\"line\">\t\t\t\totherQueue.<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tree1 == <span class=\"literal\">nullptr</span> &amp;&amp; tree2 == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] = carry;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\ttree1 = tree1 != <span class=\"literal\">nullptr</span> ? tree1 : tree2;</span><br><span class=\"line\">\t\t\t\tcarry = MergeCore(tree1, carry);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">queue</span>[i] =  otherQueue.<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[currentSize] != <span class=\"literal\">nullptr</span>) ++currentSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除最小元素，先遍历找到最小元素然后删除根几点，将剩下的子树组成一个新的二项队列然后调用合并函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinomialQueue&lt;DataType&gt;::DeleteMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDataType minElement = numeric_limits&lt;DataType&gt;::max(); <span class=\"comment\">//库函数，当前类型最大值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> miniTreeIndex = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[i] != <span class=\"literal\">nullptr</span> &amp;&amp; minElement &gt; <span class=\"built_in\">queue</span>[i]-&gt;data) &#123;</span><br><span class=\"line\">\t\t\tminiTreeIndex = i; minElement = <span class=\"built_in\">queue</span>[i]-&gt;data;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (miniTreeIndex == <span class=\"number\">-1</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>; <span class=\"comment\">//没有元素</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBinomialQueue&lt;DataType&gt; remainQueue(currentSize+<span class=\"number\">5</span>); </span><br><span class=\"line\">\tremainQueue.currentSize = miniTreeIndex;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *startTree = <span class=\"built_in\">queue</span>[miniTreeIndex]-&gt;leftChild;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = miniTreeIndex<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">\t\tremainQueue.<span class=\"built_in\">queue</span>[i] = startTree;</span><br><span class=\"line\">\t\tstartTree = startTree-&gt;nextSibling;</span><br><span class=\"line\">\t\tremainQueue.<span class=\"built_in\">queue</span>[i]-&gt;nextSibling = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> <span class=\"built_in\">queue</span>[miniTreeIndex]; <span class=\"built_in\">queue</span>[miniTreeIndex] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\tMerge(remainQueue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入元素，新建一个单树队列，调用Merge函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinomialQueue&lt;DataType&gt;::InsertElement(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBinomialQueue&lt;DataType&gt; remainQueue(currentSize+<span class=\"number\">5</span>); </span><br><span class=\"line\">\tremainQueue.<span class=\"built_in\">queue</span>[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> Node&lt;DataType&gt;;</span><br><span class=\"line\">\tremainQueue.<span class=\"built_in\">queue</span>[<span class=\"number\">0</span>]-&gt;data = inElement;</span><br><span class=\"line\">\tremainQueue.currentSize = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tMerge(remainQueue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空二项式队列，非递归遍历，采用类似于二叉树中序遍历的方式</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> BinomialQueue&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">stack</span>&lt;Node&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\t\tNode&lt;DataType&gt; *cycleIter = <span class=\"built_in\">queue</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tnodeStack.push(cycleIter); cycleIter = cycleIter-&gt;leftChild;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\t\tNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">\t\t\t\tnodeStack.pop();</span><br><span class=\"line\">\t\t\t\tcycleIter = tmp-&gt;nextSibling;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">queue</span>[i] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcurrentSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找最小元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType BinomialQueue&lt;DataType&gt;::FindMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDataType minElement = numeric_limits&lt;DataType&gt;::max(); <span class=\"comment\">//库函数，当前类型最大值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> miniTreeIndex = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[i] != <span class=\"literal\">nullptr</span> &amp;&amp; minElement &gt; <span class=\"built_in\">queue</span>[i]-&gt;data) &#123;</span><br><span class=\"line\">\t\t\tminiTreeIndex = i; minElement = <span class=\"built_in\">queue</span>[i]-&gt;data;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (miniTreeIndex == <span class=\"number\">-1</span>) <span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>; <span class=\"comment\">//没有元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> minElement;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空内存</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">BinomialQueue&lt;DataType&gt;::~BinomialQueue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty(); <span class=\"keyword\">delete</span> [] <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://blog.csdn.net/changyuanchn/article/details/14648463\" target=\"_blank\" rel=\"noopener\">二项队列</a></p>\n<p><a href=\"http://www.cnblogs.com/skywang12345/p/3655900.html\" target=\"_blank\" rel=\"noopener\">二项堆(一)之图文解析和C语言的实现</a></p>\n"},{"title":"数据结构之单向链表-指针实现","urlname":"one-way-linked-list","date":"2018-03-04T08:05:13.000Z","mathjax":true,"copyright":true,"_content":"\n## 基础知识\n\n链表是一种线性表数据结构，其和顺序表的最大区别是链表在内存中无需连续存储，因此链表节点需要增加指针域（对于无指针的编程语言可能需要通过游标实现）用来指向下一个元素的内存地址。单向链表是链表的一种，其特点是链表的链接方向是单向的，访问单向链表的全部元素必须从头部开始依次访问。在单向链表的实现中，为了便于对表头元素进行插入、删除等操作，一般定义一个表头(header)或者称为哑节点(dummy node)，且默认表头在位置0处。在单向链表ADT中，一般至少需要需要实现以下操作：\n\n- 清空整个链表：MakeEmpty\n- 查找某个元素：FindElement\n- 删除一个元素：DeleteElement\n- 插入一个元素：InsertElement\n\n在C++标准模板库(STL)中，list实现了一种双向链表。\n\n## 单向链表数据结构的定义\n\n仿照《数据结构与算法分析-C语言描述》一书中定义的格式，不过采用C++模板的编写方式尝试编写单向链表的操作。\n\n```cpp  \ntemplate <typename DataType>\nclass Node\n{\npublic:\n\tNode(DataType inData):data(inData),next(nullptr) {}\npublic:\n\tDataType data;\n\tNode *next;\n};\n\ntemplate <typename DataType>\nclass List\n{\npublic:\n\tList(DataType inDummy):dummyNode(inDummy), listSize(0), lastNode(nullptr) {}\n\t~List(); //析构函数，负责回收内存\n\tvoid MakeEmpty(); //清空链表\n\tbool IsEmpty(); //判断链表是否为空\n\tbool IsLast(Node<DataType> * inPosition); //判断是否为最后一个元素\n\tNode<DataType> *FindElement(DataType value); //查找一个元素并返回地址\n\tNode<DataType> *FindNthElement(int n); //查找第n个元素，返回地址或者nullptr\n\tvoid DeleteElement(DataType inData); //删除一个节点\n\tvoid DeleteNthElement(int n); //删除第n个节点\n\tvoid InsertElement(DataType inData, int n); //插入一个节点\n\tint Length(); //返回链表长度\nprivate:\n\tNode<DataType> dummyNode; //哑节点\n\tint listSize; //保存链表长度\n\tNode<DataType> *lastNode; //保存最后一个节点地址\n};\n\n```\n\n如上所示，在链表类中有三个数据成员，分别为dummyNode、listSize和lastNode。dummyNode是哑节点，不动态创建；listSize保存当前链表大小，对一些函数可快速判断输入是否合法；lastNode保存最后一个节点的地址。\n\n下面依次实现各函数：\n- 清空链表\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::MakeEmpty()\n{\n\tif (listSize <= 0 || dummyNode.next == nullptr) {\n\t\treturn;\n\t}\n\tNode<DataType> * tmp = nullptr;\n\twhile (dummyNode.next != nullptr) {\n\t\ttmp = dummyNode.next;\n\t\tdummyNode.next = dummyNode.next->next;\n\t\tdelete tmp;\n\t}\n\tlistSize = 0; lastNode = nullptr;\n\treturn;\n}\n```\n\n- 判断列表是否为空\n\n```cpp\ntemplate <typename DataType>\nbool List<DataType>::IsEmpty()\n{\n\tif (listSize <= 0 || dummyNode.next == nullptr) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n- 判断是否为最后一个元素\n\n```cpp\ntemplate <typename DataType>\nbool List<DataType>::IsLast(Node<DataType> * inPosition)\n{\n\treturn inPosition != nullptr && inPosition == lastNode;\n}\n```\n\n- 查找一个元素并返回地址\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * List<DataType>::FindElement(DataType value)\n{\n\tNode<DataType> *cycleIter = dummyNode.next;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == value) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\tcycleIter = cycleIter->next;\n\t}\n\treturn nullptr;\n}\n```\n\n- 查找第n个元素，dummy为第0个元素，返回地址或者nullptr\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * List<DataType>::FindNthElement(int n)\n{\n\tif (n <= 0) {\n\t\treturn nullptr;\n\t}\n\tNode<DataType> *cycleIter = dummyNode.next;\n\twhile (--n > 0 && cycleIter != nullptr) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\treturn cycleIter;\n}\n```\n\n- 删除一个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::DeleteElement(DataType inData)\n{\n\tNode<DataType> *frontIter = &dummyNode;\n\tNode<DataType> *cycleIter = frontIter->next;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == inData) {\n\t\t\tNode<DataType> * tmp = cycleIter;\n\t\t\tfrontIter->next = cycleIter->next;\n\t\t\tlastNode = lastNode == tmp ? frontIter : lastNode;\n\t\t\tdelete tmp; --listSize;\n\t\t\treturn;\n\t\t}\n\t\tfrontIter = frontIter->next;\n\t\tcycleIter = cycleIter->next;\n\t}\n\tif (dummyNode.next == nullptr) {\n\t\tlastNode = nullptr;\n\t}\n\treturn;\n}\n```\n\n- 删除第n个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::DeleteNthElement(int n)\n{\n\tif (n <= 0 || n > listSize) {\n\t\treturn;\n\t}\n\tNode<DataType> *frontIter = &dummyNode;\n\tNode<DataType> *cycleIter = frontIter->next;\n\twhile (--n > 0 && cycleIter != nullptr) {\n\t\tfrontIter = frontIter->next;\n\t\tcycleIter = cycleIter->next;\n\t}\n\tif (n <= 0) {\n\t\tNode<DataType> * tmp = cycleIter;\n\t\tfrontIter->next = cycleIter->next;\n\t\tlastNode = lastNode == tmp ? frontIter : lastNode;\n\t\tdelete tmp; --listSize;\n\t}\n\tif (dummyNode.next == nullptr) {\n\t\tlastNode = nullptr;\n\t}\n\treturn;\n}\n```\n\n- 插入一个节点, n<0或者>链表长度代表直接插到末尾，其他代表插到第n个节点后\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::InsertElement(DataType inData, int n)\n{\n\tNode<DataType> *insertElement = new Node<DataType>(inData);\n\tif (n < 0 || n >= listSize) {\n\t\tif (lastNode == nullptr) {\n\t\t\tlastNode = &dummyNode;\n\t\t}\n\t\tlastNode->next = insertElement;\n\t\tlastNode = insertElement; ++listSize;\n\t\treturn;\n\t}\n\tNode<DataType> *cycleIter = &dummyNode;\n\twhile (n-- > 0 && cycleIter != nullptr) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\tif (n <= 0) {\n\t\tinsertElement->next = cycleIter->next;\n\t\tcycleIter->next = insertElement; ++listSize;\n\t}\n\treturn;\n}\n```\n\n- 返回链表长度\n\n```cpp\ntemplate <typename DataType>\nint List<DataType>::Length()\n{\n\treturn listSize;\n}\n```\n\n- 析构函数\n\n```cpp\ntemplate <typename DataType>\nList<DataType>::~List()\n{\n\tMakeEmpty();\n}\n```\n\n## 代码测试\n\n对上述代码进行简单地测试，测试代码如下：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n        List<int> Test(-1);\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n\n        cout << Test.IsEmpty() << endl;\n\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n\n        cout << Test.Length() << endl;\n\n        Test.DeleteElement(10);\n        Test.DeleteElement(9);\n        Test.DeleteElement(14);\n        Test.DeleteElement(12);\n\n        cout << Test.IsEmpty() << endl;\n\n        cout << Test.Length() << endl;\n\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n        Test.MakeEmpty();\n\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n\n        Node<int> * pTest = Test.FindElement(12);\n        pTest = Test.FindElement(9);\n\tpTest = Test.FindElement(-1);\n\n        pTest = Test.FindNthElement(4);\n        pTest = Test.FindNthElement(-1);\n        pTest = Test.FindNthElement(1);\n        pTest = Test.FindNthElement(10);\n\n        return 0;\n}\n```\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","source":"_posts/数据结构/数据结构之单向链表-指针实现.md","raw":"---\ntitle: 数据结构之单向链表-指针实现\nurlname: one-way-linked-list\ndate: 2018-03-4 16:05:13\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\n- C++\ncategories:\n- 数据结构\n---\n\n## 基础知识\n\n链表是一种线性表数据结构，其和顺序表的最大区别是链表在内存中无需连续存储，因此链表节点需要增加指针域（对于无指针的编程语言可能需要通过游标实现）用来指向下一个元素的内存地址。单向链表是链表的一种，其特点是链表的链接方向是单向的，访问单向链表的全部元素必须从头部开始依次访问。在单向链表的实现中，为了便于对表头元素进行插入、删除等操作，一般定义一个表头(header)或者称为哑节点(dummy node)，且默认表头在位置0处。在单向链表ADT中，一般至少需要需要实现以下操作：\n\n- 清空整个链表：MakeEmpty\n- 查找某个元素：FindElement\n- 删除一个元素：DeleteElement\n- 插入一个元素：InsertElement\n\n在C++标准模板库(STL)中，list实现了一种双向链表。\n\n## 单向链表数据结构的定义\n\n仿照《数据结构与算法分析-C语言描述》一书中定义的格式，不过采用C++模板的编写方式尝试编写单向链表的操作。\n\n```cpp  \ntemplate <typename DataType>\nclass Node\n{\npublic:\n\tNode(DataType inData):data(inData),next(nullptr) {}\npublic:\n\tDataType data;\n\tNode *next;\n};\n\ntemplate <typename DataType>\nclass List\n{\npublic:\n\tList(DataType inDummy):dummyNode(inDummy), listSize(0), lastNode(nullptr) {}\n\t~List(); //析构函数，负责回收内存\n\tvoid MakeEmpty(); //清空链表\n\tbool IsEmpty(); //判断链表是否为空\n\tbool IsLast(Node<DataType> * inPosition); //判断是否为最后一个元素\n\tNode<DataType> *FindElement(DataType value); //查找一个元素并返回地址\n\tNode<DataType> *FindNthElement(int n); //查找第n个元素，返回地址或者nullptr\n\tvoid DeleteElement(DataType inData); //删除一个节点\n\tvoid DeleteNthElement(int n); //删除第n个节点\n\tvoid InsertElement(DataType inData, int n); //插入一个节点\n\tint Length(); //返回链表长度\nprivate:\n\tNode<DataType> dummyNode; //哑节点\n\tint listSize; //保存链表长度\n\tNode<DataType> *lastNode; //保存最后一个节点地址\n};\n\n```\n\n如上所示，在链表类中有三个数据成员，分别为dummyNode、listSize和lastNode。dummyNode是哑节点，不动态创建；listSize保存当前链表大小，对一些函数可快速判断输入是否合法；lastNode保存最后一个节点的地址。\n\n下面依次实现各函数：\n- 清空链表\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::MakeEmpty()\n{\n\tif (listSize <= 0 || dummyNode.next == nullptr) {\n\t\treturn;\n\t}\n\tNode<DataType> * tmp = nullptr;\n\twhile (dummyNode.next != nullptr) {\n\t\ttmp = dummyNode.next;\n\t\tdummyNode.next = dummyNode.next->next;\n\t\tdelete tmp;\n\t}\n\tlistSize = 0; lastNode = nullptr;\n\treturn;\n}\n```\n\n- 判断列表是否为空\n\n```cpp\ntemplate <typename DataType>\nbool List<DataType>::IsEmpty()\n{\n\tif (listSize <= 0 || dummyNode.next == nullptr) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n- 判断是否为最后一个元素\n\n```cpp\ntemplate <typename DataType>\nbool List<DataType>::IsLast(Node<DataType> * inPosition)\n{\n\treturn inPosition != nullptr && inPosition == lastNode;\n}\n```\n\n- 查找一个元素并返回地址\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * List<DataType>::FindElement(DataType value)\n{\n\tNode<DataType> *cycleIter = dummyNode.next;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == value) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\tcycleIter = cycleIter->next;\n\t}\n\treturn nullptr;\n}\n```\n\n- 查找第n个元素，dummy为第0个元素，返回地址或者nullptr\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * List<DataType>::FindNthElement(int n)\n{\n\tif (n <= 0) {\n\t\treturn nullptr;\n\t}\n\tNode<DataType> *cycleIter = dummyNode.next;\n\twhile (--n > 0 && cycleIter != nullptr) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\treturn cycleIter;\n}\n```\n\n- 删除一个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::DeleteElement(DataType inData)\n{\n\tNode<DataType> *frontIter = &dummyNode;\n\tNode<DataType> *cycleIter = frontIter->next;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == inData) {\n\t\t\tNode<DataType> * tmp = cycleIter;\n\t\t\tfrontIter->next = cycleIter->next;\n\t\t\tlastNode = lastNode == tmp ? frontIter : lastNode;\n\t\t\tdelete tmp; --listSize;\n\t\t\treturn;\n\t\t}\n\t\tfrontIter = frontIter->next;\n\t\tcycleIter = cycleIter->next;\n\t}\n\tif (dummyNode.next == nullptr) {\n\t\tlastNode = nullptr;\n\t}\n\treturn;\n}\n```\n\n- 删除第n个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::DeleteNthElement(int n)\n{\n\tif (n <= 0 || n > listSize) {\n\t\treturn;\n\t}\n\tNode<DataType> *frontIter = &dummyNode;\n\tNode<DataType> *cycleIter = frontIter->next;\n\twhile (--n > 0 && cycleIter != nullptr) {\n\t\tfrontIter = frontIter->next;\n\t\tcycleIter = cycleIter->next;\n\t}\n\tif (n <= 0) {\n\t\tNode<DataType> * tmp = cycleIter;\n\t\tfrontIter->next = cycleIter->next;\n\t\tlastNode = lastNode == tmp ? frontIter : lastNode;\n\t\tdelete tmp; --listSize;\n\t}\n\tif (dummyNode.next == nullptr) {\n\t\tlastNode = nullptr;\n\t}\n\treturn;\n}\n```\n\n- 插入一个节点, n<0或者>链表长度代表直接插到末尾，其他代表插到第n个节点后\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::InsertElement(DataType inData, int n)\n{\n\tNode<DataType> *insertElement = new Node<DataType>(inData);\n\tif (n < 0 || n >= listSize) {\n\t\tif (lastNode == nullptr) {\n\t\t\tlastNode = &dummyNode;\n\t\t}\n\t\tlastNode->next = insertElement;\n\t\tlastNode = insertElement; ++listSize;\n\t\treturn;\n\t}\n\tNode<DataType> *cycleIter = &dummyNode;\n\twhile (n-- > 0 && cycleIter != nullptr) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\tif (n <= 0) {\n\t\tinsertElement->next = cycleIter->next;\n\t\tcycleIter->next = insertElement; ++listSize;\n\t}\n\treturn;\n}\n```\n\n- 返回链表长度\n\n```cpp\ntemplate <typename DataType>\nint List<DataType>::Length()\n{\n\treturn listSize;\n}\n```\n\n- 析构函数\n\n```cpp\ntemplate <typename DataType>\nList<DataType>::~List()\n{\n\tMakeEmpty();\n}\n```\n\n## 代码测试\n\n对上述代码进行简单地测试，测试代码如下：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n        List<int> Test(-1);\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n\n        cout << Test.IsEmpty() << endl;\n\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n\n        cout << Test.Length() << endl;\n\n        Test.DeleteElement(10);\n        Test.DeleteElement(9);\n        Test.DeleteElement(14);\n        Test.DeleteElement(12);\n\n        cout << Test.IsEmpty() << endl;\n\n        cout << Test.Length() << endl;\n\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n        Test.MakeEmpty();\n\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n\n        Node<int> * pTest = Test.FindElement(12);\n        pTest = Test.FindElement(9);\n\tpTest = Test.FindElement(-1);\n\n        pTest = Test.FindNthElement(4);\n        pTest = Test.FindNthElement(-1);\n        pTest = Test.FindNthElement(1);\n        pTest = Test.FindNthElement(10);\n\n        return 0;\n}\n```\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","slug":"数据结构/数据结构之单向链表-指针实现","published":1,"updated":"2018-06-13T14:07:45.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3i0013gsvnw2cylmgf","content":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>链表是一种线性表数据结构，其和顺序表的最大区别是链表在内存中无需连续存储，因此链表节点需要增加指针域（对于无指针的编程语言可能需要通过游标实现）用来指向下一个元素的内存地址。单向链表是链表的一种，其特点是链表的链接方向是单向的，访问单向链表的全部元素必须从头部开始依次访问。在单向链表的实现中，为了便于对表头元素进行插入、删除等操作，一般定义一个表头(header)或者称为哑节点(dummy node)，且默认表头在位置0处。在单向链表ADT中，一般至少需要需要实现以下操作：</p>\n<ul>\n<li>清空整个链表：MakeEmpty</li>\n<li>查找某个元素：FindElement</li>\n<li>删除一个元素：DeleteElement</li>\n<li>插入一个元素：InsertElement</li>\n</ul>\n<p>在C++标准模板库(STL)中，list实现了一种双向链表。</p>\n<h2 id=\"单向链表数据结构的定义\"><a href=\"#单向链表数据结构的定义\" class=\"headerlink\" title=\"单向链表数据结构的定义\"></a>单向链表数据结构的定义</h2><p>仿照《数据结构与算法分析-C语言描述》一书中定义的格式，不过采用C++模板的编写方式尝试编写单向链表的操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode(DataType inData):data(inData),next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tList(DataType inDummy):dummyNode(inDummy), listSize(<span class=\"number\">0</span>), lastNode(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~List(); <span class=\"comment\">//析构函数，负责回收内存</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断链表是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsLast</span><span class=\"params\">(Node&lt;DataType&gt; * inPosition)</span></span>; <span class=\"comment\">//判断是否为最后一个元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindElement(DataType value); <span class=\"comment\">//查找一个元素并返回地址</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindNthElement(<span class=\"keyword\">int</span> n); <span class=\"comment\">//查找第n个元素，返回地址或者nullptr</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//删除一个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteNthElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">//删除第n个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inData, <span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">//插入一个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Length</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回链表长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; dummyNode; <span class=\"comment\">//哑节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> listSize; <span class=\"comment\">//保存链表长度</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *lastNode; <span class=\"comment\">//保存最后一个节点地址</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，在链表类中有三个数据成员，分别为dummyNode、listSize和lastNode。dummyNode是哑节点，不动态创建；listSize保存当前链表大小，对一些函数可快速判断输入是否合法；lastNode保存最后一个节点的地址。</p>\n<p>下面依次实现各函数：</p>\n<ul>\n<li>清空链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; * tmp = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (dummyNode.next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\ttmp = dummyNode.next;</span><br><span class=\"line\">\t\tdummyNode.next = dummyNode.next-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlistSize = <span class=\"number\">0</span>; lastNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断列表是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> List&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断是否为最后一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> List&lt;DataType&gt;::IsLast(Node&lt;DataType&gt; * inPosition)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inPosition != <span class=\"literal\">nullptr</span> &amp;&amp; inPosition == lastNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找一个元素并返回地址</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * List&lt;DataType&gt;::FindElement(DataType value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = dummyNode.next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == value) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找第n个元素，dummy为第0个元素，返回地址或者nullptr</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * List&lt;DataType&gt;::FindNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = dummyNode.next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::DeleteElement(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *frontIter = &amp;dummyNode;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = frontIter-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inData) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">\t\t\tfrontIter-&gt;next = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t\tlastNode = lastNode == tmp ? frontIter : lastNode;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; --listSize;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfrontIter = frontIter-&gt;next;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除第n个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::DeleteNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span> || n &gt; listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *frontIter = &amp;dummyNode;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = frontIter-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tfrontIter = frontIter-&gt;next;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tNode&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">\t\tfrontIter-&gt;next = cycleIter-&gt;next;</span><br><span class=\"line\">\t\tlastNode = lastNode == tmp ? frontIter : lastNode;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp; --listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入一个节点, n&lt;0或者&gt;链表长度代表直接插到末尾，其他代表插到第n个节点后</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::InsertElement(DataType inData, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *insertElement = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inData);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span> || n &gt;= listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lastNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tlastNode = &amp;dummyNode;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlastNode-&gt;next = insertElement;</span><br><span class=\"line\">\t\tlastNode = insertElement; ++listSize;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = &amp;dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n-- &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tinsertElement-&gt;next = cycleIter-&gt;next;</span><br><span class=\"line\">\t\tcycleIter-&gt;next = insertElement; ++listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回链表长度</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> List&lt;DataType&gt;::Length()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> listSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">List&lt;DataType&gt;::~List()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>对上述代码进行简单地测试，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>&gt; Test(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">9</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">14</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.MakeEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Node&lt;<span class=\"keyword\">int</span>&gt; * pTest = Test.FindElement(<span class=\"number\">12</span>);</span><br><span class=\"line\">        pTest = Test.FindElement(<span class=\"number\">9</span>);</span><br><span class=\"line\">\tpTest = Test.FindElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">4</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>链表是一种线性表数据结构，其和顺序表的最大区别是链表在内存中无需连续存储，因此链表节点需要增加指针域（对于无指针的编程语言可能需要通过游标实现）用来指向下一个元素的内存地址。单向链表是链表的一种，其特点是链表的链接方向是单向的，访问单向链表的全部元素必须从头部开始依次访问。在单向链表的实现中，为了便于对表头元素进行插入、删除等操作，一般定义一个表头(header)或者称为哑节点(dummy node)，且默认表头在位置0处。在单向链表ADT中，一般至少需要需要实现以下操作：</p>\n<ul>\n<li>清空整个链表：MakeEmpty</li>\n<li>查找某个元素：FindElement</li>\n<li>删除一个元素：DeleteElement</li>\n<li>插入一个元素：InsertElement</li>\n</ul>\n<p>在C++标准模板库(STL)中，list实现了一种双向链表。</p>\n<h2 id=\"单向链表数据结构的定义\"><a href=\"#单向链表数据结构的定义\" class=\"headerlink\" title=\"单向链表数据结构的定义\"></a>单向链表数据结构的定义</h2><p>仿照《数据结构与算法分析-C语言描述》一书中定义的格式，不过采用C++模板的编写方式尝试编写单向链表的操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode(DataType inData):data(inData),next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tList(DataType inDummy):dummyNode(inDummy), listSize(<span class=\"number\">0</span>), lastNode(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~List(); <span class=\"comment\">//析构函数，负责回收内存</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断链表是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsLast</span><span class=\"params\">(Node&lt;DataType&gt; * inPosition)</span></span>; <span class=\"comment\">//判断是否为最后一个元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindElement(DataType value); <span class=\"comment\">//查找一个元素并返回地址</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindNthElement(<span class=\"keyword\">int</span> n); <span class=\"comment\">//查找第n个元素，返回地址或者nullptr</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//删除一个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteNthElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">//删除第n个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inData, <span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">//插入一个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Length</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回链表长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; dummyNode; <span class=\"comment\">//哑节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> listSize; <span class=\"comment\">//保存链表长度</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *lastNode; <span class=\"comment\">//保存最后一个节点地址</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，在链表类中有三个数据成员，分别为dummyNode、listSize和lastNode。dummyNode是哑节点，不动态创建；listSize保存当前链表大小，对一些函数可快速判断输入是否合法；lastNode保存最后一个节点的地址。</p>\n<p>下面依次实现各函数：</p>\n<ul>\n<li>清空链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; * tmp = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (dummyNode.next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\ttmp = dummyNode.next;</span><br><span class=\"line\">\t\tdummyNode.next = dummyNode.next-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlistSize = <span class=\"number\">0</span>; lastNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断列表是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> List&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断是否为最后一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> List&lt;DataType&gt;::IsLast(Node&lt;DataType&gt; * inPosition)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inPosition != <span class=\"literal\">nullptr</span> &amp;&amp; inPosition == lastNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找一个元素并返回地址</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * List&lt;DataType&gt;::FindElement(DataType value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = dummyNode.next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == value) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找第n个元素，dummy为第0个元素，返回地址或者nullptr</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * List&lt;DataType&gt;::FindNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = dummyNode.next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::DeleteElement(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *frontIter = &amp;dummyNode;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = frontIter-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inData) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">\t\t\tfrontIter-&gt;next = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t\tlastNode = lastNode == tmp ? frontIter : lastNode;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; --listSize;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfrontIter = frontIter-&gt;next;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除第n个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::DeleteNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span> || n &gt; listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *frontIter = &amp;dummyNode;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = frontIter-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tfrontIter = frontIter-&gt;next;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tNode&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">\t\tfrontIter-&gt;next = cycleIter-&gt;next;</span><br><span class=\"line\">\t\tlastNode = lastNode == tmp ? frontIter : lastNode;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp; --listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入一个节点, n&lt;0或者&gt;链表长度代表直接插到末尾，其他代表插到第n个节点后</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::InsertElement(DataType inData, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *insertElement = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inData);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span> || n &gt;= listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lastNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tlastNode = &amp;dummyNode;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlastNode-&gt;next = insertElement;</span><br><span class=\"line\">\t\tlastNode = insertElement; ++listSize;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = &amp;dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n-- &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tinsertElement-&gt;next = cycleIter-&gt;next;</span><br><span class=\"line\">\t\tcycleIter-&gt;next = insertElement; ++listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回链表长度</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> List&lt;DataType&gt;::Length()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> listSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">List&lt;DataType&gt;::~List()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>对上述代码进行简单地测试，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>&gt; Test(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">9</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">14</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.MakeEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Node&lt;<span class=\"keyword\">int</span>&gt; * pTest = Test.FindElement(<span class=\"number\">12</span>);</span><br><span class=\"line\">        pTest = Test.FindElement(<span class=\"number\">9</span>);</span><br><span class=\"line\">\tpTest = Test.FindElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">4</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n"},{"title":"数据结构之双向循环链表-指针实现","urlname":"double-circular-linked-list","date":"2018-05-30T14:29:50.000Z","mathjax":true,"copyright":true,"_content":"\n## 基础知识\n\n双向循环链表和单向链表一样是一种线性表数据结构，但和单向链表不同，双向循环链表需要增加两个指针域分别指向前驱节点和后继节点，同时首尾节点分别指向彼此。双向链表的实现和单向链表相比稍微有点复杂，但是双向循环链表具有前向和后向遍历能力并且可以从任意节点开始循环遍历所有的节点。双向循环链表的指针域增加也造成了更多的空间浪费，使空间利用率进一步降低。\n\n## 双向循环链表数据结构的定义\n\n使用单向链表的ADT，采用C++模板的方式编写双向循环链表的操作。\n\n```cpp  \ntemplate <typename DataType>\nclass Node\n{\npublic:\n\tNode(DataType inData):data(inData), prior(nullptr), next(nullptr) {}\npublic:\n\tDataType data;\n\tNode *prior; /*前驱*/\n\tNode *next; /*后继*/\n};\n\ntemplate <typename DataType>\nclass List\n{\npublic:\n\tList(): listSize(0), head(nullptr) {}\n\t~List(); //析构函数，负责回收内存\n\tvoid MakeEmpty(); //清空链表\n\tbool IsEmpty(); //判断链表是否为空\n\tbool IsLast(Node<DataType> * inPosition); //判断是否为最后一个元素\n\tNode<DataType> *FindElement(DataType value); //查找一个元素并返回地址\n\tNode<DataType> *FindNthElement(int n); //查找第n个元素，返回地址或者nullptr\n\tvoid DeleteElement(DataType inData); //删除一个节点\n\tvoid DeleteNthElement(int n); //删除第n个节点\n\tvoid InsertElement(DataType inData, int n); //插入一个节点\n\tint Length(); //返回链表长度\nprivate:\n\tint listSize; //保存链表长度\n\tNode<DataType> *head; /*只需头节点即可*/\n};\n\n```\n\n如上所示，在链表类中有两个数据成员，分别为listSize和head。listSize保存当前链表大小，对一些函数可快速判断输入是否合法；head保存链表头节点，如果链表为空则置为空指针。\n\n下面依次实现各函数：\n- 清空链表\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::MakeEmpty()\n{\n\tif (listSize <= 0 || head == nullptr) {\n\t\treturn;\n\t}\n\t/*使首尾断开连接，便于终止条件判断*/\n\thead->prior->next = nullptr;\n\n\tNode<DataType> * tmp = head;\n\twhile (tmp != nullptr) {\n\t\thead = head->next;\n\t\tdelete tmp;\n\t\ttmp = head;\n\t}\n\tlistSize = 0; head = nullptr;\n\treturn;\n}\n```\n\n- 判断列表是否为空\n\n```cpp\ntemplate <typename DataType>\nbool List<DataType>::IsEmpty()\n{\n\tif (listSize <= 0 || head == nullptr) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n- 判断是否为最后一个元素\n\n```cpp\ntemplate <typename DataType>\nbool List<DataType>::IsLast(Node<DataType> * inPosition)\n{\n\treturn inPosition != nullptr && inPosition == head->prior;\n}\n```\n\n- 查找一个元素并返回地址\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * List<DataType>::FindElement(DataType value)\n{\n\tNode<DataType> *cycleIter = head;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == value) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\tcycleIter = cycleIter->next;\n\t\tif (cycleIter == head) {\n\t\t\tbreak; /*回到头节点了*/\n\t\t}\n\t}\n\treturn nullptr;\n}\n```\n\n- 查找第n个元素，下标从1开始，返回地址或者nullptr\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * List<DataType>::FindNthElement(int n)\n{\n\tif (n <= 0 || n > listSize) {\n\t\t/*超过大小直接返回nullptr防止回绕*/\n\t\treturn nullptr;\n\t}\n\tNode<DataType> *cycleIter = head;\n\twhile (--n > 0 && cycleIter != nullptr) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\treturn cycleIter;\n}\n```\n\n- 删除一个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::DeleteElement(DataType inData)\n{\n\tNode<DataType> *cycleIter = head;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == inData) {\n\t\t\t/*注意处理只有一个节点和删除头节点的问题*/\n\t\t\tif (cycleIter == head) {\n\t\t\t\thead = head->next != head ? head->next : nullptr;\n\t\t\t}\n\t\t\tNode<DataType> * tmp = cycleIter;\n\t\t\ttmp->prior->next = tmp->next;\n\t\t\ttmp->next->prior = tmp->prior;\n\t\t\tdelete tmp; --listSize;\n\t\t\treturn;\n\t\t}\n\t\tcycleIter = cycleIter->next;\n\t}\n\treturn;\n}\n```\n\n- 删除第n个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::DeleteNthElement(int n)\n{\n\tif (n <= 0 || n > listSize) {\n\t\treturn;\n\t}\n\tNode<DataType> *cycleIter = head;\n\twhile (--n > 0 && cycleIter != nullptr) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\tif (n <= 0) {\n\t\tNode<DataType> * tmp = cycleIter;\n\t\ttmp->prior->next = tmp->next;\n\t\ttmp->next->prior = tmp->prior;\n\t\tdelete tmp; --listSize;\n\t}\n\treturn;\n}\n```\n\n- 插入一个节点, n<0或者>链表长度代表直接插到末尾，其他代表插到第n个节点后\n\n如果只有一个节点将该节点的首尾均指向自己。\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::InsertElement(DataType inData, int n)\n{\n\tNode<DataType> *insertElement = new Node<DataType>(inData);\n\tif (head == nullptr || listSize <= 0) {\n\t\thead = insertElement;\n\t\thead->next = head;\n\t\thead->prior = head; ++listSize;\n\t}\n\telse {\n\t\tif (n < 0 || n >= listSize) {\n\t\t\thead->prior->next = insertElement;\n\t\t\tinsertElement->prior = head->prior;\n\t\t\tinsertElement->next = head;\n\t\t\thead->prior = insertElement; ++listSize;\n\t\t}\n\t\telse {\n\t\t\tNode<DataType> *cycleIter = head;\n\t\t\twhile (--n > 0 && cycleIter != nullptr) {\n\t\t\t\tcycleIter = cycleIter->next;\n\t\t\t}\n\t\t\tif (n <= 0) {\n\t\t\t\tinsertElement->next = cycleIter->next;\n\t\t\t\tinsertElement->prior = cycleIter;\n\t\t\t\tcycleIter->next->prior = insertElement;\n\t\t\t\tcycleIter->next = insertElement; ++listSize;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n```\n\n- 返回链表长度\n\n```cpp\ntemplate <typename DataType>\nint List<DataType>::Length()\n{\n\treturn listSize;\n}\n```\n\n- 析构函数\n\n```cpp\ntemplate <typename DataType>\nList<DataType>::~List()\n{\n\tMakeEmpty();\n}\n```\n\n## 代码测试\n\n以下对上述代码进行简单的测试，测试代码如下：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n        List<int> Test;\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n\n        cout << Test.IsEmpty() << endl;\n\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n\n        cout << Test.Length() << endl;\n\n        Test.DeleteElement(10);\n        Test.DeleteElement(9);\n        Test.DeleteElement(14);\n        Test.DeleteElement(12);\n\n        cout << Test.IsEmpty() << endl;\n\n        cout << Test.Length() << endl;\n\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n        Test.MakeEmpty();\n\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n\n        Node<int> * pTest = Test.FindElement(12);\n        pTest = Test.FindElement(9);\n\tpTest = Test.FindElement(-1);\n\n        pTest = Test.FindNthElement(4);\n        pTest = Test.FindNthElement(-1);\n        pTest = Test.FindNthElement(1);\n        pTest = Test.FindNthElement(10);\n\n        return 0;\n}\n```\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","source":"_posts/数据结构/数据结构之双向循环链表-指针实现.md","raw":"---\ntitle: 数据结构之双向循环链表-指针实现\nurlname: double-circular-linked-list\ndate: 2018-05-30 22:29:50\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\n- C++\ncategories:\n- 数据结构\n---\n\n## 基础知识\n\n双向循环链表和单向链表一样是一种线性表数据结构，但和单向链表不同，双向循环链表需要增加两个指针域分别指向前驱节点和后继节点，同时首尾节点分别指向彼此。双向链表的实现和单向链表相比稍微有点复杂，但是双向循环链表具有前向和后向遍历能力并且可以从任意节点开始循环遍历所有的节点。双向循环链表的指针域增加也造成了更多的空间浪费，使空间利用率进一步降低。\n\n## 双向循环链表数据结构的定义\n\n使用单向链表的ADT，采用C++模板的方式编写双向循环链表的操作。\n\n```cpp  \ntemplate <typename DataType>\nclass Node\n{\npublic:\n\tNode(DataType inData):data(inData), prior(nullptr), next(nullptr) {}\npublic:\n\tDataType data;\n\tNode *prior; /*前驱*/\n\tNode *next; /*后继*/\n};\n\ntemplate <typename DataType>\nclass List\n{\npublic:\n\tList(): listSize(0), head(nullptr) {}\n\t~List(); //析构函数，负责回收内存\n\tvoid MakeEmpty(); //清空链表\n\tbool IsEmpty(); //判断链表是否为空\n\tbool IsLast(Node<DataType> * inPosition); //判断是否为最后一个元素\n\tNode<DataType> *FindElement(DataType value); //查找一个元素并返回地址\n\tNode<DataType> *FindNthElement(int n); //查找第n个元素，返回地址或者nullptr\n\tvoid DeleteElement(DataType inData); //删除一个节点\n\tvoid DeleteNthElement(int n); //删除第n个节点\n\tvoid InsertElement(DataType inData, int n); //插入一个节点\n\tint Length(); //返回链表长度\nprivate:\n\tint listSize; //保存链表长度\n\tNode<DataType> *head; /*只需头节点即可*/\n};\n\n```\n\n如上所示，在链表类中有两个数据成员，分别为listSize和head。listSize保存当前链表大小，对一些函数可快速判断输入是否合法；head保存链表头节点，如果链表为空则置为空指针。\n\n下面依次实现各函数：\n- 清空链表\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::MakeEmpty()\n{\n\tif (listSize <= 0 || head == nullptr) {\n\t\treturn;\n\t}\n\t/*使首尾断开连接，便于终止条件判断*/\n\thead->prior->next = nullptr;\n\n\tNode<DataType> * tmp = head;\n\twhile (tmp != nullptr) {\n\t\thead = head->next;\n\t\tdelete tmp;\n\t\ttmp = head;\n\t}\n\tlistSize = 0; head = nullptr;\n\treturn;\n}\n```\n\n- 判断列表是否为空\n\n```cpp\ntemplate <typename DataType>\nbool List<DataType>::IsEmpty()\n{\n\tif (listSize <= 0 || head == nullptr) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n- 判断是否为最后一个元素\n\n```cpp\ntemplate <typename DataType>\nbool List<DataType>::IsLast(Node<DataType> * inPosition)\n{\n\treturn inPosition != nullptr && inPosition == head->prior;\n}\n```\n\n- 查找一个元素并返回地址\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * List<DataType>::FindElement(DataType value)\n{\n\tNode<DataType> *cycleIter = head;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == value) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\tcycleIter = cycleIter->next;\n\t\tif (cycleIter == head) {\n\t\t\tbreak; /*回到头节点了*/\n\t\t}\n\t}\n\treturn nullptr;\n}\n```\n\n- 查找第n个元素，下标从1开始，返回地址或者nullptr\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * List<DataType>::FindNthElement(int n)\n{\n\tif (n <= 0 || n > listSize) {\n\t\t/*超过大小直接返回nullptr防止回绕*/\n\t\treturn nullptr;\n\t}\n\tNode<DataType> *cycleIter = head;\n\twhile (--n > 0 && cycleIter != nullptr) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\treturn cycleIter;\n}\n```\n\n- 删除一个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::DeleteElement(DataType inData)\n{\n\tNode<DataType> *cycleIter = head;\n\twhile (cycleIter != nullptr) {\n\t\tif (cycleIter->data == inData) {\n\t\t\t/*注意处理只有一个节点和删除头节点的问题*/\n\t\t\tif (cycleIter == head) {\n\t\t\t\thead = head->next != head ? head->next : nullptr;\n\t\t\t}\n\t\t\tNode<DataType> * tmp = cycleIter;\n\t\t\ttmp->prior->next = tmp->next;\n\t\t\ttmp->next->prior = tmp->prior;\n\t\t\tdelete tmp; --listSize;\n\t\t\treturn;\n\t\t}\n\t\tcycleIter = cycleIter->next;\n\t}\n\treturn;\n}\n```\n\n- 删除第n个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::DeleteNthElement(int n)\n{\n\tif (n <= 0 || n > listSize) {\n\t\treturn;\n\t}\n\tNode<DataType> *cycleIter = head;\n\twhile (--n > 0 && cycleIter != nullptr) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\tif (n <= 0) {\n\t\tNode<DataType> * tmp = cycleIter;\n\t\ttmp->prior->next = tmp->next;\n\t\ttmp->next->prior = tmp->prior;\n\t\tdelete tmp; --listSize;\n\t}\n\treturn;\n}\n```\n\n- 插入一个节点, n<0或者>链表长度代表直接插到末尾，其他代表插到第n个节点后\n\n如果只有一个节点将该节点的首尾均指向自己。\n\n```cpp\ntemplate <typename DataType>\nvoid List<DataType>::InsertElement(DataType inData, int n)\n{\n\tNode<DataType> *insertElement = new Node<DataType>(inData);\n\tif (head == nullptr || listSize <= 0) {\n\t\thead = insertElement;\n\t\thead->next = head;\n\t\thead->prior = head; ++listSize;\n\t}\n\telse {\n\t\tif (n < 0 || n >= listSize) {\n\t\t\thead->prior->next = insertElement;\n\t\t\tinsertElement->prior = head->prior;\n\t\t\tinsertElement->next = head;\n\t\t\thead->prior = insertElement; ++listSize;\n\t\t}\n\t\telse {\n\t\t\tNode<DataType> *cycleIter = head;\n\t\t\twhile (--n > 0 && cycleIter != nullptr) {\n\t\t\t\tcycleIter = cycleIter->next;\n\t\t\t}\n\t\t\tif (n <= 0) {\n\t\t\t\tinsertElement->next = cycleIter->next;\n\t\t\t\tinsertElement->prior = cycleIter;\n\t\t\t\tcycleIter->next->prior = insertElement;\n\t\t\t\tcycleIter->next = insertElement; ++listSize;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n```\n\n- 返回链表长度\n\n```cpp\ntemplate <typename DataType>\nint List<DataType>::Length()\n{\n\treturn listSize;\n}\n```\n\n- 析构函数\n\n```cpp\ntemplate <typename DataType>\nList<DataType>::~List()\n{\n\tMakeEmpty();\n}\n```\n\n## 代码测试\n\n以下对上述代码进行简单的测试，测试代码如下：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n        List<int> Test;\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n\n        cout << Test.IsEmpty() << endl;\n\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n\n        cout << Test.Length() << endl;\n\n        Test.DeleteElement(10);\n        Test.DeleteElement(9);\n        Test.DeleteElement(14);\n        Test.DeleteElement(12);\n\n        cout << Test.IsEmpty() << endl;\n\n        cout << Test.Length() << endl;\n\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n        Test.MakeEmpty();\n\n        Test.InsertElement(9, 1);\n        Test.InsertElement(10, 3);\n        Test.InsertElement(12, 1);\n        Test.InsertElement(14, 3);\n\n        Node<int> * pTest = Test.FindElement(12);\n        pTest = Test.FindElement(9);\n\tpTest = Test.FindElement(-1);\n\n        pTest = Test.FindNthElement(4);\n        pTest = Test.FindNthElement(-1);\n        pTest = Test.FindNthElement(1);\n        pTest = Test.FindNthElement(10);\n\n        return 0;\n}\n```\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","slug":"数据结构/数据结构之双向循环链表-指针实现","published":1,"updated":"2018-06-13T14:06:29.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3k0016gsvn23ttcn6m","content":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>双向循环链表和单向链表一样是一种线性表数据结构，但和单向链表不同，双向循环链表需要增加两个指针域分别指向前驱节点和后继节点，同时首尾节点分别指向彼此。双向链表的实现和单向链表相比稍微有点复杂，但是双向循环链表具有前向和后向遍历能力并且可以从任意节点开始循环遍历所有的节点。双向循环链表的指针域增加也造成了更多的空间浪费，使空间利用率进一步降低。</p>\n<h2 id=\"双向循环链表数据结构的定义\"><a href=\"#双向循环链表数据结构的定义\" class=\"headerlink\" title=\"双向循环链表数据结构的定义\"></a>双向循环链表数据结构的定义</h2><p>使用单向链表的ADT，采用C++模板的方式编写双向循环链表的操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode(DataType inData):data(inData), prior(<span class=\"literal\">nullptr</span>), next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *prior; <span class=\"comment\">/*前驱*/</span></span><br><span class=\"line\">\tNode *next; <span class=\"comment\">/*后继*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tList(): listSize(<span class=\"number\">0</span>), head(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~List(); <span class=\"comment\">//析构函数，负责回收内存</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断链表是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsLast</span><span class=\"params\">(Node&lt;DataType&gt; * inPosition)</span></span>; <span class=\"comment\">//判断是否为最后一个元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindElement(DataType value); <span class=\"comment\">//查找一个元素并返回地址</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindNthElement(<span class=\"keyword\">int</span> n); <span class=\"comment\">//查找第n个元素，返回地址或者nullptr</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//删除一个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteNthElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">//删除第n个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inData, <span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">//插入一个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Length</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回链表长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> listSize; <span class=\"comment\">//保存链表长度</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *head; <span class=\"comment\">/*只需头节点即可*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，在链表类中有两个数据成员，分别为listSize和head。listSize保存当前链表大小，对一些函数可快速判断输入是否合法；head保存链表头节点，如果链表为空则置为空指针。</p>\n<p>下面依次实现各函数：</p>\n<ul>\n<li>清空链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || head == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/*使首尾断开连接，便于终止条件判断*/</span></span><br><span class=\"line\">\thead-&gt;prior-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tNode&lt;DataType&gt; * tmp = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\thead = head-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">\t\ttmp = head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlistSize = <span class=\"number\">0</span>; head = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断列表是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> List&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || head == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断是否为最后一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> List&lt;DataType&gt;::IsLast(Node&lt;DataType&gt; * inPosition)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inPosition != <span class=\"literal\">nullptr</span> &amp;&amp; inPosition == head-&gt;prior;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找一个元素并返回地址</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * List&lt;DataType&gt;::FindElement(DataType value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == value) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter == head) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>; <span class=\"comment\">/*回到头节点了*/</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找第n个元素，下标从1开始，返回地址或者nullptr</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * List&lt;DataType&gt;::FindNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span> || n &gt; listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*超过大小直接返回nullptr防止回绕*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::DeleteElement(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inData) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/*注意处理只有一个节点和删除头节点的问题*/</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cycleIter == head) &#123;</span><br><span class=\"line\">\t\t\t\thead = head-&gt;next != head ? head-&gt;next : <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">\t\t\ttmp-&gt;prior-&gt;next = tmp-&gt;next;</span><br><span class=\"line\">\t\t\ttmp-&gt;next-&gt;prior = tmp-&gt;prior;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; --listSize;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除第n个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::DeleteNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span> || n &gt; listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tNode&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">\t\ttmp-&gt;prior-&gt;next = tmp-&gt;next;</span><br><span class=\"line\">\t\ttmp-&gt;next-&gt;prior = tmp-&gt;prior;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp; --listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入一个节点, n&lt;0或者&gt;链表长度代表直接插到末尾，其他代表插到第n个节点后</li>\n</ul>\n<p>如果只有一个节点将该节点的首尾均指向自己。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::InsertElement(DataType inData, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *insertElement = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inData);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span> || listSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\thead = insertElement;</span><br><span class=\"line\">\t\thead-&gt;next = head;</span><br><span class=\"line\">\t\thead-&gt;prior = head; ++listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span> || n &gt;= listSize) &#123;</span><br><span class=\"line\">\t\t\thead-&gt;prior-&gt;next = insertElement;</span><br><span class=\"line\">\t\t\tinsertElement-&gt;prior = head-&gt;prior;</span><br><span class=\"line\">\t\t\tinsertElement-&gt;next = head;</span><br><span class=\"line\">\t\t\thead-&gt;prior = insertElement; ++listSize;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tinsertElement-&gt;next = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t\t\tinsertElement-&gt;prior = cycleIter;</span><br><span class=\"line\">\t\t\t\tcycleIter-&gt;next-&gt;prior = insertElement;</span><br><span class=\"line\">\t\t\t\tcycleIter-&gt;next = insertElement; ++listSize;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回链表长度</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> List&lt;DataType&gt;::Length()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> listSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">List&lt;DataType&gt;::~List()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>以下对上述代码进行简单的测试，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>&gt; Test;</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">9</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">14</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.MakeEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Node&lt;<span class=\"keyword\">int</span>&gt; * pTest = Test.FindElement(<span class=\"number\">12</span>);</span><br><span class=\"line\">        pTest = Test.FindElement(<span class=\"number\">9</span>);</span><br><span class=\"line\">\tpTest = Test.FindElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">4</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>双向循环链表和单向链表一样是一种线性表数据结构，但和单向链表不同，双向循环链表需要增加两个指针域分别指向前驱节点和后继节点，同时首尾节点分别指向彼此。双向链表的实现和单向链表相比稍微有点复杂，但是双向循环链表具有前向和后向遍历能力并且可以从任意节点开始循环遍历所有的节点。双向循环链表的指针域增加也造成了更多的空间浪费，使空间利用率进一步降低。</p>\n<h2 id=\"双向循环链表数据结构的定义\"><a href=\"#双向循环链表数据结构的定义\" class=\"headerlink\" title=\"双向循环链表数据结构的定义\"></a>双向循环链表数据结构的定义</h2><p>使用单向链表的ADT，采用C++模板的方式编写双向循环链表的操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode(DataType inData):data(inData), prior(<span class=\"literal\">nullptr</span>), next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *prior; <span class=\"comment\">/*前驱*/</span></span><br><span class=\"line\">\tNode *next; <span class=\"comment\">/*后继*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tList(): listSize(<span class=\"number\">0</span>), head(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~List(); <span class=\"comment\">//析构函数，负责回收内存</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空链表</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断链表是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsLast</span><span class=\"params\">(Node&lt;DataType&gt; * inPosition)</span></span>; <span class=\"comment\">//判断是否为最后一个元素</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindElement(DataType value); <span class=\"comment\">//查找一个元素并返回地址</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *FindNthElement(<span class=\"keyword\">int</span> n); <span class=\"comment\">//查找第n个元素，返回地址或者nullptr</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//删除一个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteNthElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">//删除第n个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inData, <span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">//插入一个节点</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Length</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回链表长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> listSize; <span class=\"comment\">//保存链表长度</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; *head; <span class=\"comment\">/*只需头节点即可*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，在链表类中有两个数据成员，分别为listSize和head。listSize保存当前链表大小，对一些函数可快速判断输入是否合法；head保存链表头节点，如果链表为空则置为空指针。</p>\n<p>下面依次实现各函数：</p>\n<ul>\n<li>清空链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || head == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/*使首尾断开连接，便于终止条件判断*/</span></span><br><span class=\"line\">\thead-&gt;prior-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tNode&lt;DataType&gt; * tmp = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\thead = head-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">\t\ttmp = head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlistSize = <span class=\"number\">0</span>; head = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断列表是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> List&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || head == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断是否为最后一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> List&lt;DataType&gt;::IsLast(Node&lt;DataType&gt; * inPosition)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inPosition != <span class=\"literal\">nullptr</span> &amp;&amp; inPosition == head-&gt;prior;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找一个元素并返回地址</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * List&lt;DataType&gt;::FindElement(DataType value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == value) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter == head) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>; <span class=\"comment\">/*回到头节点了*/</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找第n个元素，下标从1开始，返回地址或者nullptr</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * List&lt;DataType&gt;::FindNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span> || n &gt; listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*超过大小直接返回nullptr防止回绕*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::DeleteElement(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cycleIter-&gt;data == inData) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/*注意处理只有一个节点和删除头节点的问题*/</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cycleIter == head) &#123;</span><br><span class=\"line\">\t\t\t\thead = head-&gt;next != head ? head-&gt;next : <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">\t\t\ttmp-&gt;prior-&gt;next = tmp-&gt;next;</span><br><span class=\"line\">\t\t\ttmp-&gt;next-&gt;prior = tmp-&gt;prior;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; --listSize;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除第n个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::DeleteNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span> || n &gt; listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tNode&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">\t\ttmp-&gt;prior-&gt;next = tmp-&gt;next;</span><br><span class=\"line\">\t\ttmp-&gt;next-&gt;prior = tmp-&gt;prior;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp; --listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入一个节点, n&lt;0或者&gt;链表长度代表直接插到末尾，其他代表插到第n个节点后</li>\n</ul>\n<p>如果只有一个节点将该节点的首尾均指向自己。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> List&lt;DataType&gt;::InsertElement(DataType inData, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *insertElement = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inData);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span> || listSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\thead = insertElement;</span><br><span class=\"line\">\t\thead-&gt;next = head;</span><br><span class=\"line\">\t\thead-&gt;prior = head; ++listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span> || n &gt;= listSize) &#123;</span><br><span class=\"line\">\t\t\thead-&gt;prior-&gt;next = insertElement;</span><br><span class=\"line\">\t\t\tinsertElement-&gt;prior = head-&gt;prior;</span><br><span class=\"line\">\t\t\tinsertElement-&gt;next = head;</span><br><span class=\"line\">\t\t\thead-&gt;prior = insertElement; ++listSize;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *cycleIter = head;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tinsertElement-&gt;next = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t\t\tinsertElement-&gt;prior = cycleIter;</span><br><span class=\"line\">\t\t\t\tcycleIter-&gt;next-&gt;prior = insertElement;</span><br><span class=\"line\">\t\t\t\tcycleIter-&gt;next = insertElement; ++listSize;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回链表长度</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> List&lt;DataType&gt;::Length()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> listSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">List&lt;DataType&gt;::~List()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>以下对上述代码进行简单的测试，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>&gt; Test;</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">9</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">14</span>);</span><br><span class=\"line\">        Test.DeleteElement(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.MakeEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">9</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">10</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">12</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"number\">14</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Node&lt;<span class=\"keyword\">int</span>&gt; * pTest = Test.FindElement(<span class=\"number\">12</span>);</span><br><span class=\"line\">        pTest = Test.FindElement(<span class=\"number\">9</span>);</span><br><span class=\"line\">\tpTest = Test.FindElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">4</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n"},{"title":"数据结构之单向链表-游标实现","urlname":"one-way-cursor-list","date":"2018-06-06T13:47:11.000Z","mathjax":true,"copyright":true,"_content":"\n## 基础知识\n\n单向链表的游标实现和指针实现最大的不同是游标实现无法采用指针的方式连接到下一个节点，其只能通过数组下标的方式进行下一节点的索引，因此游标实现相比指针实现需要手动管理数组内存使用情况，本文直接采用《数据结构与算法分析：C语言描述》中的思路，不过本文使用了一个哑节点，代码中约定数组第0号节点用来模拟管理内存，1号节点作为哑节点，具体的定义和实现如下小节所示。\n\n## 游标单向链表的定义和实现\n\n由于游标实现中不能动态申请内存，因此函数中会预先分配一个固定大小的数组。具体实现见如下代码：\n\n```cpp  \ntemplate <typename DataType>\nstruct CursorNode\n{\n        CursorNode() : next(0) {}\n\tDataType data;\n        /*数组下标指定下一个节点，0代表没有下一个节点*/\n\tint next;\n};\n\nconst int maxListSize = 100; /*数组大小*/\n\ntemplate <typename DataType>\nclass CursorList\n{\npublic:\n\tCursorList();\n\t~CursorList(); /*析构函数，负责回收内存*/\n\tvoid MakeEmpty(); /*清空链表*/\n\tbool IsEmpty(); /*判断链表是否为空*/\n\tbool IsLast(int inPosition); /*判断是否为最后一个元素*/\n\tint FindElement(DataType value); /*查找一个元素并返回下标*/\n\tint FindNthElement(int n); /*查找第n个元素并返回下标*/\n\tvoid DeleteElement(DataType inData); /*删除一个节点*/\n\tvoid DeleteNthElement(int n); /*删除第n个节点*/\n\tvoid InsertElement(DataType inData, int n); /*插入一个节点*/\n\tint Length(); /*返回链表长度*/\n        void PrintList(); /*打印链表*/\nprivate:\n        int Alloc(); /*获取一个单位节点的空间数组小标索引，没有返回0*/\n        void Free(int nodeIndex); /*释放一个单位节点的空间*/\nprivate:\n        const int dummyNode = 1; /*哑节点下标固定为1*/\n        CursorNode<DataType> listNodes[maxListSize]; /*节点数组*/\n        int listSize; /*保存链表长度*/\n        int lastNode; /*保存最后一个节点下标*/\n};\n```\n\n如上所示，在链表类中有四个数据成员和一个全局变量maxListSize，数据成员分别为dummyNode、listNodes、listSize和lastNode。maxListSize是指节点数组最大容量，listNodes是节点数组，listSize是当前链表大小，dummyNode是哑节点索引，lastNode保存最后一个节点的数组索引。\n\n下面依次实现各函数：\n\n- 构造函数，0号节点作为内存管理头节点，1作为哑节点（因为0代表没有下一个节点）\n\n```cpp\ntemplate <typename DataType>\nCursorList<DataType>::CursorList():dummyNode(1), listSize(0), lastNode(0)\n{\n        for (int i = 0; i < maxListSize; i++) {\n                listNodes[i].next = i + 1;\n        }\n        listNodes[0].next = 2; /*跳过哑节点*/\n        listNodes[1].next = 0; /*哑节点初始下一节点指向空*/\n        listNodes[maxListSize-1].next = 0; /*最后一个节点下一个节点指向空*/\n}\n```\n\n- 析构函数，模拟内存回收\n\n```cpp\ntemplate <typename DataType>\nCursorList<DataType>::~CursorList()\n{\n        MakeEmpty();\n}\n```\n\n- 清空链表\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::MakeEmpty()\n{\n\tif (listSize <= 0 || listNodes[dummyNode].next == 0) {\n\t\treturn;\n\t}\n\tint tmp = 0;\n\twhile (listNodes[dummyNode].next != 0) {\n\t\ttmp = listNodes[dummyNode].next;\n\t\tlistNodes[dummyNode].next = listNodes[tmp].next;\n\t\tFree(tmp);\n\t}\n\tlistSize = 0; lastNode = 0;\n\treturn;\n}\n```\n\n- 判断列表是否为空\n\n```cpp\ntemplate <typename DataType>\nbool CursorList<DataType>::IsEmpty()\n{\n\tif (listSize <= 0 || listNodes[dummyNode].next == 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n- 判断是否为最后一个元素\n\n```cpp\ntemplate <typename DataType>\nbool CursorList<DataType>::IsLast(int inPosition)\n{\n\treturn inPosition != 0 && inPosition == lastNode;\n}\n```\n\n- 查找一个元素并返回下标\n\n```cpp\ntemplate <typename DataType>\nint CursorList<DataType>::FindElement(DataType value)\n{\n\tint cycleIter = listNodes[dummyNode].next;\n\twhile (cycleIter != 0) {\n\t\tif (listNodes[cycleIter].data == value) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\tcycleIter = listNodes[cycleIter].next;\n\t}\n\treturn 0;\n}\n```\n\n- 查找第n个元素，dummy为第0个元素，返回地址或者0\n\n```cpp\ntemplate <typename DataType>\nint CursorList<DataType>::FindNthElement(int n)\n{\n\tif (n <= 0) {\n\t\treturn 0;\n\t}\n\tint cycleIter = listNodes[dummyNode].next;\n\twhile (--n > 0 && cycleIter != 0) {\n\t\tcycleIter = listNodes[cycleIter].next;\n\t}\n\treturn cycleIter;\n}\n```\n\n- 删除一个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::DeleteElement(DataType inData)\n{\n\tint cycleIter = dummyNode;\n\twhile (listNodes[cycleIter].next != 0) {\n\t\tif (listNodes[listNodes[cycleIter].next].data == inData) {\n\t\t\tint tmp = listNodes[cycleIter].next;\n\t\t\tlistNodes[cycleIter].next = listNodes[tmp].next;\n\t\t\tlastNode = lastNode == tmp ? cycleIter : lastNode;\n\t\t\tFree(tmp); --listSize;\n\t\t\treturn;\n\t\t}\n\t\tcycleIter = listNodes[cycleIter].next;\n\t}\n\n\tif (listNodes[dummyNode].next == 0) {\n\t\tlastNode = 0;\n\t}\n\treturn;\n}\n```\n\n- 删除第n个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::DeleteNthElement(int n)\n{\n\tif (n <= 0 || n > listSize) {\n\t\treturn;\n\t}\n\n\tint cycleIter = dummyNode;\n\twhile (listNodes[cycleIter].next != 0 && --n > 0) {\n\t\tcycleIter =listNodes[cycleIter].next;\n\t}\n\tif (n <= 0) {\n\t\tint tmp = listNodes[cycleIter].next;\n\t\tlistNodes[cycleIter].next = listNodes[tmp].next;\n\t\tlastNode = lastNode == tmp ? cycleIter : lastNode;\n\t\tFree(tmp); --listSize;\n\t}\n\tif (listNodes[dummyNode].next == 0) {\n\t\tlastNode = 0;\n\t}\n\treturn;\n}\n```\n\n- 插入一个节点, n<0或者>链表长度代表直接插到末尾，其他代表插到第n个节点后\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::InsertElement(DataType inData, int n)\n{\n\tint insertElement = Alloc();\n        if (insertElement == 0) {\n                return; /*空间不足*/\n        }\n\tlistNodes[insertElement].data = inData;\n\tlistNodes[insertElement].next = 0;\n\tif (n < 0 || n >= listSize) {\n                /*插到末尾*/\n\t\tif (lastNode == 0) {\n\t\t\tlastNode = dummyNode;\n\t\t}\n\t\tlistNodes[lastNode].next = insertElement;\n\t\tlastNode = insertElement; ++listSize;\n\t\treturn;\n\t}\n\n\tint cycleIter = dummyNode;\n\twhile (n-- > 0 && cycleIter != 0) {\n\t\tcycleIter = listNodes[cycleIter].next;\n\t}\n\tif (n <= 0) {\n\t\tlistNodes[insertElement].next = listNodes[cycleIter].next;\n\t\tlistNodes[cycleIter].next = insertElement; ++listSize;\n\t}\n\treturn;\n}\n```\n\n- 申请一个单位空间函数\n\n```cpp\ntemplate <typename DataType>\nint CursorList<DataType>::Alloc()\n{\n        if (listNodes[0].next == 0) {\n                return 0;\n                /*没有空间了*/\n        }\n        int tmp = listNodes[0].next;\n        listNodes[0].next = listNodes[tmp].next;\n        return tmp;\n}\n```\n\n- 释放一个单位空间函数\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::Free(int nodeIndex)\n{\n        if (nodeIndex <= 1 || nodeIndex >= maxListSize) {\n                return;\n        }\n        listNodes[nodeIndex].next = listNodes[0].next;\n        listNodes[0].next = nodeIndex;\n        return;\n}\n```\n\n- 返回链表长度\n\n```cpp\ntemplate <typename DataType>\nint CursorList<DataType>::Length()\n{\n\treturn listSize;\n}\n```\n\n- 打印链表\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::PrintList()\n{\n        int cycleIter = listNodes[dummyNode].next;\n\twhile (cycleIter != 0) {\n\t\tcout << listNodes[cycleIter].data << \";\";\n                cycleIter = listNodes[cycleIter].next;\n\t}\n        cout << endl;\n}\n```\n\n## 代码测试\n\n对上述代码进行简单地测试，测试代码如下：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n        CursorList<char> Test;\n\n        Test.InsertElement('A', 0);\n        Test.InsertElement('B', 1);\n\n        Test.PrintList();\n\n        Test.InsertElement('C', 1);\n        Test.InsertElement('D', 7);\n\n        cout << Test.IsEmpty() << endl;\n        Test.PrintList();\n\n        Test.InsertElement('E', 3);\n        Test.InsertElement('F', 2);\n\n        Test.PrintList();\n\n        cout << Test.Length() << endl;\n\n        Test.DeleteElement('B');\n\n        Test.PrintList();\n\n        Test.DeleteElement('F');\n\n        Test.PrintList();\n\n        Test.DeleteElement('D');\n\n        Test.PrintList();\n\n        Test.DeleteElement('B');\n\n        Test.PrintList();\n\n        cout << Test.IsEmpty() << endl;\n\n        cout << Test.Length() << endl;\n\n        Test.InsertElement('A', 0);\n        Test.InsertElement('B', 1);\n        Test.InsertElement('C', 1);\n        Test.InsertElement('D', 7);\n        Test.InsertElement('E', 3);\n        Test.InsertElement('F', 2);\n\n        Test.PrintList();\n\n        Test.MakeEmpty();\n\n        Test.PrintList();\n\n        Test.InsertElement('A', 0);\n        Test.InsertElement('B', 1);\n        Test.InsertElement('C', 1);\n        Test.InsertElement('D', 7);\n        Test.InsertElement('E', 3);\n        Test.InsertElement('F', 2);\n\n        Test.PrintList();\n\n        int pTest = Test.FindElement('A');\n        pTest = Test.FindElement('E');\n\tpTest = Test.FindElement('G');\n\n        pTest = Test.FindNthElement(4);\n        pTest = Test.FindNthElement(-1);\n        pTest = Test.FindNthElement(1);\n        pTest = Test.FindNthElement(10);\n\n        return 0;\n}\n```\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","source":"_posts/数据结构/数据结构之单向链表-游标实现.md","raw":"---\ntitle: 数据结构之单向链表-游标实现\nurlname: one-way-cursor-list\ndate: 2018-06-06 21:47:11\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\n- C++\ncategories:\n- 数据结构\n---\n\n## 基础知识\n\n单向链表的游标实现和指针实现最大的不同是游标实现无法采用指针的方式连接到下一个节点，其只能通过数组下标的方式进行下一节点的索引，因此游标实现相比指针实现需要手动管理数组内存使用情况，本文直接采用《数据结构与算法分析：C语言描述》中的思路，不过本文使用了一个哑节点，代码中约定数组第0号节点用来模拟管理内存，1号节点作为哑节点，具体的定义和实现如下小节所示。\n\n## 游标单向链表的定义和实现\n\n由于游标实现中不能动态申请内存，因此函数中会预先分配一个固定大小的数组。具体实现见如下代码：\n\n```cpp  \ntemplate <typename DataType>\nstruct CursorNode\n{\n        CursorNode() : next(0) {}\n\tDataType data;\n        /*数组下标指定下一个节点，0代表没有下一个节点*/\n\tint next;\n};\n\nconst int maxListSize = 100; /*数组大小*/\n\ntemplate <typename DataType>\nclass CursorList\n{\npublic:\n\tCursorList();\n\t~CursorList(); /*析构函数，负责回收内存*/\n\tvoid MakeEmpty(); /*清空链表*/\n\tbool IsEmpty(); /*判断链表是否为空*/\n\tbool IsLast(int inPosition); /*判断是否为最后一个元素*/\n\tint FindElement(DataType value); /*查找一个元素并返回下标*/\n\tint FindNthElement(int n); /*查找第n个元素并返回下标*/\n\tvoid DeleteElement(DataType inData); /*删除一个节点*/\n\tvoid DeleteNthElement(int n); /*删除第n个节点*/\n\tvoid InsertElement(DataType inData, int n); /*插入一个节点*/\n\tint Length(); /*返回链表长度*/\n        void PrintList(); /*打印链表*/\nprivate:\n        int Alloc(); /*获取一个单位节点的空间数组小标索引，没有返回0*/\n        void Free(int nodeIndex); /*释放一个单位节点的空间*/\nprivate:\n        const int dummyNode = 1; /*哑节点下标固定为1*/\n        CursorNode<DataType> listNodes[maxListSize]; /*节点数组*/\n        int listSize; /*保存链表长度*/\n        int lastNode; /*保存最后一个节点下标*/\n};\n```\n\n如上所示，在链表类中有四个数据成员和一个全局变量maxListSize，数据成员分别为dummyNode、listNodes、listSize和lastNode。maxListSize是指节点数组最大容量，listNodes是节点数组，listSize是当前链表大小，dummyNode是哑节点索引，lastNode保存最后一个节点的数组索引。\n\n下面依次实现各函数：\n\n- 构造函数，0号节点作为内存管理头节点，1作为哑节点（因为0代表没有下一个节点）\n\n```cpp\ntemplate <typename DataType>\nCursorList<DataType>::CursorList():dummyNode(1), listSize(0), lastNode(0)\n{\n        for (int i = 0; i < maxListSize; i++) {\n                listNodes[i].next = i + 1;\n        }\n        listNodes[0].next = 2; /*跳过哑节点*/\n        listNodes[1].next = 0; /*哑节点初始下一节点指向空*/\n        listNodes[maxListSize-1].next = 0; /*最后一个节点下一个节点指向空*/\n}\n```\n\n- 析构函数，模拟内存回收\n\n```cpp\ntemplate <typename DataType>\nCursorList<DataType>::~CursorList()\n{\n        MakeEmpty();\n}\n```\n\n- 清空链表\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::MakeEmpty()\n{\n\tif (listSize <= 0 || listNodes[dummyNode].next == 0) {\n\t\treturn;\n\t}\n\tint tmp = 0;\n\twhile (listNodes[dummyNode].next != 0) {\n\t\ttmp = listNodes[dummyNode].next;\n\t\tlistNodes[dummyNode].next = listNodes[tmp].next;\n\t\tFree(tmp);\n\t}\n\tlistSize = 0; lastNode = 0;\n\treturn;\n}\n```\n\n- 判断列表是否为空\n\n```cpp\ntemplate <typename DataType>\nbool CursorList<DataType>::IsEmpty()\n{\n\tif (listSize <= 0 || listNodes[dummyNode].next == 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n- 判断是否为最后一个元素\n\n```cpp\ntemplate <typename DataType>\nbool CursorList<DataType>::IsLast(int inPosition)\n{\n\treturn inPosition != 0 && inPosition == lastNode;\n}\n```\n\n- 查找一个元素并返回下标\n\n```cpp\ntemplate <typename DataType>\nint CursorList<DataType>::FindElement(DataType value)\n{\n\tint cycleIter = listNodes[dummyNode].next;\n\twhile (cycleIter != 0) {\n\t\tif (listNodes[cycleIter].data == value) {\n\t\t\treturn cycleIter;\n\t\t}\n\t\tcycleIter = listNodes[cycleIter].next;\n\t}\n\treturn 0;\n}\n```\n\n- 查找第n个元素，dummy为第0个元素，返回地址或者0\n\n```cpp\ntemplate <typename DataType>\nint CursorList<DataType>::FindNthElement(int n)\n{\n\tif (n <= 0) {\n\t\treturn 0;\n\t}\n\tint cycleIter = listNodes[dummyNode].next;\n\twhile (--n > 0 && cycleIter != 0) {\n\t\tcycleIter = listNodes[cycleIter].next;\n\t}\n\treturn cycleIter;\n}\n```\n\n- 删除一个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::DeleteElement(DataType inData)\n{\n\tint cycleIter = dummyNode;\n\twhile (listNodes[cycleIter].next != 0) {\n\t\tif (listNodes[listNodes[cycleIter].next].data == inData) {\n\t\t\tint tmp = listNodes[cycleIter].next;\n\t\t\tlistNodes[cycleIter].next = listNodes[tmp].next;\n\t\t\tlastNode = lastNode == tmp ? cycleIter : lastNode;\n\t\t\tFree(tmp); --listSize;\n\t\t\treturn;\n\t\t}\n\t\tcycleIter = listNodes[cycleIter].next;\n\t}\n\n\tif (listNodes[dummyNode].next == 0) {\n\t\tlastNode = 0;\n\t}\n\treturn;\n}\n```\n\n- 删除第n个节点，如果不存在则不做任何事\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::DeleteNthElement(int n)\n{\n\tif (n <= 0 || n > listSize) {\n\t\treturn;\n\t}\n\n\tint cycleIter = dummyNode;\n\twhile (listNodes[cycleIter].next != 0 && --n > 0) {\n\t\tcycleIter =listNodes[cycleIter].next;\n\t}\n\tif (n <= 0) {\n\t\tint tmp = listNodes[cycleIter].next;\n\t\tlistNodes[cycleIter].next = listNodes[tmp].next;\n\t\tlastNode = lastNode == tmp ? cycleIter : lastNode;\n\t\tFree(tmp); --listSize;\n\t}\n\tif (listNodes[dummyNode].next == 0) {\n\t\tlastNode = 0;\n\t}\n\treturn;\n}\n```\n\n- 插入一个节点, n<0或者>链表长度代表直接插到末尾，其他代表插到第n个节点后\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::InsertElement(DataType inData, int n)\n{\n\tint insertElement = Alloc();\n        if (insertElement == 0) {\n                return; /*空间不足*/\n        }\n\tlistNodes[insertElement].data = inData;\n\tlistNodes[insertElement].next = 0;\n\tif (n < 0 || n >= listSize) {\n                /*插到末尾*/\n\t\tif (lastNode == 0) {\n\t\t\tlastNode = dummyNode;\n\t\t}\n\t\tlistNodes[lastNode].next = insertElement;\n\t\tlastNode = insertElement; ++listSize;\n\t\treturn;\n\t}\n\n\tint cycleIter = dummyNode;\n\twhile (n-- > 0 && cycleIter != 0) {\n\t\tcycleIter = listNodes[cycleIter].next;\n\t}\n\tif (n <= 0) {\n\t\tlistNodes[insertElement].next = listNodes[cycleIter].next;\n\t\tlistNodes[cycleIter].next = insertElement; ++listSize;\n\t}\n\treturn;\n}\n```\n\n- 申请一个单位空间函数\n\n```cpp\ntemplate <typename DataType>\nint CursorList<DataType>::Alloc()\n{\n        if (listNodes[0].next == 0) {\n                return 0;\n                /*没有空间了*/\n        }\n        int tmp = listNodes[0].next;\n        listNodes[0].next = listNodes[tmp].next;\n        return tmp;\n}\n```\n\n- 释放一个单位空间函数\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::Free(int nodeIndex)\n{\n        if (nodeIndex <= 1 || nodeIndex >= maxListSize) {\n                return;\n        }\n        listNodes[nodeIndex].next = listNodes[0].next;\n        listNodes[0].next = nodeIndex;\n        return;\n}\n```\n\n- 返回链表长度\n\n```cpp\ntemplate <typename DataType>\nint CursorList<DataType>::Length()\n{\n\treturn listSize;\n}\n```\n\n- 打印链表\n\n```cpp\ntemplate <typename DataType>\nvoid CursorList<DataType>::PrintList()\n{\n        int cycleIter = listNodes[dummyNode].next;\n\twhile (cycleIter != 0) {\n\t\tcout << listNodes[cycleIter].data << \";\";\n                cycleIter = listNodes[cycleIter].next;\n\t}\n        cout << endl;\n}\n```\n\n## 代码测试\n\n对上述代码进行简单地测试，测试代码如下：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n        CursorList<char> Test;\n\n        Test.InsertElement('A', 0);\n        Test.InsertElement('B', 1);\n\n        Test.PrintList();\n\n        Test.InsertElement('C', 1);\n        Test.InsertElement('D', 7);\n\n        cout << Test.IsEmpty() << endl;\n        Test.PrintList();\n\n        Test.InsertElement('E', 3);\n        Test.InsertElement('F', 2);\n\n        Test.PrintList();\n\n        cout << Test.Length() << endl;\n\n        Test.DeleteElement('B');\n\n        Test.PrintList();\n\n        Test.DeleteElement('F');\n\n        Test.PrintList();\n\n        Test.DeleteElement('D');\n\n        Test.PrintList();\n\n        Test.DeleteElement('B');\n\n        Test.PrintList();\n\n        cout << Test.IsEmpty() << endl;\n\n        cout << Test.Length() << endl;\n\n        Test.InsertElement('A', 0);\n        Test.InsertElement('B', 1);\n        Test.InsertElement('C', 1);\n        Test.InsertElement('D', 7);\n        Test.InsertElement('E', 3);\n        Test.InsertElement('F', 2);\n\n        Test.PrintList();\n\n        Test.MakeEmpty();\n\n        Test.PrintList();\n\n        Test.InsertElement('A', 0);\n        Test.InsertElement('B', 1);\n        Test.InsertElement('C', 1);\n        Test.InsertElement('D', 7);\n        Test.InsertElement('E', 3);\n        Test.InsertElement('F', 2);\n\n        Test.PrintList();\n\n        int pTest = Test.FindElement('A');\n        pTest = Test.FindElement('E');\n\tpTest = Test.FindElement('G');\n\n        pTest = Test.FindNthElement(4);\n        pTest = Test.FindNthElement(-1);\n        pTest = Test.FindNthElement(1);\n        pTest = Test.FindNthElement(10);\n\n        return 0;\n}\n```\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","slug":"数据结构/数据结构之单向链表-游标实现","published":1,"updated":"2018-06-13T14:07:21.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3l0019gsvn6ugxykg2","content":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>单向链表的游标实现和指针实现最大的不同是游标实现无法采用指针的方式连接到下一个节点，其只能通过数组下标的方式进行下一节点的索引，因此游标实现相比指针实现需要手动管理数组内存使用情况，本文直接采用《数据结构与算法分析：C语言描述》中的思路，不过本文使用了一个哑节点，代码中约定数组第0号节点用来模拟管理内存，1号节点作为哑节点，具体的定义和实现如下小节所示。</p>\n<h2 id=\"游标单向链表的定义和实现\"><a href=\"#游标单向链表的定义和实现\" class=\"headerlink\" title=\"游标单向链表的定义和实现\"></a>游标单向链表的定义和实现</h2><p>由于游标实现中不能动态申请内存，因此函数中会预先分配一个固定大小的数组。具体实现见如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CursorNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        CursorNode() : next(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">        <span class=\"comment\">/*数组下标指定下一个节点，0代表没有下一个节点*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxListSize = <span class=\"number\">100</span>; <span class=\"comment\">/*数组大小*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CursorList</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tCursorList();</span><br><span class=\"line\">\t~CursorList(); <span class=\"comment\">/*析构函数，负责回收内存*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*清空链表*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*判断链表是否为空*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsLast</span><span class=\"params\">(<span class=\"keyword\">int</span> inPosition)</span></span>; <span class=\"comment\">/*判断是否为最后一个元素*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FindElement</span><span class=\"params\">(DataType value)</span></span>; <span class=\"comment\">/*查找一个元素并返回下标*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FindNthElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">/*查找第n个元素并返回下标*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">/*删除一个节点*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteNthElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">/*删除第n个节点*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inData, <span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">/*插入一个节点*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Length</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*返回链表长度*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintList</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*打印链表*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Alloc</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*获取一个单位节点的空间数组小标索引，没有返回0*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Free</span><span class=\"params\">(<span class=\"keyword\">int</span> nodeIndex)</span></span>; <span class=\"comment\">/*释放一个单位节点的空间*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dummyNode = <span class=\"number\">1</span>; <span class=\"comment\">/*哑节点下标固定为1*/</span></span><br><span class=\"line\">        CursorNode&lt;DataType&gt; listNodes[maxListSize]; <span class=\"comment\">/*节点数组*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> listSize; <span class=\"comment\">/*保存链表长度*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> lastNode; <span class=\"comment\">/*保存最后一个节点下标*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，在链表类中有四个数据成员和一个全局变量maxListSize，数据成员分别为dummyNode、listNodes、listSize和lastNode。maxListSize是指节点数组最大容量，listNodes是节点数组，listSize是当前链表大小，dummyNode是哑节点索引，lastNode保存最后一个节点的数组索引。</p>\n<p>下面依次实现各函数：</p>\n<ul>\n<li>构造函数，0号节点作为内存管理头节点，1作为哑节点（因为0代表没有下一个节点）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">CursorList&lt;DataType&gt;::CursorList():dummyNode(<span class=\"number\">1</span>), listSize(<span class=\"number\">0</span>), lastNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxListSize; i++) &#123;</span><br><span class=\"line\">                listNodes[i].next = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        listNodes[<span class=\"number\">0</span>].next = <span class=\"number\">2</span>; <span class=\"comment\">/*跳过哑节点*/</span></span><br><span class=\"line\">        listNodes[<span class=\"number\">1</span>].next = <span class=\"number\">0</span>; <span class=\"comment\">/*哑节点初始下一节点指向空*/</span></span><br><span class=\"line\">        listNodes[maxListSize<span class=\"number\">-1</span>].next = <span class=\"number\">0</span>; <span class=\"comment\">/*最后一个节点下一个节点指向空*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，模拟内存回收</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">CursorList&lt;DataType&gt;::~CursorList()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        MakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || listNodes[dummyNode].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (listNodes[dummyNode].next != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\ttmp = listNodes[dummyNode].next;</span><br><span class=\"line\">\t\tlistNodes[dummyNode].next = listNodes[tmp].next;</span><br><span class=\"line\">\t\tFree(tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlistSize = <span class=\"number\">0</span>; lastNode = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断列表是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> CursorList&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || listNodes[dummyNode].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断是否为最后一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> CursorList&lt;DataType&gt;::IsLast(<span class=\"keyword\">int</span> inPosition)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inPosition != <span class=\"number\">0</span> &amp;&amp; inPosition == lastNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找一个元素并返回下标</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> CursorList&lt;DataType&gt;::FindElement(DataType value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = listNodes[dummyNode].next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (listNodes[cycleIter].data == value) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找第n个元素，dummy为第0个元素，返回地址或者0</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> CursorList&lt;DataType&gt;::FindNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = listNodes[dummyNode].next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::DeleteElement(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (listNodes[cycleIter].next != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (listNodes[listNodes[cycleIter].next].data == inData) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp = listNodes[cycleIter].next;</span><br><span class=\"line\">\t\t\tlistNodes[cycleIter].next = listNodes[tmp].next;</span><br><span class=\"line\">\t\t\tlastNode = lastNode == tmp ? cycleIter : lastNode;</span><br><span class=\"line\">\t\t\tFree(tmp); --listSize;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listNodes[dummyNode].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除第n个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::DeleteNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span> || n &gt; listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (listNodes[cycleIter].next != <span class=\"number\">0</span> &amp;&amp; --n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter =listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp = listNodes[cycleIter].next;</span><br><span class=\"line\">\t\tlistNodes[cycleIter].next = listNodes[tmp].next;</span><br><span class=\"line\">\t\tlastNode = lastNode == tmp ? cycleIter : lastNode;</span><br><span class=\"line\">\t\tFree(tmp); --listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listNodes[dummyNode].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入一个节点, n&lt;0或者&gt;链表长度代表直接插到末尾，其他代表插到第n个节点后</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::InsertElement(DataType inData, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> insertElement = Alloc();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (insertElement == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">/*空间不足*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\tlistNodes[insertElement].data = inData;</span><br><span class=\"line\">\tlistNodes[insertElement].next = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span> || n &gt;= listSize) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*插到末尾*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lastNode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tlastNode = dummyNode;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlistNodes[lastNode].next = insertElement;</span><br><span class=\"line\">\t\tlastNode = insertElement; ++listSize;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n-- &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tlistNodes[insertElement].next = listNodes[cycleIter].next;</span><br><span class=\"line\">\t\tlistNodes[cycleIter].next = insertElement; ++listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>申请一个单位空间函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> CursorList&lt;DataType&gt;::Alloc()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listNodes[<span class=\"number\">0</span>].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"comment\">/*没有空间了*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = listNodes[<span class=\"number\">0</span>].next;</span><br><span class=\"line\">        listNodes[<span class=\"number\">0</span>].next = listNodes[tmp].next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>释放一个单位空间函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::Free(<span class=\"keyword\">int</span> nodeIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeIndex &lt;= <span class=\"number\">1</span> || nodeIndex &gt;= maxListSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        listNodes[nodeIndex].next = listNodes[<span class=\"number\">0</span>].next;</span><br><span class=\"line\">        listNodes[<span class=\"number\">0</span>].next = nodeIndex;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回链表长度</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> CursorList&lt;DataType&gt;::Length()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> listSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::PrintList()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cycleIter = listNodes[dummyNode].next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; listNodes[cycleIter].data &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                cycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>对上述代码进行简单地测试，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        CursorList&lt;<span class=\"keyword\">char</span>&gt; Test;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'A'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'B'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'C'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'D'</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'E'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'F'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"string\">'B'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"string\">'F'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"string\">'D'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"string\">'B'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'A'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'B'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'C'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'D'</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'E'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'F'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.MakeEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'A'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'B'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'C'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'D'</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'E'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'F'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pTest = Test.FindElement(<span class=\"string\">'A'</span>);</span><br><span class=\"line\">        pTest = Test.FindElement(<span class=\"string\">'E'</span>);</span><br><span class=\"line\">\tpTest = Test.FindElement(<span class=\"string\">'G'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">4</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>单向链表的游标实现和指针实现最大的不同是游标实现无法采用指针的方式连接到下一个节点，其只能通过数组下标的方式进行下一节点的索引，因此游标实现相比指针实现需要手动管理数组内存使用情况，本文直接采用《数据结构与算法分析：C语言描述》中的思路，不过本文使用了一个哑节点，代码中约定数组第0号节点用来模拟管理内存，1号节点作为哑节点，具体的定义和实现如下小节所示。</p>\n<h2 id=\"游标单向链表的定义和实现\"><a href=\"#游标单向链表的定义和实现\" class=\"headerlink\" title=\"游标单向链表的定义和实现\"></a>游标单向链表的定义和实现</h2><p>由于游标实现中不能动态申请内存，因此函数中会预先分配一个固定大小的数组。具体实现见如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CursorNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        CursorNode() : next(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">        <span class=\"comment\">/*数组下标指定下一个节点，0代表没有下一个节点*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxListSize = <span class=\"number\">100</span>; <span class=\"comment\">/*数组大小*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CursorList</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tCursorList();</span><br><span class=\"line\">\t~CursorList(); <span class=\"comment\">/*析构函数，负责回收内存*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*清空链表*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*判断链表是否为空*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsLast</span><span class=\"params\">(<span class=\"keyword\">int</span> inPosition)</span></span>; <span class=\"comment\">/*判断是否为最后一个元素*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FindElement</span><span class=\"params\">(DataType value)</span></span>; <span class=\"comment\">/*查找一个元素并返回下标*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FindNthElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">/*查找第n个元素并返回下标*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteElement</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">/*删除一个节点*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteNthElement</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">/*删除第n个节点*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inData, <span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">/*插入一个节点*/</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Length</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*返回链表长度*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintList</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*打印链表*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Alloc</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*获取一个单位节点的空间数组小标索引，没有返回0*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Free</span><span class=\"params\">(<span class=\"keyword\">int</span> nodeIndex)</span></span>; <span class=\"comment\">/*释放一个单位节点的空间*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dummyNode = <span class=\"number\">1</span>; <span class=\"comment\">/*哑节点下标固定为1*/</span></span><br><span class=\"line\">        CursorNode&lt;DataType&gt; listNodes[maxListSize]; <span class=\"comment\">/*节点数组*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> listSize; <span class=\"comment\">/*保存链表长度*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> lastNode; <span class=\"comment\">/*保存最后一个节点下标*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，在链表类中有四个数据成员和一个全局变量maxListSize，数据成员分别为dummyNode、listNodes、listSize和lastNode。maxListSize是指节点数组最大容量，listNodes是节点数组，listSize是当前链表大小，dummyNode是哑节点索引，lastNode保存最后一个节点的数组索引。</p>\n<p>下面依次实现各函数：</p>\n<ul>\n<li>构造函数，0号节点作为内存管理头节点，1作为哑节点（因为0代表没有下一个节点）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">CursorList&lt;DataType&gt;::CursorList():dummyNode(<span class=\"number\">1</span>), listSize(<span class=\"number\">0</span>), lastNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxListSize; i++) &#123;</span><br><span class=\"line\">                listNodes[i].next = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        listNodes[<span class=\"number\">0</span>].next = <span class=\"number\">2</span>; <span class=\"comment\">/*跳过哑节点*/</span></span><br><span class=\"line\">        listNodes[<span class=\"number\">1</span>].next = <span class=\"number\">0</span>; <span class=\"comment\">/*哑节点初始下一节点指向空*/</span></span><br><span class=\"line\">        listNodes[maxListSize<span class=\"number\">-1</span>].next = <span class=\"number\">0</span>; <span class=\"comment\">/*最后一个节点下一个节点指向空*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，模拟内存回收</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">CursorList&lt;DataType&gt;::~CursorList()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        MakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || listNodes[dummyNode].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (listNodes[dummyNode].next != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\ttmp = listNodes[dummyNode].next;</span><br><span class=\"line\">\t\tlistNodes[dummyNode].next = listNodes[tmp].next;</span><br><span class=\"line\">\t\tFree(tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlistSize = <span class=\"number\">0</span>; lastNode = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断列表是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> CursorList&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listSize &lt;= <span class=\"number\">0</span> || listNodes[dummyNode].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断是否为最后一个元素</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> CursorList&lt;DataType&gt;::IsLast(<span class=\"keyword\">int</span> inPosition)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inPosition != <span class=\"number\">0</span> &amp;&amp; inPosition == lastNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找一个元素并返回下标</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> CursorList&lt;DataType&gt;::FindElement(DataType value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = listNodes[dummyNode].next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (listNodes[cycleIter].data == value) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找第n个元素，dummy为第0个元素，返回地址或者0</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> CursorList&lt;DataType&gt;::FindNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = listNodes[dummyNode].next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (--n &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cycleIter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除一个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::DeleteElement(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (listNodes[cycleIter].next != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (listNodes[listNodes[cycleIter].next].data == inData) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp = listNodes[cycleIter].next;</span><br><span class=\"line\">\t\t\tlistNodes[cycleIter].next = listNodes[tmp].next;</span><br><span class=\"line\">\t\t\tlastNode = lastNode == tmp ? cycleIter : lastNode;</span><br><span class=\"line\">\t\t\tFree(tmp); --listSize;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listNodes[dummyNode].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除第n个节点，如果不存在则不做任何事</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::DeleteNthElement(<span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span> || n &gt; listSize) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (listNodes[cycleIter].next != <span class=\"number\">0</span> &amp;&amp; --n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter =listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp = listNodes[cycleIter].next;</span><br><span class=\"line\">\t\tlistNodes[cycleIter].next = listNodes[tmp].next;</span><br><span class=\"line\">\t\tlastNode = lastNode == tmp ? cycleIter : lastNode;</span><br><span class=\"line\">\t\tFree(tmp); --listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (listNodes[dummyNode].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入一个节点, n&lt;0或者&gt;链表长度代表直接插到末尾，其他代表插到第n个节点后</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::InsertElement(DataType inData, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> insertElement = Alloc();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (insertElement == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">/*空间不足*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\tlistNodes[insertElement].data = inData;</span><br><span class=\"line\">\tlistNodes[insertElement].next = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span> || n &gt;= listSize) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*插到末尾*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lastNode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tlastNode = dummyNode;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlistNodes[lastNode].next = insertElement;</span><br><span class=\"line\">\t\tlastNode = insertElement; ++listSize;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cycleIter = dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n-- &gt; <span class=\"number\">0</span> &amp;&amp; cycleIter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tcycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tlistNodes[insertElement].next = listNodes[cycleIter].next;</span><br><span class=\"line\">\t\tlistNodes[cycleIter].next = insertElement; ++listSize;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>申请一个单位空间函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> CursorList&lt;DataType&gt;::Alloc()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listNodes[<span class=\"number\">0</span>].next == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"comment\">/*没有空间了*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = listNodes[<span class=\"number\">0</span>].next;</span><br><span class=\"line\">        listNodes[<span class=\"number\">0</span>].next = listNodes[tmp].next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>释放一个单位空间函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::Free(<span class=\"keyword\">int</span> nodeIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeIndex &lt;= <span class=\"number\">1</span> || nodeIndex &gt;= maxListSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        listNodes[nodeIndex].next = listNodes[<span class=\"number\">0</span>].next;</span><br><span class=\"line\">        listNodes[<span class=\"number\">0</span>].next = nodeIndex;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回链表长度</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> CursorList&lt;DataType&gt;::Length()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> listSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印链表</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> CursorList&lt;DataType&gt;::PrintList()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cycleIter = listNodes[dummyNode].next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; listNodes[cycleIter].data &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                cycleIter = listNodes[cycleIter].next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>对上述代码进行简单地测试，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        CursorList&lt;<span class=\"keyword\">char</span>&gt; Test;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'A'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'B'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'C'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'D'</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'E'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'F'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"string\">'B'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"string\">'F'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"string\">'D'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.DeleteElement(<span class=\"string\">'B'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.IsEmpty() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Test.Length() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'A'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'B'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'C'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'D'</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'E'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'F'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.MakeEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'A'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'B'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'C'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'D'</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'E'</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Test.InsertElement(<span class=\"string\">'F'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Test.PrintList();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pTest = Test.FindElement(<span class=\"string\">'A'</span>);</span><br><span class=\"line\">        pTest = Test.FindElement(<span class=\"string\">'E'</span>);</span><br><span class=\"line\">\tpTest = Test.FindElement(<span class=\"string\">'G'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">4</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">1</span>);</span><br><span class=\"line\">        pTest = Test.FindNthElement(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n"},{"title":"数据结构之多重表的定义与实现","urlname":"multi-table","date":"2018-06-05T13:29:45.000Z","mathjax":true,"copyright":true,"_content":"## 多重表基础\n\n多重表是《数据结构与算法分析：C语言描述》一书中给出的概念，书中给出了一张多重表示意图，如下所示：\n![多重表示意图](/images/multi-table.png)\n\n从图中可以看出多重表是指一个节点有多个链穿过，和矩阵压缩存储中的十字链表十分相似。书中是以大学选课为例说明的，本处以书中例子为蓝本设计实现一种多重表。由于书中并没有给出具体的API，故本文主要根据自己的理解以及结合普通链表的API来编写ADT。本处主要实现如下几个功能：\n\n- 多重表每条链长度\n- 多重表插入、删除节点\n- 多重表清空\n\n根据图中示意，我们很容易想到表头统一采用数组来管理，每个链表内部保持有序便于插入删除。\n\n## 多重表的定义与实现\n\n根据书中多重表示意图，我们可以设计多重表的结构如下所示：\n\n```cpp\nstruct MultiNode\n{\n        unsigned int rowIndex; /*节点所在行*/\n        unsigned int colIndex; /*节点所在列*/\n        MultiNode *rowNext; /*所在行下一个节点*/\n        MultiNode *colNext; /*列所在下一个节点*/\n        MultiNode() : rowIndex(0), colIndex(0),\n                  rowNext(nullptr), colNext(nullptr) {}\n        MultiNode(unsigned int row, unsigned int col) : rowIndex(row), colIndex(col),\n                                                 rowNext(nullptr), colNext(nullptr) {}\n};\n```\n\n在实现多重表时，行和列分别定义一个哑节点数组，具体实现代码如下所示：\n\n```cpp\nclass MultiTable\n{\npublic:\n        MultiTable(unsigned int row, unsigned int col);\n        ~MultiTable();\n        void MakeEmpty(); /*清空整个多重表*/\n        bool IsRowEmpty(unsigned int rowIndex); /*某行链表是否为空*/\n        bool IsColEmpty(unsigned int colIndex); /*某列链表是否为空*/\n        void DeleteNode(unsigned int row, unsigned int col); /*删除某个节点*/\n        void InsertNode(unsigned int row, unsigned int col); /*插入某个节点某个节点*/\n        void PrintRowList(unsigned int rowIndex); /*打印某行*/\n        void PrintColList(unsigned int ColIndex); /*打印某列*/\nprivate:\n        unsigned int rowSize;\n        unsigned int colSize;\n        MultiNode *rowArray; /*行数组*/\n        MultiNode *colArray; /*列数组*/\n};\n```\n\n如上所示，多重表主要是保存行数和列数以及对应的数组。以下分别实现个函数。\n\n- 构造函数\n\n```cpp\nMultiTable::MultiTable(unsigned int row, unsigned int col) : rowSize(row), colSize(col),\n                                               rowArray(nullptr),colArray(nullptr)\n{\n        rowSize = rowSize == 0 ? 1 : rowSize;\n        colSize = colSize == 0 ? 1 : colSize;\n\n        rowArray = new MultiNode[rowSize];\n        colArray = new MultiNode[colSize];\n        /*做成循环链表*/\n        for (unsigned int i = 0; i < rowSize; i++) {\n                rowArray[i].rowNext = &rowArray[i];\n        }\n\n        for (unsigned int i = 0; i < colSize; i++) {\n                colArray[i].colNext = &colArray[i];\n        }\n}\n```\n\n- 析构函数\n\n```cpp\nMultiTable::~MultiTable()\n{\n        MakeEmpty();\n        delete [] rowArray;\n        delete [] colArray;\n}\n```\n\n- 清空函数\n\n```cpp\nvoid MultiTable::MakeEmpty()\n{\n        /*先把行或者列哑节点指向自己*/\n        for (unsigned int i = 0; i < colSize; i++) {\n                colArray[i].colNext = &colArray[i];\n        }\n        for (unsigned int i = 0; i < rowSize; i++) {\n                MultiNode *cycleIter = rowArray[i].rowNext;\n                /*遍历整个链表删除之*/\n                while (cycleIter != &rowArray[i]) {\n                        rowArray[i].rowNext = cycleIter->rowNext;\n                        delete cycleIter;\n                        cycleIter = rowArray[i].rowNext;\n                }\n        }\n}\n```\n\n- 判断某行链表是否为空，如果行不存在也返回false，行从1开始\n\n```cpp\nbool MultiTable::IsRowEmpty(unsigned int rowIndex)\n{\n        if (rowIndex <= 0 || rowIndex > rowSize) {\n                return false;\n        }\n        return rowArray[rowIndex-1].rowNext == &rowArray[rowIndex-1];\n}\n```\n\n- 判断某列链表是否为空，如果行不存在也返回false，列从1开始计算\n\n```cpp\nbool MultiTable::IsColEmpty(unsigned int colIndex)\n{\n        if (colIndex <= 0 || colIndex > colSize) {\n                return false;\n        }\n        return colArray[colIndex-1].colNext == &colArray[colIndex-1];\n}\n```\n\n- 删除某行某列对应的节点，不存在就什么也不做，行列均从1开始\n\n```cpp\nvoid MultiTable::DeleteNode(unsigned int row, unsigned int col)\n{\n        if (row <= 0 || row > rowSize || col <= 0 || col > colSize) {\n                return;\n        }\n        MultiNode *rowIter = &rowArray[row-1]; /*行链表*/\n        MultiNode *colIter = &colArray[col-1]; /*列链表*/\n        while (rowIter->rowNext != &rowArray[row-1] && rowIter->rowNext->colIndex < col) {\n                rowIter = rowIter->rowNext;\n        }\n\n        while (colIter->colNext != &colArray[col-1] && colIter->colNext->rowIndex < row) {\n                colIter = colIter->colNext;\n        }\n\n        bool nodeExist = rowIter->rowNext != &rowArray[row-1] && rowIter->rowNext->colIndex == col;\n        nodeExist = nodeExist &&  colIter->colNext != &colArray[col-1] && colIter->colNext->rowIndex == row;\n        if (nodeExist) {\n                MultiNode *toBeDeleteNode = rowIter->rowNext; /*待删除节点*/\n                rowIter->rowNext = toBeDeleteNode->rowNext;\n                colIter->colNext = toBeDeleteNode->colNext;\n                delete toBeDeleteNode;\n        }\n        return;\n}\n```\n\n- 在一行中插入节点，如果已存在就更新（本处啥也不做）\n\n```cpp\nvoid MultiTable::InsertNode(unsigned int row, unsigned int col)\n{\n        if (row <= 0 || row > rowSize || col <= 0 || col > colSize) {\n                return;\n        }\n\n        MultiNode *rowIter = &rowArray[row-1]; /*行链表*/\n        MultiNode *colIter = &colArray[col-1]; /*列链表*/\n        while (rowIter->rowNext !=  &rowArray[row - 1] && rowIter->rowNext->colIndex < col) {\n                rowIter = rowIter->rowNext;\n        }\n\n        while (colIter->colNext != &colArray[col-1] && colIter->colNext->rowIndex < row) {\n                colIter = colIter->colNext;\n        }\n        bool nodeExist = rowIter->rowNext != &rowArray[row-1] && rowIter->rowNext->colIndex == col;\n        nodeExist = nodeExist &&  colIter->colNext != &colArray[col-1] && colIter->colNext->rowIndex == row;\n        if (!nodeExist) {\n                MultiNode *newNode = new MultiNode(row, col); /*新建节点*/\n                newNode->rowNext = rowIter->rowNext;\n                newNode->colNext = colIter->colNext;\n                rowIter->rowNext = newNode;\n                colIter->colNext = newNode;\n        }\n        return;\n}\n```\n\n- 打印某一行（行不存在不做任何事）\n\n```cpp\nvoid MultiTable::PrintRowList(unsigned int rowIndex)\n{\n        if (rowIndex <= 0 || rowIndex > rowSize) {\n                return;\n        }\n        MultiNode *rowIter = rowArray[rowIndex-1].rowNext; /*初始化遍历迭代器*/\n        cout << \"Row \"<< rowIndex << \" Data is follow：\" <<endl;\n        while (rowIter != &rowArray[rowIndex-1]) {\n                cout << \"(\" << rowIter->rowIndex << \",\" << rowIter->colIndex << \");\";\n                rowIter = rowIter->rowNext;\n        }\n        cout << endl;\n        return;\n}\n```\n\n- 打印某一行（列不存在不做任何事）\n\n```cpp\nvoid MultiTable::PrintColList(unsigned int colIndex)\n{\n        if (colIndex <= 0 || colIndex > colSize) {\n                return;\n        }\n        MultiNode *colIter = colArray[colIndex-1].colNext; /*初始化遍历迭代器*/\n        cout << \"Col \"<< colIndex << \" Data is follow：\" <<endl;\n        while (colIter != &colArray[colIndex-1]) {\n                cout << \"(\" << colIter->rowIndex << \",\" << colIter->colIndex << \");\";\n                colIter = colIter->colNext;\n        }\n        cout << endl;\n        return;\n}\n```\n\n## 代码测试\n\n就以书中图中为例，进行一些插入删除操作最后打印结果来检测代码是否正确，检测代码如下：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tMultiTable testTable(4, 5);\n\n        testTable.InsertNode(1, 1);\n        testTable.InsertNode(1, 3);\n        testTable.InsertNode(1, 4);\n\n        testTable.InsertNode(4, 4);\n        testTable.InsertNode(4, 2);\n\n        testTable.InsertNode(3, 3);\n        testTable.InsertNode(3, 4);\n        testTable.InsertNode(3, 1);\n        testTable.InsertNode(3, 5);\n\n        testTable.InsertNode(2, 2);\n        testTable.InsertNode(2, 5);\n\n        cout<< testTable.IsRowEmpty(1) << endl;\n        cout<< testTable.IsRowEmpty(2) << endl;\n        cout<< testTable.IsRowEmpty(3) << endl;\n        cout<< testTable.IsRowEmpty(4) << endl;\n\n        cout<< testTable.IsColEmpty(1) << endl;\n        cout<< testTable.IsColEmpty(2) << endl;\n        cout<< testTable.IsColEmpty(3) << endl;\n        cout<< testTable.IsColEmpty(4) << endl;\n        cout<< testTable.IsColEmpty(5) << endl;\n\n        testTable.DeleteNode(2, 2);\n        testTable.DeleteNode(2, 5);\n\n        cout<< testTable.IsRowEmpty(2) << endl;\n\n        testTable.MakeEmpty();\n\n        cout<< testTable.IsRowEmpty(1) << endl;\n        cout<< testTable.IsRowEmpty(2) << endl;\n        cout<< testTable.IsRowEmpty(3) << endl;\n        cout<< testTable.IsRowEmpty(4) << endl;\n\n        cout<< testTable.IsColEmpty(1) << endl;\n        cout<< testTable.IsColEmpty(2) << endl;\n        cout<< testTable.IsColEmpty(3) << endl;\n        cout<< testTable.IsColEmpty(4) << endl;\n        cout<< testTable.IsColEmpty(5) << endl;\n\n\n        testTable.InsertNode(1, 1);\n        testTable.InsertNode(1, 3);\n        testTable.InsertNode(1, 4);\n\n        testTable.InsertNode(4, 4);\n        testTable.InsertNode(4, 2);\n\n        testTable.InsertNode(3, 3);\n        testTable.InsertNode(3, 4);\n        testTable.InsertNode(3, 1);\n        testTable.InsertNode(3, 5);\n\n        testTable.InsertNode(2, 2);\n        testTable.InsertNode(2, 5);\n\n        testTable.PrintRowList(1);\n        testTable.PrintRowList(2);\n        testTable.PrintRowList(3);\n        testTable.PrintRowList(4);\n\n        testTable.PrintColList(1);\n        testTable.PrintColList(2);\n        testTable.PrintColList(3);\n        testTable.PrintColList(4);\n        testTable.PrintColList(5);\n\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","source":"_posts/数据结构/数据结构之多重表.md","raw":"---\ntitle: 数据结构之多重表的定义与实现\nurlname: multi-table\ndate: 2018-06-05 21:29:45\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n## 多重表基础\n\n多重表是《数据结构与算法分析：C语言描述》一书中给出的概念，书中给出了一张多重表示意图，如下所示：\n![多重表示意图](/images/multi-table.png)\n\n从图中可以看出多重表是指一个节点有多个链穿过，和矩阵压缩存储中的十字链表十分相似。书中是以大学选课为例说明的，本处以书中例子为蓝本设计实现一种多重表。由于书中并没有给出具体的API，故本文主要根据自己的理解以及结合普通链表的API来编写ADT。本处主要实现如下几个功能：\n\n- 多重表每条链长度\n- 多重表插入、删除节点\n- 多重表清空\n\n根据图中示意，我们很容易想到表头统一采用数组来管理，每个链表内部保持有序便于插入删除。\n\n## 多重表的定义与实现\n\n根据书中多重表示意图，我们可以设计多重表的结构如下所示：\n\n```cpp\nstruct MultiNode\n{\n        unsigned int rowIndex; /*节点所在行*/\n        unsigned int colIndex; /*节点所在列*/\n        MultiNode *rowNext; /*所在行下一个节点*/\n        MultiNode *colNext; /*列所在下一个节点*/\n        MultiNode() : rowIndex(0), colIndex(0),\n                  rowNext(nullptr), colNext(nullptr) {}\n        MultiNode(unsigned int row, unsigned int col) : rowIndex(row), colIndex(col),\n                                                 rowNext(nullptr), colNext(nullptr) {}\n};\n```\n\n在实现多重表时，行和列分别定义一个哑节点数组，具体实现代码如下所示：\n\n```cpp\nclass MultiTable\n{\npublic:\n        MultiTable(unsigned int row, unsigned int col);\n        ~MultiTable();\n        void MakeEmpty(); /*清空整个多重表*/\n        bool IsRowEmpty(unsigned int rowIndex); /*某行链表是否为空*/\n        bool IsColEmpty(unsigned int colIndex); /*某列链表是否为空*/\n        void DeleteNode(unsigned int row, unsigned int col); /*删除某个节点*/\n        void InsertNode(unsigned int row, unsigned int col); /*插入某个节点某个节点*/\n        void PrintRowList(unsigned int rowIndex); /*打印某行*/\n        void PrintColList(unsigned int ColIndex); /*打印某列*/\nprivate:\n        unsigned int rowSize;\n        unsigned int colSize;\n        MultiNode *rowArray; /*行数组*/\n        MultiNode *colArray; /*列数组*/\n};\n```\n\n如上所示，多重表主要是保存行数和列数以及对应的数组。以下分别实现个函数。\n\n- 构造函数\n\n```cpp\nMultiTable::MultiTable(unsigned int row, unsigned int col) : rowSize(row), colSize(col),\n                                               rowArray(nullptr),colArray(nullptr)\n{\n        rowSize = rowSize == 0 ? 1 : rowSize;\n        colSize = colSize == 0 ? 1 : colSize;\n\n        rowArray = new MultiNode[rowSize];\n        colArray = new MultiNode[colSize];\n        /*做成循环链表*/\n        for (unsigned int i = 0; i < rowSize; i++) {\n                rowArray[i].rowNext = &rowArray[i];\n        }\n\n        for (unsigned int i = 0; i < colSize; i++) {\n                colArray[i].colNext = &colArray[i];\n        }\n}\n```\n\n- 析构函数\n\n```cpp\nMultiTable::~MultiTable()\n{\n        MakeEmpty();\n        delete [] rowArray;\n        delete [] colArray;\n}\n```\n\n- 清空函数\n\n```cpp\nvoid MultiTable::MakeEmpty()\n{\n        /*先把行或者列哑节点指向自己*/\n        for (unsigned int i = 0; i < colSize; i++) {\n                colArray[i].colNext = &colArray[i];\n        }\n        for (unsigned int i = 0; i < rowSize; i++) {\n                MultiNode *cycleIter = rowArray[i].rowNext;\n                /*遍历整个链表删除之*/\n                while (cycleIter != &rowArray[i]) {\n                        rowArray[i].rowNext = cycleIter->rowNext;\n                        delete cycleIter;\n                        cycleIter = rowArray[i].rowNext;\n                }\n        }\n}\n```\n\n- 判断某行链表是否为空，如果行不存在也返回false，行从1开始\n\n```cpp\nbool MultiTable::IsRowEmpty(unsigned int rowIndex)\n{\n        if (rowIndex <= 0 || rowIndex > rowSize) {\n                return false;\n        }\n        return rowArray[rowIndex-1].rowNext == &rowArray[rowIndex-1];\n}\n```\n\n- 判断某列链表是否为空，如果行不存在也返回false，列从1开始计算\n\n```cpp\nbool MultiTable::IsColEmpty(unsigned int colIndex)\n{\n        if (colIndex <= 0 || colIndex > colSize) {\n                return false;\n        }\n        return colArray[colIndex-1].colNext == &colArray[colIndex-1];\n}\n```\n\n- 删除某行某列对应的节点，不存在就什么也不做，行列均从1开始\n\n```cpp\nvoid MultiTable::DeleteNode(unsigned int row, unsigned int col)\n{\n        if (row <= 0 || row > rowSize || col <= 0 || col > colSize) {\n                return;\n        }\n        MultiNode *rowIter = &rowArray[row-1]; /*行链表*/\n        MultiNode *colIter = &colArray[col-1]; /*列链表*/\n        while (rowIter->rowNext != &rowArray[row-1] && rowIter->rowNext->colIndex < col) {\n                rowIter = rowIter->rowNext;\n        }\n\n        while (colIter->colNext != &colArray[col-1] && colIter->colNext->rowIndex < row) {\n                colIter = colIter->colNext;\n        }\n\n        bool nodeExist = rowIter->rowNext != &rowArray[row-1] && rowIter->rowNext->colIndex == col;\n        nodeExist = nodeExist &&  colIter->colNext != &colArray[col-1] && colIter->colNext->rowIndex == row;\n        if (nodeExist) {\n                MultiNode *toBeDeleteNode = rowIter->rowNext; /*待删除节点*/\n                rowIter->rowNext = toBeDeleteNode->rowNext;\n                colIter->colNext = toBeDeleteNode->colNext;\n                delete toBeDeleteNode;\n        }\n        return;\n}\n```\n\n- 在一行中插入节点，如果已存在就更新（本处啥也不做）\n\n```cpp\nvoid MultiTable::InsertNode(unsigned int row, unsigned int col)\n{\n        if (row <= 0 || row > rowSize || col <= 0 || col > colSize) {\n                return;\n        }\n\n        MultiNode *rowIter = &rowArray[row-1]; /*行链表*/\n        MultiNode *colIter = &colArray[col-1]; /*列链表*/\n        while (rowIter->rowNext !=  &rowArray[row - 1] && rowIter->rowNext->colIndex < col) {\n                rowIter = rowIter->rowNext;\n        }\n\n        while (colIter->colNext != &colArray[col-1] && colIter->colNext->rowIndex < row) {\n                colIter = colIter->colNext;\n        }\n        bool nodeExist = rowIter->rowNext != &rowArray[row-1] && rowIter->rowNext->colIndex == col;\n        nodeExist = nodeExist &&  colIter->colNext != &colArray[col-1] && colIter->colNext->rowIndex == row;\n        if (!nodeExist) {\n                MultiNode *newNode = new MultiNode(row, col); /*新建节点*/\n                newNode->rowNext = rowIter->rowNext;\n                newNode->colNext = colIter->colNext;\n                rowIter->rowNext = newNode;\n                colIter->colNext = newNode;\n        }\n        return;\n}\n```\n\n- 打印某一行（行不存在不做任何事）\n\n```cpp\nvoid MultiTable::PrintRowList(unsigned int rowIndex)\n{\n        if (rowIndex <= 0 || rowIndex > rowSize) {\n                return;\n        }\n        MultiNode *rowIter = rowArray[rowIndex-1].rowNext; /*初始化遍历迭代器*/\n        cout << \"Row \"<< rowIndex << \" Data is follow：\" <<endl;\n        while (rowIter != &rowArray[rowIndex-1]) {\n                cout << \"(\" << rowIter->rowIndex << \",\" << rowIter->colIndex << \");\";\n                rowIter = rowIter->rowNext;\n        }\n        cout << endl;\n        return;\n}\n```\n\n- 打印某一行（列不存在不做任何事）\n\n```cpp\nvoid MultiTable::PrintColList(unsigned int colIndex)\n{\n        if (colIndex <= 0 || colIndex > colSize) {\n                return;\n        }\n        MultiNode *colIter = colArray[colIndex-1].colNext; /*初始化遍历迭代器*/\n        cout << \"Col \"<< colIndex << \" Data is follow：\" <<endl;\n        while (colIter != &colArray[colIndex-1]) {\n                cout << \"(\" << colIter->rowIndex << \",\" << colIter->colIndex << \");\";\n                colIter = colIter->colNext;\n        }\n        cout << endl;\n        return;\n}\n```\n\n## 代码测试\n\n就以书中图中为例，进行一些插入删除操作最后打印结果来检测代码是否正确，检测代码如下：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tMultiTable testTable(4, 5);\n\n        testTable.InsertNode(1, 1);\n        testTable.InsertNode(1, 3);\n        testTable.InsertNode(1, 4);\n\n        testTable.InsertNode(4, 4);\n        testTable.InsertNode(4, 2);\n\n        testTable.InsertNode(3, 3);\n        testTable.InsertNode(3, 4);\n        testTable.InsertNode(3, 1);\n        testTable.InsertNode(3, 5);\n\n        testTable.InsertNode(2, 2);\n        testTable.InsertNode(2, 5);\n\n        cout<< testTable.IsRowEmpty(1) << endl;\n        cout<< testTable.IsRowEmpty(2) << endl;\n        cout<< testTable.IsRowEmpty(3) << endl;\n        cout<< testTable.IsRowEmpty(4) << endl;\n\n        cout<< testTable.IsColEmpty(1) << endl;\n        cout<< testTable.IsColEmpty(2) << endl;\n        cout<< testTable.IsColEmpty(3) << endl;\n        cout<< testTable.IsColEmpty(4) << endl;\n        cout<< testTable.IsColEmpty(5) << endl;\n\n        testTable.DeleteNode(2, 2);\n        testTable.DeleteNode(2, 5);\n\n        cout<< testTable.IsRowEmpty(2) << endl;\n\n        testTable.MakeEmpty();\n\n        cout<< testTable.IsRowEmpty(1) << endl;\n        cout<< testTable.IsRowEmpty(2) << endl;\n        cout<< testTable.IsRowEmpty(3) << endl;\n        cout<< testTable.IsRowEmpty(4) << endl;\n\n        cout<< testTable.IsColEmpty(1) << endl;\n        cout<< testTable.IsColEmpty(2) << endl;\n        cout<< testTable.IsColEmpty(3) << endl;\n        cout<< testTable.IsColEmpty(4) << endl;\n        cout<< testTable.IsColEmpty(5) << endl;\n\n\n        testTable.InsertNode(1, 1);\n        testTable.InsertNode(1, 3);\n        testTable.InsertNode(1, 4);\n\n        testTable.InsertNode(4, 4);\n        testTable.InsertNode(4, 2);\n\n        testTable.InsertNode(3, 3);\n        testTable.InsertNode(3, 4);\n        testTable.InsertNode(3, 1);\n        testTable.InsertNode(3, 5);\n\n        testTable.InsertNode(2, 2);\n        testTable.InsertNode(2, 5);\n\n        testTable.PrintRowList(1);\n        testTable.PrintRowList(2);\n        testTable.PrintRowList(3);\n        testTable.PrintRowList(4);\n\n        testTable.PrintColList(1);\n        testTable.PrintColList(2);\n        testTable.PrintColList(3);\n        testTable.PrintColList(4);\n        testTable.PrintColList(5);\n\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","slug":"数据结构/数据结构之多重表","published":1,"updated":"2018-06-13T14:07:51.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3n001dgsvnpj7ilja9","content":"<h2 id=\"多重表基础\"><a href=\"#多重表基础\" class=\"headerlink\" title=\"多重表基础\"></a>多重表基础</h2><p>多重表是《数据结构与算法分析：C语言描述》一书中给出的概念，书中给出了一张多重表示意图，如下所示：<br><img src=\"/images/multi-table.png\" alt=\"多重表示意图\"></p>\n<p>从图中可以看出多重表是指一个节点有多个链穿过，和矩阵压缩存储中的十字链表十分相似。书中是以大学选课为例说明的，本处以书中例子为蓝本设计实现一种多重表。由于书中并没有给出具体的API，故本文主要根据自己的理解以及结合普通链表的API来编写ADT。本处主要实现如下几个功能：</p>\n<ul>\n<li>多重表每条链长度</li>\n<li>多重表插入、删除节点</li>\n<li>多重表清空</li>\n</ul>\n<p>根据图中示意，我们很容易想到表头统一采用数组来管理，每个链表内部保持有序便于插入删除。</p>\n<h2 id=\"多重表的定义与实现\"><a href=\"#多重表的定义与实现\" class=\"headerlink\" title=\"多重表的定义与实现\"></a>多重表的定义与实现</h2><p>根据书中多重表示意图，我们可以设计多重表的结构如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MultiNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex; <span class=\"comment\">/*节点所在行*/</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colIndex; <span class=\"comment\">/*节点所在列*/</span></span><br><span class=\"line\">        MultiNode *rowNext; <span class=\"comment\">/*所在行下一个节点*/</span></span><br><span class=\"line\">        MultiNode *colNext; <span class=\"comment\">/*列所在下一个节点*/</span></span><br><span class=\"line\">        MultiNode() : rowIndex(<span class=\"number\">0</span>), colIndex(<span class=\"number\">0</span>),</span><br><span class=\"line\">                  rowNext(<span class=\"literal\">nullptr</span>), colNext(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">        MultiNode(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col) : rowIndex(row), colIndex(col),</span><br><span class=\"line\">                                                 rowNext(<span class=\"literal\">nullptr</span>), colNext(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在实现多重表时，行和列分别定义一个哑节点数组，具体实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        MultiTable(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col);</span><br><span class=\"line\">        ~MultiTable();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*清空整个多重表*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsRowEmpty</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex)</span></span>; <span class=\"comment\">/*某行链表是否为空*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsColEmpty</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colIndex)</span></span>; <span class=\"comment\">/*某列链表是否为空*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteNode</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col)</span></span>; <span class=\"comment\">/*删除某个节点*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertNode</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col)</span></span>; <span class=\"comment\">/*插入某个节点某个节点*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintRowList</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex)</span></span>; <span class=\"comment\">/*打印某行*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintColList</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> ColIndex)</span></span>; <span class=\"comment\">/*打印某列*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowSize;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colSize;</span><br><span class=\"line\">        MultiNode *rowArray; <span class=\"comment\">/*行数组*/</span></span><br><span class=\"line\">        MultiNode *colArray; <span class=\"comment\">/*列数组*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，多重表主要是保存行数和列数以及对应的数组。以下分别实现个函数。</p>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MultiTable::MultiTable(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col) : rowSize(row), colSize(col),</span><br><span class=\"line\">                                               rowArray(<span class=\"literal\">nullptr</span>),colArray(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        rowSize = rowSize == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : rowSize;</span><br><span class=\"line\">        colSize = colSize == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : colSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        rowArray = <span class=\"keyword\">new</span> MultiNode[rowSize];</span><br><span class=\"line\">        colArray = <span class=\"keyword\">new</span> MultiNode[colSize];</span><br><span class=\"line\">        <span class=\"comment\">/*做成循环链表*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rowSize; i++) &#123;</span><br><span class=\"line\">                rowArray[i].rowNext = &amp;rowArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; colSize; i++) &#123;</span><br><span class=\"line\">                colArray[i].colNext = &amp;colArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MultiTable::~MultiTable()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        MakeEmpty();</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] rowArray;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] colArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*先把行或者列哑节点指向自己*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; colSize; i++) &#123;</span><br><span class=\"line\">                colArray[i].colNext = &amp;colArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rowSize; i++) &#123;</span><br><span class=\"line\">                MultiNode *cycleIter = rowArray[i].rowNext;</span><br><span class=\"line\">                <span class=\"comment\">/*遍历整个链表删除之*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cycleIter != &amp;rowArray[i]) &#123;</span><br><span class=\"line\">                        rowArray[i].rowNext = cycleIter-&gt;rowNext;</span><br><span class=\"line\">                        <span class=\"keyword\">delete</span> cycleIter;</span><br><span class=\"line\">                        cycleIter = rowArray[i].rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断某行链表是否为空，如果行不存在也返回false，行从1开始</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> MultiTable::IsRowEmpty(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowIndex &lt;= <span class=\"number\">0</span> || rowIndex &gt; rowSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rowArray[rowIndex<span class=\"number\">-1</span>].rowNext == &amp;rowArray[rowIndex<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断某列链表是否为空，如果行不存在也返回false，列从1开始计算</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> MultiTable::IsColEmpty(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (colIndex &lt;= <span class=\"number\">0</span> || colIndex &gt; colSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> colArray[colIndex<span class=\"number\">-1</span>].colNext == &amp;colArray[colIndex<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除某行某列对应的节点，不存在就什么也不做，行列均从1开始</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::DeleteNode(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt;= <span class=\"number\">0</span> || row &gt; rowSize || col &lt;= <span class=\"number\">0</span> || col &gt; colSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        MultiNode *rowIter = &amp;rowArray[row<span class=\"number\">-1</span>]; <span class=\"comment\">/*行链表*/</span></span><br><span class=\"line\">        MultiNode *colIter = &amp;colArray[col<span class=\"number\">-1</span>]; <span class=\"comment\">/*列链表*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rowIter-&gt;rowNext != &amp;rowArray[row<span class=\"number\">-1</span>] &amp;&amp; rowIter-&gt;rowNext-&gt;colIndex &lt; col) &#123;</span><br><span class=\"line\">                rowIter = rowIter-&gt;rowNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (colIter-&gt;colNext != &amp;colArray[col<span class=\"number\">-1</span>] &amp;&amp; colIter-&gt;colNext-&gt;rowIndex &lt; row) &#123;</span><br><span class=\"line\">                colIter = colIter-&gt;colNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> nodeExist = rowIter-&gt;rowNext != &amp;rowArray[row<span class=\"number\">-1</span>] &amp;&amp; rowIter-&gt;rowNext-&gt;colIndex == col;</span><br><span class=\"line\">        nodeExist = nodeExist &amp;&amp;  colIter-&gt;colNext != &amp;colArray[col<span class=\"number\">-1</span>] &amp;&amp; colIter-&gt;colNext-&gt;rowIndex == row;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeExist) &#123;</span><br><span class=\"line\">                MultiNode *toBeDeleteNode = rowIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                rowIter-&gt;rowNext = toBeDeleteNode-&gt;rowNext;</span><br><span class=\"line\">                colIter-&gt;colNext = toBeDeleteNode-&gt;colNext;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> toBeDeleteNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在一行中插入节点，如果已存在就更新（本处啥也不做）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::InsertNode(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt;= <span class=\"number\">0</span> || row &gt; rowSize || col &lt;= <span class=\"number\">0</span> || col &gt; colSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        MultiNode *rowIter = &amp;rowArray[row<span class=\"number\">-1</span>]; <span class=\"comment\">/*行链表*/</span></span><br><span class=\"line\">        MultiNode *colIter = &amp;colArray[col<span class=\"number\">-1</span>]; <span class=\"comment\">/*列链表*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rowIter-&gt;rowNext !=  &amp;rowArray[row - <span class=\"number\">1</span>] &amp;&amp; rowIter-&gt;rowNext-&gt;colIndex &lt; col) &#123;</span><br><span class=\"line\">                rowIter = rowIter-&gt;rowNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (colIter-&gt;colNext != &amp;colArray[col<span class=\"number\">-1</span>] &amp;&amp; colIter-&gt;colNext-&gt;rowIndex &lt; row) &#123;</span><br><span class=\"line\">                colIter = colIter-&gt;colNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> nodeExist = rowIter-&gt;rowNext != &amp;rowArray[row<span class=\"number\">-1</span>] &amp;&amp; rowIter-&gt;rowNext-&gt;colIndex == col;</span><br><span class=\"line\">        nodeExist = nodeExist &amp;&amp;  colIter-&gt;colNext != &amp;colArray[col<span class=\"number\">-1</span>] &amp;&amp; colIter-&gt;colNext-&gt;rowIndex == row;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!nodeExist) &#123;</span><br><span class=\"line\">                MultiNode *newNode = <span class=\"keyword\">new</span> MultiNode(row, col); <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">                newNode-&gt;rowNext = rowIter-&gt;rowNext;</span><br><span class=\"line\">                newNode-&gt;colNext = colIter-&gt;colNext;</span><br><span class=\"line\">                rowIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                colIter-&gt;colNext = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印某一行（行不存在不做任何事）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::PrintRowList(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowIndex &lt;= <span class=\"number\">0</span> || rowIndex &gt; rowSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        MultiNode *rowIter = rowArray[rowIndex<span class=\"number\">-1</span>].rowNext; <span class=\"comment\">/*初始化遍历迭代器*/</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Row \"</span>&lt;&lt; rowIndex &lt;&lt; <span class=\"string\">\" Data is follow：\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rowIter != &amp;rowArray[rowIndex<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"(\"</span> &lt;&lt; rowIter-&gt;rowIndex &lt;&lt; <span class=\"string\">\",\"</span> &lt;&lt; rowIter-&gt;colIndex &lt;&lt; <span class=\"string\">\");\"</span>;</span><br><span class=\"line\">                rowIter = rowIter-&gt;rowNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印某一行（列不存在不做任何事）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::PrintColList(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (colIndex &lt;= <span class=\"number\">0</span> || colIndex &gt; colSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        MultiNode *colIter = colArray[colIndex<span class=\"number\">-1</span>].colNext; <span class=\"comment\">/*初始化遍历迭代器*/</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Col \"</span>&lt;&lt; colIndex &lt;&lt; <span class=\"string\">\" Data is follow：\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (colIter != &amp;colArray[colIndex<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"(\"</span> &lt;&lt; colIter-&gt;rowIndex &lt;&lt; <span class=\"string\">\",\"</span> &lt;&lt; colIter-&gt;colIndex &lt;&lt; <span class=\"string\">\");\"</span>;</span><br><span class=\"line\">                colIter = colIter-&gt;colNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>就以书中图中为例，进行一些插入删除操作最后打印结果来检测代码是否正确，检测代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">MultiTable <span class=\"title\">testTable</span><span class=\"params\">(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">4</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">4</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">4</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.DeleteNode(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.DeleteNode(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.MakeEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">4</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">4</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">4</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.PrintRowList(<span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.PrintRowList(<span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.PrintRowList(<span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.PrintRowList(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"多重表基础\"><a href=\"#多重表基础\" class=\"headerlink\" title=\"多重表基础\"></a>多重表基础</h2><p>多重表是《数据结构与算法分析：C语言描述》一书中给出的概念，书中给出了一张多重表示意图，如下所示：<br><img src=\"/images/multi-table.png\" alt=\"多重表示意图\"></p>\n<p>从图中可以看出多重表是指一个节点有多个链穿过，和矩阵压缩存储中的十字链表十分相似。书中是以大学选课为例说明的，本处以书中例子为蓝本设计实现一种多重表。由于书中并没有给出具体的API，故本文主要根据自己的理解以及结合普通链表的API来编写ADT。本处主要实现如下几个功能：</p>\n<ul>\n<li>多重表每条链长度</li>\n<li>多重表插入、删除节点</li>\n<li>多重表清空</li>\n</ul>\n<p>根据图中示意，我们很容易想到表头统一采用数组来管理，每个链表内部保持有序便于插入删除。</p>\n<h2 id=\"多重表的定义与实现\"><a href=\"#多重表的定义与实现\" class=\"headerlink\" title=\"多重表的定义与实现\"></a>多重表的定义与实现</h2><p>根据书中多重表示意图，我们可以设计多重表的结构如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MultiNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex; <span class=\"comment\">/*节点所在行*/</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colIndex; <span class=\"comment\">/*节点所在列*/</span></span><br><span class=\"line\">        MultiNode *rowNext; <span class=\"comment\">/*所在行下一个节点*/</span></span><br><span class=\"line\">        MultiNode *colNext; <span class=\"comment\">/*列所在下一个节点*/</span></span><br><span class=\"line\">        MultiNode() : rowIndex(<span class=\"number\">0</span>), colIndex(<span class=\"number\">0</span>),</span><br><span class=\"line\">                  rowNext(<span class=\"literal\">nullptr</span>), colNext(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">        MultiNode(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col) : rowIndex(row), colIndex(col),</span><br><span class=\"line\">                                                 rowNext(<span class=\"literal\">nullptr</span>), colNext(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在实现多重表时，行和列分别定义一个哑节点数组，具体实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        MultiTable(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col);</span><br><span class=\"line\">        ~MultiTable();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*清空整个多重表*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsRowEmpty</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex)</span></span>; <span class=\"comment\">/*某行链表是否为空*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsColEmpty</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colIndex)</span></span>; <span class=\"comment\">/*某列链表是否为空*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteNode</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col)</span></span>; <span class=\"comment\">/*删除某个节点*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertNode</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col)</span></span>; <span class=\"comment\">/*插入某个节点某个节点*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintRowList</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex)</span></span>; <span class=\"comment\">/*打印某行*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintColList</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> ColIndex)</span></span>; <span class=\"comment\">/*打印某列*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowSize;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colSize;</span><br><span class=\"line\">        MultiNode *rowArray; <span class=\"comment\">/*行数组*/</span></span><br><span class=\"line\">        MultiNode *colArray; <span class=\"comment\">/*列数组*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，多重表主要是保存行数和列数以及对应的数组。以下分别实现个函数。</p>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MultiTable::MultiTable(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col) : rowSize(row), colSize(col),</span><br><span class=\"line\">                                               rowArray(<span class=\"literal\">nullptr</span>),colArray(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        rowSize = rowSize == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : rowSize;</span><br><span class=\"line\">        colSize = colSize == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : colSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        rowArray = <span class=\"keyword\">new</span> MultiNode[rowSize];</span><br><span class=\"line\">        colArray = <span class=\"keyword\">new</span> MultiNode[colSize];</span><br><span class=\"line\">        <span class=\"comment\">/*做成循环链表*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rowSize; i++) &#123;</span><br><span class=\"line\">                rowArray[i].rowNext = &amp;rowArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; colSize; i++) &#123;</span><br><span class=\"line\">                colArray[i].colNext = &amp;colArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MultiTable::~MultiTable()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        MakeEmpty();</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] rowArray;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] colArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*先把行或者列哑节点指向自己*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; colSize; i++) &#123;</span><br><span class=\"line\">                colArray[i].colNext = &amp;colArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rowSize; i++) &#123;</span><br><span class=\"line\">                MultiNode *cycleIter = rowArray[i].rowNext;</span><br><span class=\"line\">                <span class=\"comment\">/*遍历整个链表删除之*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cycleIter != &amp;rowArray[i]) &#123;</span><br><span class=\"line\">                        rowArray[i].rowNext = cycleIter-&gt;rowNext;</span><br><span class=\"line\">                        <span class=\"keyword\">delete</span> cycleIter;</span><br><span class=\"line\">                        cycleIter = rowArray[i].rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断某行链表是否为空，如果行不存在也返回false，行从1开始</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> MultiTable::IsRowEmpty(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowIndex &lt;= <span class=\"number\">0</span> || rowIndex &gt; rowSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rowArray[rowIndex<span class=\"number\">-1</span>].rowNext == &amp;rowArray[rowIndex<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断某列链表是否为空，如果行不存在也返回false，列从1开始计算</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> MultiTable::IsColEmpty(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (colIndex &lt;= <span class=\"number\">0</span> || colIndex &gt; colSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> colArray[colIndex<span class=\"number\">-1</span>].colNext == &amp;colArray[colIndex<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除某行某列对应的节点，不存在就什么也不做，行列均从1开始</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::DeleteNode(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt;= <span class=\"number\">0</span> || row &gt; rowSize || col &lt;= <span class=\"number\">0</span> || col &gt; colSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        MultiNode *rowIter = &amp;rowArray[row<span class=\"number\">-1</span>]; <span class=\"comment\">/*行链表*/</span></span><br><span class=\"line\">        MultiNode *colIter = &amp;colArray[col<span class=\"number\">-1</span>]; <span class=\"comment\">/*列链表*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rowIter-&gt;rowNext != &amp;rowArray[row<span class=\"number\">-1</span>] &amp;&amp; rowIter-&gt;rowNext-&gt;colIndex &lt; col) &#123;</span><br><span class=\"line\">                rowIter = rowIter-&gt;rowNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (colIter-&gt;colNext != &amp;colArray[col<span class=\"number\">-1</span>] &amp;&amp; colIter-&gt;colNext-&gt;rowIndex &lt; row) &#123;</span><br><span class=\"line\">                colIter = colIter-&gt;colNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> nodeExist = rowIter-&gt;rowNext != &amp;rowArray[row<span class=\"number\">-1</span>] &amp;&amp; rowIter-&gt;rowNext-&gt;colIndex == col;</span><br><span class=\"line\">        nodeExist = nodeExist &amp;&amp;  colIter-&gt;colNext != &amp;colArray[col<span class=\"number\">-1</span>] &amp;&amp; colIter-&gt;colNext-&gt;rowIndex == row;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeExist) &#123;</span><br><span class=\"line\">                MultiNode *toBeDeleteNode = rowIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                rowIter-&gt;rowNext = toBeDeleteNode-&gt;rowNext;</span><br><span class=\"line\">                colIter-&gt;colNext = toBeDeleteNode-&gt;colNext;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> toBeDeleteNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在一行中插入节点，如果已存在就更新（本处啥也不做）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::InsertNode(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> col)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt;= <span class=\"number\">0</span> || row &gt; rowSize || col &lt;= <span class=\"number\">0</span> || col &gt; colSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        MultiNode *rowIter = &amp;rowArray[row<span class=\"number\">-1</span>]; <span class=\"comment\">/*行链表*/</span></span><br><span class=\"line\">        MultiNode *colIter = &amp;colArray[col<span class=\"number\">-1</span>]; <span class=\"comment\">/*列链表*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rowIter-&gt;rowNext !=  &amp;rowArray[row - <span class=\"number\">1</span>] &amp;&amp; rowIter-&gt;rowNext-&gt;colIndex &lt; col) &#123;</span><br><span class=\"line\">                rowIter = rowIter-&gt;rowNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (colIter-&gt;colNext != &amp;colArray[col<span class=\"number\">-1</span>] &amp;&amp; colIter-&gt;colNext-&gt;rowIndex &lt; row) &#123;</span><br><span class=\"line\">                colIter = colIter-&gt;colNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> nodeExist = rowIter-&gt;rowNext != &amp;rowArray[row<span class=\"number\">-1</span>] &amp;&amp; rowIter-&gt;rowNext-&gt;colIndex == col;</span><br><span class=\"line\">        nodeExist = nodeExist &amp;&amp;  colIter-&gt;colNext != &amp;colArray[col<span class=\"number\">-1</span>] &amp;&amp; colIter-&gt;colNext-&gt;rowIndex == row;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!nodeExist) &#123;</span><br><span class=\"line\">                MultiNode *newNode = <span class=\"keyword\">new</span> MultiNode(row, col); <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">                newNode-&gt;rowNext = rowIter-&gt;rowNext;</span><br><span class=\"line\">                newNode-&gt;colNext = colIter-&gt;colNext;</span><br><span class=\"line\">                rowIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                colIter-&gt;colNext = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印某一行（行不存在不做任何事）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::PrintRowList(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> rowIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowIndex &lt;= <span class=\"number\">0</span> || rowIndex &gt; rowSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        MultiNode *rowIter = rowArray[rowIndex<span class=\"number\">-1</span>].rowNext; <span class=\"comment\">/*初始化遍历迭代器*/</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Row \"</span>&lt;&lt; rowIndex &lt;&lt; <span class=\"string\">\" Data is follow：\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rowIter != &amp;rowArray[rowIndex<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"(\"</span> &lt;&lt; rowIter-&gt;rowIndex &lt;&lt; <span class=\"string\">\",\"</span> &lt;&lt; rowIter-&gt;colIndex &lt;&lt; <span class=\"string\">\");\"</span>;</span><br><span class=\"line\">                rowIter = rowIter-&gt;rowNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印某一行（列不存在不做任何事）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> MultiTable::PrintColList(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> colIndex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (colIndex &lt;= <span class=\"number\">0</span> || colIndex &gt; colSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        MultiNode *colIter = colArray[colIndex<span class=\"number\">-1</span>].colNext; <span class=\"comment\">/*初始化遍历迭代器*/</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Col \"</span>&lt;&lt; colIndex &lt;&lt; <span class=\"string\">\" Data is follow：\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (colIter != &amp;colArray[colIndex<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"(\"</span> &lt;&lt; colIter-&gt;rowIndex &lt;&lt; <span class=\"string\">\",\"</span> &lt;&lt; colIter-&gt;colIndex &lt;&lt; <span class=\"string\">\");\"</span>;</span><br><span class=\"line\">                colIter = colIter-&gt;colNext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>就以书中图中为例，进行一些插入删除操作最后打印结果来检测代码是否正确，检测代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">MultiTable <span class=\"title\">testTable</span><span class=\"params\">(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">4</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">4</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">4</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.DeleteNode(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.DeleteNode(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.MakeEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsRowEmpty(<span class=\"number\">4</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">4</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt; testTable.IsColEmpty(<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">1</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">4</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.InsertNode(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.PrintRowList(<span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.PrintRowList(<span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.PrintRowList(<span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.PrintRowList(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">1</span>);</span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">2</span>);</span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">3</span>);</span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">4</span>);</span><br><span class=\"line\">        testTable.PrintColList(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n"},{"title":"数据结构之左式堆的定义与实现","urlname":"leftist-heap","date":"2018-03-10T07:12:16.000Z","mathjax":true,"copyright":true,"_content":"\n## 左式堆基础知识\n\n左式堆又称为左高树、左偏堆、左倾堆、左偏树，是一种二叉树。左式堆和二叉堆一样也具有结构性和堆序性，但是和二叉堆不同的是，左式堆不是理想平衡的而且趋于非常不平衡。左式堆是一种非常方便进行合并的堆，二叉堆是一种特殊的左式堆。\n\n## 左式堆的性质\n\n- 节点的键值小于或等于左右子节点\n- 任意节点X，左子节点零路径长至少与右子节点零路径长相等，即左子节点零路径长大于等于左子节点零路径长\n- 节点的零路径长为右子节点零路径长加1\n- 一颗N节点左式堆root节点零路径长最多为log(N+1)-1\n- 在右路径上有r个节点的左式堆必然至少有2<sup>r</sup>-1个节点\n- N个节点的左式堆有一条右路径最多含有log(N+1)个节点\n\n左式堆的某节点X的重量W(X)为以X为根的内部节点的数量。WE(X)=W(左子树)+W右子树+1。该值可以递归计算。\n\n零路径长（null path length）是指从节点X到没有两个字节点的最短路径长，因此具有0个或者1个子结点的零路径长为0。左式堆的性质使得树向左进一步加深。如下图为零路径长示意图，节点内数值为零路径长。[图片来源](http://www.cnblogs.com/pacoson/p/5142330.html)\n\n![零路径长示意图](/images/null-path-length.png)\n\n根据左式堆的定义，左式堆的左右子树依然是一个左式堆。\n\n## 左式堆的基本操作\n\n二叉堆的基本操作有插入和删除，而左式堆的基本操作为合并，左式堆的插入是合并的一种特例（单节点左式堆合并），删除看成将左式堆分解成两个左式堆再进行合并操作。左式堆在进行合并时，除了需要保证堆序性外（父节点小于等于子节点值），还需要保证合并后的树依然是一个左式堆，因此合并过程是一个递归过程，描述如下：\n\n1. 如果有一个堆为空，则返回另外一个左式堆\n2. 比较两个左式堆根的大小，以小值根作为新左式堆的根，另外一个左式堆和小根堆的右子树合并\n3. 调整新树使得满足零路径长要求\n4. 递归上述三个过程\n\n\n## 左式堆的实现\n\n由于左式堆最重要的操作是合并，其余操作均可以通过调用合并操作完成，因此左式堆有如下操作：\n\n- 返回最小值：FindMin\n- 合并两个左式堆:Merge\n- 删除最小值（出队）:DeleteMin\n- 插入一个节点：InsertElement\n\n根据《数据结构与算法分析-C语言描述》一书的定义，左式堆定义如下：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *left;\n\tNode *right;\n\tint nullPathLength;\n\tNode(DataType inData):data(inData), left(nullptr), right(nullptr), nullPathLength(0) {} \n};\n\n\ntemplate <typename DataType>\nclass LeftistHeap\n{\npublic:\n\tLeftistHeap(): root(nullptr) {}\n\t~LeftistHeap();\n\tDataType FindMin();\n\tvoid Merge(Node<DataType> *inTree);\n\tvoid DeleteMin();\n\tvoid InsertElement(DataType inElement);\n\tbool IsEmpty();\n\tvoid MakeEmpty();\nprivate:\n\tNode<DataType> *MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2);\n\tNode<DataType> *root;\n};\n```\n\n如上所示节点数据结构中新增了一个表示零路径长的成员，其余和二叉树的定义相同，以下分别实现各函数。\n\n- 查找最小元素，如果左式堆为空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType LeftistHeap<DataType>::FindMin()\n{\n\tif (root == nullptr) {\n\t\tthrow \"Leftist heap is empty!\";\n\t}\n\treturn root->data;\n}\n```\n\n- 合并两棵左式堆核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * LeftistHeap<DataType>::MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2)\n{\n\tif (inTree1 == nullptr) {\n\t\treturn inTree2;\n\t}\n\n\tif (inTree2 == nullptr) {\n\t\treturn inTree1;\n\t}\n\tif (inTree1->data > inTree2->data) {\n\t\tswap(inTree1, inTree2); //STL库函数\n\t}\n\tif (inTree1->left == nullptr) {\n\t\tinTree1->left = inTree2;\n\t}\n\telse {\n\t\tinTree1->right = MergeCore(inTree1->right, inTree2);\n\t\tif (inTree1->left->nullPathLength < inTree1->right->nullPathLength) {\n\t\t\tswap(inTree1->left, inTree1->right);\n\t\t}\n\t\tinTree1->nullPathLength = inTree1->right->nullPathLength+1;\n\t}\n\treturn inTree1;\n}\n```\n\n- 合并两棵左式堆\n\n```cpp\ntemplate <typename DataType>\nvoid LeftistHeap<DataType>::Merge(Node<DataType> *inTree)\n{\n\troot = MergeCore(root, inTree);\n}\n```\n\n- 删除最小元素，拆解为左右两棵子树，然后调用合并函数进行合并\n\n```cpp\ntemplate <typename DataType>\nvoid LeftistHeap<DataType>::DeleteMin()\n{\n\tNode<DataType> *tmp = root;\n\troot = MergeCore(root->left, root->right);\n\tdelete tmp;\n}\n```\n\n- 插入，转变为单节点左式堆的合并\n\n```cpp\ntemplate <typename DataType>\nvoid LeftistHeap<DataType>::InsertElement(DataType inElement)\n{\n\tNode<DataType> *newNode = new Node<DataType>(inElement);\n\troot = MergeCore(root, newNode);\n}\n```\n- 判断左式堆是否为空\n\n```cpp\ntemplate <typename DataType>\nbool LeftistHeap<DataType>::IsEmpty()\n{\n\treturn root == nullptr;\n}\n```\n\n- 清空左式堆，采用非递归中序遍历清空\n\n```cpp\ntemplate <typename DataType>\nvoid LeftistHeap<DataType>::MakeEmpty()\n{\n\tif (root == nullptr) {\n\t\treturn;\n\t}\n\tNode<DataType> *cycleIter = root;\n\tstack<Node<DataType> *> nodeStack;\n\twhile (cycleIter != nullptr || !nodeStack.empty()) {\n\t\twhile (cycleIter != nullptr) {\n\t\t\tnodeStack.push(cycleIter);\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\tif (!nodeStack.empty()) {\n\t\t\tNode<DataType> *tmp = nodeStack.top();\n\t\t\tcycleIter = tmp->right;\n\t\t\tdelete tmp; nodeStack.pop();\n\t\t}\n\t}\n\troot = nullptr;\n}\n```\n\n- 析构函数，回收内存\n\n```cpp\ntemplate <typename DataType>\nLeftistHeap<DataType>::~LeftistHeap()\n{\n\tMakeEmpty();\n}\n```\n\n在测试时，只要把图中左式堆的插入顺序根据二叉树的中序遍历的序列输入即可。从大量数据构造左式堆时可以先构造n个单元素的队列，然后删除队列里的前两个元素合并，并把合并结果放入队尾，重复删除合并过程直到队列只有一个元素。\n\n在非递归实现合并时，分两趟完成，第一趟将两棵树右路径上的节点分离并按照大小排序，然后依次将分离的右节点连按顺序连接，第二趟调整左右子节点使树满足零路径长条件。\n\n## 参考文章\n\n[结构之美——优先队列基本结构（四）——二叉堆、d堆、左式堆、斜堆](http://blog.csdn.net/yangtrees/article/details/8252760)\n\n[优先队列——左式堆](http://www.cnblogs.com/pacoson/p/5142330.html)\n\n[左式堆的实现与详解](http://www.cnblogs.com/zhangbaochong/p/5243463.html)\n\n\n\n\n","source":"_posts/数据结构/数据结构之左式堆.md","raw":"---\ntitle: 数据结构之左式堆的定义与实现\nurlname: leftist-heap\ndate: 2018-03-10 15:12:16\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 左式堆基础知识\n\n左式堆又称为左高树、左偏堆、左倾堆、左偏树，是一种二叉树。左式堆和二叉堆一样也具有结构性和堆序性，但是和二叉堆不同的是，左式堆不是理想平衡的而且趋于非常不平衡。左式堆是一种非常方便进行合并的堆，二叉堆是一种特殊的左式堆。\n\n## 左式堆的性质\n\n- 节点的键值小于或等于左右子节点\n- 任意节点X，左子节点零路径长至少与右子节点零路径长相等，即左子节点零路径长大于等于左子节点零路径长\n- 节点的零路径长为右子节点零路径长加1\n- 一颗N节点左式堆root节点零路径长最多为log(N+1)-1\n- 在右路径上有r个节点的左式堆必然至少有2<sup>r</sup>-1个节点\n- N个节点的左式堆有一条右路径最多含有log(N+1)个节点\n\n左式堆的某节点X的重量W(X)为以X为根的内部节点的数量。WE(X)=W(左子树)+W右子树+1。该值可以递归计算。\n\n零路径长（null path length）是指从节点X到没有两个字节点的最短路径长，因此具有0个或者1个子结点的零路径长为0。左式堆的性质使得树向左进一步加深。如下图为零路径长示意图，节点内数值为零路径长。[图片来源](http://www.cnblogs.com/pacoson/p/5142330.html)\n\n![零路径长示意图](/images/null-path-length.png)\n\n根据左式堆的定义，左式堆的左右子树依然是一个左式堆。\n\n## 左式堆的基本操作\n\n二叉堆的基本操作有插入和删除，而左式堆的基本操作为合并，左式堆的插入是合并的一种特例（单节点左式堆合并），删除看成将左式堆分解成两个左式堆再进行合并操作。左式堆在进行合并时，除了需要保证堆序性外（父节点小于等于子节点值），还需要保证合并后的树依然是一个左式堆，因此合并过程是一个递归过程，描述如下：\n\n1. 如果有一个堆为空，则返回另外一个左式堆\n2. 比较两个左式堆根的大小，以小值根作为新左式堆的根，另外一个左式堆和小根堆的右子树合并\n3. 调整新树使得满足零路径长要求\n4. 递归上述三个过程\n\n\n## 左式堆的实现\n\n由于左式堆最重要的操作是合并，其余操作均可以通过调用合并操作完成，因此左式堆有如下操作：\n\n- 返回最小值：FindMin\n- 合并两个左式堆:Merge\n- 删除最小值（出队）:DeleteMin\n- 插入一个节点：InsertElement\n\n根据《数据结构与算法分析-C语言描述》一书的定义，左式堆定义如下：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *left;\n\tNode *right;\n\tint nullPathLength;\n\tNode(DataType inData):data(inData), left(nullptr), right(nullptr), nullPathLength(0) {} \n};\n\n\ntemplate <typename DataType>\nclass LeftistHeap\n{\npublic:\n\tLeftistHeap(): root(nullptr) {}\n\t~LeftistHeap();\n\tDataType FindMin();\n\tvoid Merge(Node<DataType> *inTree);\n\tvoid DeleteMin();\n\tvoid InsertElement(DataType inElement);\n\tbool IsEmpty();\n\tvoid MakeEmpty();\nprivate:\n\tNode<DataType> *MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2);\n\tNode<DataType> *root;\n};\n```\n\n如上所示节点数据结构中新增了一个表示零路径长的成员，其余和二叉树的定义相同，以下分别实现各函数。\n\n- 查找最小元素，如果左式堆为空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType LeftistHeap<DataType>::FindMin()\n{\n\tif (root == nullptr) {\n\t\tthrow \"Leftist heap is empty!\";\n\t}\n\treturn root->data;\n}\n```\n\n- 合并两棵左式堆核心函数\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * LeftistHeap<DataType>::MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2)\n{\n\tif (inTree1 == nullptr) {\n\t\treturn inTree2;\n\t}\n\n\tif (inTree2 == nullptr) {\n\t\treturn inTree1;\n\t}\n\tif (inTree1->data > inTree2->data) {\n\t\tswap(inTree1, inTree2); //STL库函数\n\t}\n\tif (inTree1->left == nullptr) {\n\t\tinTree1->left = inTree2;\n\t}\n\telse {\n\t\tinTree1->right = MergeCore(inTree1->right, inTree2);\n\t\tif (inTree1->left->nullPathLength < inTree1->right->nullPathLength) {\n\t\t\tswap(inTree1->left, inTree1->right);\n\t\t}\n\t\tinTree1->nullPathLength = inTree1->right->nullPathLength+1;\n\t}\n\treturn inTree1;\n}\n```\n\n- 合并两棵左式堆\n\n```cpp\ntemplate <typename DataType>\nvoid LeftistHeap<DataType>::Merge(Node<DataType> *inTree)\n{\n\troot = MergeCore(root, inTree);\n}\n```\n\n- 删除最小元素，拆解为左右两棵子树，然后调用合并函数进行合并\n\n```cpp\ntemplate <typename DataType>\nvoid LeftistHeap<DataType>::DeleteMin()\n{\n\tNode<DataType> *tmp = root;\n\troot = MergeCore(root->left, root->right);\n\tdelete tmp;\n}\n```\n\n- 插入，转变为单节点左式堆的合并\n\n```cpp\ntemplate <typename DataType>\nvoid LeftistHeap<DataType>::InsertElement(DataType inElement)\n{\n\tNode<DataType> *newNode = new Node<DataType>(inElement);\n\troot = MergeCore(root, newNode);\n}\n```\n- 判断左式堆是否为空\n\n```cpp\ntemplate <typename DataType>\nbool LeftistHeap<DataType>::IsEmpty()\n{\n\treturn root == nullptr;\n}\n```\n\n- 清空左式堆，采用非递归中序遍历清空\n\n```cpp\ntemplate <typename DataType>\nvoid LeftistHeap<DataType>::MakeEmpty()\n{\n\tif (root == nullptr) {\n\t\treturn;\n\t}\n\tNode<DataType> *cycleIter = root;\n\tstack<Node<DataType> *> nodeStack;\n\twhile (cycleIter != nullptr || !nodeStack.empty()) {\n\t\twhile (cycleIter != nullptr) {\n\t\t\tnodeStack.push(cycleIter);\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\tif (!nodeStack.empty()) {\n\t\t\tNode<DataType> *tmp = nodeStack.top();\n\t\t\tcycleIter = tmp->right;\n\t\t\tdelete tmp; nodeStack.pop();\n\t\t}\n\t}\n\troot = nullptr;\n}\n```\n\n- 析构函数，回收内存\n\n```cpp\ntemplate <typename DataType>\nLeftistHeap<DataType>::~LeftistHeap()\n{\n\tMakeEmpty();\n}\n```\n\n在测试时，只要把图中左式堆的插入顺序根据二叉树的中序遍历的序列输入即可。从大量数据构造左式堆时可以先构造n个单元素的队列，然后删除队列里的前两个元素合并，并把合并结果放入队尾，重复删除合并过程直到队列只有一个元素。\n\n在非递归实现合并时，分两趟完成，第一趟将两棵树右路径上的节点分离并按照大小排序，然后依次将分离的右节点连按顺序连接，第二趟调整左右子节点使树满足零路径长条件。\n\n## 参考文章\n\n[结构之美——优先队列基本结构（四）——二叉堆、d堆、左式堆、斜堆](http://blog.csdn.net/yangtrees/article/details/8252760)\n\n[优先队列——左式堆](http://www.cnblogs.com/pacoson/p/5142330.html)\n\n[左式堆的实现与详解](http://www.cnblogs.com/zhangbaochong/p/5243463.html)\n\n\n\n\n","slug":"数据结构/数据结构之左式堆","published":1,"updated":"2018-06-13T14:06:37.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3p001ggsvnlfjt2wgy","content":"<h2 id=\"左式堆基础知识\"><a href=\"#左式堆基础知识\" class=\"headerlink\" title=\"左式堆基础知识\"></a>左式堆基础知识</h2><p>左式堆又称为左高树、左偏堆、左倾堆、左偏树，是一种二叉树。左式堆和二叉堆一样也具有结构性和堆序性，但是和二叉堆不同的是，左式堆不是理想平衡的而且趋于非常不平衡。左式堆是一种非常方便进行合并的堆，二叉堆是一种特殊的左式堆。</p>\n<h2 id=\"左式堆的性质\"><a href=\"#左式堆的性质\" class=\"headerlink\" title=\"左式堆的性质\"></a>左式堆的性质</h2><ul>\n<li>节点的键值小于或等于左右子节点</li>\n<li>任意节点X，左子节点零路径长至少与右子节点零路径长相等，即左子节点零路径长大于等于左子节点零路径长</li>\n<li>节点的零路径长为右子节点零路径长加1</li>\n<li>一颗N节点左式堆root节点零路径长最多为log(N+1)-1</li>\n<li>在右路径上有r个节点的左式堆必然至少有2<sup>r</sup>-1个节点</li>\n<li>N个节点的左式堆有一条右路径最多含有log(N+1)个节点</li>\n</ul>\n<p>左式堆的某节点X的重量W(X)为以X为根的内部节点的数量。WE(X)=W(左子树)+W右子树+1。该值可以递归计算。</p>\n<p>零路径长（null path length）是指从节点X到没有两个字节点的最短路径长，因此具有0个或者1个子结点的零路径长为0。左式堆的性质使得树向左进一步加深。如下图为零路径长示意图，节点内数值为零路径长。<a href=\"http://www.cnblogs.com/pacoson/p/5142330.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/null-path-length.png\" alt=\"零路径长示意图\"></p>\n<p>根据左式堆的定义，左式堆的左右子树依然是一个左式堆。</p>\n<h2 id=\"左式堆的基本操作\"><a href=\"#左式堆的基本操作\" class=\"headerlink\" title=\"左式堆的基本操作\"></a>左式堆的基本操作</h2><p>二叉堆的基本操作有插入和删除，而左式堆的基本操作为合并，左式堆的插入是合并的一种特例（单节点左式堆合并），删除看成将左式堆分解成两个左式堆再进行合并操作。左式堆在进行合并时，除了需要保证堆序性外（父节点小于等于子节点值），还需要保证合并后的树依然是一个左式堆，因此合并过程是一个递归过程，描述如下：</p>\n<ol>\n<li>如果有一个堆为空，则返回另外一个左式堆</li>\n<li>比较两个左式堆根的大小，以小值根作为新左式堆的根，另外一个左式堆和小根堆的右子树合并</li>\n<li>调整新树使得满足零路径长要求</li>\n<li>递归上述三个过程</li>\n</ol>\n<h2 id=\"左式堆的实现\"><a href=\"#左式堆的实现\" class=\"headerlink\" title=\"左式堆的实现\"></a>左式堆的实现</h2><p>由于左式堆最重要的操作是合并，其余操作均可以通过调用合并操作完成，因此左式堆有如下操作：</p>\n<ul>\n<li>返回最小值：FindMin</li>\n<li>合并两个左式堆:Merge</li>\n<li>删除最小值（出队）:DeleteMin</li>\n<li>插入一个节点：InsertElement</li>\n</ul>\n<p>根据《数据结构与算法分析-C语言描述》一书的定义，左式堆定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *left;</span><br><span class=\"line\">\tNode *right;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nullPathLength;</span><br><span class=\"line\">\tNode(DataType inData):data(inData), left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>), nullPathLength(<span class=\"number\">0</span>) &#123;&#125; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeftistHeap</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tLeftistHeap(): root(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~LeftistHeap();</span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">FindMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(Node&lt;DataType&gt; *inTree)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inElement)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; *MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示节点数据结构中新增了一个表示零路径长的成员，其余和二叉树的定义相同，以下分别实现各函数。</p>\n<ul>\n<li>查找最小元素，如果左式堆为空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType LeftistHeap&lt;DataType&gt;::FindMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Leftist heap is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并两棵左式堆核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * LeftistHeap&lt;DataType&gt;::MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inTree2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree2 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;data &gt; inTree2-&gt;data) &#123;</span><br><span class=\"line\">\t\tswap(inTree1, inTree2); <span class=\"comment\">//STL库函数</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tinTree1-&gt;left = inTree2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tinTree1-&gt;right = MergeCore(inTree1-&gt;right, inTree2);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inTree1-&gt;left-&gt;nullPathLength &lt; inTree1-&gt;right-&gt;nullPathLength) &#123;</span><br><span class=\"line\">\t\t\tswap(inTree1-&gt;left, inTree1-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tinTree1-&gt;nullPathLength = inTree1-&gt;right-&gt;nullPathLength+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并两棵左式堆</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> LeftistHeap&lt;DataType&gt;::Merge(Node&lt;DataType&gt; *inTree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\troot = MergeCore(root, inTree);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除最小元素，拆解为左右两棵子树，然后调用合并函数进行合并</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> LeftistHeap&lt;DataType&gt;::DeleteMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = root;</span><br><span class=\"line\">\troot = MergeCore(root-&gt;left, root-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入，转变为单节点左式堆的合并</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> LeftistHeap&lt;DataType&gt;::InsertElement(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inElement);</span><br><span class=\"line\">\troot = MergeCore(root, newNode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断左式堆是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> LeftistHeap&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root == <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空左式堆，采用非递归中序遍历清空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> LeftistHeap&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;Node&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tnodeStack.push(cycleIter);</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">\t\t\tcycleIter = tmp-&gt;right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; nodeStack.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\troot = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，回收内存</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">LeftistHeap&lt;DataType&gt;::~LeftistHeap()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在测试时，只要把图中左式堆的插入顺序根据二叉树的中序遍历的序列输入即可。从大量数据构造左式堆时可以先构造n个单元素的队列，然后删除队列里的前两个元素合并，并把合并结果放入队尾，重复删除合并过程直到队列只有一个元素。</p>\n<p>在非递归实现合并时，分两趟完成，第一趟将两棵树右路径上的节点分离并按照大小排序，然后依次将分离的右节点连按顺序连接，第二趟调整左右子节点使树满足零路径长条件。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://blog.csdn.net/yangtrees/article/details/8252760\" target=\"_blank\" rel=\"noopener\">结构之美——优先队列基本结构（四）——二叉堆、d堆、左式堆、斜堆</a></p>\n<p><a href=\"http://www.cnblogs.com/pacoson/p/5142330.html\" target=\"_blank\" rel=\"noopener\">优先队列——左式堆</a></p>\n<p><a href=\"http://www.cnblogs.com/zhangbaochong/p/5243463.html\" target=\"_blank\" rel=\"noopener\">左式堆的实现与详解</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"左式堆基础知识\"><a href=\"#左式堆基础知识\" class=\"headerlink\" title=\"左式堆基础知识\"></a>左式堆基础知识</h2><p>左式堆又称为左高树、左偏堆、左倾堆、左偏树，是一种二叉树。左式堆和二叉堆一样也具有结构性和堆序性，但是和二叉堆不同的是，左式堆不是理想平衡的而且趋于非常不平衡。左式堆是一种非常方便进行合并的堆，二叉堆是一种特殊的左式堆。</p>\n<h2 id=\"左式堆的性质\"><a href=\"#左式堆的性质\" class=\"headerlink\" title=\"左式堆的性质\"></a>左式堆的性质</h2><ul>\n<li>节点的键值小于或等于左右子节点</li>\n<li>任意节点X，左子节点零路径长至少与右子节点零路径长相等，即左子节点零路径长大于等于左子节点零路径长</li>\n<li>节点的零路径长为右子节点零路径长加1</li>\n<li>一颗N节点左式堆root节点零路径长最多为log(N+1)-1</li>\n<li>在右路径上有r个节点的左式堆必然至少有2<sup>r</sup>-1个节点</li>\n<li>N个节点的左式堆有一条右路径最多含有log(N+1)个节点</li>\n</ul>\n<p>左式堆的某节点X的重量W(X)为以X为根的内部节点的数量。WE(X)=W(左子树)+W右子树+1。该值可以递归计算。</p>\n<p>零路径长（null path length）是指从节点X到没有两个字节点的最短路径长，因此具有0个或者1个子结点的零路径长为0。左式堆的性质使得树向左进一步加深。如下图为零路径长示意图，节点内数值为零路径长。<a href=\"http://www.cnblogs.com/pacoson/p/5142330.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/null-path-length.png\" alt=\"零路径长示意图\"></p>\n<p>根据左式堆的定义，左式堆的左右子树依然是一个左式堆。</p>\n<h2 id=\"左式堆的基本操作\"><a href=\"#左式堆的基本操作\" class=\"headerlink\" title=\"左式堆的基本操作\"></a>左式堆的基本操作</h2><p>二叉堆的基本操作有插入和删除，而左式堆的基本操作为合并，左式堆的插入是合并的一种特例（单节点左式堆合并），删除看成将左式堆分解成两个左式堆再进行合并操作。左式堆在进行合并时，除了需要保证堆序性外（父节点小于等于子节点值），还需要保证合并后的树依然是一个左式堆，因此合并过程是一个递归过程，描述如下：</p>\n<ol>\n<li>如果有一个堆为空，则返回另外一个左式堆</li>\n<li>比较两个左式堆根的大小，以小值根作为新左式堆的根，另外一个左式堆和小根堆的右子树合并</li>\n<li>调整新树使得满足零路径长要求</li>\n<li>递归上述三个过程</li>\n</ol>\n<h2 id=\"左式堆的实现\"><a href=\"#左式堆的实现\" class=\"headerlink\" title=\"左式堆的实现\"></a>左式堆的实现</h2><p>由于左式堆最重要的操作是合并，其余操作均可以通过调用合并操作完成，因此左式堆有如下操作：</p>\n<ul>\n<li>返回最小值：FindMin</li>\n<li>合并两个左式堆:Merge</li>\n<li>删除最小值（出队）:DeleteMin</li>\n<li>插入一个节点：InsertElement</li>\n</ul>\n<p>根据《数据结构与算法分析-C语言描述》一书的定义，左式堆定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *left;</span><br><span class=\"line\">\tNode *right;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nullPathLength;</span><br><span class=\"line\">\tNode(DataType inData):data(inData), left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>), nullPathLength(<span class=\"number\">0</span>) &#123;&#125; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeftistHeap</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tLeftistHeap(): root(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~LeftistHeap();</span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">FindMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(Node&lt;DataType&gt; *inTree)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inElement)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; *MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示节点数据结构中新增了一个表示零路径长的成员，其余和二叉树的定义相同，以下分别实现各函数。</p>\n<ul>\n<li>查找最小元素，如果左式堆为空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType LeftistHeap&lt;DataType&gt;::FindMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Leftist heap is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并两棵左式堆核心函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * LeftistHeap&lt;DataType&gt;::MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inTree2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree2 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;data &gt; inTree2-&gt;data) &#123;</span><br><span class=\"line\">\t\tswap(inTree1, inTree2); <span class=\"comment\">//STL库函数</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tinTree1-&gt;left = inTree2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tinTree1-&gt;right = MergeCore(inTree1-&gt;right, inTree2);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inTree1-&gt;left-&gt;nullPathLength &lt; inTree1-&gt;right-&gt;nullPathLength) &#123;</span><br><span class=\"line\">\t\t\tswap(inTree1-&gt;left, inTree1-&gt;right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tinTree1-&gt;nullPathLength = inTree1-&gt;right-&gt;nullPathLength+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并两棵左式堆</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> LeftistHeap&lt;DataType&gt;::Merge(Node&lt;DataType&gt; *inTree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\troot = MergeCore(root, inTree);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除最小元素，拆解为左右两棵子树，然后调用合并函数进行合并</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> LeftistHeap&lt;DataType&gt;::DeleteMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = root;</span><br><span class=\"line\">\troot = MergeCore(root-&gt;left, root-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入，转变为单节点左式堆的合并</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> LeftistHeap&lt;DataType&gt;::InsertElement(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inElement);</span><br><span class=\"line\">\troot = MergeCore(root, newNode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断左式堆是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> LeftistHeap&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root == <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空左式堆，采用非递归中序遍历清空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> LeftistHeap&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;Node&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tnodeStack.push(cycleIter);</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">\t\t\tcycleIter = tmp-&gt;right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; nodeStack.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\troot = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，回收内存</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">LeftistHeap&lt;DataType&gt;::~LeftistHeap()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在测试时，只要把图中左式堆的插入顺序根据二叉树的中序遍历的序列输入即可。从大量数据构造左式堆时可以先构造n个单元素的队列，然后删除队列里的前两个元素合并，并把合并结果放入队尾，重复删除合并过程直到队列只有一个元素。</p>\n<p>在非递归实现合并时，分两趟完成，第一趟将两棵树右路径上的节点分离并按照大小排序，然后依次将分离的右节点连按顺序连接，第二趟调整左右子节点使树满足零路径长条件。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://blog.csdn.net/yangtrees/article/details/8252760\" target=\"_blank\" rel=\"noopener\">结构之美——优先队列基本结构（四）——二叉堆、d堆、左式堆、斜堆</a></p>\n<p><a href=\"http://www.cnblogs.com/pacoson/p/5142330.html\" target=\"_blank\" rel=\"noopener\">优先队列——左式堆</a></p>\n<p><a href=\"http://www.cnblogs.com/zhangbaochong/p/5243463.html\" target=\"_blank\" rel=\"noopener\">左式堆的实现与详解</a></p>\n"},{"title":"数据结构之斜堆的定义与实现","urlname":"self-adjusting-heap","date":"2018-03-10T11:49:59.000Z","mathjax":true,"copyright":true,"_content":"\n## 斜堆基础知识\n\n斜堆又称为自调节堆。其和左式堆最大的区别是不保留零路径长信息以及不做结构限制，可以总结为斜堆是具有堆序的二叉树，但是对结构不做任何限制。其所有操作最坏情况O(n)，每次操作的摊还时间为O(log<sub>2</sub>n)。和左式堆相似，斜堆的主要操作也是合并，但斜堆除了右路径上最大者不交换左右子节点，其余合并操作必须无条件交换左右子节点。\n\n从斜堆的定义可以知道，所有的左式堆都是斜堆，斜堆一般具有如下性质：\n\n- 仅有一个节点的树为斜堆\n- 两个斜堆合并的结果仍为斜堆\n- 任意节点关键字值小于等于左右子节点关键字值\n\n## 斜堆的实现\n\n斜堆相当于一个简化版的左式堆，因此实现起来可以直接在左式堆的代码上进行修改，斜堆主要包含的操作有：\n\n- 返回最小值：FindMin\n- 合并两个斜堆:Merge\n- 删除最小值（出队）:DeleteMin\n- 插入一个节点：InsertElement\n\n直接套用左式堆的定义有：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *left;\n\tNode *right;\n\tNode(DataType inData):data(inData), left(nullptr), right(nullptr) {} \n};\n\n\ntemplate <typename DataType>\nclass SelfAdjustingHeap\n{\npublic:\n\tSelfAdjustingHeap(): root(nullptr) {}\n\t~SelfAdjustingHeap();\n\tDataType FindMin();\n\tvoid Merge(Node<DataType> *inTree);\n\tvoid DeleteMin();\n\tvoid InsertElement(DataType inElement);\n\tbool IsEmpty();\n\tvoid MakeEmpty();\nprivate:\n\tNode<DataType> *MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2);\n\tNode<DataType> *root;\n};\n```\n\n如上所示节点数据结构中删除了零路径长的成员，其余和左式堆的定义相同，以下分别实现各函数。\n\n- 查找最小元素，如果为空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType SelfAdjustingHeap<DataType>::FindMin()\n{\n\tif (root == nullptr) {\n\t\tthrow \"Self adjusting heap is empty!\";\n\t}\n\treturn root->data;\n}\n```\n\n- 合并两棵斜堆核心函数，不再考虑零路径长度\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * SelfAdjustingHeap<DataType>::MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2)\n{\n\tif (inTree1 == nullptr) {\n\t\treturn inTree2;\n\t}\n\n\tif (inTree2 == nullptr) {\n\t\treturn inTree1;\n\t}\n\tif (inTree1->data > inTree2->data) {\n\t\tswap(inTree1, inTree2); //STL库函数\n\t}\n\tif (inTree1->left == nullptr) {\n\t\tinTree1->left = inTree2;\n\t}\n\telse {\n\t\tinTree1->right = MergeCore(inTree1->right, inTree2);\n\t\tswap(inTree1->left, inTree1->right);\n\t}\n\treturn inTree1;\n}\n```\n\n- 合并两棵斜堆\n\n```cpp\ntemplate <typename DataType>\nvoid SelfAdjustingHeap<DataType>::Merge(Node<DataType> *inTree)\n{\n\troot = MergeCore(root, inTree);\n}\n```\n\n- 删除最小元素，拆解为左右两棵子树，然后调用合并函数进行合并\n\n```cpp\ntemplate <typename DataType>\nvoid SelfAdjustingHeap<DataType>::DeleteMin()\n{\n\tNode<DataType> *tmp = root;\n\troot = MergeCore(root->left, root->right);\n\tdelete tmp;\n}\n```\n\n- 插入，转变为单节点斜堆的合并\n\n```cpp\ntemplate <typename DataType>\nvoid SelfAdjustingHeap<DataType>::InsertElement(DataType inElement)\n{\n\tNode<DataType> *newNode = new Node<DataType>(inElement);\n\troot = MergeCore(root, newNode);\n}\n```\n- 判断斜堆是否为空\n\n```cpp\ntemplate <typename DataType>\nbool SelfAdjustingHeap<DataType>::IsEmpty()\n{\n\treturn root == nullptr;\n}\n```\n\n- 清空斜堆，采用非递归中序遍历清空\n\n```cpp\ntemplate <typename DataType>\nvoid SelfAdjustingHeap<DataType>::MakeEmpty()\n{\n\tif (root == nullptr) {\n\t\treturn;\n\t}\n\tNode<DataType> *cycleIter = root;\n\tstack<Node<DataType> *> nodeStack;\n\twhile (cycleIter != nullptr || !nodeStack.empty()) {\n\t\twhile (cycleIter != nullptr) {\n\t\t\tnodeStack.push(cycleIter);\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\tif (!nodeStack.empty()) {\n\t\t\tNode<DataType> *tmp = nodeStack.top();\n\t\t\tcycleIter = tmp->right;\n\t\t\tdelete tmp; nodeStack.pop();\n\t\t}\n\t}\n\troot = nullptr;\n}\n```\n\n- 析构函数，回收内存\n\n```cpp\ntemplate <typename DataType>\nSelfAdjustingHeap<DataType>::~SelfAdjustingHeap()\n{\n\tMakeEmpty();\n}\n```\n\n","source":"_posts/数据结构/数据结构之斜堆.md","raw":"---\ntitle: 数据结构之斜堆的定义与实现\nurlname: self-adjusting-heap\ndate: 2018-03-10 19:49:59\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 斜堆基础知识\n\n斜堆又称为自调节堆。其和左式堆最大的区别是不保留零路径长信息以及不做结构限制，可以总结为斜堆是具有堆序的二叉树，但是对结构不做任何限制。其所有操作最坏情况O(n)，每次操作的摊还时间为O(log<sub>2</sub>n)。和左式堆相似，斜堆的主要操作也是合并，但斜堆除了右路径上最大者不交换左右子节点，其余合并操作必须无条件交换左右子节点。\n\n从斜堆的定义可以知道，所有的左式堆都是斜堆，斜堆一般具有如下性质：\n\n- 仅有一个节点的树为斜堆\n- 两个斜堆合并的结果仍为斜堆\n- 任意节点关键字值小于等于左右子节点关键字值\n\n## 斜堆的实现\n\n斜堆相当于一个简化版的左式堆，因此实现起来可以直接在左式堆的代码上进行修改，斜堆主要包含的操作有：\n\n- 返回最小值：FindMin\n- 合并两个斜堆:Merge\n- 删除最小值（出队）:DeleteMin\n- 插入一个节点：InsertElement\n\n直接套用左式堆的定义有：\n\n```cpp\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *left;\n\tNode *right;\n\tNode(DataType inData):data(inData), left(nullptr), right(nullptr) {} \n};\n\n\ntemplate <typename DataType>\nclass SelfAdjustingHeap\n{\npublic:\n\tSelfAdjustingHeap(): root(nullptr) {}\n\t~SelfAdjustingHeap();\n\tDataType FindMin();\n\tvoid Merge(Node<DataType> *inTree);\n\tvoid DeleteMin();\n\tvoid InsertElement(DataType inElement);\n\tbool IsEmpty();\n\tvoid MakeEmpty();\nprivate:\n\tNode<DataType> *MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2);\n\tNode<DataType> *root;\n};\n```\n\n如上所示节点数据结构中删除了零路径长的成员，其余和左式堆的定义相同，以下分别实现各函数。\n\n- 查找最小元素，如果为空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType SelfAdjustingHeap<DataType>::FindMin()\n{\n\tif (root == nullptr) {\n\t\tthrow \"Self adjusting heap is empty!\";\n\t}\n\treturn root->data;\n}\n```\n\n- 合并两棵斜堆核心函数，不再考虑零路径长度\n\n```cpp\ntemplate <typename DataType>\nNode<DataType> * SelfAdjustingHeap<DataType>::MergeCore(Node<DataType> *inTree1, Node<DataType> *inTree2)\n{\n\tif (inTree1 == nullptr) {\n\t\treturn inTree2;\n\t}\n\n\tif (inTree2 == nullptr) {\n\t\treturn inTree1;\n\t}\n\tif (inTree1->data > inTree2->data) {\n\t\tswap(inTree1, inTree2); //STL库函数\n\t}\n\tif (inTree1->left == nullptr) {\n\t\tinTree1->left = inTree2;\n\t}\n\telse {\n\t\tinTree1->right = MergeCore(inTree1->right, inTree2);\n\t\tswap(inTree1->left, inTree1->right);\n\t}\n\treturn inTree1;\n}\n```\n\n- 合并两棵斜堆\n\n```cpp\ntemplate <typename DataType>\nvoid SelfAdjustingHeap<DataType>::Merge(Node<DataType> *inTree)\n{\n\troot = MergeCore(root, inTree);\n}\n```\n\n- 删除最小元素，拆解为左右两棵子树，然后调用合并函数进行合并\n\n```cpp\ntemplate <typename DataType>\nvoid SelfAdjustingHeap<DataType>::DeleteMin()\n{\n\tNode<DataType> *tmp = root;\n\troot = MergeCore(root->left, root->right);\n\tdelete tmp;\n}\n```\n\n- 插入，转变为单节点斜堆的合并\n\n```cpp\ntemplate <typename DataType>\nvoid SelfAdjustingHeap<DataType>::InsertElement(DataType inElement)\n{\n\tNode<DataType> *newNode = new Node<DataType>(inElement);\n\troot = MergeCore(root, newNode);\n}\n```\n- 判断斜堆是否为空\n\n```cpp\ntemplate <typename DataType>\nbool SelfAdjustingHeap<DataType>::IsEmpty()\n{\n\treturn root == nullptr;\n}\n```\n\n- 清空斜堆，采用非递归中序遍历清空\n\n```cpp\ntemplate <typename DataType>\nvoid SelfAdjustingHeap<DataType>::MakeEmpty()\n{\n\tif (root == nullptr) {\n\t\treturn;\n\t}\n\tNode<DataType> *cycleIter = root;\n\tstack<Node<DataType> *> nodeStack;\n\twhile (cycleIter != nullptr || !nodeStack.empty()) {\n\t\twhile (cycleIter != nullptr) {\n\t\t\tnodeStack.push(cycleIter);\n\t\t\tcycleIter = cycleIter->left;\n\t\t}\n\t\tif (!nodeStack.empty()) {\n\t\t\tNode<DataType> *tmp = nodeStack.top();\n\t\t\tcycleIter = tmp->right;\n\t\t\tdelete tmp; nodeStack.pop();\n\t\t}\n\t}\n\troot = nullptr;\n}\n```\n\n- 析构函数，回收内存\n\n```cpp\ntemplate <typename DataType>\nSelfAdjustingHeap<DataType>::~SelfAdjustingHeap()\n{\n\tMakeEmpty();\n}\n```\n\n","slug":"数据结构/数据结构之斜堆","published":1,"updated":"2018-06-13T14:06:33.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3r001kgsvnvoae8xj6","content":"<h2 id=\"斜堆基础知识\"><a href=\"#斜堆基础知识\" class=\"headerlink\" title=\"斜堆基础知识\"></a>斜堆基础知识</h2><p>斜堆又称为自调节堆。其和左式堆最大的区别是不保留零路径长信息以及不做结构限制，可以总结为斜堆是具有堆序的二叉树，但是对结构不做任何限制。其所有操作最坏情况O(n)，每次操作的摊还时间为O(log<sub>2</sub>n)。和左式堆相似，斜堆的主要操作也是合并，但斜堆除了右路径上最大者不交换左右子节点，其余合并操作必须无条件交换左右子节点。</p>\n<p>从斜堆的定义可以知道，所有的左式堆都是斜堆，斜堆一般具有如下性质：</p>\n<ul>\n<li>仅有一个节点的树为斜堆</li>\n<li>两个斜堆合并的结果仍为斜堆</li>\n<li>任意节点关键字值小于等于左右子节点关键字值</li>\n</ul>\n<h2 id=\"斜堆的实现\"><a href=\"#斜堆的实现\" class=\"headerlink\" title=\"斜堆的实现\"></a>斜堆的实现</h2><p>斜堆相当于一个简化版的左式堆，因此实现起来可以直接在左式堆的代码上进行修改，斜堆主要包含的操作有：</p>\n<ul>\n<li>返回最小值：FindMin</li>\n<li>合并两个斜堆:Merge</li>\n<li>删除最小值（出队）:DeleteMin</li>\n<li>插入一个节点：InsertElement</li>\n</ul>\n<p>直接套用左式堆的定义有：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *left;</span><br><span class=\"line\">\tNode *right;</span><br><span class=\"line\">\tNode(DataType inData):data(inData), left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>) &#123;&#125; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SelfAdjustingHeap</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tSelfAdjustingHeap(): root(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~SelfAdjustingHeap();</span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">FindMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(Node&lt;DataType&gt; *inTree)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inElement)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; *MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示节点数据结构中删除了零路径长的成员，其余和左式堆的定义相同，以下分别实现各函数。</p>\n<ul>\n<li>查找最小元素，如果为空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType SelfAdjustingHeap&lt;DataType&gt;::FindMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Self adjusting heap is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并两棵斜堆核心函数，不再考虑零路径长度</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * SelfAdjustingHeap&lt;DataType&gt;::MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inTree2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree2 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;data &gt; inTree2-&gt;data) &#123;</span><br><span class=\"line\">\t\tswap(inTree1, inTree2); <span class=\"comment\">//STL库函数</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tinTree1-&gt;left = inTree2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tinTree1-&gt;right = MergeCore(inTree1-&gt;right, inTree2);</span><br><span class=\"line\">\t\tswap(inTree1-&gt;left, inTree1-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并两棵斜堆</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> SelfAdjustingHeap&lt;DataType&gt;::Merge(Node&lt;DataType&gt; *inTree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\troot = MergeCore(root, inTree);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除最小元素，拆解为左右两棵子树，然后调用合并函数进行合并</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> SelfAdjustingHeap&lt;DataType&gt;::DeleteMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = root;</span><br><span class=\"line\">\troot = MergeCore(root-&gt;left, root-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入，转变为单节点斜堆的合并</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> SelfAdjustingHeap&lt;DataType&gt;::InsertElement(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inElement);</span><br><span class=\"line\">\troot = MergeCore(root, newNode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断斜堆是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> SelfAdjustingHeap&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root == <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空斜堆，采用非递归中序遍历清空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> SelfAdjustingHeap&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;Node&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tnodeStack.push(cycleIter);</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">\t\t\tcycleIter = tmp-&gt;right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; nodeStack.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\troot = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，回收内存</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">SelfAdjustingHeap&lt;DataType&gt;::~SelfAdjustingHeap()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"斜堆基础知识\"><a href=\"#斜堆基础知识\" class=\"headerlink\" title=\"斜堆基础知识\"></a>斜堆基础知识</h2><p>斜堆又称为自调节堆。其和左式堆最大的区别是不保留零路径长信息以及不做结构限制，可以总结为斜堆是具有堆序的二叉树，但是对结构不做任何限制。其所有操作最坏情况O(n)，每次操作的摊还时间为O(log<sub>2</sub>n)。和左式堆相似，斜堆的主要操作也是合并，但斜堆除了右路径上最大者不交换左右子节点，其余合并操作必须无条件交换左右子节点。</p>\n<p>从斜堆的定义可以知道，所有的左式堆都是斜堆，斜堆一般具有如下性质：</p>\n<ul>\n<li>仅有一个节点的树为斜堆</li>\n<li>两个斜堆合并的结果仍为斜堆</li>\n<li>任意节点关键字值小于等于左右子节点关键字值</li>\n</ul>\n<h2 id=\"斜堆的实现\"><a href=\"#斜堆的实现\" class=\"headerlink\" title=\"斜堆的实现\"></a>斜堆的实现</h2><p>斜堆相当于一个简化版的左式堆，因此实现起来可以直接在左式堆的代码上进行修改，斜堆主要包含的操作有：</p>\n<ul>\n<li>返回最小值：FindMin</li>\n<li>合并两个斜堆:Merge</li>\n<li>删除最小值（出队）:DeleteMin</li>\n<li>插入一个节点：InsertElement</li>\n</ul>\n<p>直接套用左式堆的定义有：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *left;</span><br><span class=\"line\">\tNode *right;</span><br><span class=\"line\">\tNode(DataType inData):data(inData), left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>) &#123;&#125; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SelfAdjustingHeap</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tSelfAdjustingHeap(): root(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~SelfAdjustingHeap();</span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">FindMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(Node&lt;DataType&gt; *inTree)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMin</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertElement</span><span class=\"params\">(DataType inElement)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; *MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2);</span><br><span class=\"line\">\tNode&lt;DataType&gt; *root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示节点数据结构中删除了零路径长的成员，其余和左式堆的定义相同，以下分别实现各函数。</p>\n<ul>\n<li>查找最小元素，如果为空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType SelfAdjustingHeap&lt;DataType&gt;::FindMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Self adjusting heap is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并两棵斜堆核心函数，不再考虑零路径长度</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Node&lt;DataType&gt; * SelfAdjustingHeap&lt;DataType&gt;::MergeCore(Node&lt;DataType&gt; *inTree1, Node&lt;DataType&gt; *inTree2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inTree2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree2 == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;data &gt; inTree2-&gt;data) &#123;</span><br><span class=\"line\">\t\tswap(inTree1, inTree2); <span class=\"comment\">//STL库函数</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inTree1-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tinTree1-&gt;left = inTree2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tinTree1-&gt;right = MergeCore(inTree1-&gt;right, inTree2);</span><br><span class=\"line\">\t\tswap(inTree1-&gt;left, inTree1-&gt;right);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> inTree1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>合并两棵斜堆</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> SelfAdjustingHeap&lt;DataType&gt;::Merge(Node&lt;DataType&gt; *inTree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\troot = MergeCore(root, inTree);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除最小元素，拆解为左右两棵子树，然后调用合并函数进行合并</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> SelfAdjustingHeap&lt;DataType&gt;::DeleteMin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = root;</span><br><span class=\"line\">\troot = MergeCore(root-&gt;left, root-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>插入，转变为单节点斜堆的合并</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> SelfAdjustingHeap&lt;DataType&gt;::InsertElement(DataType inElement)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inElement);</span><br><span class=\"line\">\troot = MergeCore(root, newNode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断斜堆是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> SelfAdjustingHeap&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root == <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空斜堆，采用非递归中序遍历清空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> SelfAdjustingHeap&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = root;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;Node&lt;DataType&gt; *&gt; nodeStack;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span> || !nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tnodeStack.push(cycleIter);</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!nodeStack.empty()) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;DataType&gt; *tmp = nodeStack.top();</span><br><span class=\"line\">\t\t\tcycleIter = tmp-&gt;right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> tmp; nodeStack.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\troot = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，回收内存</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">SelfAdjustingHeap&lt;DataType&gt;::~SelfAdjustingHeap()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构之栈的定义与实现","urlname":"stack","date":"2018-03-04T14:12:33.000Z","mathjax":true,"copyright":true,"_content":"\n## 栈基础知识\n\n栈(stack)是一种限制插入和删除只能在一端进行的线性表，允许插入删除的一端称为栈顶，另一端称为栈底。栈的基本操作有进栈(push)和出栈(pop)。当栈中不存在任何元素时称为空栈，此时进行出栈操作或者读取栈顶元素是一种错误。栈的实现既可以通过顺序表，也可以使用链表来实现。使用顺序表实现的栈称为顺序栈，使用链表实现的称为链式栈。由于栈的插入删除特性，因此栈具有“后进先出(LIFO)”的特点。考虑到栈在实际中的应用情况，栈一般需要实现以下操作：\n\n- 进栈操作：Push\n- 出栈操作：Pop\n- 判断是否为空：IsEmpty\n- 清空栈：MakeEmpty\n- 读取栈顶元素：Top\n\n## 栈的链表实现\n\n根据分析，栈在使用链表实现时，为了方便可以使用头插法并从头部弹出的结构实现。在STL的实现中，既可以采用deque作为底层容器，也可以采用list作为底层容器。\n\n仿照《数据结构与算法分析-C语言描述》的定义，基本定义如下所示\n\n```cpp\ntemplate <typename DataType>\nclass Node\n{\npublic:\n\tNode(DataType inData, Node<DataType> *inNext):data(inData),next(inNext) {}\npublic:\n\tDataType data;\n\tNode<DataType> *next; /*下一个节点*/\n};\n\n\ntemplate <typename DataType>\nclass Stack\n{\npublic:\n\tStack():dummyNode(-1,nullptr), stackSize(0) {}\n\t~Stack(); //析构函数，负责清空栈\n\tvoid Push(DataType inData); //压栈\n\tvoid Pop(); //出栈\n\tbool isEmpty(); //判断栈是否为空\n\tvoid MakeEmpty(); //清空栈\n\tDataType Top(); //返回栈顶元素，如果出错则抛出异常\n\tint StackSize(); //返回栈大小\nprivate:\n\tNode<DataType> dummyNode; //哑节点\n\tint stackSize; //栈大小\n};\n```\n\n如上所示，栈的主要数据成员为栈大小和一个辅助哑节点，如下依次实现栈的各函数\n\n- 压栈，采用头插法\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::Push(DataType inData)\n{\n\tdummyNode.next = new Node<DataType>(inData, dummyNode.next);\n\t++stackSize;\n}\n```\n\n- 出栈，如果栈为空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::Pop()\n{\n\tif (stackSize <= 0 || dummyNode.next == nullptr) {\n\t\tthrow \"Stack is empty!\";\n\t}\n\tNode<DataType> *tmp = dummyNode.next; /*暂存*/\n\tdummyNode.next = dummyNode.next->next;\n\tdelete tmp; --stackSize;\n}\n```\n\n- 判断栈是否为空\n\n```cpp\ntemplate <typename DataType>\nbool Stack<DataType>::isEmpty()\n{\n\treturn stackSize == 0 || dummyNode.next == nullptr;\n}\n```\n\n- 清空栈\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::MakeEmpty()\n{\n\tNode<DataType> *tmp = dummyNode.next; /*遍历*/\n\twhile (tmp != nullptr) {\n\t\tdummyNode.next = tmp->next;\n\t\tdelete tmp; --stackSize;\n\t\ttmp = dummyNode.next;\n\t}\n}\n```\n\n- 返回栈顶元素，如果出错则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType Stack<DataType>::Top()\n{\n\tif (stackSize <= 0 || dummyNode.next == nullptr) {\n\t\tthrow \"Stack is empty!\";\n\t}\n\treturn dummyNode.next->data;\n}\n```\n\n- 返回栈大小\n\n```cpp\ntemplate <typename DataType>\nint Stack<DataType>::StackSize()\n{\n\treturn stackSize;\n}\n```\n\n- 析构函数，清空栈\n\n```cpp\ntemplate <typename DataType>\nStack<DataType>::~Stack()\n{\n\tMakeEmpty();\n}\n```\n\n## 栈的数组实现\n\n栈的数组实现可以直接使用STL的vector作为底层容器，这样数组大小可以动态调整，但是为了方便，这里使用固定数组大小的方式实现，因此会出现栈满的情况。使用数组实现的的栈定义如下：\n\n```cpp\ntemplate <typename DataType>\nclass Stack\n{\npublic:\n\tStack(int inStackCapacity);\n\t~Stack(); //析构函数，负责清空栈\n\tvoid Push(DataType inData); //压栈\n\tvoid Pop(); //出栈\n\tbool isEmpty(); //判断栈是否为空\n\tvoid MakeEmpty(); //清空栈\n\tDataType Top(); //返回栈顶元素，如果出错则抛出异常\n\tint StackSize(); //返回栈大小\nprivate:\n\tint stackCapacity;\n\tint stackSize;\n\tDataType *stackPtr; /*动态申请*/\n};\n```\n\n如上所示，数组实现的栈只保存栈容量、栈大小以及指向栈存储位置的指针，以下依次实现各函数：\n\n- 构造函数\n\n```cpp\ntemplate <typename DataType>\nStack<DataType>::Stack(int inStackCapacity):stackCapacity(inStackCapacity),stackSize(0)\n{\n\tstackPtr = new DataType[inStackCapacity];\n}\n```\n\n- 压栈，如果栈满则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::Push(DataType inData)\n{\n\tif (stackSize >= stackCapacity) {\n\t\tthrow \"Stack is full!\";\n\t}\n\tstackPtr[stackSize++] = inData;\n}\n```\n\n- 出栈，如果栈为空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::Pop()\n{\n\tif (stackSize <= 0) {\n\t\tthrow \"Stack is empty!\";\n\t}\n\t--stackSize;\n}\n```\n\n- 判断栈是否为空\n\n```cpp\ntemplate <typename DataType>\nbool Stack<DataType>::isEmpty()\n{\n\treturn stackSize <= 0;\n}\n```\n\n- 清空栈\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::MakeEmpty()\n{\n\tstackSize = 0;\n}\n```\n\n- 返回栈顶元素，如果出错则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType Stack<DataType>::Top()\n{\n\tif (stackSize <= 0) {\n\t\tthrow \"Stack is empty!\";\n\t}\n\treturn stackPtr[stackSize-1];\n}\n```\n\n- 返回栈大小\n\n```cpp\ntemplate <typename DataType>\nint Stack<DataType>::StackSize()\n{\n\treturn stackSize;\n}\n```\n\n- 析构函数，清空栈\n\n```cpp\ntemplate <typename DataType>\nStack<DataType>::~Stack()\n{\n\tMakeEmpty();\n\tdelete [] stackPtr;\n}\n```\n\n## 代码测试\n\n基本的算法测试和异常捕捉代码如下所示：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\ttry {\n\t\tStack<char> TestStack; /*不同实现*/\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tTestStack.Push('A'+i);\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tcout << TestStack.Top() << \";\";\n\t\t\tTestStack.Po0p();\n\t\t}\n\t\tcout << endl;\n\n\t}\n\tcatch(const char *msg) {\n\t\tcout << msg << endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","source":"_posts/数据结构/数据结构之栈的定义与实现.md","raw":"---\ntitle: 数据结构之栈的定义与实现\nurlname: stack\ndate: 2018-03-4 22:12:33\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\n- C++\ncategories:\n- 数据结构\n---\n\n## 栈基础知识\n\n栈(stack)是一种限制插入和删除只能在一端进行的线性表，允许插入删除的一端称为栈顶，另一端称为栈底。栈的基本操作有进栈(push)和出栈(pop)。当栈中不存在任何元素时称为空栈，此时进行出栈操作或者读取栈顶元素是一种错误。栈的实现既可以通过顺序表，也可以使用链表来实现。使用顺序表实现的栈称为顺序栈，使用链表实现的称为链式栈。由于栈的插入删除特性，因此栈具有“后进先出(LIFO)”的特点。考虑到栈在实际中的应用情况，栈一般需要实现以下操作：\n\n- 进栈操作：Push\n- 出栈操作：Pop\n- 判断是否为空：IsEmpty\n- 清空栈：MakeEmpty\n- 读取栈顶元素：Top\n\n## 栈的链表实现\n\n根据分析，栈在使用链表实现时，为了方便可以使用头插法并从头部弹出的结构实现。在STL的实现中，既可以采用deque作为底层容器，也可以采用list作为底层容器。\n\n仿照《数据结构与算法分析-C语言描述》的定义，基本定义如下所示\n\n```cpp\ntemplate <typename DataType>\nclass Node\n{\npublic:\n\tNode(DataType inData, Node<DataType> *inNext):data(inData),next(inNext) {}\npublic:\n\tDataType data;\n\tNode<DataType> *next; /*下一个节点*/\n};\n\n\ntemplate <typename DataType>\nclass Stack\n{\npublic:\n\tStack():dummyNode(-1,nullptr), stackSize(0) {}\n\t~Stack(); //析构函数，负责清空栈\n\tvoid Push(DataType inData); //压栈\n\tvoid Pop(); //出栈\n\tbool isEmpty(); //判断栈是否为空\n\tvoid MakeEmpty(); //清空栈\n\tDataType Top(); //返回栈顶元素，如果出错则抛出异常\n\tint StackSize(); //返回栈大小\nprivate:\n\tNode<DataType> dummyNode; //哑节点\n\tint stackSize; //栈大小\n};\n```\n\n如上所示，栈的主要数据成员为栈大小和一个辅助哑节点，如下依次实现栈的各函数\n\n- 压栈，采用头插法\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::Push(DataType inData)\n{\n\tdummyNode.next = new Node<DataType>(inData, dummyNode.next);\n\t++stackSize;\n}\n```\n\n- 出栈，如果栈为空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::Pop()\n{\n\tif (stackSize <= 0 || dummyNode.next == nullptr) {\n\t\tthrow \"Stack is empty!\";\n\t}\n\tNode<DataType> *tmp = dummyNode.next; /*暂存*/\n\tdummyNode.next = dummyNode.next->next;\n\tdelete tmp; --stackSize;\n}\n```\n\n- 判断栈是否为空\n\n```cpp\ntemplate <typename DataType>\nbool Stack<DataType>::isEmpty()\n{\n\treturn stackSize == 0 || dummyNode.next == nullptr;\n}\n```\n\n- 清空栈\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::MakeEmpty()\n{\n\tNode<DataType> *tmp = dummyNode.next; /*遍历*/\n\twhile (tmp != nullptr) {\n\t\tdummyNode.next = tmp->next;\n\t\tdelete tmp; --stackSize;\n\t\ttmp = dummyNode.next;\n\t}\n}\n```\n\n- 返回栈顶元素，如果出错则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType Stack<DataType>::Top()\n{\n\tif (stackSize <= 0 || dummyNode.next == nullptr) {\n\t\tthrow \"Stack is empty!\";\n\t}\n\treturn dummyNode.next->data;\n}\n```\n\n- 返回栈大小\n\n```cpp\ntemplate <typename DataType>\nint Stack<DataType>::StackSize()\n{\n\treturn stackSize;\n}\n```\n\n- 析构函数，清空栈\n\n```cpp\ntemplate <typename DataType>\nStack<DataType>::~Stack()\n{\n\tMakeEmpty();\n}\n```\n\n## 栈的数组实现\n\n栈的数组实现可以直接使用STL的vector作为底层容器，这样数组大小可以动态调整，但是为了方便，这里使用固定数组大小的方式实现，因此会出现栈满的情况。使用数组实现的的栈定义如下：\n\n```cpp\ntemplate <typename DataType>\nclass Stack\n{\npublic:\n\tStack(int inStackCapacity);\n\t~Stack(); //析构函数，负责清空栈\n\tvoid Push(DataType inData); //压栈\n\tvoid Pop(); //出栈\n\tbool isEmpty(); //判断栈是否为空\n\tvoid MakeEmpty(); //清空栈\n\tDataType Top(); //返回栈顶元素，如果出错则抛出异常\n\tint StackSize(); //返回栈大小\nprivate:\n\tint stackCapacity;\n\tint stackSize;\n\tDataType *stackPtr; /*动态申请*/\n};\n```\n\n如上所示，数组实现的栈只保存栈容量、栈大小以及指向栈存储位置的指针，以下依次实现各函数：\n\n- 构造函数\n\n```cpp\ntemplate <typename DataType>\nStack<DataType>::Stack(int inStackCapacity):stackCapacity(inStackCapacity),stackSize(0)\n{\n\tstackPtr = new DataType[inStackCapacity];\n}\n```\n\n- 压栈，如果栈满则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::Push(DataType inData)\n{\n\tif (stackSize >= stackCapacity) {\n\t\tthrow \"Stack is full!\";\n\t}\n\tstackPtr[stackSize++] = inData;\n}\n```\n\n- 出栈，如果栈为空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::Pop()\n{\n\tif (stackSize <= 0) {\n\t\tthrow \"Stack is empty!\";\n\t}\n\t--stackSize;\n}\n```\n\n- 判断栈是否为空\n\n```cpp\ntemplate <typename DataType>\nbool Stack<DataType>::isEmpty()\n{\n\treturn stackSize <= 0;\n}\n```\n\n- 清空栈\n\n```cpp\ntemplate <typename DataType>\nvoid Stack<DataType>::MakeEmpty()\n{\n\tstackSize = 0;\n}\n```\n\n- 返回栈顶元素，如果出错则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType Stack<DataType>::Top()\n{\n\tif (stackSize <= 0) {\n\t\tthrow \"Stack is empty!\";\n\t}\n\treturn stackPtr[stackSize-1];\n}\n```\n\n- 返回栈大小\n\n```cpp\ntemplate <typename DataType>\nint Stack<DataType>::StackSize()\n{\n\treturn stackSize;\n}\n```\n\n- 析构函数，清空栈\n\n```cpp\ntemplate <typename DataType>\nStack<DataType>::~Stack()\n{\n\tMakeEmpty();\n\tdelete [] stackPtr;\n}\n```\n\n## 代码测试\n\n基本的算法测试和异常捕捉代码如下所示：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\ttry {\n\t\tStack<char> TestStack; /*不同实现*/\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tTestStack.Push('A'+i);\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tcout << TestStack.Top() << \";\";\n\t\t\tTestStack.Po0p();\n\t\t}\n\t\tcout << endl;\n\n\t}\n\tcatch(const char *msg) {\n\t\tcout << msg << endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","slug":"数据结构/数据结构之栈的定义与实现","published":1,"updated":"2018-06-13T14:07:56.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3s001ngsvnifvqpalh","content":"<h2 id=\"栈基础知识\"><a href=\"#栈基础知识\" class=\"headerlink\" title=\"栈基础知识\"></a>栈基础知识</h2><p>栈(stack)是一种限制插入和删除只能在一端进行的线性表，允许插入删除的一端称为栈顶，另一端称为栈底。栈的基本操作有进栈(push)和出栈(pop)。当栈中不存在任何元素时称为空栈，此时进行出栈操作或者读取栈顶元素是一种错误。栈的实现既可以通过顺序表，也可以使用链表来实现。使用顺序表实现的栈称为顺序栈，使用链表实现的称为链式栈。由于栈的插入删除特性，因此栈具有“后进先出(LIFO)”的特点。考虑到栈在实际中的应用情况，栈一般需要实现以下操作：</p>\n<ul>\n<li>进栈操作：Push</li>\n<li>出栈操作：Pop</li>\n<li>判断是否为空：IsEmpty</li>\n<li>清空栈：MakeEmpty</li>\n<li>读取栈顶元素：Top</li>\n</ul>\n<h2 id=\"栈的链表实现\"><a href=\"#栈的链表实现\" class=\"headerlink\" title=\"栈的链表实现\"></a>栈的链表实现</h2><p>根据分析，栈在使用链表实现时，为了方便可以使用头插法并从头部弹出的结构实现。在STL的实现中，既可以采用deque作为底层容器，也可以采用list作为底层容器。</p>\n<p>仿照《数据结构与算法分析-C语言描述》的定义，基本定义如下所示</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode(DataType inData, Node&lt;DataType&gt; *inNext):data(inData),next(inNext) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *next; <span class=\"comment\">/*下一个节点*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tStack():dummyNode(<span class=\"number\">-1</span>,<span class=\"literal\">nullptr</span>), stackSize(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t~Stack(); <span class=\"comment\">//析构函数，负责清空栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//压栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop</span><span class=\"params\">()</span></span>; <span class=\"comment\">//出栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断栈是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空栈</span></span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Top</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回栈顶元素，如果出错则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">StackSize</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回栈大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; dummyNode; <span class=\"comment\">//哑节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackSize; <span class=\"comment\">//栈大小</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，栈的主要数据成员为栈大小和一个辅助哑节点，如下依次实现栈的各函数</p>\n<ul>\n<li>压栈，采用头插法</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::Push(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdummyNode.next = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inData, dummyNode.next);</span><br><span class=\"line\">\t++stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出栈，如果栈为空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::Pop()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = dummyNode.next; <span class=\"comment\">/*暂存*/</span></span><br><span class=\"line\">\tdummyNode.next = dummyNode.next-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> tmp; --stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断栈是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> Stack&lt;DataType&gt;::isEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackSize == <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = dummyNode.next; <span class=\"comment\">/*遍历*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tdummyNode.next = tmp-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp; --stackSize;</span><br><span class=\"line\">\t\ttmp = dummyNode.next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回栈顶元素，如果出错则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType Stack&lt;DataType&gt;::Top()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dummyNode.next-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回栈大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Stack&lt;DataType&gt;::StackSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Stack&lt;DataType&gt;::~Stack()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈的数组实现\"><a href=\"#栈的数组实现\" class=\"headerlink\" title=\"栈的数组实现\"></a>栈的数组实现</h2><p>栈的数组实现可以直接使用STL的vector作为底层容器，这样数组大小可以动态调整，但是为了方便，这里使用固定数组大小的方式实现，因此会出现栈满的情况。使用数组实现的的栈定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tStack(<span class=\"keyword\">int</span> inStackCapacity);</span><br><span class=\"line\">\t~Stack(); <span class=\"comment\">//析构函数，负责清空栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//压栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop</span><span class=\"params\">()</span></span>; <span class=\"comment\">//出栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断栈是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空栈</span></span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Top</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回栈顶元素，如果出错则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">StackSize</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回栈大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackCapacity;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackSize;</span><br><span class=\"line\">\tDataType *stackPtr; <span class=\"comment\">/*动态申请*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，数组实现的栈只保存栈容量、栈大小以及指向栈存储位置的指针，以下依次实现各函数：</p>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Stack&lt;DataType&gt;::Stack(<span class=\"keyword\">int</span> inStackCapacity):stackCapacity(inStackCapacity),stackSize(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstackPtr = <span class=\"keyword\">new</span> DataType[inStackCapacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>压栈，如果栈满则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::Push(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &gt;= stackCapacity) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is full!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstackPtr[stackSize++] = inData;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出栈，如果栈为空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::Pop()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t--stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断栈是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> Stack&lt;DataType&gt;::isEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackSize &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstackSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回栈顶元素，如果出错则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType Stack&lt;DataType&gt;::Top()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackPtr[stackSize<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回栈大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Stack&lt;DataType&gt;::StackSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Stack&lt;DataType&gt;::~Stack()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] stackPtr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>基本的算法测试和异常捕捉代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tStack&lt;<span class=\"keyword\">char</span>&gt; TestStack; <span class=\"comment\">/*不同实现*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tTestStack.Push(<span class=\"string\">'A'</span>+i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; TestStack.Top() &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">\t\t\tTestStack.Po0p();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *msg) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; msg &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"栈基础知识\"><a href=\"#栈基础知识\" class=\"headerlink\" title=\"栈基础知识\"></a>栈基础知识</h2><p>栈(stack)是一种限制插入和删除只能在一端进行的线性表，允许插入删除的一端称为栈顶，另一端称为栈底。栈的基本操作有进栈(push)和出栈(pop)。当栈中不存在任何元素时称为空栈，此时进行出栈操作或者读取栈顶元素是一种错误。栈的实现既可以通过顺序表，也可以使用链表来实现。使用顺序表实现的栈称为顺序栈，使用链表实现的称为链式栈。由于栈的插入删除特性，因此栈具有“后进先出(LIFO)”的特点。考虑到栈在实际中的应用情况，栈一般需要实现以下操作：</p>\n<ul>\n<li>进栈操作：Push</li>\n<li>出栈操作：Pop</li>\n<li>判断是否为空：IsEmpty</li>\n<li>清空栈：MakeEmpty</li>\n<li>读取栈顶元素：Top</li>\n</ul>\n<h2 id=\"栈的链表实现\"><a href=\"#栈的链表实现\" class=\"headerlink\" title=\"栈的链表实现\"></a>栈的链表实现</h2><p>根据分析，栈在使用链表实现时，为了方便可以使用头插法并从头部弹出的结构实现。在STL的实现中，既可以采用deque作为底层容器，也可以采用list作为底层容器。</p>\n<p>仿照《数据结构与算法分析-C语言描述》的定义，基本定义如下所示</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode(DataType inData, Node&lt;DataType&gt; *inNext):data(inData),next(inNext) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *next; <span class=\"comment\">/*下一个节点*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tStack():dummyNode(<span class=\"number\">-1</span>,<span class=\"literal\">nullptr</span>), stackSize(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t~Stack(); <span class=\"comment\">//析构函数，负责清空栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//压栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop</span><span class=\"params\">()</span></span>; <span class=\"comment\">//出栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断栈是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空栈</span></span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Top</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回栈顶元素，如果出错则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">StackSize</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回栈大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; dummyNode; <span class=\"comment\">//哑节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackSize; <span class=\"comment\">//栈大小</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，栈的主要数据成员为栈大小和一个辅助哑节点，如下依次实现栈的各函数</p>\n<ul>\n<li>压栈，采用头插法</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::Push(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdummyNode.next = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inData, dummyNode.next);</span><br><span class=\"line\">\t++stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出栈，如果栈为空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::Pop()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = dummyNode.next; <span class=\"comment\">/*暂存*/</span></span><br><span class=\"line\">\tdummyNode.next = dummyNode.next-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> tmp; --stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断栈是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> Stack&lt;DataType&gt;::isEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackSize == <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = dummyNode.next; <span class=\"comment\">/*遍历*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tdummyNode.next = tmp-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp; --stackSize;</span><br><span class=\"line\">\t\ttmp = dummyNode.next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回栈顶元素，如果出错则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType Stack&lt;DataType&gt;::Top()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dummyNode.next-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回栈大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Stack&lt;DataType&gt;::StackSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Stack&lt;DataType&gt;::~Stack()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈的数组实现\"><a href=\"#栈的数组实现\" class=\"headerlink\" title=\"栈的数组实现\"></a>栈的数组实现</h2><p>栈的数组实现可以直接使用STL的vector作为底层容器，这样数组大小可以动态调整，但是为了方便，这里使用固定数组大小的方式实现，因此会出现栈满的情况。使用数组实现的的栈定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tStack(<span class=\"keyword\">int</span> inStackCapacity);</span><br><span class=\"line\">\t~Stack(); <span class=\"comment\">//析构函数，负责清空栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Push</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//压栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop</span><span class=\"params\">()</span></span>; <span class=\"comment\">//出栈</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断栈是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空栈</span></span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Top</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回栈顶元素，如果出错则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">StackSize</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回栈大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackCapacity;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackSize;</span><br><span class=\"line\">\tDataType *stackPtr; <span class=\"comment\">/*动态申请*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，数组实现的栈只保存栈容量、栈大小以及指向栈存储位置的指针，以下依次实现各函数：</p>\n<ul>\n<li>构造函数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Stack&lt;DataType&gt;::Stack(<span class=\"keyword\">int</span> inStackCapacity):stackCapacity(inStackCapacity),stackSize(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstackPtr = <span class=\"keyword\">new</span> DataType[inStackCapacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>压栈，如果栈满则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::Push(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &gt;= stackCapacity) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is full!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstackPtr[stackSize++] = inData;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出栈，如果栈为空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::Pop()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t--stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断栈是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> Stack&lt;DataType&gt;::isEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackSize &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Stack&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstackSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回栈顶元素，如果出错则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType Stack&lt;DataType&gt;::Top()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stackSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Stack is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackPtr[stackSize<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回栈大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Stack&lt;DataType&gt;::StackSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stackSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，清空栈</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Stack&lt;DataType&gt;::~Stack()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] stackPtr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>基本的算法测试和异常捕捉代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tStack&lt;<span class=\"keyword\">char</span>&gt; TestStack; <span class=\"comment\">/*不同实现*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tTestStack.Push(<span class=\"string\">'A'</span>+i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; TestStack.Top() &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">\t\t\tTestStack.Po0p();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *msg) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; msg &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n"},{"title":"数据结构之树基础","urlname":"tree-foundation","date":"2018-03-05T11:09:34.000Z","mathjax":true,"copyright":true,"_content":"\n## 树的递归定义\n\n树由于其结构特点，一般采用递归定义的方式，其定义方式如下：\n\n- 一棵树是一些节点的集合\n- 集合可以为空集；若非空则称一棵树由称为根的节点以及 0 个或多个非空的互不相交的子树$T_1,T_2,....T_k$组成\n- 子树中每一棵的根都被来自根 $r$ 的一条有向边所连接\n\n## 树相关概念\n\n- 树叶\n\n没有儿子的节点称为树叶\n\n- 路径\n\n节点 $n_1$ 到 $n_k$ 的路径定义为节点 $n_1,n_2....n_k$ 的一个序列，使得节点 $n_i$ 是 $n_{i+1}$ 的父节点，路径长为该路径上边的长，即 $k-1$。\n\n- 深度\n\n对于任意节点 $n_i$， $n_i$ 的深度为从根到 $n_i$ 唯一路径的长。\n\n- 内部路径长\n\n一棵树所有节点的深度的称为内部路径长\n\n- 树的高\n\n$n_i$ 的高为 $n_i$ 到一片树叶最长的路径长\n\n- 节点的度\n\n节点所拥有的子树的个数称为该节点的度。\n\n- 树的度\n\n节点的度中最大值被称为树的度\n\n- 森林\n\n零棵或者有限棵不相交的树的集合称为森林\n\n- 兄弟节点\n\n具有相同父节点的节点互称为兄弟节点\n\n## 树的实现\n\n由于树子节点的个数是不确定的，因此通过保存每个子节点的指针是非常不合理的。目前树的存储结构大致存在以下几种。\n\n- 父节点表示法\n\n由于除了根没有父节点以外，所有节点有且只有一个父节点，通过存储父节点信息的数据域来表示树即是父节点表示法的基本思路，数据结构如下：\n\n```cpp\ntemplate <typename DataType, typename PositionType>\nstruct TreeNode\n{\n\tDataType data; //数据\n\tPositionType parent; //父节点位置\n};\n```\n\n- 孩子表示法\n\n父节点表示法中子节点可以快速找到自己的父节点，但是父节点难以查找自己的子节点，因此孩子表示法的思路是存储子节点的位置信息，数据结构如下：\n\n```cpp\ntemplate <typename DataType, typename PositionType>\nstruct TreeNode\n{\n\tDataType data; //数据\n\tlist<PositionType> child; //保存所有子节点位置\n};\n```\n\n- 双亲孩子表示法\n\n孩子表示法虽然解决了查找子节点的问题，但是子节点查找父节点又变得困难，因此可以结合父节点表示法和孩子表示法的优点，由此有双亲孩子表示法，数据结构如下：\n\n```cpp\ntemplate <typename DataType, typename PositionType>\nstruct TreeNode\n{\n\tDataType data; //数据\n\tPositionType parent; //父节点位置\n\tlist<PositionType> child; //保存所有子节点位置\n};\n```\n\n- 孩子兄弟表示法（又称树的二叉链表实现方式）\n\n根据树的定义，树确定以后，从左到右的子节点顺序也确定下来了，也就是父节点第一个子节点也确定了，而每个子节点最接近的右兄弟节点也确定下来了，由此引出孩子兄弟表示法，基本数据结构如下所示：\n\n```cpp\ntemplate <typename DataType, typename PositionType>\nstruct TreeNode\n{\n\tDataType data; //数据\n\tPositionType firstChild; //第一个子节点\n\tPositionType nextSibling; //当前节点最近右兄弟节点\n};\n```\n\n## 二叉树基础\n\n- 二叉树具有五种基本的形态\n\n由于二叉树分为左右子树，因此有五种基本形态：1）空树，2）仅含有根节点，3）右子树为空，4）左子树为空，5）左右子树非空。如下示意图所示：[图片来源](https://book.douban.com/subject/2024655/)\n\n![二叉树五种形态](/images/binary-tree-five-shape.png)\n\n- 二叉树第 $i(i>=1)$ 层至多有 $2^{i-1}$ 个节点\n\n由于每个节点可以有两个子节点，故下一层节点数目最多是上一层的两倍，从根节点往前递推便可得到该值。\n\n- 深度为 $k(k>=1)$ 的二叉树最多含有 $2^k-1$ 个节点\n\n由每层最多含有的节点数可有 $\\sum_{i=1}^{k}2^{i-1}=2^k-1$。等比数列求和\n\n- 任意一棵二叉树，如果含有 $n_0$ 个叶子节点以及 $n_2$ 个度为2的节点，则有 $n_0=n_2+1$\n\n由于二叉树总结点数n等于树中边数量+1，则假设度为1的节点数量为 $n_1$，则有如下关系：$n=n_0+n_1+n_2=2n_2+n_1+1$，可得出如上结论。\n\n- 满二叉树\n\n一棵深度为 $k(k>=1)$ 的二叉树且有 $2^k-1$ 个节点，则称为满二叉树。\n\n- 完全二叉树\n\n完全二叉树的定义需要借助于满二叉树：假设对满二叉树按照从上至下、从左到右的顺序进行编号，则对于一颗深度为 $k(k>=1)$ 和节点数为 $n$ 的二叉树，当且仅当每一个节点都与深度为 $k(k>=1)$  满二叉树编号一一对应则称为完全二叉树。可以认为完全二叉树是指将满二叉树从最底层从右到左删除节点形成的一棵二叉树，其叶节点只会出现在倒数一、二层。完全二叉树可以使用顺序存储的方式，其双亲结点和子节点下标具有固定的关系。\n\n- 具有 $n$ 个节点的完全二叉树深度为 $\\lfloor log_2n \\rfloor + 1$。\n\n假设完全二叉树的深度为 $k$，则根据深度节点数量关系有 $2^{k-1}-1<n<=2^{k}-1$，化简可得。\n\n\n\n## 树的种类\n\n- 无序树：树中任意节点的子节点之间没有顺序关系\n\n- 有序树：树中任意节点的子节点之间有顺序关系，有序树可分为：\n    - 二叉树\n        - 完全二叉树\n\t\t- 平衡二叉树（AVL树、红黑树、伸展树、Treap、加权平衡树、AA树、替罪羊树、节点大小平衡树）\n\t\t- 排序二叉树（二叉查找树）\n\t- 霍夫曼树\n\t- 平衡树\n\t\t- 2-3树\n\t- B树\n\t\t- B树\n\t\t- B<sup>+</sup>树\n\t\t- B<sup>\\*</sup>树\n\t- Trie树\n\n## 树的遍历\n\n树的遍历方式有多种，按照处理节点的顺序可以分为如下几种\n\n- 先序遍历（又称为前序遍历、先根遍历）\n\n在先序遍历中，对节点的处理是在处理子节点之前处理的。\n\n- 后序遍历（又称为后根遍历）\n\n在后序遍历中，对节点的处理是在处理子节点之后处理的。\n\n- 中序遍历（又称为中根遍历）\n\n中序遍历一般是二叉树中的概念，中序遍历的节点处理顺序是先处理左子节点，然后处理本节点，最后处理右子节点。\n\n- 层序遍历（BFS）\n\n层序遍历是指从根开始，每次依次从左到右处理该层节点。\n\n先序遍历、后序遍历、中序遍历均属于深度优先遍历，层序遍历属于广度优先遍历。\n\n\n## 参考资料\n\n[数据结构中各种树](http://www.cnblogs.com/maybe2030/p/4732377.html)\n\n[数据结构](https://book.douban.com/subject/2024655/)\n","source":"_posts/数据结构/数据结构之树基础.md","raw":"---\ntitle: 数据结构之树基础\nurlname: tree-foundation\ndate: 2018-03-5 19:09:34\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 树的递归定义\n\n树由于其结构特点，一般采用递归定义的方式，其定义方式如下：\n\n- 一棵树是一些节点的集合\n- 集合可以为空集；若非空则称一棵树由称为根的节点以及 0 个或多个非空的互不相交的子树$T_1,T_2,....T_k$组成\n- 子树中每一棵的根都被来自根 $r$ 的一条有向边所连接\n\n## 树相关概念\n\n- 树叶\n\n没有儿子的节点称为树叶\n\n- 路径\n\n节点 $n_1$ 到 $n_k$ 的路径定义为节点 $n_1,n_2....n_k$ 的一个序列，使得节点 $n_i$ 是 $n_{i+1}$ 的父节点，路径长为该路径上边的长，即 $k-1$。\n\n- 深度\n\n对于任意节点 $n_i$， $n_i$ 的深度为从根到 $n_i$ 唯一路径的长。\n\n- 内部路径长\n\n一棵树所有节点的深度的称为内部路径长\n\n- 树的高\n\n$n_i$ 的高为 $n_i$ 到一片树叶最长的路径长\n\n- 节点的度\n\n节点所拥有的子树的个数称为该节点的度。\n\n- 树的度\n\n节点的度中最大值被称为树的度\n\n- 森林\n\n零棵或者有限棵不相交的树的集合称为森林\n\n- 兄弟节点\n\n具有相同父节点的节点互称为兄弟节点\n\n## 树的实现\n\n由于树子节点的个数是不确定的，因此通过保存每个子节点的指针是非常不合理的。目前树的存储结构大致存在以下几种。\n\n- 父节点表示法\n\n由于除了根没有父节点以外，所有节点有且只有一个父节点，通过存储父节点信息的数据域来表示树即是父节点表示法的基本思路，数据结构如下：\n\n```cpp\ntemplate <typename DataType, typename PositionType>\nstruct TreeNode\n{\n\tDataType data; //数据\n\tPositionType parent; //父节点位置\n};\n```\n\n- 孩子表示法\n\n父节点表示法中子节点可以快速找到自己的父节点，但是父节点难以查找自己的子节点，因此孩子表示法的思路是存储子节点的位置信息，数据结构如下：\n\n```cpp\ntemplate <typename DataType, typename PositionType>\nstruct TreeNode\n{\n\tDataType data; //数据\n\tlist<PositionType> child; //保存所有子节点位置\n};\n```\n\n- 双亲孩子表示法\n\n孩子表示法虽然解决了查找子节点的问题，但是子节点查找父节点又变得困难，因此可以结合父节点表示法和孩子表示法的优点，由此有双亲孩子表示法，数据结构如下：\n\n```cpp\ntemplate <typename DataType, typename PositionType>\nstruct TreeNode\n{\n\tDataType data; //数据\n\tPositionType parent; //父节点位置\n\tlist<PositionType> child; //保存所有子节点位置\n};\n```\n\n- 孩子兄弟表示法（又称树的二叉链表实现方式）\n\n根据树的定义，树确定以后，从左到右的子节点顺序也确定下来了，也就是父节点第一个子节点也确定了，而每个子节点最接近的右兄弟节点也确定下来了，由此引出孩子兄弟表示法，基本数据结构如下所示：\n\n```cpp\ntemplate <typename DataType, typename PositionType>\nstruct TreeNode\n{\n\tDataType data; //数据\n\tPositionType firstChild; //第一个子节点\n\tPositionType nextSibling; //当前节点最近右兄弟节点\n};\n```\n\n## 二叉树基础\n\n- 二叉树具有五种基本的形态\n\n由于二叉树分为左右子树，因此有五种基本形态：1）空树，2）仅含有根节点，3）右子树为空，4）左子树为空，5）左右子树非空。如下示意图所示：[图片来源](https://book.douban.com/subject/2024655/)\n\n![二叉树五种形态](/images/binary-tree-five-shape.png)\n\n- 二叉树第 $i(i>=1)$ 层至多有 $2^{i-1}$ 个节点\n\n由于每个节点可以有两个子节点，故下一层节点数目最多是上一层的两倍，从根节点往前递推便可得到该值。\n\n- 深度为 $k(k>=1)$ 的二叉树最多含有 $2^k-1$ 个节点\n\n由每层最多含有的节点数可有 $\\sum_{i=1}^{k}2^{i-1}=2^k-1$。等比数列求和\n\n- 任意一棵二叉树，如果含有 $n_0$ 个叶子节点以及 $n_2$ 个度为2的节点，则有 $n_0=n_2+1$\n\n由于二叉树总结点数n等于树中边数量+1，则假设度为1的节点数量为 $n_1$，则有如下关系：$n=n_0+n_1+n_2=2n_2+n_1+1$，可得出如上结论。\n\n- 满二叉树\n\n一棵深度为 $k(k>=1)$ 的二叉树且有 $2^k-1$ 个节点，则称为满二叉树。\n\n- 完全二叉树\n\n完全二叉树的定义需要借助于满二叉树：假设对满二叉树按照从上至下、从左到右的顺序进行编号，则对于一颗深度为 $k(k>=1)$ 和节点数为 $n$ 的二叉树，当且仅当每一个节点都与深度为 $k(k>=1)$  满二叉树编号一一对应则称为完全二叉树。可以认为完全二叉树是指将满二叉树从最底层从右到左删除节点形成的一棵二叉树，其叶节点只会出现在倒数一、二层。完全二叉树可以使用顺序存储的方式，其双亲结点和子节点下标具有固定的关系。\n\n- 具有 $n$ 个节点的完全二叉树深度为 $\\lfloor log_2n \\rfloor + 1$。\n\n假设完全二叉树的深度为 $k$，则根据深度节点数量关系有 $2^{k-1}-1<n<=2^{k}-1$，化简可得。\n\n\n\n## 树的种类\n\n- 无序树：树中任意节点的子节点之间没有顺序关系\n\n- 有序树：树中任意节点的子节点之间有顺序关系，有序树可分为：\n    - 二叉树\n        - 完全二叉树\n\t\t- 平衡二叉树（AVL树、红黑树、伸展树、Treap、加权平衡树、AA树、替罪羊树、节点大小平衡树）\n\t\t- 排序二叉树（二叉查找树）\n\t- 霍夫曼树\n\t- 平衡树\n\t\t- 2-3树\n\t- B树\n\t\t- B树\n\t\t- B<sup>+</sup>树\n\t\t- B<sup>\\*</sup>树\n\t- Trie树\n\n## 树的遍历\n\n树的遍历方式有多种，按照处理节点的顺序可以分为如下几种\n\n- 先序遍历（又称为前序遍历、先根遍历）\n\n在先序遍历中，对节点的处理是在处理子节点之前处理的。\n\n- 后序遍历（又称为后根遍历）\n\n在后序遍历中，对节点的处理是在处理子节点之后处理的。\n\n- 中序遍历（又称为中根遍历）\n\n中序遍历一般是二叉树中的概念，中序遍历的节点处理顺序是先处理左子节点，然后处理本节点，最后处理右子节点。\n\n- 层序遍历（BFS）\n\n层序遍历是指从根开始，每次依次从左到右处理该层节点。\n\n先序遍历、后序遍历、中序遍历均属于深度优先遍历，层序遍历属于广度优先遍历。\n\n\n## 参考资料\n\n[数据结构中各种树](http://www.cnblogs.com/maybe2030/p/4732377.html)\n\n[数据结构](https://book.douban.com/subject/2024655/)\n","slug":"数据结构/数据结构之树基础","published":1,"updated":"2018-06-24T09:43:23.500Z","_id":"cjida4x3u001rgsvnud5blpu2","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"树的递归定义\"><a href=\"#树的递归定义\" class=\"headerlink\" title=\"树的递归定义\"></a>树的递归定义</h2><p>树由于其结构特点，一般采用递归定义的方式，其定义方式如下：</p>\n<ul>\n<li>一棵树是一些节点的集合</li>\n<li>集合可以为空集；若非空则称一棵树由称为根的节点以及 0 个或多个非空的互不相交的子树$T_1,T_2,….T_k$组成</li>\n<li>子树中每一棵的根都被来自根 $r$ 的一条有向边所连接</li>\n</ul>\n<h2 id=\"树相关概念\"><a href=\"#树相关概念\" class=\"headerlink\" title=\"树相关概念\"></a>树相关概念</h2><ul>\n<li>树叶</li>\n</ul>\n<p>没有儿子的节点称为树叶</p>\n<ul>\n<li>路径</li>\n</ul>\n<p>节点 $n_1$ 到 $n_k$ 的路径定义为节点 $n_1,n_2….n_k$ 的一个序列，使得节点 $n_i$ 是 $n_{i+1}$ 的父节点，路径长为该路径上边的长，即 $k-1$。</p>\n<ul>\n<li>深度</li>\n</ul>\n<p>对于任意节点 $n_i$， $n_i$ 的深度为从根到 $n_i$ 唯一路径的长。</p>\n<ul>\n<li>内部路径长</li>\n</ul>\n<p>一棵树所有节点的深度的称为内部路径长</p>\n<ul>\n<li>树的高</li>\n</ul>\n<p>$n_i$ 的高为 $n_i$ 到一片树叶最长的路径长</p>\n<ul>\n<li>节点的度</li>\n</ul>\n<p>节点所拥有的子树的个数称为该节点的度。</p>\n<ul>\n<li>树的度</li>\n</ul>\n<p>节点的度中最大值被称为树的度</p>\n<ul>\n<li>森林</li>\n</ul>\n<p>零棵或者有限棵不相交的树的集合称为森林</p>\n<ul>\n<li>兄弟节点</li>\n</ul>\n<p>具有相同父节点的节点互称为兄弟节点</p>\n<h2 id=\"树的实现\"><a href=\"#树的实现\" class=\"headerlink\" title=\"树的实现\"></a>树的实现</h2><p>由于树子节点的个数是不确定的，因此通过保存每个子节点的指针是非常不合理的。目前树的存储结构大致存在以下几种。</p>\n<ul>\n<li>父节点表示法</li>\n</ul>\n<p>由于除了根没有父节点以外，所有节点有且只有一个父节点，通过存储父节点信息的数据域来表示树即是父节点表示法的基本思路，数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType, <span class=\"keyword\">typename</span> PositionType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\tPositionType parent; <span class=\"comment\">//父节点位置</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>孩子表示法</li>\n</ul>\n<p>父节点表示法中子节点可以快速找到自己的父节点，但是父节点难以查找自己的子节点，因此孩子表示法的思路是存储子节点的位置信息，数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType, <span class=\"keyword\">typename</span> PositionType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\t<span class=\"built_in\">list</span>&lt;PositionType&gt; child; <span class=\"comment\">//保存所有子节点位置</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双亲孩子表示法</li>\n</ul>\n<p>孩子表示法虽然解决了查找子节点的问题，但是子节点查找父节点又变得困难，因此可以结合父节点表示法和孩子表示法的优点，由此有双亲孩子表示法，数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType, <span class=\"keyword\">typename</span> PositionType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\tPositionType parent; <span class=\"comment\">//父节点位置</span></span><br><span class=\"line\">\t<span class=\"built_in\">list</span>&lt;PositionType&gt; child; <span class=\"comment\">//保存所有子节点位置</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>孩子兄弟表示法（又称树的二叉链表实现方式）</li>\n</ul>\n<p>根据树的定义，树确定以后，从左到右的子节点顺序也确定下来了，也就是父节点第一个子节点也确定了，而每个子节点最接近的右兄弟节点也确定下来了，由此引出孩子兄弟表示法，基本数据结构如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType, <span class=\"keyword\">typename</span> PositionType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\tPositionType firstChild; <span class=\"comment\">//第一个子节点</span></span><br><span class=\"line\">\tPositionType nextSibling; <span class=\"comment\">//当前节点最近右兄弟节点</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树基础\"><a href=\"#二叉树基础\" class=\"headerlink\" title=\"二叉树基础\"></a>二叉树基础</h2><ul>\n<li>二叉树具有五种基本的形态</li>\n</ul>\n<p>由于二叉树分为左右子树，因此有五种基本形态：1）空树，2）仅含有根节点，3）右子树为空，4）左子树为空，5）左右子树非空。如下示意图所示：<a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binary-tree-five-shape.png\" alt=\"二叉树五种形态\"></p>\n<ul>\n<li>二叉树第 $i(i&gt;=1)$ 层至多有 $2^{i-1}$ 个节点</li>\n</ul>\n<p>由于每个节点可以有两个子节点，故下一层节点数目最多是上一层的两倍，从根节点往前递推便可得到该值。</p>\n<ul>\n<li>深度为 $k(k&gt;=1)$ 的二叉树最多含有 $2^k-1$ 个节点</li>\n</ul>\n<p>由每层最多含有的节点数可有 $\\sum_{i=1}^{k}2^{i-1}=2^k-1$。等比数列求和</p>\n<ul>\n<li>任意一棵二叉树，如果含有 $n_0$ 个叶子节点以及 $n_2$ 个度为2的节点，则有 $n_0=n_2+1$</li>\n</ul>\n<p>由于二叉树总结点数n等于树中边数量+1，则假设度为1的节点数量为 $n_1$，则有如下关系：$n=n_0+n_1+n_2=2n_2+n_1+1$，可得出如上结论。</p>\n<ul>\n<li>满二叉树</li>\n</ul>\n<p>一棵深度为 $k(k&gt;=1)$ 的二叉树且有 $2^k-1$ 个节点，则称为满二叉树。</p>\n<ul>\n<li>完全二叉树</li>\n</ul>\n<p>完全二叉树的定义需要借助于满二叉树：假设对满二叉树按照从上至下、从左到右的顺序进行编号，则对于一颗深度为 $k(k&gt;=1)$ 和节点数为 $n$ 的二叉树，当且仅当每一个节点都与深度为 $k(k&gt;=1)$  满二叉树编号一一对应则称为完全二叉树。可以认为完全二叉树是指将满二叉树从最底层从右到左删除节点形成的一棵二叉树，其叶节点只会出现在倒数一、二层。完全二叉树可以使用顺序存储的方式，其双亲结点和子节点下标具有固定的关系。</p>\n<ul>\n<li>具有 $n$ 个节点的完全二叉树深度为 $\\lfloor log_2n \\rfloor + 1$。</li>\n</ul>\n<p>假设完全二叉树的深度为 $k$，则根据深度节点数量关系有 $2^{k-1}-1&lt;n&lt;=2^{k}-1$，化简可得。</p>\n<h2 id=\"树的种类\"><a href=\"#树的种类\" class=\"headerlink\" title=\"树的种类\"></a>树的种类</h2><ul>\n<li><p>无序树：树中任意节点的子节点之间没有顺序关系</p>\n</li>\n<li><p>有序树：树中任意节点的子节点之间有顺序关系，有序树可分为：</p>\n<ul>\n<li>二叉树<ul>\n<li>完全二叉树</li>\n<li>平衡二叉树（AVL树、红黑树、伸展树、Treap、加权平衡树、AA树、替罪羊树、节点大小平衡树）</li>\n<li>排序二叉树（二叉查找树）</li>\n</ul>\n</li>\n<li>霍夫曼树</li>\n<li>平衡树<ul>\n<li>2-3树</li>\n</ul>\n</li>\n<li>B树<ul>\n<li>B树</li>\n<li>B<sup>+</sup>树</li>\n<li>B<sup>*</sup>树</li>\n</ul>\n</li>\n<li>Trie树</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h2><p>树的遍历方式有多种，按照处理节点的顺序可以分为如下几种</p>\n<ul>\n<li>先序遍历（又称为前序遍历、先根遍历）</li>\n</ul>\n<p>在先序遍历中，对节点的处理是在处理子节点之前处理的。</p>\n<ul>\n<li>后序遍历（又称为后根遍历）</li>\n</ul>\n<p>在后序遍历中，对节点的处理是在处理子节点之后处理的。</p>\n<ul>\n<li>中序遍历（又称为中根遍历）</li>\n</ul>\n<p>中序遍历一般是二叉树中的概念，中序遍历的节点处理顺序是先处理左子节点，然后处理本节点，最后处理右子节点。</p>\n<ul>\n<li>层序遍历（BFS）</li>\n</ul>\n<p>层序遍历是指从根开始，每次依次从左到右处理该层节点。</p>\n<p>先序遍历、后序遍历、中序遍历均属于深度优先遍历，层序遍历属于广度优先遍历。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.cnblogs.com/maybe2030/p/4732377.html\" target=\"_blank\" rel=\"noopener\">数据结构中各种树</a></p>\n<p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"树的递归定义\"><a href=\"#树的递归定义\" class=\"headerlink\" title=\"树的递归定义\"></a>树的递归定义</h2><p>树由于其结构特点，一般采用递归定义的方式，其定义方式如下：</p>\n<ul>\n<li>一棵树是一些节点的集合</li>\n<li>集合可以为空集；若非空则称一棵树由称为根的节点以及 0 个或多个非空的互不相交的子树$T_1,T_2,….T_k$组成</li>\n<li>子树中每一棵的根都被来自根 $r$ 的一条有向边所连接</li>\n</ul>\n<h2 id=\"树相关概念\"><a href=\"#树相关概念\" class=\"headerlink\" title=\"树相关概念\"></a>树相关概念</h2><ul>\n<li>树叶</li>\n</ul>\n<p>没有儿子的节点称为树叶</p>\n<ul>\n<li>路径</li>\n</ul>\n<p>节点 $n_1$ 到 $n_k$ 的路径定义为节点 $n_1,n_2….n_k$ 的一个序列，使得节点 $n_i$ 是 $n_{i+1}$ 的父节点，路径长为该路径上边的长，即 $k-1$。</p>\n<ul>\n<li>深度</li>\n</ul>\n<p>对于任意节点 $n_i$， $n_i$ 的深度为从根到 $n_i$ 唯一路径的长。</p>\n<ul>\n<li>内部路径长</li>\n</ul>\n<p>一棵树所有节点的深度的称为内部路径长</p>\n<ul>\n<li>树的高</li>\n</ul>\n<p>$n_i$ 的高为 $n_i$ 到一片树叶最长的路径长</p>\n<ul>\n<li>节点的度</li>\n</ul>\n<p>节点所拥有的子树的个数称为该节点的度。</p>\n<ul>\n<li>树的度</li>\n</ul>\n<p>节点的度中最大值被称为树的度</p>\n<ul>\n<li>森林</li>\n</ul>\n<p>零棵或者有限棵不相交的树的集合称为森林</p>\n<ul>\n<li>兄弟节点</li>\n</ul>\n<p>具有相同父节点的节点互称为兄弟节点</p>\n<h2 id=\"树的实现\"><a href=\"#树的实现\" class=\"headerlink\" title=\"树的实现\"></a>树的实现</h2><p>由于树子节点的个数是不确定的，因此通过保存每个子节点的指针是非常不合理的。目前树的存储结构大致存在以下几种。</p>\n<ul>\n<li>父节点表示法</li>\n</ul>\n<p>由于除了根没有父节点以外，所有节点有且只有一个父节点，通过存储父节点信息的数据域来表示树即是父节点表示法的基本思路，数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType, <span class=\"keyword\">typename</span> PositionType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\tPositionType parent; <span class=\"comment\">//父节点位置</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>孩子表示法</li>\n</ul>\n<p>父节点表示法中子节点可以快速找到自己的父节点，但是父节点难以查找自己的子节点，因此孩子表示法的思路是存储子节点的位置信息，数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType, <span class=\"keyword\">typename</span> PositionType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\t<span class=\"built_in\">list</span>&lt;PositionType&gt; child; <span class=\"comment\">//保存所有子节点位置</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双亲孩子表示法</li>\n</ul>\n<p>孩子表示法虽然解决了查找子节点的问题，但是子节点查找父节点又变得困难，因此可以结合父节点表示法和孩子表示法的优点，由此有双亲孩子表示法，数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType, <span class=\"keyword\">typename</span> PositionType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\tPositionType parent; <span class=\"comment\">//父节点位置</span></span><br><span class=\"line\">\t<span class=\"built_in\">list</span>&lt;PositionType&gt; child; <span class=\"comment\">//保存所有子节点位置</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>孩子兄弟表示法（又称树的二叉链表实现方式）</li>\n</ul>\n<p>根据树的定义，树确定以后，从左到右的子节点顺序也确定下来了，也就是父节点第一个子节点也确定了，而每个子节点最接近的右兄弟节点也确定下来了，由此引出孩子兄弟表示法，基本数据结构如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType, <span class=\"keyword\">typename</span> PositionType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data; <span class=\"comment\">//数据</span></span><br><span class=\"line\">\tPositionType firstChild; <span class=\"comment\">//第一个子节点</span></span><br><span class=\"line\">\tPositionType nextSibling; <span class=\"comment\">//当前节点最近右兄弟节点</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树基础\"><a href=\"#二叉树基础\" class=\"headerlink\" title=\"二叉树基础\"></a>二叉树基础</h2><ul>\n<li>二叉树具有五种基本的形态</li>\n</ul>\n<p>由于二叉树分为左右子树，因此有五种基本形态：1）空树，2）仅含有根节点，3）右子树为空，4）左子树为空，5）左右子树非空。如下示意图所示：<a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/binary-tree-five-shape.png\" alt=\"二叉树五种形态\"></p>\n<ul>\n<li>二叉树第 $i(i&gt;=1)$ 层至多有 $2^{i-1}$ 个节点</li>\n</ul>\n<p>由于每个节点可以有两个子节点，故下一层节点数目最多是上一层的两倍，从根节点往前递推便可得到该值。</p>\n<ul>\n<li>深度为 $k(k&gt;=1)$ 的二叉树最多含有 $2^k-1$ 个节点</li>\n</ul>\n<p>由每层最多含有的节点数可有 $\\sum_{i=1}^{k}2^{i-1}=2^k-1$。等比数列求和</p>\n<ul>\n<li>任意一棵二叉树，如果含有 $n_0$ 个叶子节点以及 $n_2$ 个度为2的节点，则有 $n_0=n_2+1$</li>\n</ul>\n<p>由于二叉树总结点数n等于树中边数量+1，则假设度为1的节点数量为 $n_1$，则有如下关系：$n=n_0+n_1+n_2=2n_2+n_1+1$，可得出如上结论。</p>\n<ul>\n<li>满二叉树</li>\n</ul>\n<p>一棵深度为 $k(k&gt;=1)$ 的二叉树且有 $2^k-1$ 个节点，则称为满二叉树。</p>\n<ul>\n<li>完全二叉树</li>\n</ul>\n<p>完全二叉树的定义需要借助于满二叉树：假设对满二叉树按照从上至下、从左到右的顺序进行编号，则对于一颗深度为 $k(k&gt;=1)$ 和节点数为 $n$ 的二叉树，当且仅当每一个节点都与深度为 $k(k&gt;=1)$  满二叉树编号一一对应则称为完全二叉树。可以认为完全二叉树是指将满二叉树从最底层从右到左删除节点形成的一棵二叉树，其叶节点只会出现在倒数一、二层。完全二叉树可以使用顺序存储的方式，其双亲结点和子节点下标具有固定的关系。</p>\n<ul>\n<li>具有 $n$ 个节点的完全二叉树深度为 $\\lfloor log_2n \\rfloor + 1$。</li>\n</ul>\n<p>假设完全二叉树的深度为 $k$，则根据深度节点数量关系有 $2^{k-1}-1&lt;n&lt;=2^{k}-1$，化简可得。</p>\n<h2 id=\"树的种类\"><a href=\"#树的种类\" class=\"headerlink\" title=\"树的种类\"></a>树的种类</h2><ul>\n<li><p>无序树：树中任意节点的子节点之间没有顺序关系</p>\n</li>\n<li><p>有序树：树中任意节点的子节点之间有顺序关系，有序树可分为：</p>\n<ul>\n<li>二叉树<ul>\n<li>完全二叉树</li>\n<li>平衡二叉树（AVL树、红黑树、伸展树、Treap、加权平衡树、AA树、替罪羊树、节点大小平衡树）</li>\n<li>排序二叉树（二叉查找树）</li>\n</ul>\n</li>\n<li>霍夫曼树</li>\n<li>平衡树<ul>\n<li>2-3树</li>\n</ul>\n</li>\n<li>B树<ul>\n<li>B树</li>\n<li>B<sup>+</sup>树</li>\n<li>B<sup>*</sup>树</li>\n</ul>\n</li>\n<li>Trie树</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h2><p>树的遍历方式有多种，按照处理节点的顺序可以分为如下几种</p>\n<ul>\n<li>先序遍历（又称为前序遍历、先根遍历）</li>\n</ul>\n<p>在先序遍历中，对节点的处理是在处理子节点之前处理的。</p>\n<ul>\n<li>后序遍历（又称为后根遍历）</li>\n</ul>\n<p>在后序遍历中，对节点的处理是在处理子节点之后处理的。</p>\n<ul>\n<li>中序遍历（又称为中根遍历）</li>\n</ul>\n<p>中序遍历一般是二叉树中的概念，中序遍历的节点处理顺序是先处理左子节点，然后处理本节点，最后处理右子节点。</p>\n<ul>\n<li>层序遍历（BFS）</li>\n</ul>\n<p>层序遍历是指从根开始，每次依次从左到右处理该层节点。</p>\n<p>先序遍历、后序遍历、中序遍历均属于深度优先遍历，层序遍历属于广度优先遍历。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.cnblogs.com/maybe2030/p/4732377.html\" target=\"_blank\" rel=\"noopener\">数据结构中各种树</a></p>\n<p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n"},{"title":"数据结构之队列的定义与实现","urlname":"queue","date":"2018-03-05T05:34:10.000Z","mathjax":true,"copyright":true,"_content":"\n## 队列基础知识\n\n和栈类似，队列也是一种线性表，不过队列是在一端插入在另外一端删除。插入的一端称为队尾，删除的一端称为队头。队列的基本操作是入队和出队。由于队列的插入删除特性，因此队列具有“先进先出(FIFO)”的特点。同理，使用顺序表实现的队列称为顺序队列，使用链表实现的队列称为链式队列。队列采用数组实现时一般需要实现为循环数组，故一般也称为循环队列。队列实现中一般有如下操作：\n\n- 入队：Enqueue\n- 出队：Dequeue\n- 判断是否为空：IsEmpty\n- 清空队列：MakeEmpty\n- 读取队首元素：Front\n\n## 队列的链表实现\n\n在采用链表实现队列时，由于队列是“先进先出”的，因此可以尝试使用尾插法同时从头部删除的方式实现队列“先进先出”的特点。在STL中queue的实现中，其底层采用的是deque，和栈类似，list也可实现队列。\n\n仿照《数据结构与算法分析-C语言描述》的定义，队列可定义如下：\n\n```cpp\ntemplate <typename DataType>\nclass Node\n{\npublic:\n\tNode(DataType inData):data(inData),next(nullptr) {}\npublic:\n\tDataType data;\n\tNode *next;\n};\n\n\ntemplate <typename DataType>\nclass Queue\n{\npublic:\n\tQueue():dummyNode(-1), queueSize(0), lastNode(nullptr) {}\n\t~Queue();\n\tvoid Enqueue(DataType inData); //入队\n\tvoid Dequeue(); //出队\n\tDataType Front(); //读取队首元素，队空则抛出异常\n\tbool IsEmpty(); //判断队列是否为空\n\tvoid MakeEmpty(); //清空队列\n\tint QueueSize(); //返回队列大小\nprivate:\n\tNode<DataType> dummyNode;\n\tint queueSize;\n\tNode<DataType> *lastNode;\n};\n```\n\n如上所示，队列的数据成员有哑节点、队列大小以及一个指链表尾端的指针。如下依次实现各个操作\n\n- 入队操作，采用尾插法\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::Enqueue(DataType inData)\n{\n\tif (queueSize <= 0 || lastNode == nullptr) {\n\t\tlastNode = &dummyNode;\n\t}\n\tlastNode->next = new Node<DataType>(inData);\n\tlastNode = lastNode->next; ++queueSize;\n}\n```\n\n- 出队操作，不断删除链表第一个元素，队空抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::Dequeue()\n{\n\tif (queueSize <= 0 || dummyNode.next == nullptr) {\n\t\tthrow \"Queue is empty!\";\n\t}\n\tNode<DataType> *tmp = dummyNode.next; /*删除头部*/\n\tdummyNode.next = dummyNode.next->next;\n\tdelete tmp; --queueSize;\n}\n```\n\n- 读取队首元素，队空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType Queue<DataType>::Front()\n{\n\tif (queueSize <= 0 || dummyNode.next == nullptr) {\n\t\tthrow \"Queue is empty!\";\n\t}\n\treturn dummyNode.next->data;\n}\n```\n\n- 判断队列是否为空\n\n```cpp\ntemplate <typename DataType>\nbool Queue<DataType>::IsEmpty()\n{\n\treturn queueSize <= 0 || dummyNode.next == nullptr;\n}\n```\n\n- 清空队列，也可以直接通过调用Dequeue函数实现\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::MakeEmpty()\n{\n\tNode<DataType> *tmp = dummyNode.next;\n\t/*循环删除头部*/\n\twhile (tmp != nullptr) {\n\t\tdummyNode.next = tmp->next;\n\t\tdelete tmp; --queueSize;\n\t\ttmp = dummyNode.next;\n\t}\n}\n```\n\n- 返回队列大小\n\n```cpp\ntemplate <typename DataType>\nint Queue<DataType>::QueueSize()\n{\n\treturn queueSize;\n}\n```\n\n- 析构函数，直接调用MakeEmpty函数实现\n\n```cpp\ntemplate <typename DataType>\nQueue<DataType>::~Queue()\n{\n\tMakeEmpty();\n}\n```\n\n## 队列的循环数组实现\n\n在使用数组实现队列时，由于队列是在一端插入，另外一端删除，因此队列和栈不同的是需要两个指针分别指向队首和队尾，同时需要采用循环数组的实现方式，循环数组意味着在物理结构上队首、队尾标记可能不遵循前后的位置关系。采用循环数组实现队列的基本ADT定义如下：\n\n```cpp\ntemplate <typename DataType>\nclass Queue\n{\npublic:\n\tQueue(int inQueueCapacity);\n\t~Queue(); //析构函数，回收内存\n\tvoid Enqueue(DataType inData); //入队，堆满则抛出异常\n\tvoid Dequeue(); //出队，队空则抛出异常\n\tDataType Front(); //读取队首元素，队空则抛出异常\n\tbool IsEmpty(); //判断队列是否为空\n\tvoid MakeEmpty(); //清空队列\n\tint QueueSize(); //返回队列大小\nprivate:\n\tint queueCapacity;\n\tDataType *queuePtr; /*动态申请*/\n\tint front, rear; /*分别指向队首、队尾*/\n\tint queueSize;\n};\n```\n\n如上所示为队列的循环数组实现的基本数据结构定义。queueCapacity保存队列的容量，queuePtr为队列的空间起始地址，front、rear分别用来指示队首、队尾位置，queueSize表示当前队列的大小。在计算front、rear时由于需要考虑绕回的情况，因此其不能直接加1，应该加1后再对容量取模。在我的是实现版本中，front==rear的情况可能是队空或者队满，因此在判断队空或者队满的时候不能简单判断两者是否相等。以下为各函数具体实现。\n\n- 构造函数的实现，分配内存，初始化数据成员\n\n```cpp\ntemplate <typename DataType>\nQueue<DataType>::Queue(int inQueueCapacity): queueCapacity(inQueueCapacity),\n\t\t\t\tfront(0), rear(0), queueSize(0)\n{\n\tqueuePtr = new DataType[inQueueCapacity];\n}\n```\n\n- 入队操作，堆满则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::Enqueue(DataType inData)\n{\n\tif (queueSize >= queueCapacity) {\n\t\tthrow \"Queue is full\";\n\t}\n\tqueuePtr[rear] = inData;\n\trear = (rear+1) % queueCapacity;\n\t++queueSize;\n}\n```\n\n- 出队操作，队空抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::Dequeue()\n{\n\tif (queueSize <= 0 && front == rear) {\n\t\tthrow \"Queue is empty!\";\n\t}\n\tfront = (front+1) % queueCapacity;\n\t--queueSize;\n}\n```\n\n- 读取队首元素，队空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType Queue<DataType>::Front()\n{\n\tif (queueSize <= 0 && front == rear) {\n\t\tthrow \"Queue is empty!\";\n\t}\n\treturn queuePtr[front];\n}\n```\n\n- 判断队列是否为空\n\n```cpp\ntemplate <typename DataType>\nbool Queue<DataType>::IsEmpty()\n{\n\treturn queueSize <= 0 && front == rear;\n}\n```\n\n- 清空队列，也可以直接通过调用Dequeue函数实现\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::MakeEmpty()\n{\n\tqueueSize = 0;\n\tfront = rear = 0;\n}\n```\n\n- 返回队列大小\n\n```cpp\ntemplate <typename DataType>\nint Queue<DataType>::QueueSize()\n{\n\treturn queueSize;\n}\n```\n\n- 析构函数，直接调用MakeEmpty函数实现\n\n```cpp\ntemplate <typename DataType>\nQueue<DataType>::~Queue()\n{\n\tMakeEmpty();\n\tdelete [] queuePtr;\n}\n```\n\n## 代码测试\n\n基本数据结构测试代码如下：\n\n```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\n\nint main()\n{\n\ttry {\n\t\tQueue<int> TestQueue; /*实际测试*/\n\t\t/*Queue<int> TestQueue(20);*/\n\t\tfor (int i = 0; i < 13; i++) {\n\t\t\tTestQueue.Enqueue(i);\n\t\t}\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tcout << TestQueue.Front() << \";\";\n\t\t\tTestQueue.Dequeue();\n\t\t}\n\t\tcout << endl;\n\n\t}\n\tcatch(const char *msg) {\n\t\tcout << msg << endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","source":"_posts/数据结构/数据结构之队列的定义与实现.md","raw":"---\ntitle: 数据结构之队列的定义与实现\nurlname: queue\ndate: 2018-03-5 13:34:10\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\n- C++\ncategories:\n- 数据结构\n---\n\n## 队列基础知识\n\n和栈类似，队列也是一种线性表，不过队列是在一端插入在另外一端删除。插入的一端称为队尾，删除的一端称为队头。队列的基本操作是入队和出队。由于队列的插入删除特性，因此队列具有“先进先出(FIFO)”的特点。同理，使用顺序表实现的队列称为顺序队列，使用链表实现的队列称为链式队列。队列采用数组实现时一般需要实现为循环数组，故一般也称为循环队列。队列实现中一般有如下操作：\n\n- 入队：Enqueue\n- 出队：Dequeue\n- 判断是否为空：IsEmpty\n- 清空队列：MakeEmpty\n- 读取队首元素：Front\n\n## 队列的链表实现\n\n在采用链表实现队列时，由于队列是“先进先出”的，因此可以尝试使用尾插法同时从头部删除的方式实现队列“先进先出”的特点。在STL中queue的实现中，其底层采用的是deque，和栈类似，list也可实现队列。\n\n仿照《数据结构与算法分析-C语言描述》的定义，队列可定义如下：\n\n```cpp\ntemplate <typename DataType>\nclass Node\n{\npublic:\n\tNode(DataType inData):data(inData),next(nullptr) {}\npublic:\n\tDataType data;\n\tNode *next;\n};\n\n\ntemplate <typename DataType>\nclass Queue\n{\npublic:\n\tQueue():dummyNode(-1), queueSize(0), lastNode(nullptr) {}\n\t~Queue();\n\tvoid Enqueue(DataType inData); //入队\n\tvoid Dequeue(); //出队\n\tDataType Front(); //读取队首元素，队空则抛出异常\n\tbool IsEmpty(); //判断队列是否为空\n\tvoid MakeEmpty(); //清空队列\n\tint QueueSize(); //返回队列大小\nprivate:\n\tNode<DataType> dummyNode;\n\tint queueSize;\n\tNode<DataType> *lastNode;\n};\n```\n\n如上所示，队列的数据成员有哑节点、队列大小以及一个指链表尾端的指针。如下依次实现各个操作\n\n- 入队操作，采用尾插法\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::Enqueue(DataType inData)\n{\n\tif (queueSize <= 0 || lastNode == nullptr) {\n\t\tlastNode = &dummyNode;\n\t}\n\tlastNode->next = new Node<DataType>(inData);\n\tlastNode = lastNode->next; ++queueSize;\n}\n```\n\n- 出队操作，不断删除链表第一个元素，队空抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::Dequeue()\n{\n\tif (queueSize <= 0 || dummyNode.next == nullptr) {\n\t\tthrow \"Queue is empty!\";\n\t}\n\tNode<DataType> *tmp = dummyNode.next; /*删除头部*/\n\tdummyNode.next = dummyNode.next->next;\n\tdelete tmp; --queueSize;\n}\n```\n\n- 读取队首元素，队空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType Queue<DataType>::Front()\n{\n\tif (queueSize <= 0 || dummyNode.next == nullptr) {\n\t\tthrow \"Queue is empty!\";\n\t}\n\treturn dummyNode.next->data;\n}\n```\n\n- 判断队列是否为空\n\n```cpp\ntemplate <typename DataType>\nbool Queue<DataType>::IsEmpty()\n{\n\treturn queueSize <= 0 || dummyNode.next == nullptr;\n}\n```\n\n- 清空队列，也可以直接通过调用Dequeue函数实现\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::MakeEmpty()\n{\n\tNode<DataType> *tmp = dummyNode.next;\n\t/*循环删除头部*/\n\twhile (tmp != nullptr) {\n\t\tdummyNode.next = tmp->next;\n\t\tdelete tmp; --queueSize;\n\t\ttmp = dummyNode.next;\n\t}\n}\n```\n\n- 返回队列大小\n\n```cpp\ntemplate <typename DataType>\nint Queue<DataType>::QueueSize()\n{\n\treturn queueSize;\n}\n```\n\n- 析构函数，直接调用MakeEmpty函数实现\n\n```cpp\ntemplate <typename DataType>\nQueue<DataType>::~Queue()\n{\n\tMakeEmpty();\n}\n```\n\n## 队列的循环数组实现\n\n在使用数组实现队列时，由于队列是在一端插入，另外一端删除，因此队列和栈不同的是需要两个指针分别指向队首和队尾，同时需要采用循环数组的实现方式，循环数组意味着在物理结构上队首、队尾标记可能不遵循前后的位置关系。采用循环数组实现队列的基本ADT定义如下：\n\n```cpp\ntemplate <typename DataType>\nclass Queue\n{\npublic:\n\tQueue(int inQueueCapacity);\n\t~Queue(); //析构函数，回收内存\n\tvoid Enqueue(DataType inData); //入队，堆满则抛出异常\n\tvoid Dequeue(); //出队，队空则抛出异常\n\tDataType Front(); //读取队首元素，队空则抛出异常\n\tbool IsEmpty(); //判断队列是否为空\n\tvoid MakeEmpty(); //清空队列\n\tint QueueSize(); //返回队列大小\nprivate:\n\tint queueCapacity;\n\tDataType *queuePtr; /*动态申请*/\n\tint front, rear; /*分别指向队首、队尾*/\n\tint queueSize;\n};\n```\n\n如上所示为队列的循环数组实现的基本数据结构定义。queueCapacity保存队列的容量，queuePtr为队列的空间起始地址，front、rear分别用来指示队首、队尾位置，queueSize表示当前队列的大小。在计算front、rear时由于需要考虑绕回的情况，因此其不能直接加1，应该加1后再对容量取模。在我的是实现版本中，front==rear的情况可能是队空或者队满，因此在判断队空或者队满的时候不能简单判断两者是否相等。以下为各函数具体实现。\n\n- 构造函数的实现，分配内存，初始化数据成员\n\n```cpp\ntemplate <typename DataType>\nQueue<DataType>::Queue(int inQueueCapacity): queueCapacity(inQueueCapacity),\n\t\t\t\tfront(0), rear(0), queueSize(0)\n{\n\tqueuePtr = new DataType[inQueueCapacity];\n}\n```\n\n- 入队操作，堆满则抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::Enqueue(DataType inData)\n{\n\tif (queueSize >= queueCapacity) {\n\t\tthrow \"Queue is full\";\n\t}\n\tqueuePtr[rear] = inData;\n\trear = (rear+1) % queueCapacity;\n\t++queueSize;\n}\n```\n\n- 出队操作，队空抛出异常\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::Dequeue()\n{\n\tif (queueSize <= 0 && front == rear) {\n\t\tthrow \"Queue is empty!\";\n\t}\n\tfront = (front+1) % queueCapacity;\n\t--queueSize;\n}\n```\n\n- 读取队首元素，队空则抛出异常\n\n```cpp\ntemplate <typename DataType>\nDataType Queue<DataType>::Front()\n{\n\tif (queueSize <= 0 && front == rear) {\n\t\tthrow \"Queue is empty!\";\n\t}\n\treturn queuePtr[front];\n}\n```\n\n- 判断队列是否为空\n\n```cpp\ntemplate <typename DataType>\nbool Queue<DataType>::IsEmpty()\n{\n\treturn queueSize <= 0 && front == rear;\n}\n```\n\n- 清空队列，也可以直接通过调用Dequeue函数实现\n\n```cpp\ntemplate <typename DataType>\nvoid Queue<DataType>::MakeEmpty()\n{\n\tqueueSize = 0;\n\tfront = rear = 0;\n}\n```\n\n- 返回队列大小\n\n```cpp\ntemplate <typename DataType>\nint Queue<DataType>::QueueSize()\n{\n\treturn queueSize;\n}\n```\n\n- 析构函数，直接调用MakeEmpty函数实现\n\n```cpp\ntemplate <typename DataType>\nQueue<DataType>::~Queue()\n{\n\tMakeEmpty();\n\tdelete [] queuePtr;\n}\n```\n\n## 代码测试\n\n基本数据结构测试代码如下：\n\n```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\n\nint main()\n{\n\ttry {\n\t\tQueue<int> TestQueue; /*实际测试*/\n\t\t/*Queue<int> TestQueue(20);*/\n\t\tfor (int i = 0; i < 13; i++) {\n\t\t\tTestQueue.Enqueue(i);\n\t\t}\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tcout << TestQueue.Front() << \";\";\n\t\t\tTestQueue.Dequeue();\n\t\t}\n\t\tcout << endl;\n\n\t}\n\tcatch(const char *msg) {\n\t\tcout << msg << endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","slug":"数据结构/数据结构之队列的定义与实现","published":1,"updated":"2018-06-13T14:06:54.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3w001ugsvnhurm2v6n","content":"<h2 id=\"队列基础知识\"><a href=\"#队列基础知识\" class=\"headerlink\" title=\"队列基础知识\"></a>队列基础知识</h2><p>和栈类似，队列也是一种线性表，不过队列是在一端插入在另外一端删除。插入的一端称为队尾，删除的一端称为队头。队列的基本操作是入队和出队。由于队列的插入删除特性，因此队列具有“先进先出(FIFO)”的特点。同理，使用顺序表实现的队列称为顺序队列，使用链表实现的队列称为链式队列。队列采用数组实现时一般需要实现为循环数组，故一般也称为循环队列。队列实现中一般有如下操作：</p>\n<ul>\n<li>入队：Enqueue</li>\n<li>出队：Dequeue</li>\n<li>判断是否为空：IsEmpty</li>\n<li>清空队列：MakeEmpty</li>\n<li>读取队首元素：Front</li>\n</ul>\n<h2 id=\"队列的链表实现\"><a href=\"#队列的链表实现\" class=\"headerlink\" title=\"队列的链表实现\"></a>队列的链表实现</h2><p>在采用链表实现队列时，由于队列是“先进先出”的，因此可以尝试使用尾插法同时从头部删除的方式实现队列“先进先出”的特点。在STL中queue的实现中，其底层采用的是deque，和栈类似，list也可实现队列。</p>\n<p>仿照《数据结构与算法分析-C语言描述》的定义，队列可定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode(DataType inData):data(inData),next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tQueue():dummyNode(<span class=\"number\">-1</span>), queueSize(<span class=\"number\">0</span>), lastNode(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~Queue();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//入队</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dequeue</span><span class=\"params\">()</span></span>; <span class=\"comment\">//出队</span></span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Front</span><span class=\"params\">()</span></span>; <span class=\"comment\">//读取队首元素，队空则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断队列是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空队列</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">QueueSize</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回队列大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> queueSize;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *lastNode;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，队列的数据成员有哑节点、队列大小以及一个指链表尾端的指针。如下依次实现各个操作</p>\n<ul>\n<li>入队操作，采用尾插法</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::Enqueue(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> || lastNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = &amp;dummyNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlastNode-&gt;next = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inData);</span><br><span class=\"line\">\tlastNode = lastNode-&gt;next; ++queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出队操作，不断删除链表第一个元素，队空抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::Dequeue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = dummyNode.next; <span class=\"comment\">/*删除头部*/</span></span><br><span class=\"line\">\tdummyNode.next = dummyNode.next-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> tmp; --queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>读取队首元素，队空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType Queue&lt;DataType&gt;::Front()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dummyNode.next-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断队列是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> Queue&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空队列，也可以直接通过调用Dequeue函数实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = dummyNode.next;</span><br><span class=\"line\">\t<span class=\"comment\">/*循环删除头部*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tdummyNode.next = tmp-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp; --queueSize;</span><br><span class=\"line\">\t\ttmp = dummyNode.next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回队列大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Queue&lt;DataType&gt;::QueueSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，直接调用MakeEmpty函数实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Queue&lt;DataType&gt;::~Queue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列的循环数组实现\"><a href=\"#队列的循环数组实现\" class=\"headerlink\" title=\"队列的循环数组实现\"></a>队列的循环数组实现</h2><p>在使用数组实现队列时，由于队列是在一端插入，另外一端删除，因此队列和栈不同的是需要两个指针分别指向队首和队尾，同时需要采用循环数组的实现方式，循环数组意味着在物理结构上队首、队尾标记可能不遵循前后的位置关系。采用循环数组实现队列的基本ADT定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tQueue(<span class=\"keyword\">int</span> inQueueCapacity);</span><br><span class=\"line\">\t~Queue(); <span class=\"comment\">//析构函数，回收内存</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//入队，堆满则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dequeue</span><span class=\"params\">()</span></span>; <span class=\"comment\">//出队，队空则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Front</span><span class=\"params\">()</span></span>; <span class=\"comment\">//读取队首元素，队空则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断队列是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空队列</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">QueueSize</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回队列大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> queueCapacity;</span><br><span class=\"line\">\tDataType *queuePtr; <span class=\"comment\">/*动态申请*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front, rear; <span class=\"comment\">/*分别指向队首、队尾*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> queueSize;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示为队列的循环数组实现的基本数据结构定义。queueCapacity保存队列的容量，queuePtr为队列的空间起始地址，front、rear分别用来指示队首、队尾位置，queueSize表示当前队列的大小。在计算front、rear时由于需要考虑绕回的情况，因此其不能直接加1，应该加1后再对容量取模。在我的是实现版本中，front==rear的情况可能是队空或者队满，因此在判断队空或者队满的时候不能简单判断两者是否相等。以下为各函数具体实现。</p>\n<ul>\n<li>构造函数的实现，分配内存，初始化数据成员</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Queue&lt;DataType&gt;::Queue(<span class=\"keyword\">int</span> inQueueCapacity): queueCapacity(inQueueCapacity),</span><br><span class=\"line\">\t\t\t\tfront(<span class=\"number\">0</span>), rear(<span class=\"number\">0</span>), queueSize(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueuePtr = <span class=\"keyword\">new</span> DataType[inQueueCapacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>入队操作，堆满则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::Enqueue(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &gt;= queueCapacity) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is full\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tqueuePtr[rear] = inData;</span><br><span class=\"line\">\trear = (rear+<span class=\"number\">1</span>) % queueCapacity;</span><br><span class=\"line\">\t++queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出队操作，队空抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::Dequeue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> &amp;&amp; front == rear) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfront = (front+<span class=\"number\">1</span>) % queueCapacity;</span><br><span class=\"line\">\t--queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>读取队首元素，队空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType Queue&lt;DataType&gt;::Front()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> &amp;&amp; front == rear) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queuePtr[front];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断队列是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> Queue&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize &lt;= <span class=\"number\">0</span> &amp;&amp; front == rear;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空队列，也可以直接通过调用Dequeue函数实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueueSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tfront = rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回队列大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Queue&lt;DataType&gt;::QueueSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，直接调用MakeEmpty函数实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Queue&lt;DataType&gt;::~Queue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] queuePtr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>基本数据结构测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tQueue&lt;<span class=\"keyword\">int</span>&gt; TestQueue; <span class=\"comment\">/*实际测试*/</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/*Queue&lt;int&gt; TestQueue(20);*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">13</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tTestQueue.Enqueue(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; TestQueue.Front() &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">\t\t\tTestQueue.Dequeue();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *msg) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; msg &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"队列基础知识\"><a href=\"#队列基础知识\" class=\"headerlink\" title=\"队列基础知识\"></a>队列基础知识</h2><p>和栈类似，队列也是一种线性表，不过队列是在一端插入在另外一端删除。插入的一端称为队尾，删除的一端称为队头。队列的基本操作是入队和出队。由于队列的插入删除特性，因此队列具有“先进先出(FIFO)”的特点。同理，使用顺序表实现的队列称为顺序队列，使用链表实现的队列称为链式队列。队列采用数组实现时一般需要实现为循环数组，故一般也称为循环队列。队列实现中一般有如下操作：</p>\n<ul>\n<li>入队：Enqueue</li>\n<li>出队：Dequeue</li>\n<li>判断是否为空：IsEmpty</li>\n<li>清空队列：MakeEmpty</li>\n<li>读取队首元素：Front</li>\n</ul>\n<h2 id=\"队列的链表实现\"><a href=\"#队列的链表实现\" class=\"headerlink\" title=\"队列的链表实现\"></a>队列的链表实现</h2><p>在采用链表实现队列时，由于队列是“先进先出”的，因此可以尝试使用尾插法同时从头部删除的方式实现队列“先进先出”的特点。在STL中queue的实现中，其底层采用的是deque，和栈类似，list也可实现队列。</p>\n<p>仿照《数据结构与算法分析-C语言描述》的定义，队列可定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNode(DataType inData):data(inData),next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tQueue():dummyNode(<span class=\"number\">-1</span>), queueSize(<span class=\"number\">0</span>), lastNode(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">\t~Queue();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//入队</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dequeue</span><span class=\"params\">()</span></span>; <span class=\"comment\">//出队</span></span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Front</span><span class=\"params\">()</span></span>; <span class=\"comment\">//读取队首元素，队空则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断队列是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空队列</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">QueueSize</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回队列大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tNode&lt;DataType&gt; dummyNode;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> queueSize;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *lastNode;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示，队列的数据成员有哑节点、队列大小以及一个指链表尾端的指针。如下依次实现各个操作</p>\n<ul>\n<li>入队操作，采用尾插法</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::Enqueue(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> || lastNode == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tlastNode = &amp;dummyNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlastNode-&gt;next = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inData);</span><br><span class=\"line\">\tlastNode = lastNode-&gt;next; ++queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出队操作，不断删除链表第一个元素，队空抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::Dequeue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = dummyNode.next; <span class=\"comment\">/*删除头部*/</span></span><br><span class=\"line\">\tdummyNode.next = dummyNode.next-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> tmp; --queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>读取队首元素，队空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType Queue&lt;DataType&gt;::Front()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dummyNode.next-&gt;data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断队列是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> Queue&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize &lt;= <span class=\"number\">0</span> || dummyNode.next == <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空队列，也可以直接通过调用Dequeue函数实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = dummyNode.next;</span><br><span class=\"line\">\t<span class=\"comment\">/*循环删除头部*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tdummyNode.next = tmp-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> tmp; --queueSize;</span><br><span class=\"line\">\t\ttmp = dummyNode.next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回队列大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Queue&lt;DataType&gt;::QueueSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，直接调用MakeEmpty函数实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Queue&lt;DataType&gt;::~Queue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列的循环数组实现\"><a href=\"#队列的循环数组实现\" class=\"headerlink\" title=\"队列的循环数组实现\"></a>队列的循环数组实现</h2><p>在使用数组实现队列时，由于队列是在一端插入，另外一端删除，因此队列和栈不同的是需要两个指针分别指向队首和队尾，同时需要采用循环数组的实现方式，循环数组意味着在物理结构上队首、队尾标记可能不遵循前后的位置关系。采用循环数组实现队列的基本ADT定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tQueue(<span class=\"keyword\">int</span> inQueueCapacity);</span><br><span class=\"line\">\t~Queue(); <span class=\"comment\">//析构函数，回收内存</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Enqueue</span><span class=\"params\">(DataType inData)</span></span>; <span class=\"comment\">//入队，堆满则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Dequeue</span><span class=\"params\">()</span></span>; <span class=\"comment\">//出队，队空则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\">DataType <span class=\"title\">Front</span><span class=\"params\">()</span></span>; <span class=\"comment\">//读取队首元素，队空则抛出异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//判断队列是否为空</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>; <span class=\"comment\">//清空队列</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">QueueSize</span><span class=\"params\">()</span></span>; <span class=\"comment\">//返回队列大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> queueCapacity;</span><br><span class=\"line\">\tDataType *queuePtr; <span class=\"comment\">/*动态申请*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front, rear; <span class=\"comment\">/*分别指向队首、队尾*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> queueSize;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上所示为队列的循环数组实现的基本数据结构定义。queueCapacity保存队列的容量，queuePtr为队列的空间起始地址，front、rear分别用来指示队首、队尾位置，queueSize表示当前队列的大小。在计算front、rear时由于需要考虑绕回的情况，因此其不能直接加1，应该加1后再对容量取模。在我的是实现版本中，front==rear的情况可能是队空或者队满，因此在判断队空或者队满的时候不能简单判断两者是否相等。以下为各函数具体实现。</p>\n<ul>\n<li>构造函数的实现，分配内存，初始化数据成员</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Queue&lt;DataType&gt;::Queue(<span class=\"keyword\">int</span> inQueueCapacity): queueCapacity(inQueueCapacity),</span><br><span class=\"line\">\t\t\t\tfront(<span class=\"number\">0</span>), rear(<span class=\"number\">0</span>), queueSize(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueuePtr = <span class=\"keyword\">new</span> DataType[inQueueCapacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>入队操作，堆满则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::Enqueue(DataType inData)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &gt;= queueCapacity) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is full\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tqueuePtr[rear] = inData;</span><br><span class=\"line\">\trear = (rear+<span class=\"number\">1</span>) % queueCapacity;</span><br><span class=\"line\">\t++queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>出队操作，队空抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::Dequeue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> &amp;&amp; front == rear) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfront = (front+<span class=\"number\">1</span>) % queueCapacity;</span><br><span class=\"line\">\t--queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>读取队首元素，队空则抛出异常</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">DataType Queue&lt;DataType&gt;::Front()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (queueSize &lt;= <span class=\"number\">0</span> &amp;&amp; front == rear) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"string\">\"Queue is empty!\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queuePtr[front];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断队列是否为空</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> Queue&lt;DataType&gt;::IsEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize &lt;= <span class=\"number\">0</span> &amp;&amp; front == rear;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空队列，也可以直接通过调用Dequeue函数实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Queue&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tqueueSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tfront = rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回队列大小</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Queue&lt;DataType&gt;::QueueSize()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> queueSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数，直接调用MakeEmpty函数实现</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">Queue&lt;DataType&gt;::~Queue()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tMakeEmpty();</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> [] queuePtr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>基本数据结构测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tQueue&lt;<span class=\"keyword\">int</span>&gt; TestQueue; <span class=\"comment\">/*实际测试*/</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/*Queue&lt;int&gt; TestQueue(20);*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">13</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tTestQueue.Enqueue(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; TestQueue.Front() &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">\t\t\tTestQueue.Dequeue();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *msg) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; msg &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n"},{"title":"数据结构基础数学知识","urlname":"data-structure-basic-math","date":"2018-03-03T14:33:17.000Z","mathjax":true,"copyright":true,"_content":"\n## 指数公式\n\n- $X^A*X^B=X^{A+B}$\n- $X^A/X^B=X^{A-B}$\n- $(X^A)^B=X^{AB}$\n\n## 对数公式\n\n- $X^A=B=>\\log_X(B)=A$\n- $\\log_A(B)=\\log_C(B)/\\log_C(A),C>0$\n- $\\log(AB)=\\log(A) + \\log(B)$\n- $\\log(A/B)=\\log(A) - \\log(B)$\n- $\\log(A^B) = B*\\log(A)$\n- $X > 0 => \\log(X) < X$\n\n## 级数\n- $\\sum_{i=0}^{N}A^i=(A^{N+1}-1)/(A-1)$\n- $\\sum_{i=0}^{N}A^i<=1/(1-A)$当$0<A<1$\n- $\\sum_{i=1}^{N}i=(N+1)N/2\\approx N^2/2$\n- $\\sum_{i=1}^{N}i^2=(N+1)(2N+1)N/6\\approx N^3/3$\n- $\\sum_{i=1}^{N}i^k\\approx N^{k+1}/|K+1|,k\\ne -1$\n- $H_N =\\sum_{i=1}^{N}(1/i)\\approx log_e(N),H_N $称为调和数\n\n\n## 模运算\n\n- $(A \\mod N) = (B \\mod N) => N$整除$(A-B)$\n- 如果$M>N$，则$M \\mod N < M/2$\n\n**注：取模运算耗费很大**\n\n## 数据结构证明常用方法\n\n- 归纳法：证明基准情形->归纳假设->证明下一个值也成立\n- 反例证明：举出反例\n- 反证法：假设定理不成立，然后证明某个已知的性质不成立，从而证明原假设是错误的\n\n## 递归\n\n当一个函数用自身来定义时就称为递归的，编写递归例程需要遵循四条基本法则：\n\n- 基准情形：必须总有某些基准情形无需递归即可求解\n- 不断递进：递归调用总是朝着基准情形推进\n- 设计法则：假设所有的递归调用都能运行\n- 合成效益法则：求解一个问题同一实例时切勿在不同递归调用中做重复性工作（类似动态规划保存结果）\n\n## 算法分析基础\n\n- 大$O$标记：如果存在正常数$c$以及$n_0$使得当$N>=n_0$时$T(N)<=cf(N)$，则记为$T(N)=O(f(N))$\n- 大$Ω$标记：如果存在正常数$c$以及$n_0$使得当$N>=n_0$时$T(N)>=cf(N)$,则记为$T(N)=Ω(f(N))$\n- $Θ$标记：$T(N)=Θ(f(N))$当且仅当$T(N)=O(f(N))$ AND $T(N)=Ω(f(N))$\n- 小$o$标记：$T(N)=o(f(N))$当且仅当$T(N)=O(f(N)) AND T(N)!=Ω(f(N))$\n- 如果$T_1(N)=O(f(N))$且$T_2(N)=O(g(N))$  \n则$T_1(N)+T_2(N)=max(O(f(N)),O(g(N))), T_1(N)\\*T_2(N)=O(f(N)\\*g(N))$\n- 如果$T(N)$是一个$k$次多项式，则$T(N)=Θ(N^k)$\n- 对于任意$k,\\log^k(N)=O(N)$，表明对数增长十分缓慢\n\n## 时间复杂度计算一般法则\n\n- FOR循环：一次FOR循环的运行时间至多是该循环语句（包括测试）的运行时间乘以迭代的次数。\n- 嵌套的FOR循环：从里向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句运行时间乘以所有的FOR循环的大小的乘积。\n- 顺序语句：将各个语句的运行时间求和即可。\n- IF/ELSE语句：IF/ELSE语句运行时间不超过判断再加上两部分运行时间长者的和。\n- 如果一个算法用常数时间将问题的的大小削减为其一部分，那么该算法就是$O(\\log(N))$；如果使用常数时间只是把问题减少一个常数，那么这种算法就是$O(N)$。\n\n## 联机算法\n\n在任意时刻算法对要操作的数据只读入（扫描）一次，一旦被读入并处理，它就不需要在被记忆了。而在此处理过程中算法能对它已经读入的数据立即给出相应子序列问题的正确答案。仅需要常量空间并以线性时间运行的联机算法几乎是完美算法。\n","source":"_posts/数据结构/数据结构基础数学知识.md","raw":"---\ntitle: 数据结构基础数学知识\nurlname: data-structure-basic-math\ndate: 2018-03-3 22:33:17\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 指数公式\n\n- $X^A*X^B=X^{A+B}$\n- $X^A/X^B=X^{A-B}$\n- $(X^A)^B=X^{AB}$\n\n## 对数公式\n\n- $X^A=B=>\\log_X(B)=A$\n- $\\log_A(B)=\\log_C(B)/\\log_C(A),C>0$\n- $\\log(AB)=\\log(A) + \\log(B)$\n- $\\log(A/B)=\\log(A) - \\log(B)$\n- $\\log(A^B) = B*\\log(A)$\n- $X > 0 => \\log(X) < X$\n\n## 级数\n- $\\sum_{i=0}^{N}A^i=(A^{N+1}-1)/(A-1)$\n- $\\sum_{i=0}^{N}A^i<=1/(1-A)$当$0<A<1$\n- $\\sum_{i=1}^{N}i=(N+1)N/2\\approx N^2/2$\n- $\\sum_{i=1}^{N}i^2=(N+1)(2N+1)N/6\\approx N^3/3$\n- $\\sum_{i=1}^{N}i^k\\approx N^{k+1}/|K+1|,k\\ne -1$\n- $H_N =\\sum_{i=1}^{N}(1/i)\\approx log_e(N),H_N $称为调和数\n\n\n## 模运算\n\n- $(A \\mod N) = (B \\mod N) => N$整除$(A-B)$\n- 如果$M>N$，则$M \\mod N < M/2$\n\n**注：取模运算耗费很大**\n\n## 数据结构证明常用方法\n\n- 归纳法：证明基准情形->归纳假设->证明下一个值也成立\n- 反例证明：举出反例\n- 反证法：假设定理不成立，然后证明某个已知的性质不成立，从而证明原假设是错误的\n\n## 递归\n\n当一个函数用自身来定义时就称为递归的，编写递归例程需要遵循四条基本法则：\n\n- 基准情形：必须总有某些基准情形无需递归即可求解\n- 不断递进：递归调用总是朝着基准情形推进\n- 设计法则：假设所有的递归调用都能运行\n- 合成效益法则：求解一个问题同一实例时切勿在不同递归调用中做重复性工作（类似动态规划保存结果）\n\n## 算法分析基础\n\n- 大$O$标记：如果存在正常数$c$以及$n_0$使得当$N>=n_0$时$T(N)<=cf(N)$，则记为$T(N)=O(f(N))$\n- 大$Ω$标记：如果存在正常数$c$以及$n_0$使得当$N>=n_0$时$T(N)>=cf(N)$,则记为$T(N)=Ω(f(N))$\n- $Θ$标记：$T(N)=Θ(f(N))$当且仅当$T(N)=O(f(N))$ AND $T(N)=Ω(f(N))$\n- 小$o$标记：$T(N)=o(f(N))$当且仅当$T(N)=O(f(N)) AND T(N)!=Ω(f(N))$\n- 如果$T_1(N)=O(f(N))$且$T_2(N)=O(g(N))$  \n则$T_1(N)+T_2(N)=max(O(f(N)),O(g(N))), T_1(N)\\*T_2(N)=O(f(N)\\*g(N))$\n- 如果$T(N)$是一个$k$次多项式，则$T(N)=Θ(N^k)$\n- 对于任意$k,\\log^k(N)=O(N)$，表明对数增长十分缓慢\n\n## 时间复杂度计算一般法则\n\n- FOR循环：一次FOR循环的运行时间至多是该循环语句（包括测试）的运行时间乘以迭代的次数。\n- 嵌套的FOR循环：从里向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句运行时间乘以所有的FOR循环的大小的乘积。\n- 顺序语句：将各个语句的运行时间求和即可。\n- IF/ELSE语句：IF/ELSE语句运行时间不超过判断再加上两部分运行时间长者的和。\n- 如果一个算法用常数时间将问题的的大小削减为其一部分，那么该算法就是$O(\\log(N))$；如果使用常数时间只是把问题减少一个常数，那么这种算法就是$O(N)$。\n\n## 联机算法\n\n在任意时刻算法对要操作的数据只读入（扫描）一次，一旦被读入并处理，它就不需要在被记忆了。而在此处理过程中算法能对它已经读入的数据立即给出相应子序列问题的正确答案。仅需要常量空间并以线性时间运行的联机算法几乎是完美算法。\n","slug":"数据结构/数据结构基础数学知识","published":1,"updated":"2018-06-13T14:04:12.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x3y001ygsvny92u3d1n","content":"<h2 id=\"指数公式\"><a href=\"#指数公式\" class=\"headerlink\" title=\"指数公式\"></a>指数公式</h2><ul>\n<li>$X^A*X^B=X^{A+B}$</li>\n<li>$X^A/X^B=X^{A-B}$</li>\n<li>$(X^A)^B=X^{AB}$</li>\n</ul>\n<h2 id=\"对数公式\"><a href=\"#对数公式\" class=\"headerlink\" title=\"对数公式\"></a>对数公式</h2><ul>\n<li>$X^A=B=&gt;\\log_X(B)=A$</li>\n<li>$\\log_A(B)=\\log_C(B)/\\log_C(A),C&gt;0$</li>\n<li>$\\log(AB)=\\log(A) + \\log(B)$</li>\n<li>$\\log(A/B)=\\log(A) - \\log(B)$</li>\n<li>$\\log(A^B) = B*\\log(A)$</li>\n<li>$X &gt; 0 =&gt; \\log(X) &lt; X$</li>\n</ul>\n<h2 id=\"级数\"><a href=\"#级数\" class=\"headerlink\" title=\"级数\"></a>级数</h2><ul>\n<li>$\\sum_{i=0}^{N}A^i=(A^{N+1}-1)/(A-1)$</li>\n<li>$\\sum_{i=0}^{N}A^i&lt;=1/(1-A)$当$0&lt;A&lt;1$</li>\n<li>$\\sum_{i=1}^{N}i=(N+1)N/2\\approx N^2/2$</li>\n<li>$\\sum_{i=1}^{N}i^2=(N+1)(2N+1)N/6\\approx N^3/3$</li>\n<li>$\\sum_{i=1}^{N}i^k\\approx N^{k+1}/|K+1|,k\\ne -1$</li>\n<li>$H_N =\\sum_{i=1}^{N}(1/i)\\approx log_e(N),H_N $称为调和数</li>\n</ul>\n<h2 id=\"模运算\"><a href=\"#模运算\" class=\"headerlink\" title=\"模运算\"></a>模运算</h2><ul>\n<li>$(A \\mod N) = (B \\mod N) =&gt; N$整除$(A-B)$</li>\n<li>如果$M&gt;N$，则$M \\mod N &lt; M/2$</li>\n</ul>\n<p><strong>注：取模运算耗费很大</strong></p>\n<h2 id=\"数据结构证明常用方法\"><a href=\"#数据结构证明常用方法\" class=\"headerlink\" title=\"数据结构证明常用方法\"></a>数据结构证明常用方法</h2><ul>\n<li>归纳法：证明基准情形-&gt;归纳假设-&gt;证明下一个值也成立</li>\n<li>反例证明：举出反例</li>\n<li>反证法：假设定理不成立，然后证明某个已知的性质不成立，从而证明原假设是错误的</li>\n</ul>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>当一个函数用自身来定义时就称为递归的，编写递归例程需要遵循四条基本法则：</p>\n<ul>\n<li>基准情形：必须总有某些基准情形无需递归即可求解</li>\n<li>不断递进：递归调用总是朝着基准情形推进</li>\n<li>设计法则：假设所有的递归调用都能运行</li>\n<li>合成效益法则：求解一个问题同一实例时切勿在不同递归调用中做重复性工作（类似动态规划保存结果）</li>\n</ul>\n<h2 id=\"算法分析基础\"><a href=\"#算法分析基础\" class=\"headerlink\" title=\"算法分析基础\"></a>算法分析基础</h2><ul>\n<li>大$O$标记：如果存在正常数$c$以及$n_0$使得当$N&gt;=n_0$时$T(N)&lt;=cf(N)$，则记为$T(N)=O(f(N))$</li>\n<li>大$Ω$标记：如果存在正常数$c$以及$n_0$使得当$N&gt;=n_0$时$T(N)&gt;=cf(N)$,则记为$T(N)=Ω(f(N))$</li>\n<li>$Θ$标记：$T(N)=Θ(f(N))$当且仅当$T(N)=O(f(N))$ AND $T(N)=Ω(f(N))$</li>\n<li>小$o$标记：$T(N)=o(f(N))$当且仅当$T(N)=O(f(N)) AND T(N)!=Ω(f(N))$</li>\n<li>如果$T_1(N)=O(f(N))$且$T_2(N)=O(g(N))$<br>则$T_1(N)+T_2(N)=max(O(f(N)),O(g(N))), T_1(N)*T_2(N)=O(f(N)*g(N))$</li>\n<li>如果$T(N)$是一个$k$次多项式，则$T(N)=Θ(N^k)$</li>\n<li>对于任意$k,\\log^k(N)=O(N)$，表明对数增长十分缓慢</li>\n</ul>\n<h2 id=\"时间复杂度计算一般法则\"><a href=\"#时间复杂度计算一般法则\" class=\"headerlink\" title=\"时间复杂度计算一般法则\"></a>时间复杂度计算一般法则</h2><ul>\n<li>FOR循环：一次FOR循环的运行时间至多是该循环语句（包括测试）的运行时间乘以迭代的次数。</li>\n<li>嵌套的FOR循环：从里向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句运行时间乘以所有的FOR循环的大小的乘积。</li>\n<li>顺序语句：将各个语句的运行时间求和即可。</li>\n<li>IF/ELSE语句：IF/ELSE语句运行时间不超过判断再加上两部分运行时间长者的和。</li>\n<li>如果一个算法用常数时间将问题的的大小削减为其一部分，那么该算法就是$O(\\log(N))$；如果使用常数时间只是把问题减少一个常数，那么这种算法就是$O(N)$。</li>\n</ul>\n<h2 id=\"联机算法\"><a href=\"#联机算法\" class=\"headerlink\" title=\"联机算法\"></a>联机算法</h2><p>在任意时刻算法对要操作的数据只读入（扫描）一次，一旦被读入并处理，它就不需要在被记忆了。而在此处理过程中算法能对它已经读入的数据立即给出相应子序列问题的正确答案。仅需要常量空间并以线性时间运行的联机算法几乎是完美算法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"指数公式\"><a href=\"#指数公式\" class=\"headerlink\" title=\"指数公式\"></a>指数公式</h2><ul>\n<li>$X^A*X^B=X^{A+B}$</li>\n<li>$X^A/X^B=X^{A-B}$</li>\n<li>$(X^A)^B=X^{AB}$</li>\n</ul>\n<h2 id=\"对数公式\"><a href=\"#对数公式\" class=\"headerlink\" title=\"对数公式\"></a>对数公式</h2><ul>\n<li>$X^A=B=&gt;\\log_X(B)=A$</li>\n<li>$\\log_A(B)=\\log_C(B)/\\log_C(A),C&gt;0$</li>\n<li>$\\log(AB)=\\log(A) + \\log(B)$</li>\n<li>$\\log(A/B)=\\log(A) - \\log(B)$</li>\n<li>$\\log(A^B) = B*\\log(A)$</li>\n<li>$X &gt; 0 =&gt; \\log(X) &lt; X$</li>\n</ul>\n<h2 id=\"级数\"><a href=\"#级数\" class=\"headerlink\" title=\"级数\"></a>级数</h2><ul>\n<li>$\\sum_{i=0}^{N}A^i=(A^{N+1}-1)/(A-1)$</li>\n<li>$\\sum_{i=0}^{N}A^i&lt;=1/(1-A)$当$0&lt;A&lt;1$</li>\n<li>$\\sum_{i=1}^{N}i=(N+1)N/2\\approx N^2/2$</li>\n<li>$\\sum_{i=1}^{N}i^2=(N+1)(2N+1)N/6\\approx N^3/3$</li>\n<li>$\\sum_{i=1}^{N}i^k\\approx N^{k+1}/|K+1|,k\\ne -1$</li>\n<li>$H_N =\\sum_{i=1}^{N}(1/i)\\approx log_e(N),H_N $称为调和数</li>\n</ul>\n<h2 id=\"模运算\"><a href=\"#模运算\" class=\"headerlink\" title=\"模运算\"></a>模运算</h2><ul>\n<li>$(A \\mod N) = (B \\mod N) =&gt; N$整除$(A-B)$</li>\n<li>如果$M&gt;N$，则$M \\mod N &lt; M/2$</li>\n</ul>\n<p><strong>注：取模运算耗费很大</strong></p>\n<h2 id=\"数据结构证明常用方法\"><a href=\"#数据结构证明常用方法\" class=\"headerlink\" title=\"数据结构证明常用方法\"></a>数据结构证明常用方法</h2><ul>\n<li>归纳法：证明基准情形-&gt;归纳假设-&gt;证明下一个值也成立</li>\n<li>反例证明：举出反例</li>\n<li>反证法：假设定理不成立，然后证明某个已知的性质不成立，从而证明原假设是错误的</li>\n</ul>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>当一个函数用自身来定义时就称为递归的，编写递归例程需要遵循四条基本法则：</p>\n<ul>\n<li>基准情形：必须总有某些基准情形无需递归即可求解</li>\n<li>不断递进：递归调用总是朝着基准情形推进</li>\n<li>设计法则：假设所有的递归调用都能运行</li>\n<li>合成效益法则：求解一个问题同一实例时切勿在不同递归调用中做重复性工作（类似动态规划保存结果）</li>\n</ul>\n<h2 id=\"算法分析基础\"><a href=\"#算法分析基础\" class=\"headerlink\" title=\"算法分析基础\"></a>算法分析基础</h2><ul>\n<li>大$O$标记：如果存在正常数$c$以及$n_0$使得当$N&gt;=n_0$时$T(N)&lt;=cf(N)$，则记为$T(N)=O(f(N))$</li>\n<li>大$Ω$标记：如果存在正常数$c$以及$n_0$使得当$N&gt;=n_0$时$T(N)&gt;=cf(N)$,则记为$T(N)=Ω(f(N))$</li>\n<li>$Θ$标记：$T(N)=Θ(f(N))$当且仅当$T(N)=O(f(N))$ AND $T(N)=Ω(f(N))$</li>\n<li>小$o$标记：$T(N)=o(f(N))$当且仅当$T(N)=O(f(N)) AND T(N)!=Ω(f(N))$</li>\n<li>如果$T_1(N)=O(f(N))$且$T_2(N)=O(g(N))$<br>则$T_1(N)+T_2(N)=max(O(f(N)),O(g(N))), T_1(N)*T_2(N)=O(f(N)*g(N))$</li>\n<li>如果$T(N)$是一个$k$次多项式，则$T(N)=Θ(N^k)$</li>\n<li>对于任意$k,\\log^k(N)=O(N)$，表明对数增长十分缓慢</li>\n</ul>\n<h2 id=\"时间复杂度计算一般法则\"><a href=\"#时间复杂度计算一般法则\" class=\"headerlink\" title=\"时间复杂度计算一般法则\"></a>时间复杂度计算一般法则</h2><ul>\n<li>FOR循环：一次FOR循环的运行时间至多是该循环语句（包括测试）的运行时间乘以迭代的次数。</li>\n<li>嵌套的FOR循环：从里向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句运行时间乘以所有的FOR循环的大小的乘积。</li>\n<li>顺序语句：将各个语句的运行时间求和即可。</li>\n<li>IF/ELSE语句：IF/ELSE语句运行时间不超过判断再加上两部分运行时间长者的和。</li>\n<li>如果一个算法用常数时间将问题的的大小削减为其一部分，那么该算法就是$O(\\log(N))$；如果使用常数时间只是把问题减少一个常数，那么这种算法就是$O(N)$。</li>\n</ul>\n<h2 id=\"联机算法\"><a href=\"#联机算法\" class=\"headerlink\" title=\"联机算法\"></a>联机算法</h2><p>在任意时刻算法对要操作的数据只读入（扫描）一次，一旦被读入并处理，它就不需要在被记忆了。而在此处理过程中算法能对它已经读入的数据立即给出相应子序列问题的正确答案。仅需要常量空间并以线性时间运行的联机算法几乎是完美算法。</p>\n"},{"title":"数据结构简介","urlname":"data-structure-introduction","date":"2018-03-03T12:51:13.000Z","mathjax":true,"copyright":true,"_content":"## 前言\n数据结构是计算机内部组织、存储数据的方式，是相互之间存在一种或者多种关系的数据元素的集合。数据结构是一个二元组（D,R），其中D是数据元素的有限集，R是D上关系的集合。\n\n## 分类\n根据数据结构的定义，其可以按照数据元素之间的关系和内部物理存储来分类。  \n按照逻辑结构可以分为：\n\n- 集合：数据元素之间除同属一种类型外不存在其他关系\n- 线性结构：数据元素之间存在一对一的关系\n- 树形结构：数据元素之间存在一对多的关系\n- 图形结构：数据结构之间存在多对多的关系\n\n按照物理结构（又称存储结构）可分为：\n\n- 顺序存储：数据元素物理内存中按照顺序连续存放，每个存储节点只含有一个元素，相对位置即反应了元素之间的关系\n-  链式存储：数据元素在物理内存不要求空间连续，其每个节点除包含本身存储的数据外还需要包括一组指针（指针数量>=1），其指向反映数据元素之间的逻辑关系\n-  索引存储：数据元素存放在一组地址连续的空间中，同时还需要建立一个索引表用于索引存储节点或存储区间的位置\n-  散列存储：通过散列函数和冲突解决方法，将关键字散列在有限的地址空间中，散列函数计算出的值解释为关键字的元素存储位置\n\n## 常见数据结构\n\n- 数组（Array）\n- 链表（Linked List）\n- 堆栈（Stack）\n- 队列（Queue）\n- 树（Tree）\n- 图（Graph）\n- 堆（Heap）\n- 散列表（Hash）\n\n## 抽象数据类型（ADT）\n抽象数据类型（Abstract Data Type，简称ADT）是指一个数学模型以及定义在该模型上的一组操作。诸如表、集合、图和他们的操作一起可以看作是抽象数据类型。\n","source":"_posts/数据结构/数据结构简介.md","raw":"---\ntitle: 数据结构简介\nurlname: data-structure-introduction\ndate: 2018-03-3 20:51:13\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n## 前言\n数据结构是计算机内部组织、存储数据的方式，是相互之间存在一种或者多种关系的数据元素的集合。数据结构是一个二元组（D,R），其中D是数据元素的有限集，R是D上关系的集合。\n\n## 分类\n根据数据结构的定义，其可以按照数据元素之间的关系和内部物理存储来分类。  \n按照逻辑结构可以分为：\n\n- 集合：数据元素之间除同属一种类型外不存在其他关系\n- 线性结构：数据元素之间存在一对一的关系\n- 树形结构：数据元素之间存在一对多的关系\n- 图形结构：数据结构之间存在多对多的关系\n\n按照物理结构（又称存储结构）可分为：\n\n- 顺序存储：数据元素物理内存中按照顺序连续存放，每个存储节点只含有一个元素，相对位置即反应了元素之间的关系\n-  链式存储：数据元素在物理内存不要求空间连续，其每个节点除包含本身存储的数据外还需要包括一组指针（指针数量>=1），其指向反映数据元素之间的逻辑关系\n-  索引存储：数据元素存放在一组地址连续的空间中，同时还需要建立一个索引表用于索引存储节点或存储区间的位置\n-  散列存储：通过散列函数和冲突解决方法，将关键字散列在有限的地址空间中，散列函数计算出的值解释为关键字的元素存储位置\n\n## 常见数据结构\n\n- 数组（Array）\n- 链表（Linked List）\n- 堆栈（Stack）\n- 队列（Queue）\n- 树（Tree）\n- 图（Graph）\n- 堆（Heap）\n- 散列表（Hash）\n\n## 抽象数据类型（ADT）\n抽象数据类型（Abstract Data Type，简称ADT）是指一个数学模型以及定义在该模型上的一组操作。诸如表、集合、图和他们的操作一起可以看作是抽象数据类型。\n","slug":"数据结构/数据结构简介","published":1,"updated":"2018-06-13T14:05:06.245Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x400021gsvn4m5ea28y","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数据结构是计算机内部组织、存储数据的方式，是相互之间存在一种或者多种关系的数据元素的集合。数据结构是一个二元组（D,R），其中D是数据元素的有限集，R是D上关系的集合。</p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>根据数据结构的定义，其可以按照数据元素之间的关系和内部物理存储来分类。<br>按照逻辑结构可以分为：</p>\n<ul>\n<li>集合：数据元素之间除同属一种类型外不存在其他关系</li>\n<li>线性结构：数据元素之间存在一对一的关系</li>\n<li>树形结构：数据元素之间存在一对多的关系</li>\n<li>图形结构：数据结构之间存在多对多的关系</li>\n</ul>\n<p>按照物理结构（又称存储结构）可分为：</p>\n<ul>\n<li>顺序存储：数据元素物理内存中按照顺序连续存放，每个存储节点只含有一个元素，相对位置即反应了元素之间的关系</li>\n<li>链式存储：数据元素在物理内存不要求空间连续，其每个节点除包含本身存储的数据外还需要包括一组指针（指针数量&gt;=1），其指向反映数据元素之间的逻辑关系</li>\n<li>索引存储：数据元素存放在一组地址连续的空间中，同时还需要建立一个索引表用于索引存储节点或存储区间的位置</li>\n<li>散列存储：通过散列函数和冲突解决方法，将关键字散列在有限的地址空间中，散列函数计算出的值解释为关键字的元素存储位置</li>\n</ul>\n<h2 id=\"常见数据结构\"><a href=\"#常见数据结构\" class=\"headerlink\" title=\"常见数据结构\"></a>常见数据结构</h2><ul>\n<li>数组（Array）</li>\n<li>链表（Linked List）</li>\n<li>堆栈（Stack）</li>\n<li>队列（Queue）</li>\n<li>树（Tree）</li>\n<li>图（Graph）</li>\n<li>堆（Heap）</li>\n<li>散列表（Hash）</li>\n</ul>\n<h2 id=\"抽象数据类型（ADT）\"><a href=\"#抽象数据类型（ADT）\" class=\"headerlink\" title=\"抽象数据类型（ADT）\"></a>抽象数据类型（ADT）</h2><p>抽象数据类型（Abstract Data Type，简称ADT）是指一个数学模型以及定义在该模型上的一组操作。诸如表、集合、图和他们的操作一起可以看作是抽象数据类型。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数据结构是计算机内部组织、存储数据的方式，是相互之间存在一种或者多种关系的数据元素的集合。数据结构是一个二元组（D,R），其中D是数据元素的有限集，R是D上关系的集合。</p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>根据数据结构的定义，其可以按照数据元素之间的关系和内部物理存储来分类。<br>按照逻辑结构可以分为：</p>\n<ul>\n<li>集合：数据元素之间除同属一种类型外不存在其他关系</li>\n<li>线性结构：数据元素之间存在一对一的关系</li>\n<li>树形结构：数据元素之间存在一对多的关系</li>\n<li>图形结构：数据结构之间存在多对多的关系</li>\n</ul>\n<p>按照物理结构（又称存储结构）可分为：</p>\n<ul>\n<li>顺序存储：数据元素物理内存中按照顺序连续存放，每个存储节点只含有一个元素，相对位置即反应了元素之间的关系</li>\n<li>链式存储：数据元素在物理内存不要求空间连续，其每个节点除包含本身存储的数据外还需要包括一组指针（指针数量&gt;=1），其指向反映数据元素之间的逻辑关系</li>\n<li>索引存储：数据元素存放在一组地址连续的空间中，同时还需要建立一个索引表用于索引存储节点或存储区间的位置</li>\n<li>散列存储：通过散列函数和冲突解决方法，将关键字散列在有限的地址空间中，散列函数计算出的值解释为关键字的元素存储位置</li>\n</ul>\n<h2 id=\"常见数据结构\"><a href=\"#常见数据结构\" class=\"headerlink\" title=\"常见数据结构\"></a>常见数据结构</h2><ul>\n<li>数组（Array）</li>\n<li>链表（Linked List）</li>\n<li>堆栈（Stack）</li>\n<li>队列（Queue）</li>\n<li>树（Tree）</li>\n<li>图（Graph）</li>\n<li>堆（Heap）</li>\n<li>散列表（Hash）</li>\n</ul>\n<h2 id=\"抽象数据类型（ADT）\"><a href=\"#抽象数据类型（ADT）\" class=\"headerlink\" title=\"抽象数据类型（ADT）\"></a>抽象数据类型（ADT）</h2><p>抽象数据类型（Abstract Data Type，简称ADT）是指一个数学模型以及定义在该模型上的一组操作。诸如表、集合、图和他们的操作一起可以看作是抽象数据类型。</p>\n"},{"title":"表达式树的定义与后缀表达式构造表达式树","urlname":"expression-tree","date":"2018-03-08T06:59:25.000Z","mathjax":true,"copyright":true,"_content":"\n## 表达式树基础知识\n\n表达式树是一类树，其基本结构为所有的叶节点为操作树，非叶节点为操作符。如下图所示为一种表达式树：\n\n![表达式树](/images/expression-tree.png)\n\n对于二元操作符，其形成的操作树是一种二叉树。对二叉表达式树进行不同的遍历得到不同的的表达式，当进行前序遍历时，得到的表达式称为前缀表达式，如上图前缀表达式为++a\\*bc\\*+\\*defg；当进行中序遍历时，得到的表达式称为中缀表达式，也就是日常书写习惯的的表达式，上图中最表达式为(a+(b\\*c))+(((d\\*e)+f)\\*g)；当进行后序遍历时，得到的表达式为后缀表达式（又称逆波兰表示法），这种形式的表达式可以直接由栈结构实现计算，上图后缀表达式为abc\\*+de\\*f+g*+。\n\n## 后缀表达式构造表达式树\n\n给出一组后缀表达式，要求构造出一颗表达式。由于后缀表达式树是后序遍历得到的，根节点的访问是在左右子树的访问顺序之后，因此后缀表达式序列第一个操作符和前面两个操作数（第一个操作符之前两个数一定是操作数）的三个节点一定可以组合成一颗三节点表达式树，通过如此递归构建便可以完成整棵数的构建，基本思路如下：\n\n\t1. 读取符号序列，如果符号是操作数则新建一个节点的数并将地址压入栈中\n\t2. 如果符号是操作符，则新建一个以该符号为元素的节点后从栈中弹出两个元素分别作为左右子树然后压入栈中。\n\n\n## 后缀表达式构建表达式树实现\n\n根据上节的分析，为了方便，采用单字符表示数字与操作符，实现代码如下：\n\n```cpp\nstruct TreeNode\n{\n\tchar data;\n\tTreeNode *left;\n\tTreeNode *right;\n\tTreeNode(char inData): data(inData), left(nullptr), right(nullptr) {}\n};\n\n//true-操作符,false-操作数\nbool isOperator(char inCh)\n{\n\tif (inCh >= 'a' && inCh <= 'z') {\n\t\treturn false;\t\n\t}\n\treturn true;\n}\n\n\nTreeNode *BuildExpressionTree(const char *inExpression)\n{\n\tif (inExpression == nullptr || *inExpression == '\\0') {\n\t\treturn nullptr;\n\t}\n\tconst char *cycleIter = inExpression;\n\tstack<TreeNode *> treeStack;\n\twhile (*cycleIter != '\\0') {\n\t\tif (!isOperator(*cycleIter)) {\n\t\t\tTreeNode *newNode = new TreeNode(*cycleIter);\n\t\t\ttreeStack.push(newNode);\n\t\t}\n\t\telse {\n\t\t\tTreeNode *newNode = new TreeNode(*cycleIter);\n\t\t\tnewNode->right = treeStack.top(); treeStack.pop();\n\t\t\tnewNode->left = treeStack.top(); treeStack.pop();\n\t\t\ttreeStack.push(newNode);\n\t\t}\n\t\t++cycleIter;\n\t}\n\treturn treeStack.top();\n}\n```\n\n\n\n","source":"_posts/数据结构/表达式树的定义与实现.md","raw":"---\ntitle: 表达式树的定义与后缀表达式构造表达式树\nurlname: expression-tree\ndate: 2018-03-8 14:59:25\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 表达式树基础知识\n\n表达式树是一类树，其基本结构为所有的叶节点为操作树，非叶节点为操作符。如下图所示为一种表达式树：\n\n![表达式树](/images/expression-tree.png)\n\n对于二元操作符，其形成的操作树是一种二叉树。对二叉表达式树进行不同的遍历得到不同的的表达式，当进行前序遍历时，得到的表达式称为前缀表达式，如上图前缀表达式为++a\\*bc\\*+\\*defg；当进行中序遍历时，得到的表达式称为中缀表达式，也就是日常书写习惯的的表达式，上图中最表达式为(a+(b\\*c))+(((d\\*e)+f)\\*g)；当进行后序遍历时，得到的表达式为后缀表达式（又称逆波兰表示法），这种形式的表达式可以直接由栈结构实现计算，上图后缀表达式为abc\\*+de\\*f+g*+。\n\n## 后缀表达式构造表达式树\n\n给出一组后缀表达式，要求构造出一颗表达式。由于后缀表达式树是后序遍历得到的，根节点的访问是在左右子树的访问顺序之后，因此后缀表达式序列第一个操作符和前面两个操作数（第一个操作符之前两个数一定是操作数）的三个节点一定可以组合成一颗三节点表达式树，通过如此递归构建便可以完成整棵数的构建，基本思路如下：\n\n\t1. 读取符号序列，如果符号是操作数则新建一个节点的数并将地址压入栈中\n\t2. 如果符号是操作符，则新建一个以该符号为元素的节点后从栈中弹出两个元素分别作为左右子树然后压入栈中。\n\n\n## 后缀表达式构建表达式树实现\n\n根据上节的分析，为了方便，采用单字符表示数字与操作符，实现代码如下：\n\n```cpp\nstruct TreeNode\n{\n\tchar data;\n\tTreeNode *left;\n\tTreeNode *right;\n\tTreeNode(char inData): data(inData), left(nullptr), right(nullptr) {}\n};\n\n//true-操作符,false-操作数\nbool isOperator(char inCh)\n{\n\tif (inCh >= 'a' && inCh <= 'z') {\n\t\treturn false;\t\n\t}\n\treturn true;\n}\n\n\nTreeNode *BuildExpressionTree(const char *inExpression)\n{\n\tif (inExpression == nullptr || *inExpression == '\\0') {\n\t\treturn nullptr;\n\t}\n\tconst char *cycleIter = inExpression;\n\tstack<TreeNode *> treeStack;\n\twhile (*cycleIter != '\\0') {\n\t\tif (!isOperator(*cycleIter)) {\n\t\t\tTreeNode *newNode = new TreeNode(*cycleIter);\n\t\t\ttreeStack.push(newNode);\n\t\t}\n\t\telse {\n\t\t\tTreeNode *newNode = new TreeNode(*cycleIter);\n\t\t\tnewNode->right = treeStack.top(); treeStack.pop();\n\t\t\tnewNode->left = treeStack.top(); treeStack.pop();\n\t\t\ttreeStack.push(newNode);\n\t\t}\n\t\t++cycleIter;\n\t}\n\treturn treeStack.top();\n}\n```\n\n\n\n","slug":"数据结构/表达式树的定义与实现","published":1,"updated":"2018-06-13T14:07:25.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x420025gsvniypl70o4","content":"<h2 id=\"表达式树基础知识\"><a href=\"#表达式树基础知识\" class=\"headerlink\" title=\"表达式树基础知识\"></a>表达式树基础知识</h2><p>表达式树是一类树，其基本结构为所有的叶节点为操作树，非叶节点为操作符。如下图所示为一种表达式树：</p>\n<p><img src=\"/images/expression-tree.png\" alt=\"表达式树\"></p>\n<p>对于二元操作符，其形成的操作树是一种二叉树。对二叉表达式树进行不同的遍历得到不同的的表达式，当进行前序遍历时，得到的表达式称为前缀表达式，如上图前缀表达式为++a*bc*+*defg；当进行中序遍历时，得到的表达式称为中缀表达式，也就是日常书写习惯的的表达式，上图中最表达式为(a+(b*c))+(((d*e)+f)*g)；当进行后序遍历时，得到的表达式为后缀表达式（又称逆波兰表示法），这种形式的表达式可以直接由栈结构实现计算，上图后缀表达式为abc*+de*f+g*+。</p>\n<h2 id=\"后缀表达式构造表达式树\"><a href=\"#后缀表达式构造表达式树\" class=\"headerlink\" title=\"后缀表达式构造表达式树\"></a>后缀表达式构造表达式树</h2><p>给出一组后缀表达式，要求构造出一颗表达式。由于后缀表达式树是后序遍历得到的，根节点的访问是在左右子树的访问顺序之后，因此后缀表达式序列第一个操作符和前面两个操作数（第一个操作符之前两个数一定是操作数）的三个节点一定可以组合成一颗三节点表达式树，通过如此递归构建便可以完成整棵数的构建，基本思路如下：</p>\n<pre><code>1. 读取符号序列，如果符号是操作数则新建一个节点的数并将地址压入栈中\n2. 如果符号是操作符，则新建一个以该符号为元素的节点后从栈中弹出两个元素分别作为左右子树然后压入栈中。\n</code></pre><h2 id=\"后缀表达式构建表达式树实现\"><a href=\"#后缀表达式构建表达式树实现\" class=\"headerlink\" title=\"后缀表达式构建表达式树实现\"></a>后缀表达式构建表达式树实现</h2><p>根据上节的分析，为了方便，采用单字符表示数字与操作符，实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\tTreeNode *left;</span><br><span class=\"line\">\tTreeNode *right;</span><br><span class=\"line\">\tTreeNode(<span class=\"keyword\">char</span> inData): data(inData), left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//true-操作符,false-操作数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isOperator</span><span class=\"params\">(<span class=\"keyword\">char</span> inCh)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inCh &gt;= <span class=\"string\">'a'</span> &amp;&amp; inCh &lt;= <span class=\"string\">'z'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">BuildExpressionTree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *inExpression)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inExpression == <span class=\"literal\">nullptr</span> || *inExpression == <span class=\"string\">'\\0'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cycleIter = inExpression;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;TreeNode *&gt; treeStack;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*cycleIter != <span class=\"string\">'\\0'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isOperator(*cycleIter)) &#123;</span><br><span class=\"line\">\t\t\tTreeNode *newNode = <span class=\"keyword\">new</span> TreeNode(*cycleIter);</span><br><span class=\"line\">\t\t\ttreeStack.push(newNode);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tTreeNode *newNode = <span class=\"keyword\">new</span> TreeNode(*cycleIter);</span><br><span class=\"line\">\t\t\tnewNode-&gt;right = treeStack.top(); treeStack.pop();</span><br><span class=\"line\">\t\t\tnewNode-&gt;left = treeStack.top(); treeStack.pop();</span><br><span class=\"line\">\t\t\ttreeStack.push(newNode);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t++cycleIter;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"表达式树基础知识\"><a href=\"#表达式树基础知识\" class=\"headerlink\" title=\"表达式树基础知识\"></a>表达式树基础知识</h2><p>表达式树是一类树，其基本结构为所有的叶节点为操作树，非叶节点为操作符。如下图所示为一种表达式树：</p>\n<p><img src=\"/images/expression-tree.png\" alt=\"表达式树\"></p>\n<p>对于二元操作符，其形成的操作树是一种二叉树。对二叉表达式树进行不同的遍历得到不同的的表达式，当进行前序遍历时，得到的表达式称为前缀表达式，如上图前缀表达式为++a*bc*+*defg；当进行中序遍历时，得到的表达式称为中缀表达式，也就是日常书写习惯的的表达式，上图中最表达式为(a+(b*c))+(((d*e)+f)*g)；当进行后序遍历时，得到的表达式为后缀表达式（又称逆波兰表示法），这种形式的表达式可以直接由栈结构实现计算，上图后缀表达式为abc*+de*f+g*+。</p>\n<h2 id=\"后缀表达式构造表达式树\"><a href=\"#后缀表达式构造表达式树\" class=\"headerlink\" title=\"后缀表达式构造表达式树\"></a>后缀表达式构造表达式树</h2><p>给出一组后缀表达式，要求构造出一颗表达式。由于后缀表达式树是后序遍历得到的，根节点的访问是在左右子树的访问顺序之后，因此后缀表达式序列第一个操作符和前面两个操作数（第一个操作符之前两个数一定是操作数）的三个节点一定可以组合成一颗三节点表达式树，通过如此递归构建便可以完成整棵数的构建，基本思路如下：</p>\n<pre><code>1. 读取符号序列，如果符号是操作数则新建一个节点的数并将地址压入栈中\n2. 如果符号是操作符，则新建一个以该符号为元素的节点后从栈中弹出两个元素分别作为左右子树然后压入栈中。\n</code></pre><h2 id=\"后缀表达式构建表达式树实现\"><a href=\"#后缀表达式构建表达式树实现\" class=\"headerlink\" title=\"后缀表达式构建表达式树实现\"></a>后缀表达式构建表达式树实现</h2><p>根据上节的分析，为了方便，采用单字符表示数字与操作符，实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\tTreeNode *left;</span><br><span class=\"line\">\tTreeNode *right;</span><br><span class=\"line\">\tTreeNode(<span class=\"keyword\">char</span> inData): data(inData), left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//true-操作符,false-操作数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isOperator</span><span class=\"params\">(<span class=\"keyword\">char</span> inCh)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inCh &gt;= <span class=\"string\">'a'</span> &amp;&amp; inCh &lt;= <span class=\"string\">'z'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">BuildExpressionTree</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *inExpression)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inExpression == <span class=\"literal\">nullptr</span> || *inExpression == <span class=\"string\">'\\0'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cycleIter = inExpression;</span><br><span class=\"line\">\t<span class=\"built_in\">stack</span>&lt;TreeNode *&gt; treeStack;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*cycleIter != <span class=\"string\">'\\0'</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isOperator(*cycleIter)) &#123;</span><br><span class=\"line\">\t\t\tTreeNode *newNode = <span class=\"keyword\">new</span> TreeNode(*cycleIter);</span><br><span class=\"line\">\t\t\ttreeStack.push(newNode);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tTreeNode *newNode = <span class=\"keyword\">new</span> TreeNode(*cycleIter);</span><br><span class=\"line\">\t\t\tnewNode-&gt;right = treeStack.top(); treeStack.pop();</span><br><span class=\"line\">\t\t\tnewNode-&gt;left = treeStack.top(); treeStack.pop();</span><br><span class=\"line\">\t\t\ttreeStack.push(newNode);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t++cycleIter;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"最大连续子序列和问题","urlname":"max-subsequence-sum","date":"2018-05-29T09:20:20.000Z","copyright":true,"mathjax":true,"_content":"\n## 问题描述\n\n给定整数序列$A_1,A_2,A_3...A_N$，求$\\sum_{k=i}^jA_k$的最大值（约定如果所有整数均为负数则最大和为0）。最大子序列和问题既是根据给出的数列抽取某段连续子数列使其和为最大。《数据结构与算法分析：C语言描述》一书中给出了四种解法，以下分别分析实现。\n\n## 穷举法\n\n穷举法的含义是求出所有子序列的和然后比较得出最大的连续子序列和。对于一个序列字串数量$C_n^2+n+1=n(n+1)/2+1$，其中$C_n^2$是子序列元素数量大于等于2的子序列个数，$n$为元素数量为1得子序列个数，1为空子序列。故穷举法需要计算$O(N^2)$数量的子序列和，而每个子序列需要遍历其中所有的元素进行累加，因此不难推算出穷举法的时间复杂度为$O(N^3)$。以下为穷举法实现的C++算法。\n\n```cpp\n#include <vector>\n#include <numeric>\nusing std::vector;\n\nint BruteAlgorithm(const vector<int> &inArray)\n{\n        int maxSum = 0;\n        for (size_t i = 0; i < inArray.size(); i++) {\n                for (size_t j = i; j < inArray.size(); j++) {\n                        int tmpSum = accumulate(inArray.begin() + i, inArray.begin() + j + 1, 0);\n                        maxSum = maxSum > tmpSum ? maxSum : tmpSum;\n                }\n        }\n        return maxSum;\n}\n```\n\n## 穷举法优化\n\n通过观察穷举法最内层代码我们知道`accumulate`函数每次均从下标`i`开始累加，前面计算得到的结果完全没有利用到，如果保存上一步计算得到的结果便可以有效地降低时间复杂度，实现代码如下：\n\n```cpp\n#include <vector>\n#include <numeric>\nusing std::vector;\n\nint BruteOptimize(const vector<int> &inArray)\n{\n        int maxSum = 0;\n        for (size_t i = 0; i < inArray.size(); i++) {\n                int tmpSum = 0;\n                for (size_t j = i; j < inArray.size(); j++) {\n                        tmpSum += inArray[j];\n                        maxSum = maxSum > tmpSum ? maxSum : tmpSum;\n                }\n        }\n        return maxSum;\n}\n```\n\n上述代码直接把时间复杂度降低到$O(N^2)$\n\n## 分治递归解法\n\n按照教材的解法，其基本思想是将序列二分，最大连续子序列和只会出现在三个位置：左半边、右半边以及中间位置，因此可以通过分治法计算子序列和，递归终止条件是待计算序列中只含有一个元素。具体实现代码如下：\n\n```cpp\n/*start指向第一个元素，end指向最后一个元素的下一个元素*/\nint DivideConquerCore(const vector<int> &inArray, int start, int end)\n{\n        if (end - start <= 1) {\n                return inArray[start] > 0 ? inArray[start] : 0;\n        }\n        int middle = start + (end-start)/2;\n        int maxLeftSum = DivideConquerCore(inArray, start, middle);\n        int maxRightSum = DivideConquerCore(inArray, middle, end);\n\n        int tmpSum = 0;\n\n        int centerLeftSum = 0;\n        for (int i = middle - 1; i >= start; i--) {\n                tmpSum += inArray[i];\n                centerLeftSum = centerLeftSum > tmpSum ? centerLeftSum : tmpSum;\n        }\n\n        tmpSum = 0;\n        int centerRightSum = 0;\n        for (int i = middle; i < end; i++) {\n                tmpSum += inArray[i];\n                centerRightSum = centerRightSum > tmpSum ? centerRightSum : tmpSum;\n        }\n\n        int centerSum = centerLeftSum + centerRightSum;\n\n        int maxSum = maxLeftSum > maxRightSum ? maxLeftSum : maxRightSum;\n        maxSum = maxSum > centerSum ? maxSum : centerSum;\n        return maxSum;\n}\n\nint DCAlgorithm(const vector<int> &inArray)\n{\n        return DivideConquerCore(inArray, 0, int(inArray.size()));\n}\n```\n\n上述算法时间复杂度递推式为$T(N)=2T(N/2)+N$易得出时间复杂度为$O(N\\log(N))$\n\n\n## 动态规划解法\n\n动态规划是前人在优化暴力穷举法中通过观察找到优化规律而得出的一种优化思路。前人观察到暴力求解中有大量的重复计算，如果可以减少这些重复计算便可以提高算法性能。考虑到连续子序列问题的连续性特点，我们在扫描数组时维持一个连续子序列，然后考察当前扫描的元素能否加入该子序列或者另起一个新序列。如果当前维持的子序列和加上当前扫描的元素总和大于该元素，则该元素加入该序列中，否则另起新序列（保证下一个元素可以加入序列），同时记录当前序列的和，该元素成为新序列的第一个元素。将上述思路以通过循环不变式的方式证明如下：  \n1. 初始化：扫描数组第一个元素加入到维持的序列中即$[a_0]$，此时记录的一个连续子序列和为$S_0$；\n2. 保持：判断当前扫描元素与保持序列和关系，导致两种情况：$[a_0,a_1]$和$[a_1]$，和记为$S_1$。无论那种情况，在扫描下一个元素时我们依旧可以保证**当前维持的序列可以和下一个元素合并（保证连续性）且是最好的序列**；\n3. 终止：记录了$N$个$S_i$值，找出最大值作为结果返回。\n\n上述思路的代码实现如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\nint DPAlgorithm(const vector<int> &inArray)\n{\n        vector<int> SArray(inArray.size(), 0);\n        SArray[0] = inArray[0];\n        for (size_t i = 1; i < inArray.size(); i++) {\n                if (SArray[i-1] + inArray[i] < inArray[i]) {\n                        /*更换序列*/\n                        SArray[i] = inArray[i];\n                }\n                else {\n                        SArray[i] = SArray[i-1]+inArray[i];\n                }\n        }\n        int maxSum = 0;\n        for (size_t i = 0; i < SArray.size(); i++) {\n                maxSum = maxSum > SArray[i] ? maxSum : SArray[i];\n        }\n        return maxSum;\n}\n```\n\n## 动态规划优化\n\n通过观察上述代码，我们已经把时间复杂度优化到了$O(N)$了，但是使用了$O(N)$的空间，这是因为我们保存了维持序列过程中产生的所有和，但是代码中下一个和只与上一个和以及当前扫描元素有关，因此我们只保存上一个和以及不断更新最大和值，代码如下所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\nint DPOptimize(const vector<int> &inArray)\n{\n        int maxSum = 0;\n        int lastSum = inArray[0];\n        for (size_t i = 1; i < inArray.size(); i++) {\n                maxSum = maxSum > lastSum ? maxSum : lastSum;\n                if (lastSum + inArray[i] < inArray[i]) {\n                        /*更换序列*/\n                        lastSum = inArray[i];\n                }\n                else {\n                        lastSum = lastSum+inArray[i];\n                }\n        }\n        return maxSum;\n}\n```\n\n## 算法测试\n\n上述算法的测试代码如下，随机生成一段数列，然后调用每个函数进行测试，为了测试代码正确性，我们直接抄录书上的代码作为测试基准，教材实现代码如下`MaxSubsequenceSum`函数所示\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint MaxSubsequenceSum(const int A[], int N)\n{\n        int ThisSum, MaxSum, j;\n        ThisSum = MaxSum = 0;\n        for (j = 0; j < N; j++) {\n                ThisSum += A[j];\n                if (ThisSum > MaxSum) {\n                        MaxSum = ThisSum;\n                }\n                else if (ThisSum < 0) {\n                        ThisSum = 0;\n                }\n        }\n        return MaxSum;\n}\n\nint main()\n{\n\tconst int testNum[] = { 10, 100, 1000, 10000, 100000, 1000000, 10000000 };\n\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<int> intDis(int(-10e4), int(10e4));\n\n        int testTimes = 5;\n\n\twhile ((testTimes--) > 0) {\n                for (size_t i = 0; i < sizeof(testNum) / sizeof(testNum[0]); i++) {\n                        vector<int> testData1;\n                        int *testData2 = new int[testNum[i]];\n\n                        for (int j = 0; j < testNum[i]; j++) {\n                                int tmp = intDis(randEngine);\n                                testData1.push_back(tmp);\n                                testData2[j] = tmp;\n                        }\n\n                        auto startTime = system_clock::now();\n\n                        int maxSum = -1;\n                        //maxSum = DPOptimize(testData1); /*调用具体的算法*/\n\n                        auto endTime = system_clock::now();\n\n                        int correctSum = MaxSubsequenceSum(testData2, int(testNum[i]));\n\n                        cout << ((maxSum == correctSum) ? \"Correct;\" : \"Wrong;\");\n\n                        auto duration = duration_cast<microseconds>(endTime - startTime);\n                        cout << \"TimeCost:\" << duration.count() << endl;\n                        delete [] testData2;\n                }\n        }\n\treturn 0;\n}\n```\n\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","source":"_posts/算法设计/最大连续子序列和.md","raw":"---\ntitle: 最大连续子序列和问题\nurlname: max-subsequence-sum\ndate: 2018-05-29 17:20:20\ncopyright: true\nmathjax: true\ntags:\n- 算法设计\ncategories:\n- 算法设计\n---\n\n## 问题描述\n\n给定整数序列$A_1,A_2,A_3...A_N$，求$\\sum_{k=i}^jA_k$的最大值（约定如果所有整数均为负数则最大和为0）。最大子序列和问题既是根据给出的数列抽取某段连续子数列使其和为最大。《数据结构与算法分析：C语言描述》一书中给出了四种解法，以下分别分析实现。\n\n## 穷举法\n\n穷举法的含义是求出所有子序列的和然后比较得出最大的连续子序列和。对于一个序列字串数量$C_n^2+n+1=n(n+1)/2+1$，其中$C_n^2$是子序列元素数量大于等于2的子序列个数，$n$为元素数量为1得子序列个数，1为空子序列。故穷举法需要计算$O(N^2)$数量的子序列和，而每个子序列需要遍历其中所有的元素进行累加，因此不难推算出穷举法的时间复杂度为$O(N^3)$。以下为穷举法实现的C++算法。\n\n```cpp\n#include <vector>\n#include <numeric>\nusing std::vector;\n\nint BruteAlgorithm(const vector<int> &inArray)\n{\n        int maxSum = 0;\n        for (size_t i = 0; i < inArray.size(); i++) {\n                for (size_t j = i; j < inArray.size(); j++) {\n                        int tmpSum = accumulate(inArray.begin() + i, inArray.begin() + j + 1, 0);\n                        maxSum = maxSum > tmpSum ? maxSum : tmpSum;\n                }\n        }\n        return maxSum;\n}\n```\n\n## 穷举法优化\n\n通过观察穷举法最内层代码我们知道`accumulate`函数每次均从下标`i`开始累加，前面计算得到的结果完全没有利用到，如果保存上一步计算得到的结果便可以有效地降低时间复杂度，实现代码如下：\n\n```cpp\n#include <vector>\n#include <numeric>\nusing std::vector;\n\nint BruteOptimize(const vector<int> &inArray)\n{\n        int maxSum = 0;\n        for (size_t i = 0; i < inArray.size(); i++) {\n                int tmpSum = 0;\n                for (size_t j = i; j < inArray.size(); j++) {\n                        tmpSum += inArray[j];\n                        maxSum = maxSum > tmpSum ? maxSum : tmpSum;\n                }\n        }\n        return maxSum;\n}\n```\n\n上述代码直接把时间复杂度降低到$O(N^2)$\n\n## 分治递归解法\n\n按照教材的解法，其基本思想是将序列二分，最大连续子序列和只会出现在三个位置：左半边、右半边以及中间位置，因此可以通过分治法计算子序列和，递归终止条件是待计算序列中只含有一个元素。具体实现代码如下：\n\n```cpp\n/*start指向第一个元素，end指向最后一个元素的下一个元素*/\nint DivideConquerCore(const vector<int> &inArray, int start, int end)\n{\n        if (end - start <= 1) {\n                return inArray[start] > 0 ? inArray[start] : 0;\n        }\n        int middle = start + (end-start)/2;\n        int maxLeftSum = DivideConquerCore(inArray, start, middle);\n        int maxRightSum = DivideConquerCore(inArray, middle, end);\n\n        int tmpSum = 0;\n\n        int centerLeftSum = 0;\n        for (int i = middle - 1; i >= start; i--) {\n                tmpSum += inArray[i];\n                centerLeftSum = centerLeftSum > tmpSum ? centerLeftSum : tmpSum;\n        }\n\n        tmpSum = 0;\n        int centerRightSum = 0;\n        for (int i = middle; i < end; i++) {\n                tmpSum += inArray[i];\n                centerRightSum = centerRightSum > tmpSum ? centerRightSum : tmpSum;\n        }\n\n        int centerSum = centerLeftSum + centerRightSum;\n\n        int maxSum = maxLeftSum > maxRightSum ? maxLeftSum : maxRightSum;\n        maxSum = maxSum > centerSum ? maxSum : centerSum;\n        return maxSum;\n}\n\nint DCAlgorithm(const vector<int> &inArray)\n{\n        return DivideConquerCore(inArray, 0, int(inArray.size()));\n}\n```\n\n上述算法时间复杂度递推式为$T(N)=2T(N/2)+N$易得出时间复杂度为$O(N\\log(N))$\n\n\n## 动态规划解法\n\n动态规划是前人在优化暴力穷举法中通过观察找到优化规律而得出的一种优化思路。前人观察到暴力求解中有大量的重复计算，如果可以减少这些重复计算便可以提高算法性能。考虑到连续子序列问题的连续性特点，我们在扫描数组时维持一个连续子序列，然后考察当前扫描的元素能否加入该子序列或者另起一个新序列。如果当前维持的子序列和加上当前扫描的元素总和大于该元素，则该元素加入该序列中，否则另起新序列（保证下一个元素可以加入序列），同时记录当前序列的和，该元素成为新序列的第一个元素。将上述思路以通过循环不变式的方式证明如下：  \n1. 初始化：扫描数组第一个元素加入到维持的序列中即$[a_0]$，此时记录的一个连续子序列和为$S_0$；\n2. 保持：判断当前扫描元素与保持序列和关系，导致两种情况：$[a_0,a_1]$和$[a_1]$，和记为$S_1$。无论那种情况，在扫描下一个元素时我们依旧可以保证**当前维持的序列可以和下一个元素合并（保证连续性）且是最好的序列**；\n3. 终止：记录了$N$个$S_i$值，找出最大值作为结果返回。\n\n上述思路的代码实现如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\nint DPAlgorithm(const vector<int> &inArray)\n{\n        vector<int> SArray(inArray.size(), 0);\n        SArray[0] = inArray[0];\n        for (size_t i = 1; i < inArray.size(); i++) {\n                if (SArray[i-1] + inArray[i] < inArray[i]) {\n                        /*更换序列*/\n                        SArray[i] = inArray[i];\n                }\n                else {\n                        SArray[i] = SArray[i-1]+inArray[i];\n                }\n        }\n        int maxSum = 0;\n        for (size_t i = 0; i < SArray.size(); i++) {\n                maxSum = maxSum > SArray[i] ? maxSum : SArray[i];\n        }\n        return maxSum;\n}\n```\n\n## 动态规划优化\n\n通过观察上述代码，我们已经把时间复杂度优化到了$O(N)$了，但是使用了$O(N)$的空间，这是因为我们保存了维持序列过程中产生的所有和，但是代码中下一个和只与上一个和以及当前扫描元素有关，因此我们只保存上一个和以及不断更新最大和值，代码如下所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\nint DPOptimize(const vector<int> &inArray)\n{\n        int maxSum = 0;\n        int lastSum = inArray[0];\n        for (size_t i = 1; i < inArray.size(); i++) {\n                maxSum = maxSum > lastSum ? maxSum : lastSum;\n                if (lastSum + inArray[i] < inArray[i]) {\n                        /*更换序列*/\n                        lastSum = inArray[i];\n                }\n                else {\n                        lastSum = lastSum+inArray[i];\n                }\n        }\n        return maxSum;\n}\n```\n\n## 算法测试\n\n上述算法的测试代码如下，随机生成一段数列，然后调用每个函数进行测试，为了测试代码正确性，我们直接抄录书上的代码作为测试基准，教材实现代码如下`MaxSubsequenceSum`函数所示\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint MaxSubsequenceSum(const int A[], int N)\n{\n        int ThisSum, MaxSum, j;\n        ThisSum = MaxSum = 0;\n        for (j = 0; j < N; j++) {\n                ThisSum += A[j];\n                if (ThisSum > MaxSum) {\n                        MaxSum = ThisSum;\n                }\n                else if (ThisSum < 0) {\n                        ThisSum = 0;\n                }\n        }\n        return MaxSum;\n}\n\nint main()\n{\n\tconst int testNum[] = { 10, 100, 1000, 10000, 100000, 1000000, 10000000 };\n\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<int> intDis(int(-10e4), int(10e4));\n\n        int testTimes = 5;\n\n\twhile ((testTimes--) > 0) {\n                for (size_t i = 0; i < sizeof(testNum) / sizeof(testNum[0]); i++) {\n                        vector<int> testData1;\n                        int *testData2 = new int[testNum[i]];\n\n                        for (int j = 0; j < testNum[i]; j++) {\n                                int tmp = intDis(randEngine);\n                                testData1.push_back(tmp);\n                                testData2[j] = tmp;\n                        }\n\n                        auto startTime = system_clock::now();\n\n                        int maxSum = -1;\n                        //maxSum = DPOptimize(testData1); /*调用具体的算法*/\n\n                        auto endTime = system_clock::now();\n\n                        int correctSum = MaxSubsequenceSum(testData2, int(testNum[i]));\n\n                        cout << ((maxSum == correctSum) ? \"Correct;\" : \"Wrong;\");\n\n                        auto duration = duration_cast<microseconds>(endTime - startTime);\n                        cout << \"TimeCost:\" << duration.count() << endl;\n                        delete [] testData2;\n                }\n        }\n\treturn 0;\n}\n```\n\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n","slug":"算法设计/最大连续子序列和","published":1,"updated":"2018-06-13T14:18:17.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x430028gsvnl74sdfyx","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>给定整数序列$A_1,A_2,A_3…A_N$，求$\\sum_{k=i}^jA_k$的最大值（约定如果所有整数均为负数则最大和为0）。最大子序列和问题既是根据给出的数列抽取某段连续子数列使其和为最大。《数据结构与算法分析：C语言描述》一书中给出了四种解法，以下分别分析实现。</p>\n<h2 id=\"穷举法\"><a href=\"#穷举法\" class=\"headerlink\" title=\"穷举法\"></a>穷举法</h2><p>穷举法的含义是求出所有子序列的和然后比较得出最大的连续子序列和。对于一个序列字串数量$C_n^2+n+1=n(n+1)/2+1$，其中$C_n^2$是子序列元素数量大于等于2的子序列个数，$n$为元素数量为1得子序列个数，1为空子序列。故穷举法需要计算$O(N^2)$数量的子序列和，而每个子序列需要遍历其中所有的元素进行累加，因此不难推算出穷举法的时间复杂度为$O(N^3)$。以下为穷举法实现的C++算法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BruteAlgorithm</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = i; j &lt; inArray.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmpSum = accumulate(inArray.begin() + i, inArray.begin() + j + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                        maxSum = maxSum &gt; tmpSum ? maxSum : tmpSum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"穷举法优化\"><a href=\"#穷举法优化\" class=\"headerlink\" title=\"穷举法优化\"></a>穷举法优化</h2><p>通过观察穷举法最内层代码我们知道<code>accumulate</code>函数每次均从下标<code>i</code>开始累加，前面计算得到的结果完全没有利用到，如果保存上一步计算得到的结果便可以有效地降低时间复杂度，实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BruteOptimize</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmpSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = i; j &lt; inArray.size(); j++) &#123;</span><br><span class=\"line\">                        tmpSum += inArray[j];</span><br><span class=\"line\">                        maxSum = maxSum &gt; tmpSum ? maxSum : tmpSum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码直接把时间复杂度降低到$O(N^2)$</p>\n<h2 id=\"分治递归解法\"><a href=\"#分治递归解法\" class=\"headerlink\" title=\"分治递归解法\"></a>分治递归解法</h2><p>按照教材的解法，其基本思想是将序列二分，最大连续子序列和只会出现在三个位置：左半边、右半边以及中间位置，因此可以通过分治法计算子序列和，递归终止条件是待计算序列中只含有一个元素。具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*start指向第一个元素，end指向最后一个元素的下一个元素*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DivideConquerCore</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (end - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inArray[start] &gt; <span class=\"number\">0</span> ? inArray[start] : <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> middle = start + (end-start)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxLeftSum = DivideConquerCore(inArray, start, middle);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxRightSum = DivideConquerCore(inArray, middle, end);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmpSum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> centerLeftSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = middle - <span class=\"number\">1</span>; i &gt;= start; i--) &#123;</span><br><span class=\"line\">                tmpSum += inArray[i];</span><br><span class=\"line\">                centerLeftSum = centerLeftSum &gt; tmpSum ? centerLeftSum : tmpSum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tmpSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> centerRightSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = middle; i &lt; end; i++) &#123;</span><br><span class=\"line\">                tmpSum += inArray[i];</span><br><span class=\"line\">                centerRightSum = centerRightSum &gt; tmpSum ? centerRightSum : tmpSum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> centerSum = centerLeftSum + centerRightSum;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = maxLeftSum &gt; maxRightSum ? maxLeftSum : maxRightSum;</span><br><span class=\"line\">        maxSum = maxSum &gt; centerSum ? maxSum : centerSum;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DCAlgorithm</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DivideConquerCore(inArray, <span class=\"number\">0</span>, <span class=\"keyword\">int</span>(inArray.size()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述算法时间复杂度递推式为$T(N)=2T(N/2)+N$易得出时间复杂度为$O(N\\log(N))$</p>\n<h2 id=\"动态规划解法\"><a href=\"#动态规划解法\" class=\"headerlink\" title=\"动态规划解法\"></a>动态规划解法</h2><p>动态规划是前人在优化暴力穷举法中通过观察找到优化规律而得出的一种优化思路。前人观察到暴力求解中有大量的重复计算，如果可以减少这些重复计算便可以提高算法性能。考虑到连续子序列问题的连续性特点，我们在扫描数组时维持一个连续子序列，然后考察当前扫描的元素能否加入该子序列或者另起一个新序列。如果当前维持的子序列和加上当前扫描的元素总和大于该元素，则该元素加入该序列中，否则另起新序列（保证下一个元素可以加入序列），同时记录当前序列的和，该元素成为新序列的第一个元素。将上述思路以通过循环不变式的方式证明如下：  </p>\n<ol>\n<li>初始化：扫描数组第一个元素加入到维持的序列中即$[a_0]$，此时记录的一个连续子序列和为$S_0$；</li>\n<li>保持：判断当前扫描元素与保持序列和关系，导致两种情况：$[a_0,a_1]$和$[a_1]$，和记为$S_1$。无论那种情况，在扫描下一个元素时我们依旧可以保证<strong>当前维持的序列可以和下一个元素合并（保证连续性）且是最好的序列</strong>；</li>\n<li>终止：记录了$N$个$S_i$值，找出最大值作为结果返回。</li>\n</ol>\n<p>上述思路的代码实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DPAlgorithm</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; SArray(inArray.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        SArray[<span class=\"number\">0</span>] = inArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (SArray[i<span class=\"number\">-1</span>] + inArray[i] &lt; inArray[i]) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*更换序列*/</span></span><br><span class=\"line\">                        SArray[i] = inArray[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        SArray[i] = SArray[i<span class=\"number\">-1</span>]+inArray[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; SArray.size(); i++) &#123;</span><br><span class=\"line\">                maxSum = maxSum &gt; SArray[i] ? maxSum : SArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态规划优化\"><a href=\"#动态规划优化\" class=\"headerlink\" title=\"动态规划优化\"></a>动态规划优化</h2><p>通过观察上述代码，我们已经把时间复杂度优化到了$O(N)$了，但是使用了$O(N)$的空间，这是因为我们保存了维持序列过程中产生的所有和，但是代码中下一个和只与上一个和以及当前扫描元素有关，因此我们只保存上一个和以及不断更新最大和值，代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DPOptimize</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lastSum = inArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">                maxSum = maxSum &gt; lastSum ? maxSum : lastSum;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lastSum + inArray[i] &lt; inArray[i]) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*更换序列*/</span></span><br><span class=\"line\">                        lastSum = inArray[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        lastSum = lastSum+inArray[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"算法测试\"><a href=\"#算法测试\" class=\"headerlink\" title=\"算法测试\"></a>算法测试</h2><p>上述算法的测试代码如下，随机生成一段数列，然后调用每个函数进行测试，为了测试代码正确性，我们直接抄录书上的代码作为测试基准，教材实现代码如下<code>MaxSubsequenceSum</code>函数所示</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubsequenceSum</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ThisSum, MaxSum, j;</span><br><span class=\"line\">        ThisSum = MaxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; N; j++) &#123;</span><br><span class=\"line\">                ThisSum += A[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ThisSum &gt; MaxSum) &#123;</span><br><span class=\"line\">                        MaxSum = ThisSum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ThisSum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        ThisSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> testNum[] = &#123; <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-10e4</span>), <span class=\"keyword\">int</span>(<span class=\"number\">10e4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(testNum) / <span class=\"keyword\">sizeof</span>(testNum[<span class=\"number\">0</span>]); i++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; testData1;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> *testData2 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[testNum[i]];</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; testNum[i]; j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> tmp = intDis(randEngine);</span><br><span class=\"line\">                                testData1.push_back(tmp);</span><br><span class=\"line\">                                testData2[j] = tmp;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                        <span class=\"comment\">//maxSum = DPOptimize(testData1); /*调用具体的算法*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> correctSum = MaxSubsequenceSum(testData2, <span class=\"keyword\">int</span>(testNum[i]));</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; ((maxSum == correctSum) ? <span class=\"string\">\"Correct;\"</span> : <span class=\"string\">\"Wrong;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">delete</span> [] testData2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>给定整数序列$A_1,A_2,A_3…A_N$，求$\\sum_{k=i}^jA_k$的最大值（约定如果所有整数均为负数则最大和为0）。最大子序列和问题既是根据给出的数列抽取某段连续子数列使其和为最大。《数据结构与算法分析：C语言描述》一书中给出了四种解法，以下分别分析实现。</p>\n<h2 id=\"穷举法\"><a href=\"#穷举法\" class=\"headerlink\" title=\"穷举法\"></a>穷举法</h2><p>穷举法的含义是求出所有子序列的和然后比较得出最大的连续子序列和。对于一个序列字串数量$C_n^2+n+1=n(n+1)/2+1$，其中$C_n^2$是子序列元素数量大于等于2的子序列个数，$n$为元素数量为1得子序列个数，1为空子序列。故穷举法需要计算$O(N^2)$数量的子序列和，而每个子序列需要遍历其中所有的元素进行累加，因此不难推算出穷举法的时间复杂度为$O(N^3)$。以下为穷举法实现的C++算法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BruteAlgorithm</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = i; j &lt; inArray.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmpSum = accumulate(inArray.begin() + i, inArray.begin() + j + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                        maxSum = maxSum &gt; tmpSum ? maxSum : tmpSum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"穷举法优化\"><a href=\"#穷举法优化\" class=\"headerlink\" title=\"穷举法优化\"></a>穷举法优化</h2><p>通过观察穷举法最内层代码我们知道<code>accumulate</code>函数每次均从下标<code>i</code>开始累加，前面计算得到的结果完全没有利用到，如果保存上一步计算得到的结果便可以有效地降低时间复杂度，实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BruteOptimize</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmpSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = i; j &lt; inArray.size(); j++) &#123;</span><br><span class=\"line\">                        tmpSum += inArray[j];</span><br><span class=\"line\">                        maxSum = maxSum &gt; tmpSum ? maxSum : tmpSum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码直接把时间复杂度降低到$O(N^2)$</p>\n<h2 id=\"分治递归解法\"><a href=\"#分治递归解法\" class=\"headerlink\" title=\"分治递归解法\"></a>分治递归解法</h2><p>按照教材的解法，其基本思想是将序列二分，最大连续子序列和只会出现在三个位置：左半边、右半边以及中间位置，因此可以通过分治法计算子序列和，递归终止条件是待计算序列中只含有一个元素。具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*start指向第一个元素，end指向最后一个元素的下一个元素*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DivideConquerCore</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (end - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inArray[start] &gt; <span class=\"number\">0</span> ? inArray[start] : <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> middle = start + (end-start)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxLeftSum = DivideConquerCore(inArray, start, middle);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxRightSum = DivideConquerCore(inArray, middle, end);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmpSum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> centerLeftSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = middle - <span class=\"number\">1</span>; i &gt;= start; i--) &#123;</span><br><span class=\"line\">                tmpSum += inArray[i];</span><br><span class=\"line\">                centerLeftSum = centerLeftSum &gt; tmpSum ? centerLeftSum : tmpSum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tmpSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> centerRightSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = middle; i &lt; end; i++) &#123;</span><br><span class=\"line\">                tmpSum += inArray[i];</span><br><span class=\"line\">                centerRightSum = centerRightSum &gt; tmpSum ? centerRightSum : tmpSum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> centerSum = centerLeftSum + centerRightSum;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = maxLeftSum &gt; maxRightSum ? maxLeftSum : maxRightSum;</span><br><span class=\"line\">        maxSum = maxSum &gt; centerSum ? maxSum : centerSum;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DCAlgorithm</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DivideConquerCore(inArray, <span class=\"number\">0</span>, <span class=\"keyword\">int</span>(inArray.size()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述算法时间复杂度递推式为$T(N)=2T(N/2)+N$易得出时间复杂度为$O(N\\log(N))$</p>\n<h2 id=\"动态规划解法\"><a href=\"#动态规划解法\" class=\"headerlink\" title=\"动态规划解法\"></a>动态规划解法</h2><p>动态规划是前人在优化暴力穷举法中通过观察找到优化规律而得出的一种优化思路。前人观察到暴力求解中有大量的重复计算，如果可以减少这些重复计算便可以提高算法性能。考虑到连续子序列问题的连续性特点，我们在扫描数组时维持一个连续子序列，然后考察当前扫描的元素能否加入该子序列或者另起一个新序列。如果当前维持的子序列和加上当前扫描的元素总和大于该元素，则该元素加入该序列中，否则另起新序列（保证下一个元素可以加入序列），同时记录当前序列的和，该元素成为新序列的第一个元素。将上述思路以通过循环不变式的方式证明如下：  </p>\n<ol>\n<li>初始化：扫描数组第一个元素加入到维持的序列中即$[a_0]$，此时记录的一个连续子序列和为$S_0$；</li>\n<li>保持：判断当前扫描元素与保持序列和关系，导致两种情况：$[a_0,a_1]$和$[a_1]$，和记为$S_1$。无论那种情况，在扫描下一个元素时我们依旧可以保证<strong>当前维持的序列可以和下一个元素合并（保证连续性）且是最好的序列</strong>；</li>\n<li>终止：记录了$N$个$S_i$值，找出最大值作为结果返回。</li>\n</ol>\n<p>上述思路的代码实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DPAlgorithm</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; SArray(inArray.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        SArray[<span class=\"number\">0</span>] = inArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (SArray[i<span class=\"number\">-1</span>] + inArray[i] &lt; inArray[i]) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*更换序列*/</span></span><br><span class=\"line\">                        SArray[i] = inArray[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        SArray[i] = SArray[i<span class=\"number\">-1</span>]+inArray[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; SArray.size(); i++) &#123;</span><br><span class=\"line\">                maxSum = maxSum &gt; SArray[i] ? maxSum : SArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态规划优化\"><a href=\"#动态规划优化\" class=\"headerlink\" title=\"动态规划优化\"></a>动态规划优化</h2><p>通过观察上述代码，我们已经把时间复杂度优化到了$O(N)$了，但是使用了$O(N)$的空间，这是因为我们保存了维持序列过程中产生的所有和，但是代码中下一个和只与上一个和以及当前扫描元素有关，因此我们只保存上一个和以及不断更新最大和值，代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DPOptimize</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;inArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lastSum = inArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inArray.size(); i++) &#123;</span><br><span class=\"line\">                maxSum = maxSum &gt; lastSum ? maxSum : lastSum;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lastSum + inArray[i] &lt; inArray[i]) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*更换序列*/</span></span><br><span class=\"line\">                        lastSum = inArray[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        lastSum = lastSum+inArray[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"算法测试\"><a href=\"#算法测试\" class=\"headerlink\" title=\"算法测试\"></a>算法测试</h2><p>上述算法的测试代码如下，随机生成一段数列，然后调用每个函数进行测试，为了测试代码正确性，我们直接抄录书上的代码作为测试基准，教材实现代码如下<code>MaxSubsequenceSum</code>函数所示</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubsequenceSum</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ThisSum, MaxSum, j;</span><br><span class=\"line\">        ThisSum = MaxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; N; j++) &#123;</span><br><span class=\"line\">                ThisSum += A[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ThisSum &gt; MaxSum) &#123;</span><br><span class=\"line\">                        MaxSum = ThisSum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ThisSum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        ThisSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> testNum[] = &#123; <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-10e4</span>), <span class=\"keyword\">int</span>(<span class=\"number\">10e4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(testNum) / <span class=\"keyword\">sizeof</span>(testNum[<span class=\"number\">0</span>]); i++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; testData1;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> *testData2 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[testNum[i]];</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; testNum[i]; j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> tmp = intDis(randEngine);</span><br><span class=\"line\">                                testData1.push_back(tmp);</span><br><span class=\"line\">                                testData2[j] = tmp;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> maxSum = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                        <span class=\"comment\">//maxSum = DPOptimize(testData1); /*调用具体的算法*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> correctSum = MaxSubsequenceSum(testData2, <span class=\"keyword\">int</span>(testNum[i]));</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; ((maxSum == correctSum) ? <span class=\"string\">\"Correct;\"</span> : <span class=\"string\">\"Wrong;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">delete</span> [] testData2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n"},{"title":"前、中缀表达式转后缀表达式以及后缀表达式求值的实现","urlname":"prefix-infix-to-postfix","date":"2018-06-13T13:07:34.000Z","copyright":true,"mathjax":true,"_content":"\n## 前言\n\n前缀表达式又称波兰表达式，其将操作符放置于操作数前面，该类型的表达式无需括号仍然可以无歧义地被解析，如果将表达式以表达式树的形式展现，则前缀表达式对应于前序遍历结果。\n\n中缀表达式在表达式中将操作符（双目）置于操作数的中间，是目前常用的一种表示方法，中缀表达式需要通过括号来指示运算优先顺序，一般中缀表达式在计算机中无法直接用于计算，中缀表达式对应于表达式树的中序遍历结果。\n\n后缀表达式又称逆波兰表达式，式中操作符位于操作数的后面，在计算机内部易于直接计算（借助栈），和前缀表达式一样后缀表达式也无需借助括号便可以无歧地被解析，后缀表达式对应于表达式树的后序遍历结果。\n\n本文分别实现将前缀、中缀表达式转变为后缀表达式并且实现一个简单的后缀表达式计算器。同时约定放置表达式的基本数据结构如下：\n\n```cpp\nenum OperType\n{\n        /*OPERAND-操作数，OPERATOR-操作符*/\n        OPERAND, OPERATOR\n};\n\ntemplate <typename DataType>\nunion OperData {\n        char operatorCh;\n        DataType operand;\n};\n\ntemplate <typename DataType>\nstruct ExpressionAtom\n{\n        OperType operFlag;\n        OperData<DataType> operValue;\n};\n```\n\n**注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。**\n\n## 前缀转后缀表达式\n\n我们可以通过观察前缀和后缀表达式在表达式树中的遍历顺序：前缀，根->左->右；后缀，左->右->根。从以上顺序可以得出两者遍历顺序中操作数始终在一起，只是操作符顺序不一致。而且在表达式树上操作数都是叶子节点而操作符必定有两个（双目）子节点。因此在实现前缀转后缀时只需把根放在操作符之后即可，而操作数相对顺序保持不变。综合以上分析我们可以用一个栈来存放根（操作符），队列用来存放结果，通过队列+栈实现根的逆序，基本实现代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\n#include <queue>\nusing std::vector;\nusing std::stack;\nusing std::queue;\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> PrefixToPostfix(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n        stack<int> visitTimesStack;\n        queue<ExpressionAtom<DataType>> resultQueue;\n\n        /*不做差错检测*/\n        for (size_t i = 0; i < inPrefix.size(); i++) {\n                /*后序遍历在第三次访问时弹出*/\n                while (!visitTimesStack.empty() && visitTimesStack.top() >= 2) {\n                        resultQueue.push(operatorStack.top());\n                        operatorStack.pop(); visitTimesStack.pop();\n                }\n                /*每访问一次+1*/\n                if (!visitTimesStack.empty()) {\n                        ++visitTimesStack.top();\n                }\n                if (inPrefix[i].operFlag == OPERATOR) {\n                        operatorStack.push(inPrefix[i]);\n                        visitTimesStack.push(0); /*初始化访问数据*/\n                }\n                else {\n                        resultQueue.push(inPrefix[i]);\n                }\n        }\n\n        /*清空栈中操作符*/\n        while (!visitTimesStack.empty() && visitTimesStack.top() >= 2) {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop(); visitTimesStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultQueue.empty()) {\n                result.push_back(resultQueue.front());\n                resultQueue.pop();\n        }\n        return result;\n}\n```\n\n## 前缀转后缀代码测试\n\n使用如下图所示表达式树生成的前缀表达式来进行测试：[图片来源](http://www.cnblogs.com/lulipro/p/7563217.html)\n![表达式树](/images/expression-tree-test.png)\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        PrintExpression(testVec);\n\n        auto result = PrefixToPostfix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 中缀转后缀表达式\n\n表达式树在进行中序遍历时，为了保留求值顺序信息必须通过增加括号，因此在进行中缀转后缀时必须处理括号的情况。中缀表达式转后缀表达式有一个经典的调度场算法，具体可参见参考资料中的文章。由于考虑到栈的先进后出的特性，而且表达式从左到右结合，因此操作数在后缀表达式中的相对顺序不发生变化。在决定操作符的输出顺序时只要保证高优先级先出栈即可。综合上述可以使用一个栈来保存操作符，如果当前读到的操作符优先级大于栈顶操作符则一直压栈直至优先级**小于等于**栈顶操作符。在处理括号时，一旦出现左括号则先压入栈，出现右括号则不断从操作符栈中弹出直至遇到左括号为止。具体实现代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\n#include <queue>\nusing std::vector;\nusing std::stack;\nusing std::queue;\n\nbool isGreater(char oper1, char oper2)\n{\n        if (oper2 == '(') {\n                return true;\n        }\n\n        if (oper1 == '*' || oper1 == '/') {\n                if (oper2 == '*' || oper2 == '/') {\n                        return false;\n                }\n                else {\n                        return true;\n                }\n        }\n        return false;\n}\n\ntemplate <typename DataType>\nvoid PopOperatorUntilLeftBracket(stack<ExpressionAtom<DataType>> &operatorStack,\n         queue<ExpressionAtom<DataType>> &resultQueue)\n{\n        while (operatorStack.top().operValue.operatorCh != '(') {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop();\n        }\n        operatorStack.pop(); /*弹出左括号*/\n}\n\ntemplate <typename DataType>\nvoid PopOperatorUntilLowPriority(stack<ExpressionAtom<DataType>> &operatorStack,\n         queue<ExpressionAtom<DataType>> &resultQueue, char nowOperator)\n{\n        while (!operatorStack.empty() &&\n                        !isGreater(nowOperator, operatorStack.top().operValue.operatorCh)) {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop();\n        }\n}\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> InfixToPostfix(vector<ExpressionAtom<DataType>> &inInfix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n\n        queue<ExpressionAtom<DataType>> resultQueue;\n\n        /*不做差错检测*/\n        for (size_t i = 0; i < inInfix.size(); i++) {\n                if (inInfix[i].operFlag == OPERATOR) {\n                        if (inInfix[i].operValue.operatorCh == ')') {\n                                PopOperatorUntilLeftBracket(operatorStack, resultQueue);\n                        }\n                        else if (inInfix[i].operValue.operatorCh == '(') {\n                                operatorStack.push(inInfix[i]);\n                        }\n                        else {\n                                PopOperatorUntilLowPriority(operatorStack, resultQueue,\n                                        inInfix[i].operValue.operatorCh);\n                                operatorStack.push(inInfix[i]);\n                        }\n                }\n                else {\n                        resultQueue.push(inInfix[i]);\n                }\n        }\n\n\n        /*清空栈中操作符*/\n        while (!operatorStack.empty()) {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultQueue.empty()) {\n                result.push_back(resultQueue.front());\n                resultQueue.pop();\n        }\n        return result;\n}\n```\n\n## 中缀转后缀代码测试\n\n使用前缀中的表达式树，同时使用括号改变优先级，具体测试代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        /*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n\n        PrintExpression(testVec);\n\n        auto result = InfixToPostfix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 后缀表达式求值\n\n后缀表达式求值非常简单，只要在遇到操作符后立刻弹出两个操作数（双目运算符）进行计算。最后栈里剩下一个元素即为求值结果，具体见下所示：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nDataType Calculate(DataType inData1, DataType inData2, char operatorCh)\n{\n        if (operatorCh == '+') {\n                return inData1 + inData2;\n        }\n        else if (operatorCh == '-') {\n                return inData1 - inData2;\n        }\n        else if (operatorCh == '*') {\n                return inData1 * inData2;\n        }\n        else if (operatorCh == '/') {\n                return inData1 / inData2;\n        }\n        else {\n                return DataType(0);\n        }\n}\n\ntemplate <typename DataType>\nDataType CalculatePostfixValue(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        stack<DataType> operandStack;\n\n        /*不做差错检测*/\n        for (size_t i = 0; i < inPostfix.size(); i++) {\n                if (inPostfix[i].operFlag == OPERATOR) {\n                        int tmp1 = operandStack.top(); operandStack.pop();\n                        int tmp2 = operandStack.top(); operandStack.pop();\n                        int result = Calculate(tmp2, tmp1, inPostfix[i].operValue.operatorCh);\n                        operandStack.push(result);\n                }\n                else {\n                        operandStack.push(inPostfix[i].operValue.operand);\n                }\n        }\n        return operandStack.top();\n}\n```\n\n## 后缀表达式求值代码测试\n\n在进行测试时直接使用上节求出的后缀表达式，具体代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\nusing std::vector;\nusing std::cout;\nusing std::endl;\n\nint main()\n{\n    vector<ExpressionAtom<int>> testVec;\n\n    ExpressionAtom<int> manualData;\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '(';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 3;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '+';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 1;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = ')';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '*';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 3;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '/';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '(';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 9;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '-';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 5;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '+';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 2;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = ')';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '-';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '(';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 3;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '*';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '(';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 7;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '-';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 4;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = ')';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '+';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 6;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = ')';\n    testVec.push_back(manualData);\n\n\n    PrintExpression(testVec);\n\n    auto result = InfixToPostfix(testVec);\n\n    PrintExpression(result);\n\n    cout << CalculatePostfixValue(result) << endl; /*后缀计算结果*/\n\n    return 0;\n}\n```\n\n## 参考资料\n\n[波兰表示法-维基百科](https://zh.wikipedia.org/wiki/波兰表示法)\n\n[中缀表示法-维基百科](https://zh.wikipedia.org/wiki/中缀表示法)\n\n[逆波兰表示法-维基百科](https://zh.wikipedia.org/wiki/逆波兰表示法)\n\n[调度场算法-维基百科](https://zh.wikipedia.org/wiki/调度场算法)\n","source":"_posts/算法设计/前_中缀表达式转后缀表达式和后缀表达式求值的计算.md","raw":"---\ntitle: 前、中缀表达式转后缀表达式以及后缀表达式求值的实现\nurlname: prefix-infix-to-postfix\ndate: 2018-06-13 21:07:34\ncopyright: true\nmathjax: true\ntags:\n- 算法设计\ncategories:\n- 算法设计\n---\n\n## 前言\n\n前缀表达式又称波兰表达式，其将操作符放置于操作数前面，该类型的表达式无需括号仍然可以无歧义地被解析，如果将表达式以表达式树的形式展现，则前缀表达式对应于前序遍历结果。\n\n中缀表达式在表达式中将操作符（双目）置于操作数的中间，是目前常用的一种表示方法，中缀表达式需要通过括号来指示运算优先顺序，一般中缀表达式在计算机中无法直接用于计算，中缀表达式对应于表达式树的中序遍历结果。\n\n后缀表达式又称逆波兰表达式，式中操作符位于操作数的后面，在计算机内部易于直接计算（借助栈），和前缀表达式一样后缀表达式也无需借助括号便可以无歧地被解析，后缀表达式对应于表达式树的后序遍历结果。\n\n本文分别实现将前缀、中缀表达式转变为后缀表达式并且实现一个简单的后缀表达式计算器。同时约定放置表达式的基本数据结构如下：\n\n```cpp\nenum OperType\n{\n        /*OPERAND-操作数，OPERATOR-操作符*/\n        OPERAND, OPERATOR\n};\n\ntemplate <typename DataType>\nunion OperData {\n        char operatorCh;\n        DataType operand;\n};\n\ntemplate <typename DataType>\nstruct ExpressionAtom\n{\n        OperType operFlag;\n        OperData<DataType> operValue;\n};\n```\n\n**注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。**\n\n## 前缀转后缀表达式\n\n我们可以通过观察前缀和后缀表达式在表达式树中的遍历顺序：前缀，根->左->右；后缀，左->右->根。从以上顺序可以得出两者遍历顺序中操作数始终在一起，只是操作符顺序不一致。而且在表达式树上操作数都是叶子节点而操作符必定有两个（双目）子节点。因此在实现前缀转后缀时只需把根放在操作符之后即可，而操作数相对顺序保持不变。综合以上分析我们可以用一个栈来存放根（操作符），队列用来存放结果，通过队列+栈实现根的逆序，基本实现代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\n#include <queue>\nusing std::vector;\nusing std::stack;\nusing std::queue;\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> PrefixToPostfix(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n        stack<int> visitTimesStack;\n        queue<ExpressionAtom<DataType>> resultQueue;\n\n        /*不做差错检测*/\n        for (size_t i = 0; i < inPrefix.size(); i++) {\n                /*后序遍历在第三次访问时弹出*/\n                while (!visitTimesStack.empty() && visitTimesStack.top() >= 2) {\n                        resultQueue.push(operatorStack.top());\n                        operatorStack.pop(); visitTimesStack.pop();\n                }\n                /*每访问一次+1*/\n                if (!visitTimesStack.empty()) {\n                        ++visitTimesStack.top();\n                }\n                if (inPrefix[i].operFlag == OPERATOR) {\n                        operatorStack.push(inPrefix[i]);\n                        visitTimesStack.push(0); /*初始化访问数据*/\n                }\n                else {\n                        resultQueue.push(inPrefix[i]);\n                }\n        }\n\n        /*清空栈中操作符*/\n        while (!visitTimesStack.empty() && visitTimesStack.top() >= 2) {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop(); visitTimesStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultQueue.empty()) {\n                result.push_back(resultQueue.front());\n                resultQueue.pop();\n        }\n        return result;\n}\n```\n\n## 前缀转后缀代码测试\n\n使用如下图所示表达式树生成的前缀表达式来进行测试：[图片来源](http://www.cnblogs.com/lulipro/p/7563217.html)\n![表达式树](/images/expression-tree-test.png)\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        PrintExpression(testVec);\n\n        auto result = PrefixToPostfix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 中缀转后缀表达式\n\n表达式树在进行中序遍历时，为了保留求值顺序信息必须通过增加括号，因此在进行中缀转后缀时必须处理括号的情况。中缀表达式转后缀表达式有一个经典的调度场算法，具体可参见参考资料中的文章。由于考虑到栈的先进后出的特性，而且表达式从左到右结合，因此操作数在后缀表达式中的相对顺序不发生变化。在决定操作符的输出顺序时只要保证高优先级先出栈即可。综合上述可以使用一个栈来保存操作符，如果当前读到的操作符优先级大于栈顶操作符则一直压栈直至优先级**小于等于**栈顶操作符。在处理括号时，一旦出现左括号则先压入栈，出现右括号则不断从操作符栈中弹出直至遇到左括号为止。具体实现代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\n#include <queue>\nusing std::vector;\nusing std::stack;\nusing std::queue;\n\nbool isGreater(char oper1, char oper2)\n{\n        if (oper2 == '(') {\n                return true;\n        }\n\n        if (oper1 == '*' || oper1 == '/') {\n                if (oper2 == '*' || oper2 == '/') {\n                        return false;\n                }\n                else {\n                        return true;\n                }\n        }\n        return false;\n}\n\ntemplate <typename DataType>\nvoid PopOperatorUntilLeftBracket(stack<ExpressionAtom<DataType>> &operatorStack,\n         queue<ExpressionAtom<DataType>> &resultQueue)\n{\n        while (operatorStack.top().operValue.operatorCh != '(') {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop();\n        }\n        operatorStack.pop(); /*弹出左括号*/\n}\n\ntemplate <typename DataType>\nvoid PopOperatorUntilLowPriority(stack<ExpressionAtom<DataType>> &operatorStack,\n         queue<ExpressionAtom<DataType>> &resultQueue, char nowOperator)\n{\n        while (!operatorStack.empty() &&\n                        !isGreater(nowOperator, operatorStack.top().operValue.operatorCh)) {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop();\n        }\n}\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> InfixToPostfix(vector<ExpressionAtom<DataType>> &inInfix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n\n        queue<ExpressionAtom<DataType>> resultQueue;\n\n        /*不做差错检测*/\n        for (size_t i = 0; i < inInfix.size(); i++) {\n                if (inInfix[i].operFlag == OPERATOR) {\n                        if (inInfix[i].operValue.operatorCh == ')') {\n                                PopOperatorUntilLeftBracket(operatorStack, resultQueue);\n                        }\n                        else if (inInfix[i].operValue.operatorCh == '(') {\n                                operatorStack.push(inInfix[i]);\n                        }\n                        else {\n                                PopOperatorUntilLowPriority(operatorStack, resultQueue,\n                                        inInfix[i].operValue.operatorCh);\n                                operatorStack.push(inInfix[i]);\n                        }\n                }\n                else {\n                        resultQueue.push(inInfix[i]);\n                }\n        }\n\n\n        /*清空栈中操作符*/\n        while (!operatorStack.empty()) {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultQueue.empty()) {\n                result.push_back(resultQueue.front());\n                resultQueue.pop();\n        }\n        return result;\n}\n```\n\n## 中缀转后缀代码测试\n\n使用前缀中的表达式树，同时使用括号改变优先级，具体测试代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        /*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n\n        PrintExpression(testVec);\n\n        auto result = InfixToPostfix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 后缀表达式求值\n\n后缀表达式求值非常简单，只要在遇到操作符后立刻弹出两个操作数（双目运算符）进行计算。最后栈里剩下一个元素即为求值结果，具体见下所示：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nDataType Calculate(DataType inData1, DataType inData2, char operatorCh)\n{\n        if (operatorCh == '+') {\n                return inData1 + inData2;\n        }\n        else if (operatorCh == '-') {\n                return inData1 - inData2;\n        }\n        else if (operatorCh == '*') {\n                return inData1 * inData2;\n        }\n        else if (operatorCh == '/') {\n                return inData1 / inData2;\n        }\n        else {\n                return DataType(0);\n        }\n}\n\ntemplate <typename DataType>\nDataType CalculatePostfixValue(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        stack<DataType> operandStack;\n\n        /*不做差错检测*/\n        for (size_t i = 0; i < inPostfix.size(); i++) {\n                if (inPostfix[i].operFlag == OPERATOR) {\n                        int tmp1 = operandStack.top(); operandStack.pop();\n                        int tmp2 = operandStack.top(); operandStack.pop();\n                        int result = Calculate(tmp2, tmp1, inPostfix[i].operValue.operatorCh);\n                        operandStack.push(result);\n                }\n                else {\n                        operandStack.push(inPostfix[i].operValue.operand);\n                }\n        }\n        return operandStack.top();\n}\n```\n\n## 后缀表达式求值代码测试\n\n在进行测试时直接使用上节求出的后缀表达式，具体代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\nusing std::vector;\nusing std::cout;\nusing std::endl;\n\nint main()\n{\n    vector<ExpressionAtom<int>> testVec;\n\n    ExpressionAtom<int> manualData;\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '(';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 3;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '+';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 1;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = ')';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '*';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 3;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '/';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '(';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 9;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '-';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 5;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '+';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 2;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = ')';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '-';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '(';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 3;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '*';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '(';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 7;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '-';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 4;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = ')';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = '+';\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERAND;\n    manualData.operValue.operand = 6;\n    testVec.push_back(manualData);\n\n    manualData.operFlag = OPERATOR;\n    manualData.operValue.operatorCh = ')';\n    testVec.push_back(manualData);\n\n\n    PrintExpression(testVec);\n\n    auto result = InfixToPostfix(testVec);\n\n    PrintExpression(result);\n\n    cout << CalculatePostfixValue(result) << endl; /*后缀计算结果*/\n\n    return 0;\n}\n```\n\n## 参考资料\n\n[波兰表示法-维基百科](https://zh.wikipedia.org/wiki/波兰表示法)\n\n[中缀表示法-维基百科](https://zh.wikipedia.org/wiki/中缀表示法)\n\n[逆波兰表示法-维基百科](https://zh.wikipedia.org/wiki/逆波兰表示法)\n\n[调度场算法-维基百科](https://zh.wikipedia.org/wiki/调度场算法)\n","slug":"算法设计/前_中缀表达式转后缀表达式和后缀表达式求值的计算","published":1,"updated":"2018-06-14T07:54:58.381Z","_id":"cjida4x45002cgsvn30twuxxk","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前缀表达式又称波兰表达式，其将操作符放置于操作数前面，该类型的表达式无需括号仍然可以无歧义地被解析，如果将表达式以表达式树的形式展现，则前缀表达式对应于前序遍历结果。</p>\n<p>中缀表达式在表达式中将操作符（双目）置于操作数的中间，是目前常用的一种表示方法，中缀表达式需要通过括号来指示运算优先顺序，一般中缀表达式在计算机中无法直接用于计算，中缀表达式对应于表达式树的中序遍历结果。</p>\n<p>后缀表达式又称逆波兰表达式，式中操作符位于操作数的后面，在计算机内部易于直接计算（借助栈），和前缀表达式一样后缀表达式也无需借助括号便可以无歧地被解析，后缀表达式对应于表达式树的后序遍历结果。</p>\n<p>本文分别实现将前缀、中缀表达式转变为后缀表达式并且实现一个简单的后缀表达式计算器。同时约定放置表达式的基本数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> OperType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*OPERAND-操作数，OPERATOR-操作符*/</span></span><br><span class=\"line\">        OPERAND, OPERATOR</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">union</span> OperData &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> operatorCh;</span><br><span class=\"line\">        DataType operand;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ExpressionAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        OperType operFlag;</span><br><span class=\"line\">        OperData&lt;DataType&gt; operValue;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。</strong></p>\n<h2 id=\"前缀转后缀表达式\"><a href=\"#前缀转后缀表达式\" class=\"headerlink\" title=\"前缀转后缀表达式\"></a>前缀转后缀表达式</h2><p>我们可以通过观察前缀和后缀表达式在表达式树中的遍历顺序：前缀，根-&gt;左-&gt;右；后缀，左-&gt;右-&gt;根。从以上顺序可以得出两者遍历顺序中操作数始终在一起，只是操作符顺序不一致。而且在表达式树上操作数都是叶子节点而操作符必定有两个（双目）子节点。因此在实现前缀转后缀时只需把根放在操作符之后即可，而操作数相对顺序保持不变。综合以上分析我们可以用一个栈来存放根（操作符），队列用来存放结果，通过队列+栈实现根的逆序，基本实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; PrefixToPostfix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; visitTimesStack;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inPrefix.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*后序遍历在第三次访问时弹出*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                        resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                        operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/*每访问一次+1*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!visitTimesStack.empty()) &#123;</span><br><span class=\"line\">                        ++visitTimesStack.top();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPrefix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        operatorStack.push(inPrefix[i]);</span><br><span class=\"line\">                        visitTimesStack.push(<span class=\"number\">0</span>); <span class=\"comment\">/*初始化访问数据*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        resultQueue.push(inPrefix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultQueue.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultQueue.front());</span><br><span class=\"line\">                resultQueue.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀转后缀代码测试\"><a href=\"#前缀转后缀代码测试\" class=\"headerlink\" title=\"前缀转后缀代码测试\"></a>前缀转后缀代码测试</h2><p>使用如下图所示表达式树生成的前缀表达式来进行测试：<a href=\"http://www.cnblogs.com/lulipro/p/7563217.html\" target=\"_blank\" rel=\"noopener\">图片来源</a><br><img src=\"/images/expression-tree-test.png\" alt=\"表达式树\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PrefixToPostfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中缀转后缀表达式\"><a href=\"#中缀转后缀表达式\" class=\"headerlink\" title=\"中缀转后缀表达式\"></a>中缀转后缀表达式</h2><p>表达式树在进行中序遍历时，为了保留求值顺序信息必须通过增加括号，因此在进行中缀转后缀时必须处理括号的情况。中缀表达式转后缀表达式有一个经典的调度场算法，具体可参见参考资料中的文章。由于考虑到栈的先进后出的特性，而且表达式从左到右结合，因此操作数在后缀表达式中的相对顺序不发生变化。在决定操作符的输出顺序时只要保证高优先级先出栈即可。综合上述可以使用一个栈来保存操作符，如果当前读到的操作符优先级大于栈顶操作符则一直压栈直至优先级<strong>小于等于</strong>栈顶操作符。在处理括号时，一旦出现左括号则先压入栈，出现右括号则不断从操作符栈中弹出直至遇到左括号为止。具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isGreater</span><span class=\"params\">(<span class=\"keyword\">char</span> oper1, <span class=\"keyword\">char</span> oper2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oper2 == <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oper1 == <span class=\"string\">'*'</span> || oper1 == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oper2 == <span class=\"string\">'*'</span> || oper2 == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PopOperatorUntilLeftBracket</span><span class=\"params\">(<span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;operatorStack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;resultQueue)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (operatorStack.top().operValue.operatorCh != <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        operatorStack.pop(); <span class=\"comment\">/*弹出左括号*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PopOperatorUntilLowPriority</span><span class=\"params\">(<span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;operatorStack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;resultQueue, <span class=\"keyword\">char</span> nowOperator)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!operatorStack.empty() &amp;&amp;</span><br><span class=\"line\">                        !isGreater(nowOperator, operatorStack.top().operValue.operatorCh)) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; InfixToPostfix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inInfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inInfix.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inInfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (inInfix[i].operValue.operatorCh == <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">                                PopOperatorUntilLeftBracket(operatorStack, resultQueue);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inInfix[i].operValue.operatorCh == <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                                operatorStack.push(inInfix[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                PopOperatorUntilLowPriority(operatorStack, resultQueue,</span><br><span class=\"line\">                                        inInfix[i].operValue.operatorCh);</span><br><span class=\"line\">                                operatorStack.push(inInfix[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        resultQueue.push(inInfix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!operatorStack.empty()) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultQueue.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultQueue.front());</span><br><span class=\"line\">                resultQueue.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中缀转后缀代码测试\"><a href=\"#中缀转后缀代码测试\" class=\"headerlink\" title=\"中缀转后缀代码测试\"></a>中缀转后缀代码测试</h2><p>使用前缀中的表达式树，同时使用括号改变优先级，具体测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = InfixToPostfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀表达式求值\"><a href=\"#后缀表达式求值\" class=\"headerlink\" title=\"后缀表达式求值\"></a>后缀表达式求值</h2><p>后缀表达式求值非常简单，只要在遇到操作符后立刻弹出两个操作数（双目运算符）进行计算。最后栈里剩下一个元素即为求值结果，具体见下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\">DataType <span class=\"title\">Calculate</span><span class=\"params\">(DataType inData1, DataType inData2, <span class=\"keyword\">char</span> operatorCh)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'+'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 + inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'-'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 - inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'*'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 * inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 / inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> DataType(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\">DataType <span class=\"title\">CalculatePostfixValue</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;DataType&gt; operandStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inPostfix.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPostfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmp1 = operandStack.top(); operandStack.pop();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmp2 = operandStack.top(); operandStack.pop();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> result = Calculate(tmp2, tmp1, inPostfix[i].operValue.operatorCh);</span><br><span class=\"line\">                        operandStack.push(result);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        operandStack.push(inPostfix[i].operValue.operand);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> operandStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀表达式求值代码测试\"><a href=\"#后缀表达式求值代码测试\" class=\"headerlink\" title=\"后缀表达式求值代码测试\"></a>后缀表达式求值代码测试</h2><p>在进行测试时直接使用上节求出的后缀表达式，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">    ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> result = InfixToPostfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">    PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; CalculatePostfixValue(result) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">/*后缀计算结果*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/波兰表示法\" target=\"_blank\" rel=\"noopener\">波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/中缀表示法\" target=\"_blank\" rel=\"noopener\">中缀表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/逆波兰表示法\" target=\"_blank\" rel=\"noopener\">逆波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/调度场算法\" target=\"_blank\" rel=\"noopener\">调度场算法-维基百科</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前缀表达式又称波兰表达式，其将操作符放置于操作数前面，该类型的表达式无需括号仍然可以无歧义地被解析，如果将表达式以表达式树的形式展现，则前缀表达式对应于前序遍历结果。</p>\n<p>中缀表达式在表达式中将操作符（双目）置于操作数的中间，是目前常用的一种表示方法，中缀表达式需要通过括号来指示运算优先顺序，一般中缀表达式在计算机中无法直接用于计算，中缀表达式对应于表达式树的中序遍历结果。</p>\n<p>后缀表达式又称逆波兰表达式，式中操作符位于操作数的后面，在计算机内部易于直接计算（借助栈），和前缀表达式一样后缀表达式也无需借助括号便可以无歧地被解析，后缀表达式对应于表达式树的后序遍历结果。</p>\n<p>本文分别实现将前缀、中缀表达式转变为后缀表达式并且实现一个简单的后缀表达式计算器。同时约定放置表达式的基本数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> OperType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*OPERAND-操作数，OPERATOR-操作符*/</span></span><br><span class=\"line\">        OPERAND, OPERATOR</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">union</span> OperData &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> operatorCh;</span><br><span class=\"line\">        DataType operand;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ExpressionAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        OperType operFlag;</span><br><span class=\"line\">        OperData&lt;DataType&gt; operValue;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。</strong></p>\n<h2 id=\"前缀转后缀表达式\"><a href=\"#前缀转后缀表达式\" class=\"headerlink\" title=\"前缀转后缀表达式\"></a>前缀转后缀表达式</h2><p>我们可以通过观察前缀和后缀表达式在表达式树中的遍历顺序：前缀，根-&gt;左-&gt;右；后缀，左-&gt;右-&gt;根。从以上顺序可以得出两者遍历顺序中操作数始终在一起，只是操作符顺序不一致。而且在表达式树上操作数都是叶子节点而操作符必定有两个（双目）子节点。因此在实现前缀转后缀时只需把根放在操作符之后即可，而操作数相对顺序保持不变。综合以上分析我们可以用一个栈来存放根（操作符），队列用来存放结果，通过队列+栈实现根的逆序，基本实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; PrefixToPostfix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; visitTimesStack;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inPrefix.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*后序遍历在第三次访问时弹出*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                        resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                        operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/*每访问一次+1*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!visitTimesStack.empty()) &#123;</span><br><span class=\"line\">                        ++visitTimesStack.top();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPrefix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        operatorStack.push(inPrefix[i]);</span><br><span class=\"line\">                        visitTimesStack.push(<span class=\"number\">0</span>); <span class=\"comment\">/*初始化访问数据*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        resultQueue.push(inPrefix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultQueue.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultQueue.front());</span><br><span class=\"line\">                resultQueue.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀转后缀代码测试\"><a href=\"#前缀转后缀代码测试\" class=\"headerlink\" title=\"前缀转后缀代码测试\"></a>前缀转后缀代码测试</h2><p>使用如下图所示表达式树生成的前缀表达式来进行测试：<a href=\"http://www.cnblogs.com/lulipro/p/7563217.html\" target=\"_blank\" rel=\"noopener\">图片来源</a><br><img src=\"/images/expression-tree-test.png\" alt=\"表达式树\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PrefixToPostfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中缀转后缀表达式\"><a href=\"#中缀转后缀表达式\" class=\"headerlink\" title=\"中缀转后缀表达式\"></a>中缀转后缀表达式</h2><p>表达式树在进行中序遍历时，为了保留求值顺序信息必须通过增加括号，因此在进行中缀转后缀时必须处理括号的情况。中缀表达式转后缀表达式有一个经典的调度场算法，具体可参见参考资料中的文章。由于考虑到栈的先进后出的特性，而且表达式从左到右结合，因此操作数在后缀表达式中的相对顺序不发生变化。在决定操作符的输出顺序时只要保证高优先级先出栈即可。综合上述可以使用一个栈来保存操作符，如果当前读到的操作符优先级大于栈顶操作符则一直压栈直至优先级<strong>小于等于</strong>栈顶操作符。在处理括号时，一旦出现左括号则先压入栈，出现右括号则不断从操作符栈中弹出直至遇到左括号为止。具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isGreater</span><span class=\"params\">(<span class=\"keyword\">char</span> oper1, <span class=\"keyword\">char</span> oper2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oper2 == <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oper1 == <span class=\"string\">'*'</span> || oper1 == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oper2 == <span class=\"string\">'*'</span> || oper2 == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PopOperatorUntilLeftBracket</span><span class=\"params\">(<span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;operatorStack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;resultQueue)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (operatorStack.top().operValue.operatorCh != <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        operatorStack.pop(); <span class=\"comment\">/*弹出左括号*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PopOperatorUntilLowPriority</span><span class=\"params\">(<span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;operatorStack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;resultQueue, <span class=\"keyword\">char</span> nowOperator)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!operatorStack.empty() &amp;&amp;</span><br><span class=\"line\">                        !isGreater(nowOperator, operatorStack.top().operValue.operatorCh)) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; InfixToPostfix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inInfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inInfix.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inInfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (inInfix[i].operValue.operatorCh == <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">                                PopOperatorUntilLeftBracket(operatorStack, resultQueue);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inInfix[i].operValue.operatorCh == <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                                operatorStack.push(inInfix[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                PopOperatorUntilLowPriority(operatorStack, resultQueue,</span><br><span class=\"line\">                                        inInfix[i].operValue.operatorCh);</span><br><span class=\"line\">                                operatorStack.push(inInfix[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        resultQueue.push(inInfix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!operatorStack.empty()) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultQueue.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultQueue.front());</span><br><span class=\"line\">                resultQueue.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中缀转后缀代码测试\"><a href=\"#中缀转后缀代码测试\" class=\"headerlink\" title=\"中缀转后缀代码测试\"></a>中缀转后缀代码测试</h2><p>使用前缀中的表达式树，同时使用括号改变优先级，具体测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = InfixToPostfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀表达式求值\"><a href=\"#后缀表达式求值\" class=\"headerlink\" title=\"后缀表达式求值\"></a>后缀表达式求值</h2><p>后缀表达式求值非常简单，只要在遇到操作符后立刻弹出两个操作数（双目运算符）进行计算。最后栈里剩下一个元素即为求值结果，具体见下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\">DataType <span class=\"title\">Calculate</span><span class=\"params\">(DataType inData1, DataType inData2, <span class=\"keyword\">char</span> operatorCh)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'+'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 + inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'-'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 - inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'*'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 * inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 / inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> DataType(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\">DataType <span class=\"title\">CalculatePostfixValue</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;DataType&gt; operandStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inPostfix.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPostfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmp1 = operandStack.top(); operandStack.pop();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmp2 = operandStack.top(); operandStack.pop();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> result = Calculate(tmp2, tmp1, inPostfix[i].operValue.operatorCh);</span><br><span class=\"line\">                        operandStack.push(result);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        operandStack.push(inPostfix[i].operValue.operand);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> operandStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀表达式求值代码测试\"><a href=\"#后缀表达式求值代码测试\" class=\"headerlink\" title=\"后缀表达式求值代码测试\"></a>后缀表达式求值代码测试</h2><p>在进行测试时直接使用上节求出的后缀表达式，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">    ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERAND;</span><br><span class=\"line\">    manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">    manualData.operFlag = OPERATOR;</span><br><span class=\"line\">    manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">    testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> result = InfixToPostfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">    PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; CalculatePostfixValue(result) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">/*后缀计算结果*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/波兰表示法\" target=\"_blank\" rel=\"noopener\">波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/中缀表示法\" target=\"_blank\" rel=\"noopener\">中缀表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/逆波兰表示法\" target=\"_blank\" rel=\"noopener\">逆波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/调度场算法\" target=\"_blank\" rel=\"noopener\">调度场算法-维基百科</a></p>\n"},{"title":"各大排序算法的分析与实现","urlname":"sort-algorithm","date":"2018-03-15T13:12:41.000Z","copyright":true,"mathjax":true,"_content":"\n## 排序算法汇总\n\n- 插入排序：插入排序思想是通过逐遍扫描（N-1遍扫描，N为排序元素个数）的方式消除逆序对，对于位置P=1遍到P=N-1遍保证插入顺序位置0到位置P为已排序状态。\n- 冒泡排序：通过重复遍历待排序的数列，每次比较一对元素，过程中不断消除逆序对，最终达到排序的目的，和插入排序对比，冒泡排序每次遍历结束后已排序的数列元素个数至少+1\n- 选择排序：每次遍历找到未排序序列的最大或者最小值，将其插入已排序队列的末尾，一般需要N-1趟遍历，因此选择排序移动元素次数很少，至多为N-1次\n- 归并排序：归并排序是分治法的典型应用之一，分治法解决问题主要步骤为：分解，将原问题分解成一系列子问题；解决，递归地解各子问题，若子问题足够小，则直接求解；合并，将子问题的解合并成原问题的解。归并排序分解动作为将数组分为两半；递归解规模为N/2的子问题，最终分解成只有一个元素的子问题；最后将子问题解合并得到最终排序的序列\n- 快速排序：快速排序和归并排序一样，也是采用分治思想，不过其分解思路为将数组分解为以某一基准值的两部分，使得一部分序列的所有元素都小于等于该基准值，另一部分序列的所有元素都大于该基准值（实际和基准值相等的元素可以放到任何一部分）。递归地分解直到分解序列元素个数为0或1。最后合并子问题解得到原问题解\n- 计数排序：计数排序的基本思想为对每个序列元素x，确定小于等于x的元素的个数m，从而根据m确定元素的排序后的位置。其基本流程可归纳如下：找出序列的最大最小值，确定k值；定义数组Count[0~k]，统计序列中值为i的元素的个数并存入Count[i]中；计算Count[i]=Count[i]+Count[i-1]；反向填充目标排序数组，将每个元素放入数组的第Count[i]项，同时Count[i]值减1\n- 基数排序：基数排序的原理是将整数按位切割成若干数字，按照每位数分别比较，最终合并成有序的序列\n- 桶排序：桶排序的基本思想是将待排序序列分到数量有限的桶中，然后对每个桶分别排序，最后将各个桶中的数据有序地合并起来\n- 希尔排序：希尔排序是递减增量排序算法，是插入排序更高效的改进版本，其基本思想为通过将比较的元素根据增量序列分为若干区域，然后对若干区域进行直接插入排序，随着增量序列减少到1时，进行最终的插入排序\n- 堆排序：堆排序的基本原理是利用堆这种数据结构完成排序，通过不断的删除堆顶元素和调整堆，最终得到有序的序列\n- 鸡尾酒排序：鸡尾酒排序也称为定向冒泡排序，是冒泡排序的一种变形，主要区别在于排序时是以双向在序列中排序，即大值往上交换时小值往下交换\n\n各排序算法的时间复杂度和空间复杂比较如下表：\n\n![排序算法对比](/images/sort-algorithm-compare.png)\n\n以下分别分析实现各大算法。\n\n## 插入排序\n\n插入排序是基于比较的排序，其基本原理是在初始状态前1个元素是有序的，然后每次将后方的一个元素插入前方的有序段并保持有序，当最后一个元素插入完成时，整个序列保持有序。其时间复杂度可以通过简单的计算得出，我们不妨假设每趟元素至少需要和有序元素段的一半元素进行比较，则时间复杂度可为1/2+1+3/2+4/2....+(N-1)/2=(N-1)N/4=O(N<sup>2</sup>)；最差时间就是1+2+3+N-1=(N-1)N/2=O(N<sup>2</sup>)；最好的就是每次只需和有序队列比较一个元素就可以确定位置，即输入序列即为有序，此时时间复杂度为1+1+1+....(n-1个)=N-1=O(N)。插入排序除了几个变量外无需额外空间，因此空间复杂度为O(1)。下面为插入排序的实现，采用模板编程方式实现。\n\n```cpp\n//非递减\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid InsertionSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n\n\tDataType tmp; int j = 0;\n\tfor (size_t i = 1; i < inputArray.size(); i++) {\n\t\ttmp = inputArray[i];\n\t\tfor (j = int(i); j > 0 && inputArray[j-1] > tmp; j--) {\n\t\t\tinputArray[j] = inputArray[j-1];\n\t\t}\n\t\tinputArray[j] = tmp;\n\t}\n}\n```\n\n有一道腾讯笔试题即可采用该算法思想完成，题目见下：\n\n>腾讯笔试题“字符移位”  \n>小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？  \n>输入描述：输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.  \n>输出描述：对于每组数据，输出移位后的字符串。  \n>输入输出示例：输入AkleBiCeilD，输出kleieilABCD。  \n\n此题只要对于小写字母，只要往前移动知道遇到小写字母或者移动到首位置即可停止，代码见下：\n\n```cpp\nvoid MoveChar(string &inputString)\n{\n    for (int i = 1; i < int(inputString.size()); i++) {\n        for (int j = i; j >= 1; j--) {\n            if (islower(inputString.at(j)) && isupper(inputString.at(j-1))) {\n                swap(inputString.at(j), inputString.at(j-1));\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n## 冒泡排序\n\n冒泡排序的过程非常类似于自然界上浮现象，从第一个元素开始，依次和后一个元素比较，如果大，则交换，直到上浮到顶端，其时间复杂度分析和插入排序类似但是由于需要一路比较直到顶部，因此冒泡算法的时间复杂度最坏和平均情况都需要一直交换到顶端，因此为N-1+N-2+.....1=(N-1)N/2，而最好时间复杂度可以通过设置一个标志位达到O(N)，否则按照常规无标志位的最好依然需要O(N<sup>2</sup>)，冒泡排序空间复杂度和插入排序一样为O(1)。标志位原理如下代码所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid BubbleSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n\n\tfor (size_t i = 0; i < inputArray.size() - 1; i++) {\n\t\t//标记在一趟排序遍历时是否交换过，如果没有交换过说明原始有序，可以直接退出\n\t\tbool hasSwap = false; \n\t\tfor (size_t j = 0; j < inputArray.size() - i - 1; j++) {\n\t\t\tif (inputArray[j] > inputArray[j+1]) {\n\t\t\t\tswap(inputArray[j], inputArray[j+1]); //STL库函数\n\t\t\t\thasSwap = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasSwap) {\n                        return;\n                }\n\t}\n}\n```\n\n## 选择排序\n\n选择排序的原理是在未排序的序列找到一个最小值，插到已排序序列第的末尾。在第一遍历时找到最小值，第二次找多第二小值，经过N-1趟遍历可以排好N-1个元素，最后一个元素肯定处在正确位置。由于选择排序每次都要遍历整个未排序序列，故其最好与最坏时间复杂度均为N+N-1.....2=(N+2)(N-1)/2=O(N<sup>2</sup>)，其基本代码如下所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid SelectionSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n\n\tfor (size_t i = 0; i < inputArray.size() - 1; i++) {\n\t\tsize_t minIndex = i;\n\n\t\tfor (size_t j = i+1; j < inputArray.size(); j++) {\n\t\t\tif (inputArray[j] < inputArray[minIndex]) {\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\n\t\tif (minIndex != i) {\n                        swap(inputArray[i], inputArray[minIndex]);\n                }\n\t}\n}\n```\n\n## 归并排序\n\n归并排序是分治法经典的应用之一，归并排序通过将问题划分为两个大小相似的问题分别求解，然后合并两部分解得到最后的解，其时间复杂度递推关系式为T(N)=2T(N/2)+N（T(1)=1）；其中N代表在合并解时花费的时间，即合并两个序列的总大小。在求解这个关系式时，可以两边同时除以N，有T(N)/N=T(N/2)/(N/2)+1，而T(N/2)/(N/2)=T(N/4)/(N/4)+1....T(2)/2=T(1)+1。所有左边相加，所有右边相加有T(N)/N=T(1)+log<sub>2</sub>N，推出T(N)=Nlog<sub>2</sub>N+N=O(Nlog<sub>2</sub>N)，归并排序由于需要一个附加的数组保存归并结果，因此空间复杂度为O(N)，递归栈空间为log<sub>2</sub>N。归并排序有两种算法，递归和非递归，递归版算法代码分别如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\n//区间为左闭右开，和STL保持一致\ntemplate <typename DataType>\nvoid Merge(vector<DataType> &inputArray, vector<DataType> &tmpArray, int left, int middle, int right)\n{\n\tint i = left, j = middle, tmpStart = left;\n\twhile (i < middle && j < right) {\n\t\tif (inputArray[i] < inputArray[j]) {\n\t\t\ttmpArray[tmpStart] = inputArray[i];\n\t\t\t++tmpStart; ++i;\n\t\t}\n\t\telse {\n\t\t\ttmpArray[tmpStart] = inputArray[j];\n\t\t\t++tmpStart; ++j;\n\t\t}\n\t}\n\twhile (i < middle) {\n\t\ttmpArray[tmpStart] = inputArray[i];\n\t\t++tmpStart; ++i;\n\t}\n\twhile (j < right) {\n\t\ttmpArray[tmpStart] = inputArray[j];\n\t\t++tmpStart; ++j;\n\t}\n\tfor (i = left; i < right; i++) {\n\t\tinputArray[i] = tmpArray[i];\n\t}\n}\n\ntemplate <typename DataType>\nvoid MergeSortCore(vector<DataType> &inputArray, vector<DataType> &tmpArray, int left, int right)\n{\n        if (left + 1 >= right) {\n                return;\n        }\n\n\tint middle = (left+right)/2;\n\n\tMergeSortCore(inputArray, tmpArray, left, middle);\n\tMergeSortCore(inputArray, tmpArray, middle, right);\n\n\tMerge(inputArray, tmpArray, left, middle, right);\n}\n\ntemplate <typename DataType>\nvoid MergeSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n        \n        vector<DataType> tmpArray(inputArray.size(), 0);\n\n        int left = 0, right = int(inputArray.size());\n\n        MergeSortCore(inputArray, tmpArray, left, right);\n}\n```\n\n## 快速排序\n\n快速排序和归并排序的基本思想都是分治法，不过快速排序划分子问题是以一个元素为基准，小于该元素的放在一边，大于的放在另外一边，通过这样的递归划分，最终递归只剩一个元素时返回，由于每次分割排序后分割元素都在正确位置，因此该算法最终将会使整个序列有序。由于快速排序分割元素选取是不固定的，一般有固定选取头部或者尾部（如果原始有序则时间复杂度很差）、随机选取和三数中值分割法等。快速排序最好时间复杂度产生在每次都均分数组，此时时间复杂度为O(Nlog<sub>2</sub>N)，而最差发生在每次将数组分割成1个元素和剩余的元素，此时时间复杂度为O(N<sup>2</sup>)。在空间复杂度上，由于快速排序可以不借助额外空间进行原地交换，因此其空间复杂度为栈空间复杂度log<sub>2</sub>N，最差空间复杂度为O(N)。和归并排序一样，快速排序也有递归与非递归版本，递归版实现如下代码：\n\n**果然如《数据结构与算法分析》所言，大部分人一般无法正确编写快排程序，( ╯□╰ )**\n\n\n```cpp\n#include <vector>\nusing std::vector;\n\n//左闭右开区间\ntemplate <typename DataType>\nvoid QuickSortCore(vector<DataType> &inputArray, int start, int end)\n{\n\tif (start+1 >= end) {\n                return;\n        }\n\n\tint base = inputArray[end-1];\n\tint i = start, j = end-2;\n\twhile (i <= j) { /*使i行进到正确的位置*/\n\t\twhile (i < end && inputArray[i] < base) {\n                        ++i;\n                }\n\n\t\twhile (j > start && inputArray[j] > base) {\n                        --j;\n                }\n\n\t\tif (i < j) {\n\t\t\tswap(inputArray[i], inputArray[j]);\n\t\t\t++i; --j; /*可能导致i,j指向同一位置*/\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswap(inputArray[i], inputArray[end-1]);\n\n\tQuickSortCore(inputArray, start, i);\n\tQuickSortCore(inputArray, i+1, end);\n}\n\ntemplate <typename DataType>\nvoid QuickSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n\tQuickSortCore(inputArray, 0, int(inputArray.size()));\n}\n```\n\n## 计数排序\n\n在基于比较的排序算法中，根据决策树分析，基于比较的排序的时间复杂度下界为O(Nlog<sub>2</sub>N)。如果需要突破该下限，则必须使用非比较型的算法，计数排序既是其中的一种。在使用计数排序时，对输入序列的范围有要求，计数排序需要额外一个数组用来保存元素出现的次数，该数组的大小为元素最大值（或者可以优化为最大值最小值范围，通过调整数组使最小元素从0开始），在保存元素出现的次数后依次把前一个元素出现次数加到后一个元素中，该值代表当前元素在排序序列中的位置，比如序列待排序序列为{0,0,2,3,4,5,6,2,3,1}，通过第一步计数得到Count数组Count[0~6]={2,1,2,2,1,1,1}，然后依次将前一个元素出现的次数加到后一个元素中得到Count[0~6]={2,3,5,7,8,9,10}，比如Count[0]=2表示包括自己在内前面有2个元素，因此最后出现的0元素在的位置为第二个，依此类推。为了保证排序的稳定性，计数排序在最后一步排序时采用从后往前扫描的方式。由于计数排序需要Count数组以及一个附加数组保存排序后的元素，因此其空间复杂度为O(N+K)，N为元素个数，K为Count数组大小。计数排序在排序过程中需要先扫描一遍整个数组，然后扫描Count数组，最后扫描整个数组回填序列，因此时间复杂度为O(2N+K)。实现代码如下所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid CountingSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n        DataType maxElement = inputArray[0], minElement = inputArray[0];\n        for (size_t i = 1; i < inputArray.size(); i++) {\n                maxElement = maxElement > inputArray[i] ? maxElement : inputArray[i];\n                minElement = minElement < inputArray[i] ? minElement : inputArray[i];\n        }\n\n        for (size_t i = 0; i < inputArray.size(); i++) {\n                inputArray[i] -= minElement;\n        }\n\n        int CountSize = maxElement - minElement + 1;\n        vector<DataType> tmpArray(inputArray.size(), 0);\n        vector<int> Count(CountSize, 0);\n\n\tfor (size_t i = 0; i < inputArray.size(); i++) {\n\t\tCount[inputArray[i]]++;\n\t}\n\tfor (int i = 1; i < CountSize; i++) {\n\t\tCount[i] += Count[i-1];\n\t}\n\tfor (int i = int(inputArray.size()-1); i >= 0; i--) {\n\t\ttmpArray[--Count[inputArray[i]]] = inputArray[i];\n\t}\n\tfor (size_t i = 0; i < inputArray.size(); i++) {\n\t\tinputArray[i] = tmpArray[i] + minElement;\n\t}\n}\n```\n\n## 基数排序\n\n基数排序的基本思路和计数排序类似，不过基数排序把元素按照位数切割，对每一位进行排序比较，最后得到有序序列，由于进行了切割，其使用额外的空间大大下降，只和每位的数字取值个数有关（即进制）。基数排序方式有LSD(Least significant digital)和MSD(Most significant digital)，LSD从低位到高位，MSD从高位到低位，一般而言LSD的编程方式更简单。基数排序需要进行d轮计数，每轮包括三次遍历原始数组和一次遍历计数数组，故时间复杂度为O(d(3N+r))，r为位数，空间复杂度为申请的计数数组和存放排序结果的附加数组，空间复杂度为O(N+r)，具体代码如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid RadixSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n        DataType maxElement = inputArray[0], minElement = inputArray[0];\n        for (size_t i = 1; i < inputArray.size(); i++) {\n                maxElement = maxElement > inputArray[i] ? maxElement : inputArray[i];\n                minElement = minElement < inputArray[i] ? minElement : inputArray[i];\n        }\n        \n        for (size_t i = 0; i < inputArray.size(); i++) {\n                inputArray[i] -= minElement;\n        }\n\n        int maxBit = 0; DataType tmp = maxElement - minElement;\n        while (tmp > 0) {\n                ++maxBit; tmp /= 10;\n        }\n        \n        const int notation = 10;\n        vector<int> Count(notation, 0); //默认十进制\n        vector<DataType> tmpArray(inputArray.size(), 0);\n\n\tDataType radix = 1;\n\tfor (int i = 1; i <= maxBit; i++) {\n\t\tfor (int j = 0; j < notation; j++) {\n                        Count[j] = 0;\n                }\n\n\t\tfor (size_t j = 0; j < inputArray.size(); j++) {\n\t\t\ttmp = (inputArray[j]/radix) % notation;\n\t\t\t++Count[tmp];\n\t\t}\n\n\t\tfor (int j = 1; j < notation; j++) {\n                        Count[j] += Count[j-1];\n                }\n\t\t\n\t\tfor (int j = int(inputArray.size()-1); j >= 0; j--) {\n\t\t\ttmp = (inputArray[j]/radix)%notation;\n\t\t\ttmpArray[--Count[tmp]] = inputArray[j];\n\t\t}\n\n\t\tfor (size_t j = 0; j < inputArray.size(); j++) {\n\t\t\tinputArray[j] = tmpArray[j];\n\t\t}\n\t\t\n\t\tradix *= notation;\n\t}\n\n\tfor (size_t i = 0; i < inputArray.size(); i++) {\n\t\tinputArray[i] += minElement;\n\t}\n}\n```\n\n## 桶排序\n\n桶排序又称为箱排序，其基本思路是将待排序的序列分散到不同的桶中（按照大小范围，比如0~100放到一个桶中，101~200放到第二个桶中，依此类推），在每个桶中进行某种排序，最后把各个桶的结果组合起来形成最终的排序结果，在每个桶中可以采用计数排序、插入排序等排序算法，如果数组元素范围不大，每个桶可以直接采用计数排序。按照桶中排序方式不同时间复杂度差异比较大，而且是否稳定排序也和排序策略有关。桶排序最差时间复杂度可以达到O(N<sup>2</sup>)，最好发生在每个桶排序时间复杂度均为线性，此时为O(N+k)，k为桶的个数。桶排序的空间复杂度也和使用的底部排序算法有关，如果采用插入排序空间复杂度可以做到O(N+k)，k为定义桶发生的空间消耗，以下基于插入排序和链表结构完成桶排序的算法。\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *next;\n\tNode(DataType inData):data(inData), next(nullptr) {}\n};\n\ntemplate <typename DataType>\nvoid InsertSort(Node<DataType> *dummyNode, DataType inVal)\n{\n\tif (dummyNode == nullptr) return;\n\tNode<DataType> *cycleIter = dummyNode; //哑节点一定存在\n\t//保持稳定性，插入想等元素的最后方\n\twhile (cycleIter->next != nullptr && cycleIter->next->data <= inVal) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\tNode<DataType> * tmp = cycleIter->next;\n\tcycleIter->next = new Node<DataType>(inVal);\n\tcycleIter->next->next = tmp;\n}\n\ntemplate <typename DataType>\nvoid MakeEmpty(Node<DataType> *dummyNode)\n{\n\tNode<DataType> *cycleIter = dummyNode->next;\n\tNode<DataType> *tmp = nullptr;\n\twhile (cycleIter != nullptr) {\n\t\ttmp = cycleIter->next;\n\t\tdelete cycleIter;\n\t\tcycleIter = tmp;\n\t}\n}\n\ntemplate <typename DataType>\nvoid BucketSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n\n        DataType maxElement = inputArray[0], minElement = inputArray[0];\n        for (size_t i = 1; i < inputArray.size(); i++) {\n                maxElement = maxElement > inputArray[i] ? maxElement : inputArray[i];\n                minElement = minElement < inputArray[i] ? minElement : inputArray[i];\n        }\n        \n        for (size_t i = 0; i < inputArray.size(); i++) {\n                inputArray[i] -= minElement;\n        }\n\n\tDataType max = maxElement - minElement;\n\n\t//不妨假设有10个桶\n\tNode<DataType> bucket[10] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};\n\n\tmax /= 10; ++max;\n\tfor (size_t i = 0; i < inputArray.size(); i++) {\n\t\tInsertSort(&bucket[(inputArray[i]/max)], inputArray[i]);\n\t}\n\tfor (int i = 0, j = 0; i < 10; i++) {\n\t\tNode<DataType> *cycleIter = bucket[i].next;\n\t\twhile (cycleIter != nullptr) {\n\t\t\tinputArray[j++] = cycleIter->data;\n\t\t\tcycleIter = cycleIter->next;\n\t\t}\n\t}\n\tfor (int i = 0; i < 10; i++) {\n\t\tMakeEmpty(&bucket[i]);\n\t}\n\n        for (size_t i = 0; i < inputArray.size(); i++) {\n\t\tinputArray[i] += minElement;\n\t}\n}\n```\n\n## 希尔排序\n\n希尔排序是直接插入排序的优化版，其通过将相隔一定区间的元素进行插入排序来使得元素跨越式交换，在这个过程中可能会一次交换消除多个逆序对，因此希尔排序的时间复杂度可以达到亚二次上界。希尔排序使用增量序列来进行元素跨区间插入排序，只要最后一个增量为1增可以保证最终可以得到有序的序列（增量为1退化成普通的插入排序）。增量序列的选取将会极大影响希尔排序的性能，因此不同的增量序列时间复杂度也不同，因此这里不做时间复杂度的分析，希尔排序的空间复杂度为O(1)。希尔排序由于大跨度插入，导致其排序结果是不稳定的。这里采用Donald Shell最初建议步长序列实现如下希尔排序代码（只要把插入排序稍微调整即可）：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid ShellSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n\tDataType tmp; int j = 0;\n\tfor (size_t step = inputArray.size()/2; step > 0; step /= 2) {\n\t\tfor (size_t i = step; i < inputArray.size(); i++) {\n\t\t\ttmp = inputArray[i];\n\t\t\tfor (j = int(i); j >= int(step) && inputArray[j-int(step)] > tmp; j -= step) {\n\t\t\t\tinputArray[j] = inputArray[j-step];\n\t\t\t}\n\t\t\tinputArray[j] = tmp;\n\t\t}\n\t}\n}\n```\n\n## 堆排序\n\n堆排序采用的是二叉堆这种数据结构和不断删除堆顶元素最后得到一个有序序列的思想实现的，在建堆和删除时都可以采用一种称为下滤策略的方式及完成，因此可以将该策略做成一个单独的函数部分。在数据结构二叉堆分析中建堆过程中花费的时间为O(N)，而每次删除最差时间复杂度为log<sub>2</sub>N，共需进行Nlog<sub>2</sub>N完成整个的删除，而建堆是可以在数组中原地完成的，因此其空间复杂度为O(1)。堆排序代码如下： \n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid PercolateDown(vector<DataType> &inputArray, int index, int end)\n{\n\tDataType tmp = inputArray[index]; int i = index;\n\tfor (i = index; 2*i+1 < end; ) {\n\t\tint maxChild = 2*i+1;\n\t\tif (maxChild+1 < end && inputArray[maxChild] < inputArray[maxChild+1]) {\n\t\t\t++maxChild;\n\t\t}\n\t\tif (inputArray[maxChild] > tmp) {\n\t\t\tinputArray[i] = inputArray[maxChild];\n\t\t\ti = maxChild;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinputArray[i] = tmp;\n}\n\n\ntemplate <typename DataType>\nvoid HeapSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n\tfor (int i = int(inputArray.size()/2); i >= 0; i--) {\n\t\tPercolateDown(inputArray, i, int(inputArray.size())); //分层下滤建堆\n\t}\n\n\tfor (size_t i = 0; i < inputArray.size()-1; i++) {\n\t\tswap(inputArray[0], inputArray[inputArray.size()-i-1]); //删除堆顶\n\t\tPercolateDown(inputArray, 0, int(inputArray.size()-i-1));\n\t}\n}\n```\n\n## 鸡尾酒排序\n\n鸡尾酒排序是冒泡排序的一种变形，在一趟遍历中既让元素上浮也让元素下沉，其时间负复杂度和冒泡泡排序一样，其时间复杂度分析和冒泡排序类似，同时也可以通过设置标志位优化最佳排序时间复杂度，代码如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid CocktailShakerSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n\tint unordedStart = 0, unordedEnd = int(inputArray.size()); //左闭右开\n\twhile (unordedStart < unordedEnd) {\n\t\tbool hasSwap = false;\n\t\tfor (int i = unordedStart; i < unordedEnd-1; i++) {\n\t\t\tif (inputArray[i] > inputArray[i+1]) {\n\t\t\t\tswap(inputArray[i], inputArray[i+1]);\n\t\t\t\thasSwap = true;\n\t\t\t}\n\t\t}\n\t\t--unordedEnd;\n\t\tif (!hasSwap) {\n                        return;\n                }\n\n\t\thasSwap = false;\n\t\tfor (int i = unordedEnd-1; i > unordedStart; i--) {\n\t\t\tif (inputArray[i] < inputArray[i-1]) {\n\t\t\t\tswap(inputArray[i], inputArray[i-1]);\n\t\t\t\thasSwap = true;\n\t\t\t}\n\t\t}\n\t\t++unordedStart;\n\t\tif (!hasSwap) {\n                        return;\n                }\n\t}\n}\n```\n\n## 排序算法测试\n\n上述排序代码的测试如下：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tconst int testNum[] = { 10, 100, 1000, 10000, 100000, 1000000, 10000000 };\n\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<int> intDis(int(-10e4), int(10e4));\n\n        int testTimes = 5;\n\n\twhile ((testTimes--) > 0) {\n                for (size_t i = 0; i < sizeof(testNum) / sizeof(testNum[0]); i++) {\n                        vector<int> testData1, testData2;\n\n                        for (int j = 0; j < testNum[i]; j++) {\n                                int tmp = intDis(randEngine);\n                                testData1.push_back(tmp); testData2.push_back(tmp);\n                        }\n\n                        auto startTime = system_clock::now();\n                        //调用具体的排序算法\n                        //InsertionSort(testData1);\n\n                        auto endTime = system_clock::now();\n\n                        sort(testData2.begin(), testData2.end());\n\n                        cout << ((testData1 == testData2) ? \"Correct;\" : \"Wrong;\");\n\n                        auto duration = duration_cast<microseconds>(endTime - startTime);\n                        cout << \"TimeCost:\" << duration.count() << endl;\n                }\n        }\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/算法设计/各大排序算法分析与实现.md","raw":"---\ntitle: 各大排序算法的分析与实现\nurlname: sort-algorithm\ndate: 2018-03-15 21:12:41\ncopyright: true\nmathjax: true\ntags:\n- 算法设计\ncategories:\n- 算法设计\n---\n\n## 排序算法汇总\n\n- 插入排序：插入排序思想是通过逐遍扫描（N-1遍扫描，N为排序元素个数）的方式消除逆序对，对于位置P=1遍到P=N-1遍保证插入顺序位置0到位置P为已排序状态。\n- 冒泡排序：通过重复遍历待排序的数列，每次比较一对元素，过程中不断消除逆序对，最终达到排序的目的，和插入排序对比，冒泡排序每次遍历结束后已排序的数列元素个数至少+1\n- 选择排序：每次遍历找到未排序序列的最大或者最小值，将其插入已排序队列的末尾，一般需要N-1趟遍历，因此选择排序移动元素次数很少，至多为N-1次\n- 归并排序：归并排序是分治法的典型应用之一，分治法解决问题主要步骤为：分解，将原问题分解成一系列子问题；解决，递归地解各子问题，若子问题足够小，则直接求解；合并，将子问题的解合并成原问题的解。归并排序分解动作为将数组分为两半；递归解规模为N/2的子问题，最终分解成只有一个元素的子问题；最后将子问题解合并得到最终排序的序列\n- 快速排序：快速排序和归并排序一样，也是采用分治思想，不过其分解思路为将数组分解为以某一基准值的两部分，使得一部分序列的所有元素都小于等于该基准值，另一部分序列的所有元素都大于该基准值（实际和基准值相等的元素可以放到任何一部分）。递归地分解直到分解序列元素个数为0或1。最后合并子问题解得到原问题解\n- 计数排序：计数排序的基本思想为对每个序列元素x，确定小于等于x的元素的个数m，从而根据m确定元素的排序后的位置。其基本流程可归纳如下：找出序列的最大最小值，确定k值；定义数组Count[0~k]，统计序列中值为i的元素的个数并存入Count[i]中；计算Count[i]=Count[i]+Count[i-1]；反向填充目标排序数组，将每个元素放入数组的第Count[i]项，同时Count[i]值减1\n- 基数排序：基数排序的原理是将整数按位切割成若干数字，按照每位数分别比较，最终合并成有序的序列\n- 桶排序：桶排序的基本思想是将待排序序列分到数量有限的桶中，然后对每个桶分别排序，最后将各个桶中的数据有序地合并起来\n- 希尔排序：希尔排序是递减增量排序算法，是插入排序更高效的改进版本，其基本思想为通过将比较的元素根据增量序列分为若干区域，然后对若干区域进行直接插入排序，随着增量序列减少到1时，进行最终的插入排序\n- 堆排序：堆排序的基本原理是利用堆这种数据结构完成排序，通过不断的删除堆顶元素和调整堆，最终得到有序的序列\n- 鸡尾酒排序：鸡尾酒排序也称为定向冒泡排序，是冒泡排序的一种变形，主要区别在于排序时是以双向在序列中排序，即大值往上交换时小值往下交换\n\n各排序算法的时间复杂度和空间复杂比较如下表：\n\n![排序算法对比](/images/sort-algorithm-compare.png)\n\n以下分别分析实现各大算法。\n\n## 插入排序\n\n插入排序是基于比较的排序，其基本原理是在初始状态前1个元素是有序的，然后每次将后方的一个元素插入前方的有序段并保持有序，当最后一个元素插入完成时，整个序列保持有序。其时间复杂度可以通过简单的计算得出，我们不妨假设每趟元素至少需要和有序元素段的一半元素进行比较，则时间复杂度可为1/2+1+3/2+4/2....+(N-1)/2=(N-1)N/4=O(N<sup>2</sup>)；最差时间就是1+2+3+N-1=(N-1)N/2=O(N<sup>2</sup>)；最好的就是每次只需和有序队列比较一个元素就可以确定位置，即输入序列即为有序，此时时间复杂度为1+1+1+....(n-1个)=N-1=O(N)。插入排序除了几个变量外无需额外空间，因此空间复杂度为O(1)。下面为插入排序的实现，采用模板编程方式实现。\n\n```cpp\n//非递减\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid InsertionSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n\n\tDataType tmp; int j = 0;\n\tfor (size_t i = 1; i < inputArray.size(); i++) {\n\t\ttmp = inputArray[i];\n\t\tfor (j = int(i); j > 0 && inputArray[j-1] > tmp; j--) {\n\t\t\tinputArray[j] = inputArray[j-1];\n\t\t}\n\t\tinputArray[j] = tmp;\n\t}\n}\n```\n\n有一道腾讯笔试题即可采用该算法思想完成，题目见下：\n\n>腾讯笔试题“字符移位”  \n>小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？  \n>输入描述：输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.  \n>输出描述：对于每组数据，输出移位后的字符串。  \n>输入输出示例：输入AkleBiCeilD，输出kleieilABCD。  \n\n此题只要对于小写字母，只要往前移动知道遇到小写字母或者移动到首位置即可停止，代码见下：\n\n```cpp\nvoid MoveChar(string &inputString)\n{\n    for (int i = 1; i < int(inputString.size()); i++) {\n        for (int j = i; j >= 1; j--) {\n            if (islower(inputString.at(j)) && isupper(inputString.at(j-1))) {\n                swap(inputString.at(j), inputString.at(j-1));\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n## 冒泡排序\n\n冒泡排序的过程非常类似于自然界上浮现象，从第一个元素开始，依次和后一个元素比较，如果大，则交换，直到上浮到顶端，其时间复杂度分析和插入排序类似但是由于需要一路比较直到顶部，因此冒泡算法的时间复杂度最坏和平均情况都需要一直交换到顶端，因此为N-1+N-2+.....1=(N-1)N/2，而最好时间复杂度可以通过设置一个标志位达到O(N)，否则按照常规无标志位的最好依然需要O(N<sup>2</sup>)，冒泡排序空间复杂度和插入排序一样为O(1)。标志位原理如下代码所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid BubbleSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n\n\tfor (size_t i = 0; i < inputArray.size() - 1; i++) {\n\t\t//标记在一趟排序遍历时是否交换过，如果没有交换过说明原始有序，可以直接退出\n\t\tbool hasSwap = false; \n\t\tfor (size_t j = 0; j < inputArray.size() - i - 1; j++) {\n\t\t\tif (inputArray[j] > inputArray[j+1]) {\n\t\t\t\tswap(inputArray[j], inputArray[j+1]); //STL库函数\n\t\t\t\thasSwap = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasSwap) {\n                        return;\n                }\n\t}\n}\n```\n\n## 选择排序\n\n选择排序的原理是在未排序的序列找到一个最小值，插到已排序序列第的末尾。在第一遍历时找到最小值，第二次找多第二小值，经过N-1趟遍历可以排好N-1个元素，最后一个元素肯定处在正确位置。由于选择排序每次都要遍历整个未排序序列，故其最好与最坏时间复杂度均为N+N-1.....2=(N+2)(N-1)/2=O(N<sup>2</sup>)，其基本代码如下所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid SelectionSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n\n\tfor (size_t i = 0; i < inputArray.size() - 1; i++) {\n\t\tsize_t minIndex = i;\n\n\t\tfor (size_t j = i+1; j < inputArray.size(); j++) {\n\t\t\tif (inputArray[j] < inputArray[minIndex]) {\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\n\t\tif (minIndex != i) {\n                        swap(inputArray[i], inputArray[minIndex]);\n                }\n\t}\n}\n```\n\n## 归并排序\n\n归并排序是分治法经典的应用之一，归并排序通过将问题划分为两个大小相似的问题分别求解，然后合并两部分解得到最后的解，其时间复杂度递推关系式为T(N)=2T(N/2)+N（T(1)=1）；其中N代表在合并解时花费的时间，即合并两个序列的总大小。在求解这个关系式时，可以两边同时除以N，有T(N)/N=T(N/2)/(N/2)+1，而T(N/2)/(N/2)=T(N/4)/(N/4)+1....T(2)/2=T(1)+1。所有左边相加，所有右边相加有T(N)/N=T(1)+log<sub>2</sub>N，推出T(N)=Nlog<sub>2</sub>N+N=O(Nlog<sub>2</sub>N)，归并排序由于需要一个附加的数组保存归并结果，因此空间复杂度为O(N)，递归栈空间为log<sub>2</sub>N。归并排序有两种算法，递归和非递归，递归版算法代码分别如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\n//区间为左闭右开，和STL保持一致\ntemplate <typename DataType>\nvoid Merge(vector<DataType> &inputArray, vector<DataType> &tmpArray, int left, int middle, int right)\n{\n\tint i = left, j = middle, tmpStart = left;\n\twhile (i < middle && j < right) {\n\t\tif (inputArray[i] < inputArray[j]) {\n\t\t\ttmpArray[tmpStart] = inputArray[i];\n\t\t\t++tmpStart; ++i;\n\t\t}\n\t\telse {\n\t\t\ttmpArray[tmpStart] = inputArray[j];\n\t\t\t++tmpStart; ++j;\n\t\t}\n\t}\n\twhile (i < middle) {\n\t\ttmpArray[tmpStart] = inputArray[i];\n\t\t++tmpStart; ++i;\n\t}\n\twhile (j < right) {\n\t\ttmpArray[tmpStart] = inputArray[j];\n\t\t++tmpStart; ++j;\n\t}\n\tfor (i = left; i < right; i++) {\n\t\tinputArray[i] = tmpArray[i];\n\t}\n}\n\ntemplate <typename DataType>\nvoid MergeSortCore(vector<DataType> &inputArray, vector<DataType> &tmpArray, int left, int right)\n{\n        if (left + 1 >= right) {\n                return;\n        }\n\n\tint middle = (left+right)/2;\n\n\tMergeSortCore(inputArray, tmpArray, left, middle);\n\tMergeSortCore(inputArray, tmpArray, middle, right);\n\n\tMerge(inputArray, tmpArray, left, middle, right);\n}\n\ntemplate <typename DataType>\nvoid MergeSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n        \n        vector<DataType> tmpArray(inputArray.size(), 0);\n\n        int left = 0, right = int(inputArray.size());\n\n        MergeSortCore(inputArray, tmpArray, left, right);\n}\n```\n\n## 快速排序\n\n快速排序和归并排序的基本思想都是分治法，不过快速排序划分子问题是以一个元素为基准，小于该元素的放在一边，大于的放在另外一边，通过这样的递归划分，最终递归只剩一个元素时返回，由于每次分割排序后分割元素都在正确位置，因此该算法最终将会使整个序列有序。由于快速排序分割元素选取是不固定的，一般有固定选取头部或者尾部（如果原始有序则时间复杂度很差）、随机选取和三数中值分割法等。快速排序最好时间复杂度产生在每次都均分数组，此时时间复杂度为O(Nlog<sub>2</sub>N)，而最差发生在每次将数组分割成1个元素和剩余的元素，此时时间复杂度为O(N<sup>2</sup>)。在空间复杂度上，由于快速排序可以不借助额外空间进行原地交换，因此其空间复杂度为栈空间复杂度log<sub>2</sub>N，最差空间复杂度为O(N)。和归并排序一样，快速排序也有递归与非递归版本，递归版实现如下代码：\n\n**果然如《数据结构与算法分析》所言，大部分人一般无法正确编写快排程序，( ╯□╰ )**\n\n\n```cpp\n#include <vector>\nusing std::vector;\n\n//左闭右开区间\ntemplate <typename DataType>\nvoid QuickSortCore(vector<DataType> &inputArray, int start, int end)\n{\n\tif (start+1 >= end) {\n                return;\n        }\n\n\tint base = inputArray[end-1];\n\tint i = start, j = end-2;\n\twhile (i <= j) { /*使i行进到正确的位置*/\n\t\twhile (i < end && inputArray[i] < base) {\n                        ++i;\n                }\n\n\t\twhile (j > start && inputArray[j] > base) {\n                        --j;\n                }\n\n\t\tif (i < j) {\n\t\t\tswap(inputArray[i], inputArray[j]);\n\t\t\t++i; --j; /*可能导致i,j指向同一位置*/\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswap(inputArray[i], inputArray[end-1]);\n\n\tQuickSortCore(inputArray, start, i);\n\tQuickSortCore(inputArray, i+1, end);\n}\n\ntemplate <typename DataType>\nvoid QuickSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n\tQuickSortCore(inputArray, 0, int(inputArray.size()));\n}\n```\n\n## 计数排序\n\n在基于比较的排序算法中，根据决策树分析，基于比较的排序的时间复杂度下界为O(Nlog<sub>2</sub>N)。如果需要突破该下限，则必须使用非比较型的算法，计数排序既是其中的一种。在使用计数排序时，对输入序列的范围有要求，计数排序需要额外一个数组用来保存元素出现的次数，该数组的大小为元素最大值（或者可以优化为最大值最小值范围，通过调整数组使最小元素从0开始），在保存元素出现的次数后依次把前一个元素出现次数加到后一个元素中，该值代表当前元素在排序序列中的位置，比如序列待排序序列为{0,0,2,3,4,5,6,2,3,1}，通过第一步计数得到Count数组Count[0~6]={2,1,2,2,1,1,1}，然后依次将前一个元素出现的次数加到后一个元素中得到Count[0~6]={2,3,5,7,8,9,10}，比如Count[0]=2表示包括自己在内前面有2个元素，因此最后出现的0元素在的位置为第二个，依此类推。为了保证排序的稳定性，计数排序在最后一步排序时采用从后往前扫描的方式。由于计数排序需要Count数组以及一个附加数组保存排序后的元素，因此其空间复杂度为O(N+K)，N为元素个数，K为Count数组大小。计数排序在排序过程中需要先扫描一遍整个数组，然后扫描Count数组，最后扫描整个数组回填序列，因此时间复杂度为O(2N+K)。实现代码如下所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid CountingSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n        DataType maxElement = inputArray[0], minElement = inputArray[0];\n        for (size_t i = 1; i < inputArray.size(); i++) {\n                maxElement = maxElement > inputArray[i] ? maxElement : inputArray[i];\n                minElement = minElement < inputArray[i] ? minElement : inputArray[i];\n        }\n\n        for (size_t i = 0; i < inputArray.size(); i++) {\n                inputArray[i] -= minElement;\n        }\n\n        int CountSize = maxElement - minElement + 1;\n        vector<DataType> tmpArray(inputArray.size(), 0);\n        vector<int> Count(CountSize, 0);\n\n\tfor (size_t i = 0; i < inputArray.size(); i++) {\n\t\tCount[inputArray[i]]++;\n\t}\n\tfor (int i = 1; i < CountSize; i++) {\n\t\tCount[i] += Count[i-1];\n\t}\n\tfor (int i = int(inputArray.size()-1); i >= 0; i--) {\n\t\ttmpArray[--Count[inputArray[i]]] = inputArray[i];\n\t}\n\tfor (size_t i = 0; i < inputArray.size(); i++) {\n\t\tinputArray[i] = tmpArray[i] + minElement;\n\t}\n}\n```\n\n## 基数排序\n\n基数排序的基本思路和计数排序类似，不过基数排序把元素按照位数切割，对每一位进行排序比较，最后得到有序序列，由于进行了切割，其使用额外的空间大大下降，只和每位的数字取值个数有关（即进制）。基数排序方式有LSD(Least significant digital)和MSD(Most significant digital)，LSD从低位到高位，MSD从高位到低位，一般而言LSD的编程方式更简单。基数排序需要进行d轮计数，每轮包括三次遍历原始数组和一次遍历计数数组，故时间复杂度为O(d(3N+r))，r为位数，空间复杂度为申请的计数数组和存放排序结果的附加数组，空间复杂度为O(N+r)，具体代码如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid RadixSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n        DataType maxElement = inputArray[0], minElement = inputArray[0];\n        for (size_t i = 1; i < inputArray.size(); i++) {\n                maxElement = maxElement > inputArray[i] ? maxElement : inputArray[i];\n                minElement = minElement < inputArray[i] ? minElement : inputArray[i];\n        }\n        \n        for (size_t i = 0; i < inputArray.size(); i++) {\n                inputArray[i] -= minElement;\n        }\n\n        int maxBit = 0; DataType tmp = maxElement - minElement;\n        while (tmp > 0) {\n                ++maxBit; tmp /= 10;\n        }\n        \n        const int notation = 10;\n        vector<int> Count(notation, 0); //默认十进制\n        vector<DataType> tmpArray(inputArray.size(), 0);\n\n\tDataType radix = 1;\n\tfor (int i = 1; i <= maxBit; i++) {\n\t\tfor (int j = 0; j < notation; j++) {\n                        Count[j] = 0;\n                }\n\n\t\tfor (size_t j = 0; j < inputArray.size(); j++) {\n\t\t\ttmp = (inputArray[j]/radix) % notation;\n\t\t\t++Count[tmp];\n\t\t}\n\n\t\tfor (int j = 1; j < notation; j++) {\n                        Count[j] += Count[j-1];\n                }\n\t\t\n\t\tfor (int j = int(inputArray.size()-1); j >= 0; j--) {\n\t\t\ttmp = (inputArray[j]/radix)%notation;\n\t\t\ttmpArray[--Count[tmp]] = inputArray[j];\n\t\t}\n\n\t\tfor (size_t j = 0; j < inputArray.size(); j++) {\n\t\t\tinputArray[j] = tmpArray[j];\n\t\t}\n\t\t\n\t\tradix *= notation;\n\t}\n\n\tfor (size_t i = 0; i < inputArray.size(); i++) {\n\t\tinputArray[i] += minElement;\n\t}\n}\n```\n\n## 桶排序\n\n桶排序又称为箱排序，其基本思路是将待排序的序列分散到不同的桶中（按照大小范围，比如0~100放到一个桶中，101~200放到第二个桶中，依此类推），在每个桶中进行某种排序，最后把各个桶的结果组合起来形成最终的排序结果，在每个桶中可以采用计数排序、插入排序等排序算法，如果数组元素范围不大，每个桶可以直接采用计数排序。按照桶中排序方式不同时间复杂度差异比较大，而且是否稳定排序也和排序策略有关。桶排序最差时间复杂度可以达到O(N<sup>2</sup>)，最好发生在每个桶排序时间复杂度均为线性，此时为O(N+k)，k为桶的个数。桶排序的空间复杂度也和使用的底部排序算法有关，如果采用插入排序空间复杂度可以做到O(N+k)，k为定义桶发生的空间消耗，以下基于插入排序和链表结构完成桶排序的算法。\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nstruct Node\n{\n\tDataType data;\n\tNode *next;\n\tNode(DataType inData):data(inData), next(nullptr) {}\n};\n\ntemplate <typename DataType>\nvoid InsertSort(Node<DataType> *dummyNode, DataType inVal)\n{\n\tif (dummyNode == nullptr) return;\n\tNode<DataType> *cycleIter = dummyNode; //哑节点一定存在\n\t//保持稳定性，插入想等元素的最后方\n\twhile (cycleIter->next != nullptr && cycleIter->next->data <= inVal) {\n\t\tcycleIter = cycleIter->next;\n\t}\n\tNode<DataType> * tmp = cycleIter->next;\n\tcycleIter->next = new Node<DataType>(inVal);\n\tcycleIter->next->next = tmp;\n}\n\ntemplate <typename DataType>\nvoid MakeEmpty(Node<DataType> *dummyNode)\n{\n\tNode<DataType> *cycleIter = dummyNode->next;\n\tNode<DataType> *tmp = nullptr;\n\twhile (cycleIter != nullptr) {\n\t\ttmp = cycleIter->next;\n\t\tdelete cycleIter;\n\t\tcycleIter = tmp;\n\t}\n}\n\ntemplate <typename DataType>\nvoid BucketSort(vector<DataType> &inputArray)\n{\n\tif (inputArray.size() <= 1) {\n                return;\n        }\n\n        DataType maxElement = inputArray[0], minElement = inputArray[0];\n        for (size_t i = 1; i < inputArray.size(); i++) {\n                maxElement = maxElement > inputArray[i] ? maxElement : inputArray[i];\n                minElement = minElement < inputArray[i] ? minElement : inputArray[i];\n        }\n        \n        for (size_t i = 0; i < inputArray.size(); i++) {\n                inputArray[i] -= minElement;\n        }\n\n\tDataType max = maxElement - minElement;\n\n\t//不妨假设有10个桶\n\tNode<DataType> bucket[10] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};\n\n\tmax /= 10; ++max;\n\tfor (size_t i = 0; i < inputArray.size(); i++) {\n\t\tInsertSort(&bucket[(inputArray[i]/max)], inputArray[i]);\n\t}\n\tfor (int i = 0, j = 0; i < 10; i++) {\n\t\tNode<DataType> *cycleIter = bucket[i].next;\n\t\twhile (cycleIter != nullptr) {\n\t\t\tinputArray[j++] = cycleIter->data;\n\t\t\tcycleIter = cycleIter->next;\n\t\t}\n\t}\n\tfor (int i = 0; i < 10; i++) {\n\t\tMakeEmpty(&bucket[i]);\n\t}\n\n        for (size_t i = 0; i < inputArray.size(); i++) {\n\t\tinputArray[i] += minElement;\n\t}\n}\n```\n\n## 希尔排序\n\n希尔排序是直接插入排序的优化版，其通过将相隔一定区间的元素进行插入排序来使得元素跨越式交换，在这个过程中可能会一次交换消除多个逆序对，因此希尔排序的时间复杂度可以达到亚二次上界。希尔排序使用增量序列来进行元素跨区间插入排序，只要最后一个增量为1增可以保证最终可以得到有序的序列（增量为1退化成普通的插入排序）。增量序列的选取将会极大影响希尔排序的性能，因此不同的增量序列时间复杂度也不同，因此这里不做时间复杂度的分析，希尔排序的空间复杂度为O(1)。希尔排序由于大跨度插入，导致其排序结果是不稳定的。这里采用Donald Shell最初建议步长序列实现如下希尔排序代码（只要把插入排序稍微调整即可）：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid ShellSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n\tDataType tmp; int j = 0;\n\tfor (size_t step = inputArray.size()/2; step > 0; step /= 2) {\n\t\tfor (size_t i = step; i < inputArray.size(); i++) {\n\t\t\ttmp = inputArray[i];\n\t\t\tfor (j = int(i); j >= int(step) && inputArray[j-int(step)] > tmp; j -= step) {\n\t\t\t\tinputArray[j] = inputArray[j-step];\n\t\t\t}\n\t\t\tinputArray[j] = tmp;\n\t\t}\n\t}\n}\n```\n\n## 堆排序\n\n堆排序采用的是二叉堆这种数据结构和不断删除堆顶元素最后得到一个有序序列的思想实现的，在建堆和删除时都可以采用一种称为下滤策略的方式及完成，因此可以将该策略做成一个单独的函数部分。在数据结构二叉堆分析中建堆过程中花费的时间为O(N)，而每次删除最差时间复杂度为log<sub>2</sub>N，共需进行Nlog<sub>2</sub>N完成整个的删除，而建堆是可以在数组中原地完成的，因此其空间复杂度为O(1)。堆排序代码如下： \n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid PercolateDown(vector<DataType> &inputArray, int index, int end)\n{\n\tDataType tmp = inputArray[index]; int i = index;\n\tfor (i = index; 2*i+1 < end; ) {\n\t\tint maxChild = 2*i+1;\n\t\tif (maxChild+1 < end && inputArray[maxChild] < inputArray[maxChild+1]) {\n\t\t\t++maxChild;\n\t\t}\n\t\tif (inputArray[maxChild] > tmp) {\n\t\t\tinputArray[i] = inputArray[maxChild];\n\t\t\ti = maxChild;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinputArray[i] = tmp;\n}\n\n\ntemplate <typename DataType>\nvoid HeapSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n\tfor (int i = int(inputArray.size()/2); i >= 0; i--) {\n\t\tPercolateDown(inputArray, i, int(inputArray.size())); //分层下滤建堆\n\t}\n\n\tfor (size_t i = 0; i < inputArray.size()-1; i++) {\n\t\tswap(inputArray[0], inputArray[inputArray.size()-i-1]); //删除堆顶\n\t\tPercolateDown(inputArray, 0, int(inputArray.size()-i-1));\n\t}\n}\n```\n\n## 鸡尾酒排序\n\n鸡尾酒排序是冒泡排序的一种变形，在一趟遍历中既让元素上浮也让元素下沉，其时间负复杂度和冒泡泡排序一样，其时间复杂度分析和冒泡排序类似，同时也可以通过设置标志位优化最佳排序时间复杂度，代码如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nvoid CocktailShakerSort(vector<DataType> &inputArray)\n{\n        if (inputArray.size() <= 1) {\n                return;\n        }\n\n\tint unordedStart = 0, unordedEnd = int(inputArray.size()); //左闭右开\n\twhile (unordedStart < unordedEnd) {\n\t\tbool hasSwap = false;\n\t\tfor (int i = unordedStart; i < unordedEnd-1; i++) {\n\t\t\tif (inputArray[i] > inputArray[i+1]) {\n\t\t\t\tswap(inputArray[i], inputArray[i+1]);\n\t\t\t\thasSwap = true;\n\t\t\t}\n\t\t}\n\t\t--unordedEnd;\n\t\tif (!hasSwap) {\n                        return;\n                }\n\n\t\thasSwap = false;\n\t\tfor (int i = unordedEnd-1; i > unordedStart; i--) {\n\t\t\tif (inputArray[i] < inputArray[i-1]) {\n\t\t\t\tswap(inputArray[i], inputArray[i-1]);\n\t\t\t\thasSwap = true;\n\t\t\t}\n\t\t}\n\t\t++unordedStart;\n\t\tif (!hasSwap) {\n                        return;\n                }\n\t}\n}\n```\n\n## 排序算法测试\n\n上述排序代码的测试如下：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tconst int testNum[] = { 10, 100, 1000, 10000, 100000, 1000000, 10000000 };\n\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<int> intDis(int(-10e4), int(10e4));\n\n        int testTimes = 5;\n\n\twhile ((testTimes--) > 0) {\n                for (size_t i = 0; i < sizeof(testNum) / sizeof(testNum[0]); i++) {\n                        vector<int> testData1, testData2;\n\n                        for (int j = 0; j < testNum[i]; j++) {\n                                int tmp = intDis(randEngine);\n                                testData1.push_back(tmp); testData2.push_back(tmp);\n                        }\n\n                        auto startTime = system_clock::now();\n                        //调用具体的排序算法\n                        //InsertionSort(testData1);\n\n                        auto endTime = system_clock::now();\n\n                        sort(testData2.begin(), testData2.end());\n\n                        cout << ((testData1 == testData2) ? \"Correct;\" : \"Wrong;\");\n\n                        auto duration = duration_cast<microseconds>(endTime - startTime);\n                        cout << \"TimeCost:\" << duration.count() << endl;\n                }\n        }\n\treturn 0;\n}\n```\n\n\n\n","slug":"算法设计/各大排序算法分析与实现","published":1,"updated":"2018-06-13T14:18:44.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x47002fgsvn1m5pc5pl","content":"<h2 id=\"排序算法汇总\"><a href=\"#排序算法汇总\" class=\"headerlink\" title=\"排序算法汇总\"></a>排序算法汇总</h2><ul>\n<li>插入排序：插入排序思想是通过逐遍扫描（N-1遍扫描，N为排序元素个数）的方式消除逆序对，对于位置P=1遍到P=N-1遍保证插入顺序位置0到位置P为已排序状态。</li>\n<li>冒泡排序：通过重复遍历待排序的数列，每次比较一对元素，过程中不断消除逆序对，最终达到排序的目的，和插入排序对比，冒泡排序每次遍历结束后已排序的数列元素个数至少+1</li>\n<li>选择排序：每次遍历找到未排序序列的最大或者最小值，将其插入已排序队列的末尾，一般需要N-1趟遍历，因此选择排序移动元素次数很少，至多为N-1次</li>\n<li>归并排序：归并排序是分治法的典型应用之一，分治法解决问题主要步骤为：分解，将原问题分解成一系列子问题；解决，递归地解各子问题，若子问题足够小，则直接求解；合并，将子问题的解合并成原问题的解。归并排序分解动作为将数组分为两半；递归解规模为N/2的子问题，最终分解成只有一个元素的子问题；最后将子问题解合并得到最终排序的序列</li>\n<li>快速排序：快速排序和归并排序一样，也是采用分治思想，不过其分解思路为将数组分解为以某一基准值的两部分，使得一部分序列的所有元素都小于等于该基准值，另一部分序列的所有元素都大于该基准值（实际和基准值相等的元素可以放到任何一部分）。递归地分解直到分解序列元素个数为0或1。最后合并子问题解得到原问题解</li>\n<li>计数排序：计数排序的基本思想为对每个序列元素x，确定小于等于x的元素的个数m，从而根据m确定元素的排序后的位置。其基本流程可归纳如下：找出序列的最大最小值，确定k值；定义数组Count[0~k]，统计序列中值为i的元素的个数并存入Count[i]中；计算Count[i]=Count[i]+Count[i-1]；反向填充目标排序数组，将每个元素放入数组的第Count[i]项，同时Count[i]值减1</li>\n<li>基数排序：基数排序的原理是将整数按位切割成若干数字，按照每位数分别比较，最终合并成有序的序列</li>\n<li>桶排序：桶排序的基本思想是将待排序序列分到数量有限的桶中，然后对每个桶分别排序，最后将各个桶中的数据有序地合并起来</li>\n<li>希尔排序：希尔排序是递减增量排序算法，是插入排序更高效的改进版本，其基本思想为通过将比较的元素根据增量序列分为若干区域，然后对若干区域进行直接插入排序，随着增量序列减少到1时，进行最终的插入排序</li>\n<li>堆排序：堆排序的基本原理是利用堆这种数据结构完成排序，通过不断的删除堆顶元素和调整堆，最终得到有序的序列</li>\n<li>鸡尾酒排序：鸡尾酒排序也称为定向冒泡排序，是冒泡排序的一种变形，主要区别在于排序时是以双向在序列中排序，即大值往上交换时小值往下交换</li>\n</ul>\n<p>各排序算法的时间复杂度和空间复杂比较如下表：</p>\n<p><img src=\"/images/sort-algorithm-compare.png\" alt=\"排序算法对比\"></p>\n<p>以下分别分析实现各大算法。</p>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序是基于比较的排序，其基本原理是在初始状态前1个元素是有序的，然后每次将后方的一个元素插入前方的有序段并保持有序，当最后一个元素插入完成时，整个序列保持有序。其时间复杂度可以通过简单的计算得出，我们不妨假设每趟元素至少需要和有序元素段的一半元素进行比较，则时间复杂度可为1/2+1+3/2+4/2….+(N-1)/2=(N-1)N/4=O(N<sup>2</sup>)；最差时间就是1+2+3+N-1=(N-1)N/2=O(N<sup>2</sup>)；最好的就是每次只需和有序队列比较一个元素就可以确定位置，即输入序列即为有序，此时时间复杂度为1+1+1+….(n-1个)=N-1=O(N)。插入排序除了几个变量外无需额外空间，因此空间复杂度为O(1)。下面为插入排序的实现，采用模板编程方式实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非递减</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertionSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tDataType tmp; <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\ttmp = inputArray[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = <span class=\"keyword\">int</span>(i); j &gt; <span class=\"number\">0</span> &amp;&amp; inputArray[j<span class=\"number\">-1</span>] &gt; tmp; j--) &#123;</span><br><span class=\"line\">\t\t\tinputArray[j] = inputArray[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tinputArray[j] = tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有一道腾讯笔试题即可采用该算法思想完成，题目见下：</p>\n<blockquote>\n<p>腾讯笔试题“字符移位”<br>小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？<br>输入描述：输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000.<br>输出描述：对于每组数据，输出移位后的字符串。<br>输入输出示例：输入AkleBiCeilD，输出kleieilABCD。  </p>\n</blockquote>\n<p>此题只要对于小写字母，只要往前移动知道遇到小写字母或者移动到首位置即可停止，代码见下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MoveChar</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;inputString)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"keyword\">int</span>(inputString.size()); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">islower</span>(inputString.at(j)) &amp;&amp; <span class=\"built_in\">isupper</span>(inputString.at(j<span class=\"number\">-1</span>))) &#123;</span><br><span class=\"line\">                swap(inputString.at(j), inputString.at(j<span class=\"number\">-1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序的过程非常类似于自然界上浮现象，从第一个元素开始，依次和后一个元素比较，如果大，则交换，直到上浮到顶端，其时间复杂度分析和插入排序类似但是由于需要一路比较直到顶部，因此冒泡算法的时间复杂度最坏和平均情况都需要一直交换到顶端，因此为N-1+N-2+…..1=(N-1)N/2，而最好时间复杂度可以通过设置一个标志位达到O(N)，否则按照常规无标志位的最好依然需要O(N<sup>2</sup>)，冒泡排序空间复杂度和插入排序一样为O(1)。标志位原理如下代码所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BubbleSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//标记在一趟排序遍历时是否交换过，如果没有交换过说明原始有序，可以直接退出</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> hasSwap = <span class=\"literal\">false</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; inputArray.size() - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inputArray[j] &gt; inputArray[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\tswap(inputArray[j], inputArray[j+<span class=\"number\">1</span>]); <span class=\"comment\">//STL库函数</span></span><br><span class=\"line\">\t\t\t\thasSwap = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!hasSwap) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序的原理是在未排序的序列找到一个最小值，插到已排序序列第的末尾。在第一遍历时找到最小值，第二次找多第二小值，经过N-1趟遍历可以排好N-1个元素，最后一个元素肯定处在正确位置。由于选择排序每次都要遍历整个未排序序列，故其最好与最坏时间复杂度均为N+N-1…..2=(N+2)(N-1)/2=O(N<sup>2</sup>)，其基本代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SelectionSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> minIndex = i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = i+<span class=\"number\">1</span>; j &lt; inputArray.size(); j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inputArray[j] &lt; inputArray[minIndex]) &#123;</span><br><span class=\"line\">\t\t\t\tminIndex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (minIndex != i) &#123;</span><br><span class=\"line\">                        swap(inputArray[i], inputArray[minIndex]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>归并排序是分治法经典的应用之一，归并排序通过将问题划分为两个大小相似的问题分别求解，然后合并两部分解得到最后的解，其时间复杂度递推关系式为T(N)=2T(N/2)+N（T(1)=1）；其中N代表在合并解时花费的时间，即合并两个序列的总大小。在求解这个关系式时，可以两边同时除以N，有T(N)/N=T(N/2)/(N/2)+1，而T(N/2)/(N/2)=T(N/4)/(N/4)+1….T(2)/2=T(1)+1。所有左边相加，所有右边相加有T(N)/N=T(1)+log<sub>2</sub>N，推出T(N)=Nlog<sub>2</sub>N+N=O(Nlog<sub>2</sub>N)，归并排序由于需要一个附加的数组保存归并结果，因此空间复杂度为O(N)，递归栈空间为log<sub>2</sub>N。归并排序有两种算法，递归和非递归，递归版算法代码分别如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//区间为左闭右开，和STL保持一致</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray, <span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;tmpArray, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> middle, <span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = left, j = middle, tmpStart = left;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; middle &amp;&amp; j &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inputArray[i] &lt; inputArray[j]) &#123;</span><br><span class=\"line\">\t\t\ttmpArray[tmpStart] = inputArray[i];</span><br><span class=\"line\">\t\t\t++tmpStart; ++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ttmpArray[tmpStart] = inputArray[j];</span><br><span class=\"line\">\t\t\t++tmpStart; ++j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; middle) &#123;</span><br><span class=\"line\">\t\ttmpArray[tmpStart] = inputArray[i];</span><br><span class=\"line\">\t\t++tmpStart; ++i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt; right) &#123;</span><br><span class=\"line\">\t\ttmpArray[tmpStart] = inputArray[j];</span><br><span class=\"line\">\t\t++tmpStart; ++j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = left; i &lt; right; i++) &#123;</span><br><span class=\"line\">\t\tinputArray[i] = tmpArray[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeSortCore</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray, <span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;tmpArray, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left + <span class=\"number\">1</span> &gt;= right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> middle = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tMergeSortCore(inputArray, tmpArray, left, middle);</span><br><span class=\"line\">\tMergeSortCore(inputArray, tmpArray, middle, right);</span><br><span class=\"line\"></span><br><span class=\"line\">\tMerge(inputArray, tmpArray, left, middle, right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; tmpArray(inputArray.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"keyword\">int</span>(inputArray.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        MergeSortCore(inputArray, tmpArray, left, right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序和归并排序的基本思想都是分治法，不过快速排序划分子问题是以一个元素为基准，小于该元素的放在一边，大于的放在另外一边，通过这样的递归划分，最终递归只剩一个元素时返回，由于每次分割排序后分割元素都在正确位置，因此该算法最终将会使整个序列有序。由于快速排序分割元素选取是不固定的，一般有固定选取头部或者尾部（如果原始有序则时间复杂度很差）、随机选取和三数中值分割法等。快速排序最好时间复杂度产生在每次都均分数组，此时时间复杂度为O(Nlog<sub>2</sub>N)，而最差发生在每次将数组分割成1个元素和剩余的元素，此时时间复杂度为O(N<sup>2</sup>)。在空间复杂度上，由于快速排序可以不借助额外空间进行原地交换，因此其空间复杂度为栈空间复杂度log<sub>2</sub>N，最差空间复杂度为O(N)。和归并排序一样，快速排序也有递归与非递归版本，递归版实现如下代码：</p>\n<p><strong>果然如《数据结构与算法分析》所言，大部分人一般无法正确编写快排程序，( ╯□╰ )</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//左闭右开区间</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSortCore</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (start+<span class=\"number\">1</span> &gt;= end) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> base = inputArray[end<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = start, j = end<span class=\"number\">-2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= j) &#123; <span class=\"comment\">/*使i行进到正确的位置*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt; end &amp;&amp; inputArray[i] &lt; base) &#123;</span><br><span class=\"line\">                        ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (j &gt; start &amp;&amp; inputArray[j] &gt; base) &#123;</span><br><span class=\"line\">                        --j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">\t\t\tswap(inputArray[i], inputArray[j]);</span><br><span class=\"line\">\t\t\t++i; --j; <span class=\"comment\">/*可能导致i,j指向同一位置*/</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tswap(inputArray[i], inputArray[end<span class=\"number\">-1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">\tQuickSortCore(inputArray, start, i);</span><br><span class=\"line\">\tQuickSortCore(inputArray, i+<span class=\"number\">1</span>, end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tQuickSortCore(inputArray, <span class=\"number\">0</span>, <span class=\"keyword\">int</span>(inputArray.size()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>在基于比较的排序算法中，根据决策树分析，基于比较的排序的时间复杂度下界为O(Nlog<sub>2</sub>N)。如果需要突破该下限，则必须使用非比较型的算法，计数排序既是其中的一种。在使用计数排序时，对输入序列的范围有要求，计数排序需要额外一个数组用来保存元素出现的次数，该数组的大小为元素最大值（或者可以优化为最大值最小值范围，通过调整数组使最小元素从0开始），在保存元素出现的次数后依次把前一个元素出现次数加到后一个元素中，该值代表当前元素在排序序列中的位置，比如序列待排序序列为{0,0,2,3,4,5,6,2,3,1}，通过第一步计数得到Count数组Count[0~6]={2,1,2,2,1,1,1}，然后依次将前一个元素出现的次数加到后一个元素中得到Count[0~6]={2,3,5,7,8,9,10}，比如Count[0]=2表示包括自己在内前面有2个元素，因此最后出现的0元素在的位置为第二个，依此类推。为了保证排序的稳定性，计数排序在最后一步排序时采用从后往前扫描的方式。由于计数排序需要Count数组以及一个附加数组保存排序后的元素，因此其空间复杂度为O(N+K)，N为元素个数，K为Count数组大小。计数排序在排序过程中需要先扫描一遍整个数组，然后扫描Count数组，最后扫描整个数组回填序列，因此时间复杂度为O(2N+K)。实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CountingSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType maxElement = inputArray[<span class=\"number\">0</span>], minElement = inputArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                maxElement = maxElement &gt; inputArray[i] ? maxElement : inputArray[i];</span><br><span class=\"line\">                minElement = minElement &lt; inputArray[i] ? minElement : inputArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                inputArray[i] -= minElement;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> CountSize = maxElement - minElement + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; tmpArray(inputArray.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; Count(CountSize, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tCount[inputArray[i]]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; CountSize; i++) &#123;</span><br><span class=\"line\">\t\tCount[i] += Count[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"keyword\">int</span>(inputArray.size()<span class=\"number\">-1</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\ttmpArray[--Count[inputArray[i]]] = inputArray[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tinputArray[i] = tmpArray[i] + minElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>基数排序的基本思路和计数排序类似，不过基数排序把元素按照位数切割，对每一位进行排序比较，最后得到有序序列，由于进行了切割，其使用额外的空间大大下降，只和每位的数字取值个数有关（即进制）。基数排序方式有LSD(Least significant digital)和MSD(Most significant digital)，LSD从低位到高位，MSD从高位到低位，一般而言LSD的编程方式更简单。基数排序需要进行d轮计数，每轮包括三次遍历原始数组和一次遍历计数数组，故时间复杂度为O(d(3N+r))，r为位数，空间复杂度为申请的计数数组和存放排序结果的附加数组，空间复杂度为O(N+r)，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">RadixSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType maxElement = inputArray[<span class=\"number\">0</span>], minElement = inputArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                maxElement = maxElement &gt; inputArray[i] ? maxElement : inputArray[i];</span><br><span class=\"line\">                minElement = minElement &lt; inputArray[i] ? minElement : inputArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                inputArray[i] -= minElement;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxBit = <span class=\"number\">0</span>; DataType tmp = maxElement - minElement;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                ++maxBit; tmp /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> notation = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; Count(notation, <span class=\"number\">0</span>); <span class=\"comment\">//默认十进制</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; tmpArray(inputArray.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tDataType radix = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= maxBit; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; notation; j++) &#123;</span><br><span class=\"line\">                        Count[j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; inputArray.size(); j++) &#123;</span><br><span class=\"line\">\t\t\ttmp = (inputArray[j]/radix) % notation;</span><br><span class=\"line\">\t\t\t++Count[tmp];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; notation; j++) &#123;</span><br><span class=\"line\">                        Count[j] += Count[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"keyword\">int</span>(inputArray.size()<span class=\"number\">-1</span>); j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">\t\t\ttmp = (inputArray[j]/radix)%notation;</span><br><span class=\"line\">\t\t\ttmpArray[--Count[tmp]] = inputArray[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; inputArray.size(); j++) &#123;</span><br><span class=\"line\">\t\t\tinputArray[j] = tmpArray[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tradix *= notation;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tinputArray[i] += minElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>桶排序又称为箱排序，其基本思路是将待排序的序列分散到不同的桶中（按照大小范围，比如0~100放到一个桶中，101~200放到第二个桶中，依此类推），在每个桶中进行某种排序，最后把各个桶的结果组合起来形成最终的排序结果，在每个桶中可以采用计数排序、插入排序等排序算法，如果数组元素范围不大，每个桶可以直接采用计数排序。按照桶中排序方式不同时间复杂度差异比较大，而且是否稳定排序也和排序策略有关。桶排序最差时间复杂度可以达到O(N<sup>2</sup>)，最好发生在每个桶排序时间复杂度均为线性，此时为O(N+k)，k为桶的个数。桶排序的空间复杂度也和使用的底部排序算法有关，如果采用插入排序空间复杂度可以做到O(N+k)，k为定义桶发生的空间消耗，以下基于插入排序和链表结构完成桶排序的算法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">\tNode(DataType inData):data(inData), next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertSort</span><span class=\"params\">(Node&lt;DataType&gt; *dummyNode, DataType inVal)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dummyNode == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = dummyNode; <span class=\"comment\">//哑节点一定存在</span></span><br><span class=\"line\">\t<span class=\"comment\">//保持稳定性，插入想等元素的最后方</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter-&gt;next != <span class=\"literal\">nullptr</span> &amp;&amp; cycleIter-&gt;next-&gt;data &lt;= inVal) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; * tmp = cycleIter-&gt;next;</span><br><span class=\"line\">\tcycleIter-&gt;next = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inVal);</span><br><span class=\"line\">\tcycleIter-&gt;next-&gt;next = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">(Node&lt;DataType&gt; *dummyNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = dummyNode-&gt;next;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\ttmp = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> cycleIter;</span><br><span class=\"line\">\t\tcycleIter = tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BucketSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType maxElement = inputArray[<span class=\"number\">0</span>], minElement = inputArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                maxElement = maxElement &gt; inputArray[i] ? maxElement : inputArray[i];</span><br><span class=\"line\">                minElement = minElement &lt; inputArray[i] ? minElement : inputArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                inputArray[i] -= minElement;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tDataType max = maxElement - minElement;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//不妨假设有10个桶</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; bucket[<span class=\"number\">10</span>] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmax /= <span class=\"number\">10</span>; ++max;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tInsertSort(&amp;bucket[(inputArray[i]/max)], inputArray[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\tNode&lt;DataType&gt; *cycleIter = bucket[i].next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tinputArray[j++] = cycleIter-&gt;data;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\tMakeEmpty(&amp;bucket[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tinputArray[i] += minElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><p>希尔排序是直接插入排序的优化版，其通过将相隔一定区间的元素进行插入排序来使得元素跨越式交换，在这个过程中可能会一次交换消除多个逆序对，因此希尔排序的时间复杂度可以达到亚二次上界。希尔排序使用增量序列来进行元素跨区间插入排序，只要最后一个增量为1增可以保证最终可以得到有序的序列（增量为1退化成普通的插入排序）。增量序列的选取将会极大影响希尔排序的性能，因此不同的增量序列时间复杂度也不同，因此这里不做时间复杂度的分析，希尔排序的空间复杂度为O(1)。希尔排序由于大跨度插入，导致其排序结果是不稳定的。这里采用Donald Shell最初建议步长序列实现如下希尔排序代码（只要把插入排序稍微调整即可）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ShellSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tDataType tmp; <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> step = inputArray.size()/<span class=\"number\">2</span>; step &gt; <span class=\"number\">0</span>; step /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = step; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\t\ttmp = inputArray[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (j = <span class=\"keyword\">int</span>(i); j &gt;= <span class=\"keyword\">int</span>(step) &amp;&amp; inputArray[j-<span class=\"keyword\">int</span>(step)] &gt; tmp; j -= step) &#123;</span><br><span class=\"line\">\t\t\t\tinputArray[j] = inputArray[j-step];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tinputArray[j] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>堆排序采用的是二叉堆这种数据结构和不断删除堆顶元素最后得到一个有序序列的思想实现的，在建堆和删除时都可以采用一种称为下滤策略的方式及完成，因此可以将该策略做成一个单独的函数部分。在数据结构二叉堆分析中建堆过程中花费的时间为O(N)，而每次删除最差时间复杂度为log<sub>2</sub>N，共需进行Nlog<sub>2</sub>N完成整个的删除，而建堆是可以在数组中原地完成的，因此其空间复杂度为O(1)。堆排序代码如下： </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PercolateDown</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tDataType tmp = inputArray[index]; <span class=\"keyword\">int</span> i = index;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = index; <span class=\"number\">2</span>*i+<span class=\"number\">1</span> &lt; end; ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> maxChild = <span class=\"number\">2</span>*i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (maxChild+<span class=\"number\">1</span> &lt; end &amp;&amp; inputArray[maxChild] &lt; inputArray[maxChild+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t++maxChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inputArray[maxChild] &gt; tmp) &#123;</span><br><span class=\"line\">\t\t\tinputArray[i] = inputArray[maxChild];</span><br><span class=\"line\">\t\t\ti = maxChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tinputArray[i] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HeapSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"keyword\">int</span>(inputArray.size()/<span class=\"number\">2</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\tPercolateDown(inputArray, i, <span class=\"keyword\">int</span>(inputArray.size())); <span class=\"comment\">//分层下滤建堆</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size()<span class=\"number\">-1</span>; i++) &#123;</span><br><span class=\"line\">\t\tswap(inputArray[<span class=\"number\">0</span>], inputArray[inputArray.size()-i<span class=\"number\">-1</span>]); <span class=\"comment\">//删除堆顶</span></span><br><span class=\"line\">\t\tPercolateDown(inputArray, <span class=\"number\">0</span>, <span class=\"keyword\">int</span>(inputArray.size()-i<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"鸡尾酒排序\"><a href=\"#鸡尾酒排序\" class=\"headerlink\" title=\"鸡尾酒排序\"></a>鸡尾酒排序</h2><p>鸡尾酒排序是冒泡排序的一种变形，在一趟遍历中既让元素上浮也让元素下沉，其时间负复杂度和冒泡泡排序一样，其时间复杂度分析和冒泡排序类似，同时也可以通过设置标志位优化最佳排序时间复杂度，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CocktailShakerSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> unordedStart = <span class=\"number\">0</span>, unordedEnd = <span class=\"keyword\">int</span>(inputArray.size()); <span class=\"comment\">//左闭右开</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (unordedStart &lt; unordedEnd) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> hasSwap = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = unordedStart; i &lt; unordedEnd<span class=\"number\">-1</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inputArray[i] &gt; inputArray[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\tswap(inputArray[i], inputArray[i+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\t\thasSwap = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t--unordedEnd;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!hasSwap) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thasSwap = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = unordedEnd<span class=\"number\">-1</span>; i &gt; unordedStart; i--) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inputArray[i] &lt; inputArray[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\tswap(inputArray[i], inputArray[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t\t\thasSwap = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t++unordedStart;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!hasSwap) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"排序算法测试\"><a href=\"#排序算法测试\" class=\"headerlink\" title=\"排序算法测试\"></a>排序算法测试</h2><p>上述排序代码的测试如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> testNum[] = &#123; <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-10e4</span>), <span class=\"keyword\">int</span>(<span class=\"number\">10e4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(testNum) / <span class=\"keyword\">sizeof</span>(testNum[<span class=\"number\">0</span>]); i++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; testData1, testData2;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; testNum[i]; j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> tmp = intDis(randEngine);</span><br><span class=\"line\">                                testData1.push_back(tmp); testData2.push_back(tmp);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\">                        <span class=\"comment\">//调用具体的排序算法</span></span><br><span class=\"line\">                        <span class=\"comment\">//InsertionSort(testData1);</span></span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        sort(testData2.begin(), testData2.end());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; ((testData1 == testData2) ? <span class=\"string\">\"Correct;\"</span> : <span class=\"string\">\"Wrong;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"排序算法汇总\"><a href=\"#排序算法汇总\" class=\"headerlink\" title=\"排序算法汇总\"></a>排序算法汇总</h2><ul>\n<li>插入排序：插入排序思想是通过逐遍扫描（N-1遍扫描，N为排序元素个数）的方式消除逆序对，对于位置P=1遍到P=N-1遍保证插入顺序位置0到位置P为已排序状态。</li>\n<li>冒泡排序：通过重复遍历待排序的数列，每次比较一对元素，过程中不断消除逆序对，最终达到排序的目的，和插入排序对比，冒泡排序每次遍历结束后已排序的数列元素个数至少+1</li>\n<li>选择排序：每次遍历找到未排序序列的最大或者最小值，将其插入已排序队列的末尾，一般需要N-1趟遍历，因此选择排序移动元素次数很少，至多为N-1次</li>\n<li>归并排序：归并排序是分治法的典型应用之一，分治法解决问题主要步骤为：分解，将原问题分解成一系列子问题；解决，递归地解各子问题，若子问题足够小，则直接求解；合并，将子问题的解合并成原问题的解。归并排序分解动作为将数组分为两半；递归解规模为N/2的子问题，最终分解成只有一个元素的子问题；最后将子问题解合并得到最终排序的序列</li>\n<li>快速排序：快速排序和归并排序一样，也是采用分治思想，不过其分解思路为将数组分解为以某一基准值的两部分，使得一部分序列的所有元素都小于等于该基准值，另一部分序列的所有元素都大于该基准值（实际和基准值相等的元素可以放到任何一部分）。递归地分解直到分解序列元素个数为0或1。最后合并子问题解得到原问题解</li>\n<li>计数排序：计数排序的基本思想为对每个序列元素x，确定小于等于x的元素的个数m，从而根据m确定元素的排序后的位置。其基本流程可归纳如下：找出序列的最大最小值，确定k值；定义数组Count[0~k]，统计序列中值为i的元素的个数并存入Count[i]中；计算Count[i]=Count[i]+Count[i-1]；反向填充目标排序数组，将每个元素放入数组的第Count[i]项，同时Count[i]值减1</li>\n<li>基数排序：基数排序的原理是将整数按位切割成若干数字，按照每位数分别比较，最终合并成有序的序列</li>\n<li>桶排序：桶排序的基本思想是将待排序序列分到数量有限的桶中，然后对每个桶分别排序，最后将各个桶中的数据有序地合并起来</li>\n<li>希尔排序：希尔排序是递减增量排序算法，是插入排序更高效的改进版本，其基本思想为通过将比较的元素根据增量序列分为若干区域，然后对若干区域进行直接插入排序，随着增量序列减少到1时，进行最终的插入排序</li>\n<li>堆排序：堆排序的基本原理是利用堆这种数据结构完成排序，通过不断的删除堆顶元素和调整堆，最终得到有序的序列</li>\n<li>鸡尾酒排序：鸡尾酒排序也称为定向冒泡排序，是冒泡排序的一种变形，主要区别在于排序时是以双向在序列中排序，即大值往上交换时小值往下交换</li>\n</ul>\n<p>各排序算法的时间复杂度和空间复杂比较如下表：</p>\n<p><img src=\"/images/sort-algorithm-compare.png\" alt=\"排序算法对比\"></p>\n<p>以下分别分析实现各大算法。</p>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序是基于比较的排序，其基本原理是在初始状态前1个元素是有序的，然后每次将后方的一个元素插入前方的有序段并保持有序，当最后一个元素插入完成时，整个序列保持有序。其时间复杂度可以通过简单的计算得出，我们不妨假设每趟元素至少需要和有序元素段的一半元素进行比较，则时间复杂度可为1/2+1+3/2+4/2….+(N-1)/2=(N-1)N/4=O(N<sup>2</sup>)；最差时间就是1+2+3+N-1=(N-1)N/2=O(N<sup>2</sup>)；最好的就是每次只需和有序队列比较一个元素就可以确定位置，即输入序列即为有序，此时时间复杂度为1+1+1+….(n-1个)=N-1=O(N)。插入排序除了几个变量外无需额外空间，因此空间复杂度为O(1)。下面为插入排序的实现，采用模板编程方式实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非递减</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertionSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tDataType tmp; <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\ttmp = inputArray[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = <span class=\"keyword\">int</span>(i); j &gt; <span class=\"number\">0</span> &amp;&amp; inputArray[j<span class=\"number\">-1</span>] &gt; tmp; j--) &#123;</span><br><span class=\"line\">\t\t\tinputArray[j] = inputArray[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tinputArray[j] = tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有一道腾讯笔试题即可采用该算法思想完成，题目见下：</p>\n<blockquote>\n<p>腾讯笔试题“字符移位”<br>小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？<br>输入描述：输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000.<br>输出描述：对于每组数据，输出移位后的字符串。<br>输入输出示例：输入AkleBiCeilD，输出kleieilABCD。  </p>\n</blockquote>\n<p>此题只要对于小写字母，只要往前移动知道遇到小写字母或者移动到首位置即可停止，代码见下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MoveChar</span><span class=\"params\">(<span class=\"built_in\">string</span> &amp;inputString)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"keyword\">int</span>(inputString.size()); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">islower</span>(inputString.at(j)) &amp;&amp; <span class=\"built_in\">isupper</span>(inputString.at(j<span class=\"number\">-1</span>))) &#123;</span><br><span class=\"line\">                swap(inputString.at(j), inputString.at(j<span class=\"number\">-1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序的过程非常类似于自然界上浮现象，从第一个元素开始，依次和后一个元素比较，如果大，则交换，直到上浮到顶端，其时间复杂度分析和插入排序类似但是由于需要一路比较直到顶部，因此冒泡算法的时间复杂度最坏和平均情况都需要一直交换到顶端，因此为N-1+N-2+…..1=(N-1)N/2，而最好时间复杂度可以通过设置一个标志位达到O(N)，否则按照常规无标志位的最好依然需要O(N<sup>2</sup>)，冒泡排序空间复杂度和插入排序一样为O(1)。标志位原理如下代码所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BubbleSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//标记在一趟排序遍历时是否交换过，如果没有交换过说明原始有序，可以直接退出</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> hasSwap = <span class=\"literal\">false</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; inputArray.size() - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inputArray[j] &gt; inputArray[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\tswap(inputArray[j], inputArray[j+<span class=\"number\">1</span>]); <span class=\"comment\">//STL库函数</span></span><br><span class=\"line\">\t\t\t\thasSwap = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!hasSwap) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序的原理是在未排序的序列找到一个最小值，插到已排序序列第的末尾。在第一遍历时找到最小值，第二次找多第二小值，经过N-1趟遍历可以排好N-1个元素，最后一个元素肯定处在正确位置。由于选择排序每次都要遍历整个未排序序列，故其最好与最坏时间复杂度均为N+N-1…..2=(N+2)(N-1)/2=O(N<sup>2</sup>)，其基本代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SelectionSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> minIndex = i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = i+<span class=\"number\">1</span>; j &lt; inputArray.size(); j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inputArray[j] &lt; inputArray[minIndex]) &#123;</span><br><span class=\"line\">\t\t\t\tminIndex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (minIndex != i) &#123;</span><br><span class=\"line\">                        swap(inputArray[i], inputArray[minIndex]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>归并排序是分治法经典的应用之一，归并排序通过将问题划分为两个大小相似的问题分别求解，然后合并两部分解得到最后的解，其时间复杂度递推关系式为T(N)=2T(N/2)+N（T(1)=1）；其中N代表在合并解时花费的时间，即合并两个序列的总大小。在求解这个关系式时，可以两边同时除以N，有T(N)/N=T(N/2)/(N/2)+1，而T(N/2)/(N/2)=T(N/4)/(N/4)+1….T(2)/2=T(1)+1。所有左边相加，所有右边相加有T(N)/N=T(1)+log<sub>2</sub>N，推出T(N)=Nlog<sub>2</sub>N+N=O(Nlog<sub>2</sub>N)，归并排序由于需要一个附加的数组保存归并结果，因此空间复杂度为O(N)，递归栈空间为log<sub>2</sub>N。归并排序有两种算法，递归和非递归，递归版算法代码分别如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//区间为左闭右开，和STL保持一致</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray, <span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;tmpArray, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> middle, <span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = left, j = middle, tmpStart = left;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; middle &amp;&amp; j &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inputArray[i] &lt; inputArray[j]) &#123;</span><br><span class=\"line\">\t\t\ttmpArray[tmpStart] = inputArray[i];</span><br><span class=\"line\">\t\t\t++tmpStart; ++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ttmpArray[tmpStart] = inputArray[j];</span><br><span class=\"line\">\t\t\t++tmpStart; ++j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; middle) &#123;</span><br><span class=\"line\">\t\ttmpArray[tmpStart] = inputArray[i];</span><br><span class=\"line\">\t\t++tmpStart; ++i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt; right) &#123;</span><br><span class=\"line\">\t\ttmpArray[tmpStart] = inputArray[j];</span><br><span class=\"line\">\t\t++tmpStart; ++j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = left; i &lt; right; i++) &#123;</span><br><span class=\"line\">\t\tinputArray[i] = tmpArray[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeSortCore</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray, <span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;tmpArray, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left + <span class=\"number\">1</span> &gt;= right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> middle = (left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tMergeSortCore(inputArray, tmpArray, left, middle);</span><br><span class=\"line\">\tMergeSortCore(inputArray, tmpArray, middle, right);</span><br><span class=\"line\"></span><br><span class=\"line\">\tMerge(inputArray, tmpArray, left, middle, right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; tmpArray(inputArray.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"keyword\">int</span>(inputArray.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        MergeSortCore(inputArray, tmpArray, left, right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序和归并排序的基本思想都是分治法，不过快速排序划分子问题是以一个元素为基准，小于该元素的放在一边，大于的放在另外一边，通过这样的递归划分，最终递归只剩一个元素时返回，由于每次分割排序后分割元素都在正确位置，因此该算法最终将会使整个序列有序。由于快速排序分割元素选取是不固定的，一般有固定选取头部或者尾部（如果原始有序则时间复杂度很差）、随机选取和三数中值分割法等。快速排序最好时间复杂度产生在每次都均分数组，此时时间复杂度为O(Nlog<sub>2</sub>N)，而最差发生在每次将数组分割成1个元素和剩余的元素，此时时间复杂度为O(N<sup>2</sup>)。在空间复杂度上，由于快速排序可以不借助额外空间进行原地交换，因此其空间复杂度为栈空间复杂度log<sub>2</sub>N，最差空间复杂度为O(N)。和归并排序一样，快速排序也有递归与非递归版本，递归版实现如下代码：</p>\n<p><strong>果然如《数据结构与算法分析》所言，大部分人一般无法正确编写快排程序，( ╯□╰ )</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//左闭右开区间</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSortCore</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (start+<span class=\"number\">1</span> &gt;= end) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> base = inputArray[end<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = start, j = end<span class=\"number\">-2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= j) &#123; <span class=\"comment\">/*使i行进到正确的位置*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt; end &amp;&amp; inputArray[i] &lt; base) &#123;</span><br><span class=\"line\">                        ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (j &gt; start &amp;&amp; inputArray[j] &gt; base) &#123;</span><br><span class=\"line\">                        --j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">\t\t\tswap(inputArray[i], inputArray[j]);</span><br><span class=\"line\">\t\t\t++i; --j; <span class=\"comment\">/*可能导致i,j指向同一位置*/</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tswap(inputArray[i], inputArray[end<span class=\"number\">-1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">\tQuickSortCore(inputArray, start, i);</span><br><span class=\"line\">\tQuickSortCore(inputArray, i+<span class=\"number\">1</span>, end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tQuickSortCore(inputArray, <span class=\"number\">0</span>, <span class=\"keyword\">int</span>(inputArray.size()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p>在基于比较的排序算法中，根据决策树分析，基于比较的排序的时间复杂度下界为O(Nlog<sub>2</sub>N)。如果需要突破该下限，则必须使用非比较型的算法，计数排序既是其中的一种。在使用计数排序时，对输入序列的范围有要求，计数排序需要额外一个数组用来保存元素出现的次数，该数组的大小为元素最大值（或者可以优化为最大值最小值范围，通过调整数组使最小元素从0开始），在保存元素出现的次数后依次把前一个元素出现次数加到后一个元素中，该值代表当前元素在排序序列中的位置，比如序列待排序序列为{0,0,2,3,4,5,6,2,3,1}，通过第一步计数得到Count数组Count[0~6]={2,1,2,2,1,1,1}，然后依次将前一个元素出现的次数加到后一个元素中得到Count[0~6]={2,3,5,7,8,9,10}，比如Count[0]=2表示包括自己在内前面有2个元素，因此最后出现的0元素在的位置为第二个，依此类推。为了保证排序的稳定性，计数排序在最后一步排序时采用从后往前扫描的方式。由于计数排序需要Count数组以及一个附加数组保存排序后的元素，因此其空间复杂度为O(N+K)，N为元素个数，K为Count数组大小。计数排序在排序过程中需要先扫描一遍整个数组，然后扫描Count数组，最后扫描整个数组回填序列，因此时间复杂度为O(2N+K)。实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CountingSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType maxElement = inputArray[<span class=\"number\">0</span>], minElement = inputArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                maxElement = maxElement &gt; inputArray[i] ? maxElement : inputArray[i];</span><br><span class=\"line\">                minElement = minElement &lt; inputArray[i] ? minElement : inputArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                inputArray[i] -= minElement;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> CountSize = maxElement - minElement + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; tmpArray(inputArray.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; Count(CountSize, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tCount[inputArray[i]]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; CountSize; i++) &#123;</span><br><span class=\"line\">\t\tCount[i] += Count[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"keyword\">int</span>(inputArray.size()<span class=\"number\">-1</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\ttmpArray[--Count[inputArray[i]]] = inputArray[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tinputArray[i] = tmpArray[i] + minElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>基数排序的基本思路和计数排序类似，不过基数排序把元素按照位数切割，对每一位进行排序比较，最后得到有序序列，由于进行了切割，其使用额外的空间大大下降，只和每位的数字取值个数有关（即进制）。基数排序方式有LSD(Least significant digital)和MSD(Most significant digital)，LSD从低位到高位，MSD从高位到低位，一般而言LSD的编程方式更简单。基数排序需要进行d轮计数，每轮包括三次遍历原始数组和一次遍历计数数组，故时间复杂度为O(d(3N+r))，r为位数，空间复杂度为申请的计数数组和存放排序结果的附加数组，空间复杂度为O(N+r)，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">RadixSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType maxElement = inputArray[<span class=\"number\">0</span>], minElement = inputArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                maxElement = maxElement &gt; inputArray[i] ? maxElement : inputArray[i];</span><br><span class=\"line\">                minElement = minElement &lt; inputArray[i] ? minElement : inputArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                inputArray[i] -= minElement;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxBit = <span class=\"number\">0</span>; DataType tmp = maxElement - minElement;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tmp &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                ++maxBit; tmp /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> notation = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; Count(notation, <span class=\"number\">0</span>); <span class=\"comment\">//默认十进制</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;DataType&gt; tmpArray(inputArray.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tDataType radix = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= maxBit; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; notation; j++) &#123;</span><br><span class=\"line\">                        Count[j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; inputArray.size(); j++) &#123;</span><br><span class=\"line\">\t\t\ttmp = (inputArray[j]/radix) % notation;</span><br><span class=\"line\">\t\t\t++Count[tmp];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; notation; j++) &#123;</span><br><span class=\"line\">                        Count[j] += Count[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"keyword\">int</span>(inputArray.size()<span class=\"number\">-1</span>); j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">\t\t\ttmp = (inputArray[j]/radix)%notation;</span><br><span class=\"line\">\t\t\ttmpArray[--Count[tmp]] = inputArray[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; inputArray.size(); j++) &#123;</span><br><span class=\"line\">\t\t\tinputArray[j] = tmpArray[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tradix *= notation;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tinputArray[i] += minElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>桶排序又称为箱排序，其基本思路是将待排序的序列分散到不同的桶中（按照大小范围，比如0~100放到一个桶中，101~200放到第二个桶中，依此类推），在每个桶中进行某种排序，最后把各个桶的结果组合起来形成最终的排序结果，在每个桶中可以采用计数排序、插入排序等排序算法，如果数组元素范围不大，每个桶可以直接采用计数排序。按照桶中排序方式不同时间复杂度差异比较大，而且是否稳定排序也和排序策略有关。桶排序最差时间复杂度可以达到O(N<sup>2</sup>)，最好发生在每个桶排序时间复杂度均为线性，此时为O(N+k)，k为桶的个数。桶排序的空间复杂度也和使用的底部排序算法有关，如果采用插入排序空间复杂度可以做到O(N+k)，k为定义桶发生的空间消耗，以下基于插入排序和链表结构完成桶排序的算法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDataType data;</span><br><span class=\"line\">\tNode *next;</span><br><span class=\"line\">\tNode(DataType inData):data(inData), next(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InsertSort</span><span class=\"params\">(Node&lt;DataType&gt; *dummyNode, DataType inVal)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dummyNode == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = dummyNode; <span class=\"comment\">//哑节点一定存在</span></span><br><span class=\"line\">\t<span class=\"comment\">//保持稳定性，插入想等元素的最后方</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter-&gt;next != <span class=\"literal\">nullptr</span> &amp;&amp; cycleIter-&gt;next-&gt;data &lt;= inVal) &#123;</span><br><span class=\"line\">\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNode&lt;DataType&gt; * tmp = cycleIter-&gt;next;</span><br><span class=\"line\">\tcycleIter-&gt;next = <span class=\"keyword\">new</span> Node&lt;DataType&gt;(inVal);</span><br><span class=\"line\">\tcycleIter-&gt;next-&gt;next = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">(Node&lt;DataType&gt; *dummyNode)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *cycleIter = dummyNode-&gt;next;</span><br><span class=\"line\">\tNode&lt;DataType&gt; *tmp = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\ttmp = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> cycleIter;</span><br><span class=\"line\">\t\tcycleIter = tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BucketSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType maxElement = inputArray[<span class=\"number\">0</span>], minElement = inputArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                maxElement = maxElement &gt; inputArray[i] ? maxElement : inputArray[i];</span><br><span class=\"line\">                minElement = minElement &lt; inputArray[i] ? minElement : inputArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">                inputArray[i] -= minElement;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tDataType max = maxElement - minElement;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//不妨假设有10个桶</span></span><br><span class=\"line\">\tNode&lt;DataType&gt; bucket[<span class=\"number\">10</span>] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmax /= <span class=\"number\">10</span>; ++max;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tInsertSort(&amp;bucket[(inputArray[i]/max)], inputArray[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\tNode&lt;DataType&gt; *cycleIter = bucket[i].next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t\tinputArray[j++] = cycleIter-&gt;data;</span><br><span class=\"line\">\t\t\tcycleIter = cycleIter-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\tMakeEmpty(&amp;bucket[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\tinputArray[i] += minElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><p>希尔排序是直接插入排序的优化版，其通过将相隔一定区间的元素进行插入排序来使得元素跨越式交换，在这个过程中可能会一次交换消除多个逆序对，因此希尔排序的时间复杂度可以达到亚二次上界。希尔排序使用增量序列来进行元素跨区间插入排序，只要最后一个增量为1增可以保证最终可以得到有序的序列（增量为1退化成普通的插入排序）。增量序列的选取将会极大影响希尔排序的性能，因此不同的增量序列时间复杂度也不同，因此这里不做时间复杂度的分析，希尔排序的空间复杂度为O(1)。希尔排序由于大跨度插入，导致其排序结果是不稳定的。这里采用Donald Shell最初建议步长序列实现如下希尔排序代码（只要把插入排序稍微调整即可）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ShellSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tDataType tmp; <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> step = inputArray.size()/<span class=\"number\">2</span>; step &gt; <span class=\"number\">0</span>; step /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = step; i &lt; inputArray.size(); i++) &#123;</span><br><span class=\"line\">\t\t\ttmp = inputArray[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (j = <span class=\"keyword\">int</span>(i); j &gt;= <span class=\"keyword\">int</span>(step) &amp;&amp; inputArray[j-<span class=\"keyword\">int</span>(step)] &gt; tmp; j -= step) &#123;</span><br><span class=\"line\">\t\t\t\tinputArray[j] = inputArray[j-step];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tinputArray[j] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>堆排序采用的是二叉堆这种数据结构和不断删除堆顶元素最后得到一个有序序列的思想实现的，在建堆和删除时都可以采用一种称为下滤策略的方式及完成，因此可以将该策略做成一个单独的函数部分。在数据结构二叉堆分析中建堆过程中花费的时间为O(N)，而每次删除最差时间复杂度为log<sub>2</sub>N，共需进行Nlog<sub>2</sub>N完成整个的删除，而建堆是可以在数组中原地完成的，因此其空间复杂度为O(1)。堆排序代码如下： </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PercolateDown</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tDataType tmp = inputArray[index]; <span class=\"keyword\">int</span> i = index;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = index; <span class=\"number\">2</span>*i+<span class=\"number\">1</span> &lt; end; ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> maxChild = <span class=\"number\">2</span>*i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (maxChild+<span class=\"number\">1</span> &lt; end &amp;&amp; inputArray[maxChild] &lt; inputArray[maxChild+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t++maxChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inputArray[maxChild] &gt; tmp) &#123;</span><br><span class=\"line\">\t\t\tinputArray[i] = inputArray[maxChild];</span><br><span class=\"line\">\t\t\ti = maxChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tinputArray[i] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HeapSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"keyword\">int</span>(inputArray.size()/<span class=\"number\">2</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\tPercolateDown(inputArray, i, <span class=\"keyword\">int</span>(inputArray.size())); <span class=\"comment\">//分层下滤建堆</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inputArray.size()<span class=\"number\">-1</span>; i++) &#123;</span><br><span class=\"line\">\t\tswap(inputArray[<span class=\"number\">0</span>], inputArray[inputArray.size()-i<span class=\"number\">-1</span>]); <span class=\"comment\">//删除堆顶</span></span><br><span class=\"line\">\t\tPercolateDown(inputArray, <span class=\"number\">0</span>, <span class=\"keyword\">int</span>(inputArray.size()-i<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"鸡尾酒排序\"><a href=\"#鸡尾酒排序\" class=\"headerlink\" title=\"鸡尾酒排序\"></a>鸡尾酒排序</h2><p>鸡尾酒排序是冒泡排序的一种变形，在一趟遍历中既让元素上浮也让元素下沉，其时间负复杂度和冒泡泡排序一样，其时间复杂度分析和冒泡排序类似，同时也可以通过设置标志位优化最佳排序时间复杂度，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CocktailShakerSort</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;DataType&gt; &amp;inputArray)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputArray.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> unordedStart = <span class=\"number\">0</span>, unordedEnd = <span class=\"keyword\">int</span>(inputArray.size()); <span class=\"comment\">//左闭右开</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (unordedStart &lt; unordedEnd) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> hasSwap = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = unordedStart; i &lt; unordedEnd<span class=\"number\">-1</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inputArray[i] &gt; inputArray[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\tswap(inputArray[i], inputArray[i+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\t\thasSwap = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t--unordedEnd;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!hasSwap) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thasSwap = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = unordedEnd<span class=\"number\">-1</span>; i &gt; unordedStart; i--) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (inputArray[i] &lt; inputArray[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\tswap(inputArray[i], inputArray[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t\t\thasSwap = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t++unordedStart;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!hasSwap) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"排序算法测试\"><a href=\"#排序算法测试\" class=\"headerlink\" title=\"排序算法测试\"></a>排序算法测试</h2><p>上述排序代码的测试如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> testNum[] = &#123; <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-10e4</span>), <span class=\"keyword\">int</span>(<span class=\"number\">10e4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(testNum) / <span class=\"keyword\">sizeof</span>(testNum[<span class=\"number\">0</span>]); i++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; testData1, testData2;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; testNum[i]; j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> tmp = intDis(randEngine);</span><br><span class=\"line\">                                testData1.push_back(tmp); testData2.push_back(tmp);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\">                        <span class=\"comment\">//调用具体的排序算法</span></span><br><span class=\"line\">                        <span class=\"comment\">//InsertionSort(testData1);</span></span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        sort(testData2.begin(), testData2.end());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; ((testData1 == testData2) ? <span class=\"string\">\"Correct;\"</span> : <span class=\"string\">\"Wrong;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"欧几里得计算最大公因数数学原理及实现","urlname":"euclidean-algorithm-foundation","date":"2018-05-30T03:08:11.000Z","copyright":true,"mathjax":true,"_content":"\n## 最大公因数定义\n\n最大公因数又名最大公约数，是指两个整数（本文约定为正整数）共同的最大约数。在实际编程中按照维基百科的说法主要有穷举法、素因数分解法、短除法、辗转相除法（欧几里得算法）。本文主要尝试分析实现穷举法和辗转相除法。具体分析实现见下小节。\n\n## 穷举法\n\n穷举法的思路非常简单，即在所有可能的解中遍历找出符合要求的解。按照遍历思路可以从小往大遍历，也可以从两个数中较小的一个数往前遍历。本文使用第二种思路实现穷举法暴力求解最大公约数，具体代码如下所示：\n\n```cpp\n#include <algorithm>\n#include <<utility>>\nusing namespace std;\n\nunsigned int BruteGCD(unsigned int num1, unsigned int num2)\n{\n        if (num1 > num2) {\n                swap(num1, num2);\n        }\n        unsigned int result = 0;\n        for (unsigned int i = num1; i >= 1; i--) {\n                if (num1 % i == 0 && num2 % i == 0) {\n                        result = i; break;\n                }\n        }\n        return result;\n}\n```\n\n## 欧几里得算法\n\n欧几里得算法的主要依据是$gcd(a,b)=gcd(b, a\\%b)$。该公式证明如下：  \n\n1. 令$g$为$(a,b)$的任意一个公因数，则有$a=k_1g, b=k_2g$，假设$a \\mod b=r$，则有$a = kb+r$\n2. 将前两式代入第三式得出$k_1g = kk_2g + r=>r = (k_1g-kk_2g)g$，可得出$r\\mod g=0$\n4. 结合上述可知$a,b$任意的公因数也是$r$的因数，即可推知$(a,b)$的任意公因数是$(b,r)$的公因数\n5. 同理对于任意$(b,r)$的公因数$h$，$b=m_1h,r=m_2h=>a=km_1h+m_2h$，亦可推出$(b,r)$的任意公因数也是$(a,b)$的公因数\n6. 最终得出两者具有相同的公因数序列，进一步得知最大公因数也相等\n\n根据上述数学结论如何得出最大公因数算法呢？需要注意的是，对于两个数，如果其中一个数能被另外一个数整除，那么被除数一定是两个数的最大公因数，因此我们只要重复$gcd(a,b)=gcd(b, a\\%b)$过程直到出现两数可以整除为止，以上思路的实现代码如下：\n\n```cpp\n/*显而易见的递归算法*/\nunsigned int EuclideanAlgorithm(unsigned int num1, unsigned int num2)\n{\n        if (num1 % num2 == 0) {\n                return num2;\n        }\n        else {\n                return EuclideanAlgorithm(num2, num1 % num2);\n        }\n}\n\n/*非递归写法*/\nunsigned int EuclideanAlgorithm(unsigned int num1, unsigned int num2)\n{\n        while (num1 % num2 != 0) {\n                unsigned int tmp = num1 % num2;\n                num1 = num2;\n                num2 = tmp;\n        }\n        return num2;\n}\n```\n\n以上算法的时间复杂度如何计算呢？注意根据取模运算特点，对于$M>N$，那么有$M\\mod N<M/2$，因此可以大致认为欧几里得算法的时间复杂度为$O(\\log M)$。\n\n## 算法测试\n\n上述算法的测试代码如下，随机生成两个正整数，然后调用每个函数进行测试，为了测试代码正确性，我们直接抄录书上的代码作为测试基准，教材实现代码如下`Gcd`函数所示\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nunsigned int Gcd(unsigned int M, unsigned int N)\n{\n        unsigned int Rem;\n\n        while (N > 0) {\n                Rem = M % N;\n                M = N;\n                N = Rem;\n        }\n        return M;\n}\n\nint main()\n{\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<unsigned int> uIntDis(unsigned int(1), unsigned int(10e4));\n\n        int testTimes = 15;\n\n\twhile ((testTimes--) > 0) {\n                unsigned int num1 = uIntDis(randEngine);\n                unsigned int num2 = uIntDis(randEngine);\n\n\n                auto startTime = system_clock::now();\n\n                unsigned int testResult = 0;\n                //testResult = BruteGCD(num1, num2); /*调用具体的算法*/\n\n                auto endTime = system_clock::now();\n\n                unsigned int correctResult = Gcd(num1, num2);\n\n                cout << \"num1 = \" << num1 << \"\\tnum2 = \" << num2;\n                cout << \"\\tgcd = \" << correctResult << \"\\t\";\n                cout << ((testResult == correctResult) ? \"Correct;\" : \"Wrong;\");\n\n                auto duration = duration_cast<microseconds>(endTime - startTime);\n                cout << \"TimeCost:\" << duration.count() << endl;\n        }\n\treturn 0;\n}\n```\n\n## 参考文章\n\n[最大公因数-维基百科](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B8)\n\n[辗转相除法-维基百科](https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95)\n\n[最大公约数(Gcd)两种算法](https://www.cnblogs.com/drizzlecrj/archive/2007/09/14/892340.html)\n","source":"_posts/算法设计/欧几里得计算最大公因数数学原理及实现.md","raw":"---\ntitle: 欧几里得计算最大公因数数学原理及实现\nurlname: euclidean-algorithm-foundation\ndate: 2018-05-30 11:08:11\ncopyright: true\nmathjax: true\ntags:\n- 算法设计\ncategories:\n- 算法设计\n---\n\n## 最大公因数定义\n\n最大公因数又名最大公约数，是指两个整数（本文约定为正整数）共同的最大约数。在实际编程中按照维基百科的说法主要有穷举法、素因数分解法、短除法、辗转相除法（欧几里得算法）。本文主要尝试分析实现穷举法和辗转相除法。具体分析实现见下小节。\n\n## 穷举法\n\n穷举法的思路非常简单，即在所有可能的解中遍历找出符合要求的解。按照遍历思路可以从小往大遍历，也可以从两个数中较小的一个数往前遍历。本文使用第二种思路实现穷举法暴力求解最大公约数，具体代码如下所示：\n\n```cpp\n#include <algorithm>\n#include <<utility>>\nusing namespace std;\n\nunsigned int BruteGCD(unsigned int num1, unsigned int num2)\n{\n        if (num1 > num2) {\n                swap(num1, num2);\n        }\n        unsigned int result = 0;\n        for (unsigned int i = num1; i >= 1; i--) {\n                if (num1 % i == 0 && num2 % i == 0) {\n                        result = i; break;\n                }\n        }\n        return result;\n}\n```\n\n## 欧几里得算法\n\n欧几里得算法的主要依据是$gcd(a,b)=gcd(b, a\\%b)$。该公式证明如下：  \n\n1. 令$g$为$(a,b)$的任意一个公因数，则有$a=k_1g, b=k_2g$，假设$a \\mod b=r$，则有$a = kb+r$\n2. 将前两式代入第三式得出$k_1g = kk_2g + r=>r = (k_1g-kk_2g)g$，可得出$r\\mod g=0$\n4. 结合上述可知$a,b$任意的公因数也是$r$的因数，即可推知$(a,b)$的任意公因数是$(b,r)$的公因数\n5. 同理对于任意$(b,r)$的公因数$h$，$b=m_1h,r=m_2h=>a=km_1h+m_2h$，亦可推出$(b,r)$的任意公因数也是$(a,b)$的公因数\n6. 最终得出两者具有相同的公因数序列，进一步得知最大公因数也相等\n\n根据上述数学结论如何得出最大公因数算法呢？需要注意的是，对于两个数，如果其中一个数能被另外一个数整除，那么被除数一定是两个数的最大公因数，因此我们只要重复$gcd(a,b)=gcd(b, a\\%b)$过程直到出现两数可以整除为止，以上思路的实现代码如下：\n\n```cpp\n/*显而易见的递归算法*/\nunsigned int EuclideanAlgorithm(unsigned int num1, unsigned int num2)\n{\n        if (num1 % num2 == 0) {\n                return num2;\n        }\n        else {\n                return EuclideanAlgorithm(num2, num1 % num2);\n        }\n}\n\n/*非递归写法*/\nunsigned int EuclideanAlgorithm(unsigned int num1, unsigned int num2)\n{\n        while (num1 % num2 != 0) {\n                unsigned int tmp = num1 % num2;\n                num1 = num2;\n                num2 = tmp;\n        }\n        return num2;\n}\n```\n\n以上算法的时间复杂度如何计算呢？注意根据取模运算特点，对于$M>N$，那么有$M\\mod N<M/2$，因此可以大致认为欧几里得算法的时间复杂度为$O(\\log M)$。\n\n## 算法测试\n\n上述算法的测试代码如下，随机生成两个正整数，然后调用每个函数进行测试，为了测试代码正确性，我们直接抄录书上的代码作为测试基准，教材实现代码如下`Gcd`函数所示\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nunsigned int Gcd(unsigned int M, unsigned int N)\n{\n        unsigned int Rem;\n\n        while (N > 0) {\n                Rem = M % N;\n                M = N;\n                N = Rem;\n        }\n        return M;\n}\n\nint main()\n{\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<unsigned int> uIntDis(unsigned int(1), unsigned int(10e4));\n\n        int testTimes = 15;\n\n\twhile ((testTimes--) > 0) {\n                unsigned int num1 = uIntDis(randEngine);\n                unsigned int num2 = uIntDis(randEngine);\n\n\n                auto startTime = system_clock::now();\n\n                unsigned int testResult = 0;\n                //testResult = BruteGCD(num1, num2); /*调用具体的算法*/\n\n                auto endTime = system_clock::now();\n\n                unsigned int correctResult = Gcd(num1, num2);\n\n                cout << \"num1 = \" << num1 << \"\\tnum2 = \" << num2;\n                cout << \"\\tgcd = \" << correctResult << \"\\t\";\n                cout << ((testResult == correctResult) ? \"Correct;\" : \"Wrong;\");\n\n                auto duration = duration_cast<microseconds>(endTime - startTime);\n                cout << \"TimeCost:\" << duration.count() << endl;\n        }\n\treturn 0;\n}\n```\n\n## 参考文章\n\n[最大公因数-维基百科](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B8)\n\n[辗转相除法-维基百科](https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95)\n\n[最大公约数(Gcd)两种算法](https://www.cnblogs.com/drizzlecrj/archive/2007/09/14/892340.html)\n","slug":"算法设计/欧几里得计算最大公因数数学原理及实现","published":1,"updated":"2018-06-13T14:18:38.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x49002jgsvnfxmuxjed","content":"<h2 id=\"最大公因数定义\"><a href=\"#最大公因数定义\" class=\"headerlink\" title=\"最大公因数定义\"></a>最大公因数定义</h2><p>最大公因数又名最大公约数，是指两个整数（本文约定为正整数）共同的最大约数。在实际编程中按照维基百科的说法主要有穷举法、素因数分解法、短除法、辗转相除法（欧几里得算法）。本文主要尝试分析实现穷举法和辗转相除法。具体分析实现见下小节。</p>\n<h2 id=\"穷举法\"><a href=\"#穷举法\" class=\"headerlink\" title=\"穷举法\"></a>穷举法</h2><p>穷举法的思路非常简单，即在所有可能的解中遍历找出符合要求的解。按照遍历思路可以从小往大遍历，也可以从两个数中较小的一个数往前遍历。本文使用第二种思路实现穷举法暴力求解最大公约数，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;&lt;utility&gt;&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">BruteGCD</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num1 &gt; num2) &#123;</span><br><span class=\"line\">                swap(num1, num2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = num1; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (num1 % i == <span class=\"number\">0</span> &amp;&amp; num2 % i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        result = i; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h2><p>欧几里得算法的主要依据是$gcd(a,b)=gcd(b, a\\%b)$。该公式证明如下：  </p>\n<ol>\n<li>令$g$为$(a,b)$的任意一个公因数，则有$a=k_1g, b=k_2g$，假设$a \\mod b=r$，则有$a = kb+r$</li>\n<li>将前两式代入第三式得出$k_1g = kk_2g + r=&gt;r = (k_1g-kk_2g)g$，可得出$r\\mod g=0$</li>\n<li>结合上述可知$a,b$任意的公因数也是$r$的因数，即可推知$(a,b)$的任意公因数是$(b,r)$的公因数</li>\n<li>同理对于任意$(b,r)$的公因数$h$，$b=m_1h,r=m_2h=&gt;a=km_1h+m_2h$，亦可推出$(b,r)$的任意公因数也是$(a,b)$的公因数</li>\n<li>最终得出两者具有相同的公因数序列，进一步得知最大公因数也相等</li>\n</ol>\n<p>根据上述数学结论如何得出最大公因数算法呢？需要注意的是，对于两个数，如果其中一个数能被另外一个数整除，那么被除数一定是两个数的最大公因数，因此我们只要重复$gcd(a,b)=gcd(b, a\\%b)$过程直到出现两数可以整除为止，以上思路的实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*显而易见的递归算法*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">EuclideanAlgorithm</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num1 % num2 == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> num2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> EuclideanAlgorithm(num2, num1 % num2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*非递归写法*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">EuclideanAlgorithm</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (num1 % num2 != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> tmp = num1 % num2;</span><br><span class=\"line\">                num1 = num2;</span><br><span class=\"line\">                num2 = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上算法的时间复杂度如何计算呢？注意根据取模运算特点，对于$M&gt;N$，那么有$M\\mod N&lt;M/2$，因此可以大致认为欧几里得算法的时间复杂度为$O(\\log M)$。</p>\n<h2 id=\"算法测试\"><a href=\"#算法测试\" class=\"headerlink\" title=\"算法测试\"></a>算法测试</h2><p>上述算法的测试代码如下，随机生成两个正整数，然后调用每个函数进行测试，为了测试代码正确性，我们直接抄录书上的代码作为测试基准，教材实现代码如下<code>Gcd</code>函数所示</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">Gcd</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> M, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> Rem;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (N &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                Rem = M % N;</span><br><span class=\"line\">                M = N;</span><br><span class=\"line\">                N = Rem;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> M;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>&gt; uIntDis(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>(<span class=\"number\">10e4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num1 = uIntDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num2 = uIntDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> testResult = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"comment\">//testResult = BruteGCD(num1, num2); /*调用具体的算法*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> correctResult = Gcd(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"num1 = \"</span> &lt;&lt; num1 &lt;&lt; <span class=\"string\">\"\\tnum2 = \"</span> &lt;&lt; num2;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\tgcd = \"</span> &lt;&lt; correctResult &lt;&lt; <span class=\"string\">\"\\t\"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; ((testResult == correctResult) ? <span class=\"string\">\"Correct;\"</span> : <span class=\"string\">\"Wrong;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B8\" target=\"_blank\" rel=\"noopener\">最大公因数-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95\" target=\"_blank\" rel=\"noopener\">辗转相除法-维基百科</a></p>\n<p><a href=\"https://www.cnblogs.com/drizzlecrj/archive/2007/09/14/892340.html\" target=\"_blank\" rel=\"noopener\">最大公约数(Gcd)两种算法</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"最大公因数定义\"><a href=\"#最大公因数定义\" class=\"headerlink\" title=\"最大公因数定义\"></a>最大公因数定义</h2><p>最大公因数又名最大公约数，是指两个整数（本文约定为正整数）共同的最大约数。在实际编程中按照维基百科的说法主要有穷举法、素因数分解法、短除法、辗转相除法（欧几里得算法）。本文主要尝试分析实现穷举法和辗转相除法。具体分析实现见下小节。</p>\n<h2 id=\"穷举法\"><a href=\"#穷举法\" class=\"headerlink\" title=\"穷举法\"></a>穷举法</h2><p>穷举法的思路非常简单，即在所有可能的解中遍历找出符合要求的解。按照遍历思路可以从小往大遍历，也可以从两个数中较小的一个数往前遍历。本文使用第二种思路实现穷举法暴力求解最大公约数，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;&lt;utility&gt;&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">BruteGCD</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num1 &gt; num2) &#123;</span><br><span class=\"line\">                swap(num1, num2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = num1; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (num1 % i == <span class=\"number\">0</span> &amp;&amp; num2 % i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        result = i; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h2><p>欧几里得算法的主要依据是$gcd(a,b)=gcd(b, a\\%b)$。该公式证明如下：  </p>\n<ol>\n<li>令$g$为$(a,b)$的任意一个公因数，则有$a=k_1g, b=k_2g$，假设$a \\mod b=r$，则有$a = kb+r$</li>\n<li>将前两式代入第三式得出$k_1g = kk_2g + r=&gt;r = (k_1g-kk_2g)g$，可得出$r\\mod g=0$</li>\n<li>结合上述可知$a,b$任意的公因数也是$r$的因数，即可推知$(a,b)$的任意公因数是$(b,r)$的公因数</li>\n<li>同理对于任意$(b,r)$的公因数$h$，$b=m_1h,r=m_2h=&gt;a=km_1h+m_2h$，亦可推出$(b,r)$的任意公因数也是$(a,b)$的公因数</li>\n<li>最终得出两者具有相同的公因数序列，进一步得知最大公因数也相等</li>\n</ol>\n<p>根据上述数学结论如何得出最大公因数算法呢？需要注意的是，对于两个数，如果其中一个数能被另外一个数整除，那么被除数一定是两个数的最大公因数，因此我们只要重复$gcd(a,b)=gcd(b, a\\%b)$过程直到出现两数可以整除为止，以上思路的实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*显而易见的递归算法*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">EuclideanAlgorithm</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num1 % num2 == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> num2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> EuclideanAlgorithm(num2, num1 % num2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*非递归写法*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">EuclideanAlgorithm</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (num1 % num2 != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> tmp = num1 % num2;</span><br><span class=\"line\">                num1 = num2;</span><br><span class=\"line\">                num2 = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上算法的时间复杂度如何计算呢？注意根据取模运算特点，对于$M&gt;N$，那么有$M\\mod N&lt;M/2$，因此可以大致认为欧几里得算法的时间复杂度为$O(\\log M)$。</p>\n<h2 id=\"算法测试\"><a href=\"#算法测试\" class=\"headerlink\" title=\"算法测试\"></a>算法测试</h2><p>上述算法的测试代码如下，随机生成两个正整数，然后调用每个函数进行测试，为了测试代码正确性，我们直接抄录书上的代码作为测试基准，教材实现代码如下<code>Gcd</code>函数所示</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">Gcd</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> M, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> Rem;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (N &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                Rem = M % N;</span><br><span class=\"line\">                M = N;</span><br><span class=\"line\">                N = Rem;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> M;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>&gt; uIntDis(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>(<span class=\"number\">10e4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num1 = uIntDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> num2 = uIntDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> testResult = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"comment\">//testResult = BruteGCD(num1, num2); /*调用具体的算法*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> correctResult = Gcd(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"num1 = \"</span> &lt;&lt; num1 &lt;&lt; <span class=\"string\">\"\\tnum2 = \"</span> &lt;&lt; num2;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\tgcd = \"</span> &lt;&lt; correctResult &lt;&lt; <span class=\"string\">\"\\t\"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; ((testResult == correctResult) ? <span class=\"string\">\"Correct;\"</span> : <span class=\"string\">\"Wrong;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B8\" target=\"_blank\" rel=\"noopener\">最大公因数-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95\" target=\"_blank\" rel=\"noopener\">辗转相除法-维基百科</a></p>\n<p><a href=\"https://www.cnblogs.com/drizzlecrj/archive/2007/09/14/892340.html\" target=\"_blank\" rel=\"noopener\">最大公约数(Gcd)两种算法</a></p>\n"},{"title":"Linux下C++实现一个简单的线程池","urlname":"linux-cpp-thread-pool","date":"2018-04-08T12:18:17.000Z","copyright":true,"mathjax":true,"_content":"\n## 线程池基本概念\n\n线程池是一种线程使用模式，其思想非常类似于内存池，均是从性能出发而开发出来的一种优化技巧。线程池主要用在需要频繁执行较短的任务的情况下，由于短时间内如果进行大量线程的创建与销毁带来的开销是不可接受，因此通常预先创建好一些工作线程，然后在需要使用时直接将任务分派给空闲线程即可，同时可以根据任务数量动态增加减少内存池中的线程数量，在尽量将少资源占用的情况下获得较好的性能。\n\n\n## 线程池特点\n\n- 线程池数量限制\n\n由于线程自身会占用系统资源，带来系统开销，因此个数并不是越多越好，但是如果太少将会降低并发性能，使得任务长期得不到服务，因此线程池数量需要有一个合理值。\n\n- 适用于大量较短暂任务\n\n一般而言，线程数量会小于并发任务量，因此如果任务时间很长，甚至和进程生命周期处在同一个数量级上，此时直接使用普通线程即可，无需使用线程池。\n\n- 线程数量选取\n\n一般而言，对于IO密集型线程，线程数量一般大于CPU数量，而计算密集型线程数量则取和CPU相同比较合理。\n\n- 根据任务情况动态增减线程池中线程数量\n\n初始线程池数量一般不直接创建到最大数量，因此在运行中需要根据任务情况动态进行线程的创建和销毁。\n\n## 线程池基本结构\n\n线程池的目的以及特点，可总结出线程池以及任务需要实现以下功能：\n\n\t1. 线程池初始化：用于创建一定数量的线程\n\t2. 线程池增加线程数量：用于任务过多时增加线程数量\n\t3. 线程池销毁：销毁线程池\n\t4. 往线程池中增加任务\n\n结构体如下：\n\n```cpp\n//Condition.h文件\n\n#include <pthread.h>\n\n//封装Linux下互斥锁与条件变量，后期平台迁移只需要修改内部实现即可\nclass Condition\n{\npublic:\n    Condition();\n    ~Condition();\n    int lock(); //加锁\n    int unlock(); //解锁\n    int wait(); //等待条件变量\n    int timeWait(timespec &waitTime); //等待一段时间\n    int signal(); //给信号\n    int broadcast(); //广播信号\nprivate:\n    void init(); //初始化锁和条件变量\n    void destroy(); //销毁锁和条件变量\nprivate:\n    pthread_mutex_t mutext;\n    pthread_cond_t cond;\n};\n\n\n//ThreadPool.h\n\n#include \"Condition.h\"\n#include <queue>\n#include <set>\n#include <string>\nusing std::queue;\nusing std::set;\nusing std::string;\n\n//封装任务虚基类，可以方便扩充任务类别\nclass TaskBase\n{\npublic:\n    TaskBase(string tmpName, void *arg) : taskName(tmpName), taskArg(arg) {}\n    virtual void taskRun() = 0;\nprotected:\n    string taskName; //任务名称，用于测试\n    void *taskArg; //任务参数\n};\n\n//封装好的线程池实现，只开放增加任务接口\nclass ThreadPool\n{\npublic:\n    ThreadPool(int initNum, int maxNum);\n    ~ThreadPool();\n    void addTask(TaskBase *tmpTask); //增加任务\n    friend void *threadRoutine(void *arg); //将线程入口函数定义为友元\nprivate:\n    void initThreadPool(); //初始化线程池\n    void destroyThreadPool(); //销毁线程池\nprivate:\n    int initThreadNum; //初始线程池数量\n    int maxThreadNum; //最大允许的线程数量\n    queue<TaskBase *> taskQueue; //任务队列\n    set<pthread_t> threadIDs; //创建线程的ID集合\n    int nowThreadNum; //当前线程池线程数量\n    int idleThreadNum; //当前空闲线程数量\n    Condition cond; //锁和条件变量\n    bool isDestroyNotify; //线程销毁通知\n};\n```\n\n## 线程池实现\n\nTaskBase是一个抽象基类，需要派生出不同的任务，所有任务需要的参数可以全部打包到void *taskArg成员变量中。以下为线程池的具体实现。\n\n```cpp\n//class Condition，实现于Condition.cpp\n\n#include \"Condition.h\"\n#include <iostream>\nusing std::cerr;\nusing std::endl;\nusing std::cout;\n\nCondition::Condition()\n{\n    init();\n}\n\nCondition::~Condition()\n{\n    destroy();\n}\n\nvoid Condition::init()\n{\n    int mIrc = pthread_mutex_init(&mutext, nullptr);\n    int cIrc = pthread_cond_init(&cond, nullptr);\n    if (mIrc != 0 || cIrc != 0) {\n        cerr << \"init failed\" << endl;\n    }\n}\n\nvoid Condition::destroy()\n{\n    int mIrc = pthread_mutex_destroy(&mutext);\n    int cIrc = pthread_cond_destroy(&cond);\n    if (mIrc != 0 || cIrc != 0) {\n        cerr << \"destroy failed\" << endl;\n    }\n}\n\nint Condition::lock()\n{\n    return pthread_mutex_lock(&mutext);\n}\n\nint Condition::unlock()\n{\n    return pthread_mutex_unlock(&mutext);\n}\n\nint Condition::wait()\n{\n    return pthread_cond_wait(&cond, &mutext);\n}\n\nint Condition::timeWait(timespec &waitTime)\n{\n    return pthread_cond_timedwait(&cond, &mutext, &waitTime);\n}\n\nint Condition::signal()\n{\n    return pthread_cond_signal(&cond);\n}\n\nint Condition::broadcast()\n{\n    return pthread_cond_broadcast(&cond);\n}\n\n//class ThreadPool，实现于ThreadPool.cpp文件\n\n#include \"ThreadPool.h\"\n#include <time.h>\n#include <iostream>\nusing std::endl;\nusing std::cout;\n\nvoid *threadRoutine(void *arg)\n{\n    ThreadPool *thPool = static_cast<ThreadPool *>(arg);\n    bool exit = false; timespec timeOut = {0}; const time_t maxWaitTime = 5;\n    while (!exit) {\n        thPool->cond.lock(); //访问互斥资源时先加锁\n        ++(thPool->idleThreadNum); //此时线程空闲，因此空闲线程数+1\n\t//测试是否有任务或者收到线程销毁通知\n        while (thPool->taskQueue.empty() && !thPool->isDestroyNotify) {\n            cout << \"Thread \" << pthread_self() << \" is waiting.\" << endl;\n            clock_gettime(CLOCK_REALTIME, &timeOut);\n            timeOut.tv_sec += maxWaitTime;\n            if (thPool->cond.timeWait(timeOut) == ETIMEDOUT) {\n                cout << \"Thread \" << pthread_self() << \" waiting timeout.\" << endl;\n                exit = true; break; //超时退出\n            }\n        }\n        cout << \"Thread \" << pthread_self() << \" is working.\" << endl;\n        --(thPool->idleThreadNum); //开始执行说明当前线程不再空闲\n        if (!thPool->taskQueue.empty()) {\n            TaskBase *tmpTask = thPool->taskQueue.front(); thPool->taskQueue.pop();\n            thPool->cond.unlock();\n            tmpTask->taskRun(); //执行具体任务时解锁\n            thPool->cond.lock();\n        }\n\t//如果没有任务且接到销毁或者退出信号\n        if ((thPool->isDestroyNotify || exit) && thPool->taskQueue.empty()) {\n            --(thPool->nowThreadNum);\n            if (thPool->nowThreadNum <= 0) {\n                thPool->cond.signal();\n            }\n            exit = true;\n        }\n        thPool->cond.unlock();\n    }\n    cout << \"Thread \" << pthread_self() << \" exited.\" << endl;\n    return arg;\n}\n\nThreadPool::ThreadPool(int initNum, int maxNum)\n        : initThreadNum(initNum), maxThreadNum(maxNum), nowThreadNum(0),\n          idleThreadNum(0), isDestroyNotify(false)\n{\n    initThreadPool();\n}\n\nThreadPool::~ThreadPool()\n{\n    destroyThreadPool();\n}\n\nvoid ThreadPool::addTask(TaskBase *tmpTask)\n{\n    if (tmpTask == nullptr) return;\n    this->cond.lock();\n    taskQueue.push(tmpTask);\n    if (this->idleThreadNum > 0) {\n        this->cond.signal();\n    }\n    else {\n        if (this->nowThreadNum < this->maxThreadNum) {\n            pthread_t threadID = 0;\n            int irc = pthread_create(&threadID, nullptr, &threadRoutine, static_cast<void *>(this));\n            if (irc == 0) {\n                this->threadIDs.insert(this->threadIDs.end(), threadID); ++nowThreadNum;\n            }\n        }\n    }\n    this->cond.unlock();\n}\n\nvoid ThreadPool::initThreadPool()\n{\n    pthread_t threadID = 0; int irc = 0;\n    this->cond.lock(); //创建时会读写互斥资源\n    for (int i = 0; i < this->initThreadNum; i++) {\n        irc = pthread_create(&threadID, nullptr, &threadRoutine, static_cast<void *>(this));\n        if (irc == 0) {\n            this->threadIDs.insert(this->threadIDs.end(), threadID); ++nowThreadNum;\n        }\n    }\n    this->cond.unlock();\n}\n\nvoid ThreadPool::destroyThreadPool()\n{\n    this->cond.lock();\n    if (!isDestroyNotify) {\n        isDestroyNotify = true;\n    }\n    if (this->idleThreadNum > 0) {\n        this->cond.broadcast();\n    }\n    if (this->nowThreadNum > 0) {\n        while (this->nowThreadNum > 0) {\n            this->cond.wait();\n        }\n    }\n    auto iter = this->threadIDs.begin();\n    for ( ; iter != this->threadIDs.end(); iter++) {\n        pthread_join(*iter, nullptr);\n    }\n    this->cond.unlock();\n}\n```\n\n测试代码如下所示：\n\n```cpp\n#include \"ThreadPool.h\"\n#include <iostream>\n#include <unistd.h>\nusing std::cout;\nusing std::endl;\n\nclass RealTask : public TaskBase\n{\npublic:\n    RealTask(string tmpName, void *outString) : TaskBase(tmpName, outString) {};\n    void taskRun()\n    {\n        sleep(3);\n        cout << static_cast<char *>(taskArg) << endl;\n        cout << taskName << \" finished.\\n\";\n    }\n};\n\nint main()\n{\n    char workData[10][30] = {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"};\n    RealTask task[10] = {{\"Task0\", workData[0]}, {\"Task1\", workData[1]}, {\"Task2\", workData[2]},\n                         {\"Task3\", workData[3]}, {\"Task4\", workData[4]}, {\"Task5\", workData[5]},\n                         {\"Task6\", workData[6]}, {\"Task7\", workData[7]}, {\"Task8\", workData[8]},\n                         {\"Task9\", workData[9]}};\n    ThreadPool testPool(2, 8);\n    for (int i = 0; i < 10; i++) {\n        testPool.addTask(&task[i]);\n    }\n    return 0;\n}\n```\n\n线程池的代码可见：[一个简单的Linux线程池实现](https://github.com/hsuloong/simple_thread_pool)\n\n## 参考文章\n\n[线程池-维基百科](https://zh.wikipedia.org/zh-cn/线程池)\n\n[C++线程池实现原理](https://yanyiwu.com/work/2015/12/16/cpp-thread-pool-programming.html)\n\n[C++ 11简化线程池的实现](https://blog.csdn.net/shreck66/article/details/50412986)\n\n[基于C++ 11的100行实现简单线程池](https://blog.csdn.net/gcola007/article/details/78750220)\n\n[线程池原理及创建（C++实现）](https://www.cnblogs.com/lidabo/p/3328402.html)\n\n[c++简单线程池实现](https://www.cnblogs.com/yangang92/p/5485868.html)","source":"_posts/操作系统/Linux下C++实现一个简单的线程池.md","raw":"---\ntitle: Linux下C++实现一个简单的线程池\nurlname: linux-cpp-thread-pool\ndate: 2018-04-8 20:18:17\ncopyright: true\nmathjax: true\ntags:\n- 操作系统\n- Linux\ncategories:\n- 操作系统\n---\n\n## 线程池基本概念\n\n线程池是一种线程使用模式，其思想非常类似于内存池，均是从性能出发而开发出来的一种优化技巧。线程池主要用在需要频繁执行较短的任务的情况下，由于短时间内如果进行大量线程的创建与销毁带来的开销是不可接受，因此通常预先创建好一些工作线程，然后在需要使用时直接将任务分派给空闲线程即可，同时可以根据任务数量动态增加减少内存池中的线程数量，在尽量将少资源占用的情况下获得较好的性能。\n\n\n## 线程池特点\n\n- 线程池数量限制\n\n由于线程自身会占用系统资源，带来系统开销，因此个数并不是越多越好，但是如果太少将会降低并发性能，使得任务长期得不到服务，因此线程池数量需要有一个合理值。\n\n- 适用于大量较短暂任务\n\n一般而言，线程数量会小于并发任务量，因此如果任务时间很长，甚至和进程生命周期处在同一个数量级上，此时直接使用普通线程即可，无需使用线程池。\n\n- 线程数量选取\n\n一般而言，对于IO密集型线程，线程数量一般大于CPU数量，而计算密集型线程数量则取和CPU相同比较合理。\n\n- 根据任务情况动态增减线程池中线程数量\n\n初始线程池数量一般不直接创建到最大数量，因此在运行中需要根据任务情况动态进行线程的创建和销毁。\n\n## 线程池基本结构\n\n线程池的目的以及特点，可总结出线程池以及任务需要实现以下功能：\n\n\t1. 线程池初始化：用于创建一定数量的线程\n\t2. 线程池增加线程数量：用于任务过多时增加线程数量\n\t3. 线程池销毁：销毁线程池\n\t4. 往线程池中增加任务\n\n结构体如下：\n\n```cpp\n//Condition.h文件\n\n#include <pthread.h>\n\n//封装Linux下互斥锁与条件变量，后期平台迁移只需要修改内部实现即可\nclass Condition\n{\npublic:\n    Condition();\n    ~Condition();\n    int lock(); //加锁\n    int unlock(); //解锁\n    int wait(); //等待条件变量\n    int timeWait(timespec &waitTime); //等待一段时间\n    int signal(); //给信号\n    int broadcast(); //广播信号\nprivate:\n    void init(); //初始化锁和条件变量\n    void destroy(); //销毁锁和条件变量\nprivate:\n    pthread_mutex_t mutext;\n    pthread_cond_t cond;\n};\n\n\n//ThreadPool.h\n\n#include \"Condition.h\"\n#include <queue>\n#include <set>\n#include <string>\nusing std::queue;\nusing std::set;\nusing std::string;\n\n//封装任务虚基类，可以方便扩充任务类别\nclass TaskBase\n{\npublic:\n    TaskBase(string tmpName, void *arg) : taskName(tmpName), taskArg(arg) {}\n    virtual void taskRun() = 0;\nprotected:\n    string taskName; //任务名称，用于测试\n    void *taskArg; //任务参数\n};\n\n//封装好的线程池实现，只开放增加任务接口\nclass ThreadPool\n{\npublic:\n    ThreadPool(int initNum, int maxNum);\n    ~ThreadPool();\n    void addTask(TaskBase *tmpTask); //增加任务\n    friend void *threadRoutine(void *arg); //将线程入口函数定义为友元\nprivate:\n    void initThreadPool(); //初始化线程池\n    void destroyThreadPool(); //销毁线程池\nprivate:\n    int initThreadNum; //初始线程池数量\n    int maxThreadNum; //最大允许的线程数量\n    queue<TaskBase *> taskQueue; //任务队列\n    set<pthread_t> threadIDs; //创建线程的ID集合\n    int nowThreadNum; //当前线程池线程数量\n    int idleThreadNum; //当前空闲线程数量\n    Condition cond; //锁和条件变量\n    bool isDestroyNotify; //线程销毁通知\n};\n```\n\n## 线程池实现\n\nTaskBase是一个抽象基类，需要派生出不同的任务，所有任务需要的参数可以全部打包到void *taskArg成员变量中。以下为线程池的具体实现。\n\n```cpp\n//class Condition，实现于Condition.cpp\n\n#include \"Condition.h\"\n#include <iostream>\nusing std::cerr;\nusing std::endl;\nusing std::cout;\n\nCondition::Condition()\n{\n    init();\n}\n\nCondition::~Condition()\n{\n    destroy();\n}\n\nvoid Condition::init()\n{\n    int mIrc = pthread_mutex_init(&mutext, nullptr);\n    int cIrc = pthread_cond_init(&cond, nullptr);\n    if (mIrc != 0 || cIrc != 0) {\n        cerr << \"init failed\" << endl;\n    }\n}\n\nvoid Condition::destroy()\n{\n    int mIrc = pthread_mutex_destroy(&mutext);\n    int cIrc = pthread_cond_destroy(&cond);\n    if (mIrc != 0 || cIrc != 0) {\n        cerr << \"destroy failed\" << endl;\n    }\n}\n\nint Condition::lock()\n{\n    return pthread_mutex_lock(&mutext);\n}\n\nint Condition::unlock()\n{\n    return pthread_mutex_unlock(&mutext);\n}\n\nint Condition::wait()\n{\n    return pthread_cond_wait(&cond, &mutext);\n}\n\nint Condition::timeWait(timespec &waitTime)\n{\n    return pthread_cond_timedwait(&cond, &mutext, &waitTime);\n}\n\nint Condition::signal()\n{\n    return pthread_cond_signal(&cond);\n}\n\nint Condition::broadcast()\n{\n    return pthread_cond_broadcast(&cond);\n}\n\n//class ThreadPool，实现于ThreadPool.cpp文件\n\n#include \"ThreadPool.h\"\n#include <time.h>\n#include <iostream>\nusing std::endl;\nusing std::cout;\n\nvoid *threadRoutine(void *arg)\n{\n    ThreadPool *thPool = static_cast<ThreadPool *>(arg);\n    bool exit = false; timespec timeOut = {0}; const time_t maxWaitTime = 5;\n    while (!exit) {\n        thPool->cond.lock(); //访问互斥资源时先加锁\n        ++(thPool->idleThreadNum); //此时线程空闲，因此空闲线程数+1\n\t//测试是否有任务或者收到线程销毁通知\n        while (thPool->taskQueue.empty() && !thPool->isDestroyNotify) {\n            cout << \"Thread \" << pthread_self() << \" is waiting.\" << endl;\n            clock_gettime(CLOCK_REALTIME, &timeOut);\n            timeOut.tv_sec += maxWaitTime;\n            if (thPool->cond.timeWait(timeOut) == ETIMEDOUT) {\n                cout << \"Thread \" << pthread_self() << \" waiting timeout.\" << endl;\n                exit = true; break; //超时退出\n            }\n        }\n        cout << \"Thread \" << pthread_self() << \" is working.\" << endl;\n        --(thPool->idleThreadNum); //开始执行说明当前线程不再空闲\n        if (!thPool->taskQueue.empty()) {\n            TaskBase *tmpTask = thPool->taskQueue.front(); thPool->taskQueue.pop();\n            thPool->cond.unlock();\n            tmpTask->taskRun(); //执行具体任务时解锁\n            thPool->cond.lock();\n        }\n\t//如果没有任务且接到销毁或者退出信号\n        if ((thPool->isDestroyNotify || exit) && thPool->taskQueue.empty()) {\n            --(thPool->nowThreadNum);\n            if (thPool->nowThreadNum <= 0) {\n                thPool->cond.signal();\n            }\n            exit = true;\n        }\n        thPool->cond.unlock();\n    }\n    cout << \"Thread \" << pthread_self() << \" exited.\" << endl;\n    return arg;\n}\n\nThreadPool::ThreadPool(int initNum, int maxNum)\n        : initThreadNum(initNum), maxThreadNum(maxNum), nowThreadNum(0),\n          idleThreadNum(0), isDestroyNotify(false)\n{\n    initThreadPool();\n}\n\nThreadPool::~ThreadPool()\n{\n    destroyThreadPool();\n}\n\nvoid ThreadPool::addTask(TaskBase *tmpTask)\n{\n    if (tmpTask == nullptr) return;\n    this->cond.lock();\n    taskQueue.push(tmpTask);\n    if (this->idleThreadNum > 0) {\n        this->cond.signal();\n    }\n    else {\n        if (this->nowThreadNum < this->maxThreadNum) {\n            pthread_t threadID = 0;\n            int irc = pthread_create(&threadID, nullptr, &threadRoutine, static_cast<void *>(this));\n            if (irc == 0) {\n                this->threadIDs.insert(this->threadIDs.end(), threadID); ++nowThreadNum;\n            }\n        }\n    }\n    this->cond.unlock();\n}\n\nvoid ThreadPool::initThreadPool()\n{\n    pthread_t threadID = 0; int irc = 0;\n    this->cond.lock(); //创建时会读写互斥资源\n    for (int i = 0; i < this->initThreadNum; i++) {\n        irc = pthread_create(&threadID, nullptr, &threadRoutine, static_cast<void *>(this));\n        if (irc == 0) {\n            this->threadIDs.insert(this->threadIDs.end(), threadID); ++nowThreadNum;\n        }\n    }\n    this->cond.unlock();\n}\n\nvoid ThreadPool::destroyThreadPool()\n{\n    this->cond.lock();\n    if (!isDestroyNotify) {\n        isDestroyNotify = true;\n    }\n    if (this->idleThreadNum > 0) {\n        this->cond.broadcast();\n    }\n    if (this->nowThreadNum > 0) {\n        while (this->nowThreadNum > 0) {\n            this->cond.wait();\n        }\n    }\n    auto iter = this->threadIDs.begin();\n    for ( ; iter != this->threadIDs.end(); iter++) {\n        pthread_join(*iter, nullptr);\n    }\n    this->cond.unlock();\n}\n```\n\n测试代码如下所示：\n\n```cpp\n#include \"ThreadPool.h\"\n#include <iostream>\n#include <unistd.h>\nusing std::cout;\nusing std::endl;\n\nclass RealTask : public TaskBase\n{\npublic:\n    RealTask(string tmpName, void *outString) : TaskBase(tmpName, outString) {};\n    void taskRun()\n    {\n        sleep(3);\n        cout << static_cast<char *>(taskArg) << endl;\n        cout << taskName << \" finished.\\n\";\n    }\n};\n\nint main()\n{\n    char workData[10][30] = {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"};\n    RealTask task[10] = {{\"Task0\", workData[0]}, {\"Task1\", workData[1]}, {\"Task2\", workData[2]},\n                         {\"Task3\", workData[3]}, {\"Task4\", workData[4]}, {\"Task5\", workData[5]},\n                         {\"Task6\", workData[6]}, {\"Task7\", workData[7]}, {\"Task8\", workData[8]},\n                         {\"Task9\", workData[9]}};\n    ThreadPool testPool(2, 8);\n    for (int i = 0; i < 10; i++) {\n        testPool.addTask(&task[i]);\n    }\n    return 0;\n}\n```\n\n线程池的代码可见：[一个简单的Linux线程池实现](https://github.com/hsuloong/simple_thread_pool)\n\n## 参考文章\n\n[线程池-维基百科](https://zh.wikipedia.org/zh-cn/线程池)\n\n[C++线程池实现原理](https://yanyiwu.com/work/2015/12/16/cpp-thread-pool-programming.html)\n\n[C++ 11简化线程池的实现](https://blog.csdn.net/shreck66/article/details/50412986)\n\n[基于C++ 11的100行实现简单线程池](https://blog.csdn.net/gcola007/article/details/78750220)\n\n[线程池原理及创建（C++实现）](https://www.cnblogs.com/lidabo/p/3328402.html)\n\n[c++简单线程池实现](https://www.cnblogs.com/yangang92/p/5485868.html)","slug":"操作系统/Linux下C++实现一个简单的线程池","published":1,"updated":"2018-06-13T14:21:25.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x4a002mgsvn4wdaezkh","content":"<h2 id=\"线程池基本概念\"><a href=\"#线程池基本概念\" class=\"headerlink\" title=\"线程池基本概念\"></a>线程池基本概念</h2><p>线程池是一种线程使用模式，其思想非常类似于内存池，均是从性能出发而开发出来的一种优化技巧。线程池主要用在需要频繁执行较短的任务的情况下，由于短时间内如果进行大量线程的创建与销毁带来的开销是不可接受，因此通常预先创建好一些工作线程，然后在需要使用时直接将任务分派给空闲线程即可，同时可以根据任务数量动态增加减少内存池中的线程数量，在尽量将少资源占用的情况下获得较好的性能。</p>\n<h2 id=\"线程池特点\"><a href=\"#线程池特点\" class=\"headerlink\" title=\"线程池特点\"></a>线程池特点</h2><ul>\n<li>线程池数量限制</li>\n</ul>\n<p>由于线程自身会占用系统资源，带来系统开销，因此个数并不是越多越好，但是如果太少将会降低并发性能，使得任务长期得不到服务，因此线程池数量需要有一个合理值。</p>\n<ul>\n<li>适用于大量较短暂任务</li>\n</ul>\n<p>一般而言，线程数量会小于并发任务量，因此如果任务时间很长，甚至和进程生命周期处在同一个数量级上，此时直接使用普通线程即可，无需使用线程池。</p>\n<ul>\n<li>线程数量选取</li>\n</ul>\n<p>一般而言，对于IO密集型线程，线程数量一般大于CPU数量，而计算密集型线程数量则取和CPU相同比较合理。</p>\n<ul>\n<li>根据任务情况动态增减线程池中线程数量</li>\n</ul>\n<p>初始线程池数量一般不直接创建到最大数量，因此在运行中需要根据任务情况动态进行线程的创建和销毁。</p>\n<h2 id=\"线程池基本结构\"><a href=\"#线程池基本结构\" class=\"headerlink\" title=\"线程池基本结构\"></a>线程池基本结构</h2><p>线程池的目的以及特点，可总结出线程池以及任务需要实现以下功能：</p>\n<pre><code>1. 线程池初始化：用于创建一定数量的线程\n2. 线程池增加线程数量：用于任务过多时增加线程数量\n3. 线程池销毁：销毁线程池\n4. 往线程池中增加任务\n</code></pre><p>结构体如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Condition.h文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//封装Linux下互斥锁与条件变量，后期平台迁移只需要修改内部实现即可</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Condition</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Condition();</span><br><span class=\"line\">    ~Condition();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>; <span class=\"comment\">//加锁</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>; <span class=\"comment\">//解锁</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span>; <span class=\"comment\">//等待条件变量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">timeWait</span><span class=\"params\">(timespec &amp;waitTime)</span></span>; <span class=\"comment\">//等待一段时间</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">signal</span><span class=\"params\">()</span></span>; <span class=\"comment\">//给信号</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">broadcast</span><span class=\"params\">()</span></span>; <span class=\"comment\">//广播信号</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>; <span class=\"comment\">//初始化锁和条件变量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>; <span class=\"comment\">//销毁锁和条件变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> mutext;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_cond_t</span> cond;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ThreadPool.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Condition.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//封装任务虚基类，可以方便扩充任务类别</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TaskBase(<span class=\"built_in\">string</span> tmpName, <span class=\"keyword\">void</span> *arg) : taskName(tmpName), taskArg(arg) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">taskRun</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> taskName; <span class=\"comment\">//任务名称，用于测试</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *taskArg; <span class=\"comment\">//任务参数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//封装好的线程池实现，只开放增加任务接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPool</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ThreadPool(<span class=\"keyword\">int</span> initNum, <span class=\"keyword\">int</span> maxNum);</span><br><span class=\"line\">    ~ThreadPool();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(TaskBase *tmpTask)</span></span>; <span class=\"comment\">//增加任务</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> *<span class=\"title\">threadRoutine</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>; <span class=\"comment\">//将线程入口函数定义为友元</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initThreadPool</span><span class=\"params\">()</span></span>; <span class=\"comment\">//初始化线程池</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyThreadPool</span><span class=\"params\">()</span></span>; <span class=\"comment\">//销毁线程池</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> initThreadNum; <span class=\"comment\">//初始线程池数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxThreadNum; <span class=\"comment\">//最大允许的线程数量</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TaskBase *&gt; taskQueue; <span class=\"comment\">//任务队列</span></span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">pthread_t</span>&gt; threadIDs; <span class=\"comment\">//创建线程的ID集合</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nowThreadNum; <span class=\"comment\">//当前线程池线程数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idleThreadNum; <span class=\"comment\">//当前空闲线程数量</span></span><br><span class=\"line\">    Condition cond; <span class=\"comment\">//锁和条件变量</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isDestroyNotify; <span class=\"comment\">//线程销毁通知</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程池实现\"><a href=\"#线程池实现\" class=\"headerlink\" title=\"线程池实现\"></a>线程池实现</h2><p>TaskBase是一个抽象基类，需要派生出不同的任务，所有任务需要的参数可以全部打包到void *taskArg成员变量中。以下为线程池的具体实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//class Condition，实现于Condition.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Condition.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Condition::Condition()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Condition::~Condition()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    destroy();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Condition::init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mIrc = pthread_mutex_init(&amp;mutext, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cIrc = pthread_cond_init(&amp;cond, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIrc != <span class=\"number\">0</span> || cIrc != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"init failed\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Condition::destroy()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mIrc = pthread_mutex_destroy(&amp;mutext);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cIrc = pthread_cond_destroy(&amp;cond);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIrc != <span class=\"number\">0</span> || cIrc != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"destroy failed\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::lock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_mutex_lock(&amp;mutext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::unlock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_mutex_unlock(&amp;mutext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::wait()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_cond_wait(&amp;cond, &amp;mutext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::timeWait(timespec &amp;waitTime)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_cond_timedwait(&amp;cond, &amp;mutext, &amp;waitTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::signal()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_cond_signal(&amp;cond);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::broadcast()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_cond_broadcast(&amp;cond);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//class ThreadPool，实现于ThreadPool.cpp文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"ThreadPool.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">threadRoutine</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ThreadPool *thPool = <span class=\"keyword\">static_cast</span>&lt;ThreadPool *&gt;(arg);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"built_in\">exit</span> = <span class=\"literal\">false</span>; timespec timeOut = &#123;<span class=\"number\">0</span>&#125;; <span class=\"keyword\">const</span> <span class=\"keyword\">time_t</span> maxWaitTime = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"built_in\">exit</span>) &#123;</span><br><span class=\"line\">        thPool-&gt;cond.lock(); <span class=\"comment\">//访问互斥资源时先加锁</span></span><br><span class=\"line\">        ++(thPool-&gt;idleThreadNum); <span class=\"comment\">//此时线程空闲，因此空闲线程数+1</span></span><br><span class=\"line\">\t<span class=\"comment\">//测试是否有任务或者收到线程销毁通知</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (thPool-&gt;taskQueue.empty() &amp;&amp; !thPool-&gt;isDestroyNotify) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Thread \"</span> &lt;&lt; pthread_self() &lt;&lt; <span class=\"string\">\" is waiting.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            clock_gettime(CLOCK_REALTIME, &amp;timeOut);</span><br><span class=\"line\">            timeOut.tv_sec += maxWaitTime;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (thPool-&gt;cond.timeWait(timeOut) == ETIMEDOUT) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Thread \"</span> &lt;&lt; pthread_self() &lt;&lt; <span class=\"string\">\" waiting timeout.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                <span class=\"built_in\">exit</span> = <span class=\"literal\">true</span>; <span class=\"keyword\">break</span>; <span class=\"comment\">//超时退出</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Thread \"</span> &lt;&lt; pthread_self() &lt;&lt; <span class=\"string\">\" is working.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        --(thPool-&gt;idleThreadNum); <span class=\"comment\">//开始执行说明当前线程不再空闲</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!thPool-&gt;taskQueue.empty()) &#123;</span><br><span class=\"line\">            TaskBase *tmpTask = thPool-&gt;taskQueue.front(); thPool-&gt;taskQueue.pop();</span><br><span class=\"line\">            thPool-&gt;cond.unlock();</span><br><span class=\"line\">            tmpTask-&gt;taskRun(); <span class=\"comment\">//执行具体任务时解锁</span></span><br><span class=\"line\">            thPool-&gt;cond.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//如果没有任务且接到销毁或者退出信号</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((thPool-&gt;isDestroyNotify || <span class=\"built_in\">exit</span>) &amp;&amp; thPool-&gt;taskQueue.empty()) &#123;</span><br><span class=\"line\">            --(thPool-&gt;nowThreadNum);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (thPool-&gt;nowThreadNum &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                thPool-&gt;cond.signal();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">exit</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        thPool-&gt;cond.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Thread \"</span> &lt;&lt; pthread_self() &lt;&lt; <span class=\"string\">\" exited.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPool::ThreadPool(<span class=\"keyword\">int</span> initNum, <span class=\"keyword\">int</span> maxNum)</span><br><span class=\"line\">        : initThreadNum(initNum), maxThreadNum(maxNum), nowThreadNum(<span class=\"number\">0</span>),</span><br><span class=\"line\">          idleThreadNum(<span class=\"number\">0</span>), isDestroyNotify(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    initThreadPool();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPool::~ThreadPool()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    destroyThreadPool();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> ThreadPool::addTask(TaskBase *tmpTask)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmpTask == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.lock();</span><br><span class=\"line\">    taskQueue.push(tmpTask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;idleThreadNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;cond.signal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;nowThreadNum &lt; <span class=\"keyword\">this</span>-&gt;maxThreadNum) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">pthread_t</span> threadID = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> irc = pthread_create(&amp;threadID, <span class=\"literal\">nullptr</span>, &amp;threadRoutine, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span> *&gt;(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (irc == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>-&gt;threadIDs.insert(<span class=\"keyword\">this</span>-&gt;threadIDs.end(), threadID); ++nowThreadNum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> ThreadPool::initThreadPool()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> threadID = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> irc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.lock(); <span class=\"comment\">//创建时会读写互斥资源</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>-&gt;initThreadNum; i++) &#123;</span><br><span class=\"line\">        irc = pthread_create(&amp;threadID, <span class=\"literal\">nullptr</span>, &amp;threadRoutine, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span> *&gt;(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (irc == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;threadIDs.insert(<span class=\"keyword\">this</span>-&gt;threadIDs.end(), threadID); ++nowThreadNum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> ThreadPool::destroyThreadPool()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.lock();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDestroyNotify) &#123;</span><br><span class=\"line\">        isDestroyNotify = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;idleThreadNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;cond.broadcast();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;nowThreadNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>-&gt;nowThreadNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;cond.wait();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> iter = <span class=\"keyword\">this</span>-&gt;threadIDs.begin();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; iter != <span class=\"keyword\">this</span>-&gt;threadIDs.end(); iter++) &#123;</span><br><span class=\"line\">        pthread_join(*iter, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"ThreadPool.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealTask</span> :</span> <span class=\"keyword\">public</span> TaskBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    RealTask(<span class=\"built_in\">string</span> tmpName, <span class=\"keyword\">void</span> *outString) : TaskBase(tmpName, outString) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">taskRun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">char</span> *&gt;(taskArg) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; taskName &lt;&lt; <span class=\"string\">\" finished.\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> workData[<span class=\"number\">10</span>][<span class=\"number\">30</span>] = &#123;<span class=\"string\">\"0\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\"5\"</span>, <span class=\"string\">\"6\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\"9\"</span>&#125;;</span><br><span class=\"line\">    RealTask task[<span class=\"number\">10</span>] = &#123;&#123;<span class=\"string\">\"Task0\"</span>, workData[<span class=\"number\">0</span>]&#125;, &#123;<span class=\"string\">\"Task1\"</span>, workData[<span class=\"number\">1</span>]&#125;, &#123;<span class=\"string\">\"Task2\"</span>, workData[<span class=\"number\">2</span>]&#125;,</span><br><span class=\"line\">                         &#123;<span class=\"string\">\"Task3\"</span>, workData[<span class=\"number\">3</span>]&#125;, &#123;<span class=\"string\">\"Task4\"</span>, workData[<span class=\"number\">4</span>]&#125;, &#123;<span class=\"string\">\"Task5\"</span>, workData[<span class=\"number\">5</span>]&#125;,</span><br><span class=\"line\">                         &#123;<span class=\"string\">\"Task6\"</span>, workData[<span class=\"number\">6</span>]&#125;, &#123;<span class=\"string\">\"Task7\"</span>, workData[<span class=\"number\">7</span>]&#125;, &#123;<span class=\"string\">\"Task8\"</span>, workData[<span class=\"number\">8</span>]&#125;,</span><br><span class=\"line\">                         &#123;<span class=\"string\">\"Task9\"</span>, workData[<span class=\"number\">9</span>]&#125;&#125;;</span><br><span class=\"line\">    <span class=\"function\">ThreadPool <span class=\"title\">testPool</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">8</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        testPool.addTask(&amp;task[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程池的代码可见：<a href=\"https://github.com/hsuloong/simple_thread_pool\" target=\"_blank\" rel=\"noopener\">一个简单的Linux线程池实现</a></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://zh.wikipedia.org/zh-cn/线程池\" target=\"_blank\" rel=\"noopener\">线程池-维基百科</a></p>\n<p><a href=\"https://yanyiwu.com/work/2015/12/16/cpp-thread-pool-programming.html\" target=\"_blank\" rel=\"noopener\">C++线程池实现原理</a></p>\n<p><a href=\"https://blog.csdn.net/shreck66/article/details/50412986\" target=\"_blank\" rel=\"noopener\">C++ 11简化线程池的实现</a></p>\n<p><a href=\"https://blog.csdn.net/gcola007/article/details/78750220\" target=\"_blank\" rel=\"noopener\">基于C++ 11的100行实现简单线程池</a></p>\n<p><a href=\"https://www.cnblogs.com/lidabo/p/3328402.html\" target=\"_blank\" rel=\"noopener\">线程池原理及创建（C++实现）</a></p>\n<p><a href=\"https://www.cnblogs.com/yangang92/p/5485868.html\" target=\"_blank\" rel=\"noopener\">c++简单线程池实现</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线程池基本概念\"><a href=\"#线程池基本概念\" class=\"headerlink\" title=\"线程池基本概念\"></a>线程池基本概念</h2><p>线程池是一种线程使用模式，其思想非常类似于内存池，均是从性能出发而开发出来的一种优化技巧。线程池主要用在需要频繁执行较短的任务的情况下，由于短时间内如果进行大量线程的创建与销毁带来的开销是不可接受，因此通常预先创建好一些工作线程，然后在需要使用时直接将任务分派给空闲线程即可，同时可以根据任务数量动态增加减少内存池中的线程数量，在尽量将少资源占用的情况下获得较好的性能。</p>\n<h2 id=\"线程池特点\"><a href=\"#线程池特点\" class=\"headerlink\" title=\"线程池特点\"></a>线程池特点</h2><ul>\n<li>线程池数量限制</li>\n</ul>\n<p>由于线程自身会占用系统资源，带来系统开销，因此个数并不是越多越好，但是如果太少将会降低并发性能，使得任务长期得不到服务，因此线程池数量需要有一个合理值。</p>\n<ul>\n<li>适用于大量较短暂任务</li>\n</ul>\n<p>一般而言，线程数量会小于并发任务量，因此如果任务时间很长，甚至和进程生命周期处在同一个数量级上，此时直接使用普通线程即可，无需使用线程池。</p>\n<ul>\n<li>线程数量选取</li>\n</ul>\n<p>一般而言，对于IO密集型线程，线程数量一般大于CPU数量，而计算密集型线程数量则取和CPU相同比较合理。</p>\n<ul>\n<li>根据任务情况动态增减线程池中线程数量</li>\n</ul>\n<p>初始线程池数量一般不直接创建到最大数量，因此在运行中需要根据任务情况动态进行线程的创建和销毁。</p>\n<h2 id=\"线程池基本结构\"><a href=\"#线程池基本结构\" class=\"headerlink\" title=\"线程池基本结构\"></a>线程池基本结构</h2><p>线程池的目的以及特点，可总结出线程池以及任务需要实现以下功能：</p>\n<pre><code>1. 线程池初始化：用于创建一定数量的线程\n2. 线程池增加线程数量：用于任务过多时增加线程数量\n3. 线程池销毁：销毁线程池\n4. 往线程池中增加任务\n</code></pre><p>结构体如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Condition.h文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//封装Linux下互斥锁与条件变量，后期平台迁移只需要修改内部实现即可</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Condition</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Condition();</span><br><span class=\"line\">    ~Condition();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>; <span class=\"comment\">//加锁</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>; <span class=\"comment\">//解锁</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wait</span><span class=\"params\">()</span></span>; <span class=\"comment\">//等待条件变量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">timeWait</span><span class=\"params\">(timespec &amp;waitTime)</span></span>; <span class=\"comment\">//等待一段时间</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">signal</span><span class=\"params\">()</span></span>; <span class=\"comment\">//给信号</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">broadcast</span><span class=\"params\">()</span></span>; <span class=\"comment\">//广播信号</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>; <span class=\"comment\">//初始化锁和条件变量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>; <span class=\"comment\">//销毁锁和条件变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> mutext;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_cond_t</span> cond;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ThreadPool.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Condition.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//封装任务虚基类，可以方便扩充任务类别</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TaskBase(<span class=\"built_in\">string</span> tmpName, <span class=\"keyword\">void</span> *arg) : taskName(tmpName), taskArg(arg) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">taskRun</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">string</span> taskName; <span class=\"comment\">//任务名称，用于测试</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *taskArg; <span class=\"comment\">//任务参数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//封装好的线程池实现，只开放增加任务接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPool</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ThreadPool(<span class=\"keyword\">int</span> initNum, <span class=\"keyword\">int</span> maxNum);</span><br><span class=\"line\">    ~ThreadPool();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(TaskBase *tmpTask)</span></span>; <span class=\"comment\">//增加任务</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> *<span class=\"title\">threadRoutine</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>; <span class=\"comment\">//将线程入口函数定义为友元</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initThreadPool</span><span class=\"params\">()</span></span>; <span class=\"comment\">//初始化线程池</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyThreadPool</span><span class=\"params\">()</span></span>; <span class=\"comment\">//销毁线程池</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> initThreadNum; <span class=\"comment\">//初始线程池数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxThreadNum; <span class=\"comment\">//最大允许的线程数量</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TaskBase *&gt; taskQueue; <span class=\"comment\">//任务队列</span></span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">pthread_t</span>&gt; threadIDs; <span class=\"comment\">//创建线程的ID集合</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nowThreadNum; <span class=\"comment\">//当前线程池线程数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idleThreadNum; <span class=\"comment\">//当前空闲线程数量</span></span><br><span class=\"line\">    Condition cond; <span class=\"comment\">//锁和条件变量</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isDestroyNotify; <span class=\"comment\">//线程销毁通知</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程池实现\"><a href=\"#线程池实现\" class=\"headerlink\" title=\"线程池实现\"></a>线程池实现</h2><p>TaskBase是一个抽象基类，需要派生出不同的任务，所有任务需要的参数可以全部打包到void *taskArg成员变量中。以下为线程池的具体实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//class Condition，实现于Condition.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Condition.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Condition::Condition()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Condition::~Condition()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    destroy();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Condition::init()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mIrc = pthread_mutex_init(&amp;mutext, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cIrc = pthread_cond_init(&amp;cond, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIrc != <span class=\"number\">0</span> || cIrc != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"init failed\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Condition::destroy()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mIrc = pthread_mutex_destroy(&amp;mutext);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cIrc = pthread_cond_destroy(&amp;cond);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIrc != <span class=\"number\">0</span> || cIrc != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"destroy failed\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::lock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_mutex_lock(&amp;mutext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::unlock()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_mutex_unlock(&amp;mutext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::wait()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_cond_wait(&amp;cond, &amp;mutext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::timeWait(timespec &amp;waitTime)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_cond_timedwait(&amp;cond, &amp;mutext, &amp;waitTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::signal()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_cond_signal(&amp;cond);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> Condition::broadcast()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_cond_broadcast(&amp;cond);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//class ThreadPool，实现于ThreadPool.cpp文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"ThreadPool.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">threadRoutine</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ThreadPool *thPool = <span class=\"keyword\">static_cast</span>&lt;ThreadPool *&gt;(arg);</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"built_in\">exit</span> = <span class=\"literal\">false</span>; timespec timeOut = &#123;<span class=\"number\">0</span>&#125;; <span class=\"keyword\">const</span> <span class=\"keyword\">time_t</span> maxWaitTime = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"built_in\">exit</span>) &#123;</span><br><span class=\"line\">        thPool-&gt;cond.lock(); <span class=\"comment\">//访问互斥资源时先加锁</span></span><br><span class=\"line\">        ++(thPool-&gt;idleThreadNum); <span class=\"comment\">//此时线程空闲，因此空闲线程数+1</span></span><br><span class=\"line\">\t<span class=\"comment\">//测试是否有任务或者收到线程销毁通知</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (thPool-&gt;taskQueue.empty() &amp;&amp; !thPool-&gt;isDestroyNotify) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Thread \"</span> &lt;&lt; pthread_self() &lt;&lt; <span class=\"string\">\" is waiting.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            clock_gettime(CLOCK_REALTIME, &amp;timeOut);</span><br><span class=\"line\">            timeOut.tv_sec += maxWaitTime;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (thPool-&gt;cond.timeWait(timeOut) == ETIMEDOUT) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Thread \"</span> &lt;&lt; pthread_self() &lt;&lt; <span class=\"string\">\" waiting timeout.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                <span class=\"built_in\">exit</span> = <span class=\"literal\">true</span>; <span class=\"keyword\">break</span>; <span class=\"comment\">//超时退出</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Thread \"</span> &lt;&lt; pthread_self() &lt;&lt; <span class=\"string\">\" is working.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        --(thPool-&gt;idleThreadNum); <span class=\"comment\">//开始执行说明当前线程不再空闲</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!thPool-&gt;taskQueue.empty()) &#123;</span><br><span class=\"line\">            TaskBase *tmpTask = thPool-&gt;taskQueue.front(); thPool-&gt;taskQueue.pop();</span><br><span class=\"line\">            thPool-&gt;cond.unlock();</span><br><span class=\"line\">            tmpTask-&gt;taskRun(); <span class=\"comment\">//执行具体任务时解锁</span></span><br><span class=\"line\">            thPool-&gt;cond.lock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//如果没有任务且接到销毁或者退出信号</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((thPool-&gt;isDestroyNotify || <span class=\"built_in\">exit</span>) &amp;&amp; thPool-&gt;taskQueue.empty()) &#123;</span><br><span class=\"line\">            --(thPool-&gt;nowThreadNum);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (thPool-&gt;nowThreadNum &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                thPool-&gt;cond.signal();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">exit</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        thPool-&gt;cond.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Thread \"</span> &lt;&lt; pthread_self() &lt;&lt; <span class=\"string\">\" exited.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPool::ThreadPool(<span class=\"keyword\">int</span> initNum, <span class=\"keyword\">int</span> maxNum)</span><br><span class=\"line\">        : initThreadNum(initNum), maxThreadNum(maxNum), nowThreadNum(<span class=\"number\">0</span>),</span><br><span class=\"line\">          idleThreadNum(<span class=\"number\">0</span>), isDestroyNotify(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    initThreadPool();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPool::~ThreadPool()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    destroyThreadPool();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> ThreadPool::addTask(TaskBase *tmpTask)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmpTask == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.lock();</span><br><span class=\"line\">    taskQueue.push(tmpTask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;idleThreadNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;cond.signal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;nowThreadNum &lt; <span class=\"keyword\">this</span>-&gt;maxThreadNum) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">pthread_t</span> threadID = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> irc = pthread_create(&amp;threadID, <span class=\"literal\">nullptr</span>, &amp;threadRoutine, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span> *&gt;(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (irc == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>-&gt;threadIDs.insert(<span class=\"keyword\">this</span>-&gt;threadIDs.end(), threadID); ++nowThreadNum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> ThreadPool::initThreadPool()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> threadID = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> irc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.lock(); <span class=\"comment\">//创建时会读写互斥资源</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>-&gt;initThreadNum; i++) &#123;</span><br><span class=\"line\">        irc = pthread_create(&amp;threadID, <span class=\"literal\">nullptr</span>, &amp;threadRoutine, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span> *&gt;(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (irc == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;threadIDs.insert(<span class=\"keyword\">this</span>-&gt;threadIDs.end(), threadID); ++nowThreadNum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> ThreadPool::destroyThreadPool()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.lock();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDestroyNotify) &#123;</span><br><span class=\"line\">        isDestroyNotify = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;idleThreadNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;cond.broadcast();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;nowThreadNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>-&gt;nowThreadNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;cond.wait();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> iter = <span class=\"keyword\">this</span>-&gt;threadIDs.begin();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; iter != <span class=\"keyword\">this</span>-&gt;threadIDs.end(); iter++) &#123;</span><br><span class=\"line\">        pthread_join(*iter, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;cond.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"ThreadPool.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealTask</span> :</span> <span class=\"keyword\">public</span> TaskBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    RealTask(<span class=\"built_in\">string</span> tmpName, <span class=\"keyword\">void</span> *outString) : TaskBase(tmpName, outString) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">taskRun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">char</span> *&gt;(taskArg) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; taskName &lt;&lt; <span class=\"string\">\" finished.\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> workData[<span class=\"number\">10</span>][<span class=\"number\">30</span>] = &#123;<span class=\"string\">\"0\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\"5\"</span>, <span class=\"string\">\"6\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\"9\"</span>&#125;;</span><br><span class=\"line\">    RealTask task[<span class=\"number\">10</span>] = &#123;&#123;<span class=\"string\">\"Task0\"</span>, workData[<span class=\"number\">0</span>]&#125;, &#123;<span class=\"string\">\"Task1\"</span>, workData[<span class=\"number\">1</span>]&#125;, &#123;<span class=\"string\">\"Task2\"</span>, workData[<span class=\"number\">2</span>]&#125;,</span><br><span class=\"line\">                         &#123;<span class=\"string\">\"Task3\"</span>, workData[<span class=\"number\">3</span>]&#125;, &#123;<span class=\"string\">\"Task4\"</span>, workData[<span class=\"number\">4</span>]&#125;, &#123;<span class=\"string\">\"Task5\"</span>, workData[<span class=\"number\">5</span>]&#125;,</span><br><span class=\"line\">                         &#123;<span class=\"string\">\"Task6\"</span>, workData[<span class=\"number\">6</span>]&#125;, &#123;<span class=\"string\">\"Task7\"</span>, workData[<span class=\"number\">7</span>]&#125;, &#123;<span class=\"string\">\"Task8\"</span>, workData[<span class=\"number\">8</span>]&#125;,</span><br><span class=\"line\">                         &#123;<span class=\"string\">\"Task9\"</span>, workData[<span class=\"number\">9</span>]&#125;&#125;;</span><br><span class=\"line\">    <span class=\"function\">ThreadPool <span class=\"title\">testPool</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">8</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        testPool.addTask(&amp;task[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程池的代码可见：<a href=\"https://github.com/hsuloong/simple_thread_pool\" target=\"_blank\" rel=\"noopener\">一个简单的Linux线程池实现</a></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://zh.wikipedia.org/zh-cn/线程池\" target=\"_blank\" rel=\"noopener\">线程池-维基百科</a></p>\n<p><a href=\"https://yanyiwu.com/work/2015/12/16/cpp-thread-pool-programming.html\" target=\"_blank\" rel=\"noopener\">C++线程池实现原理</a></p>\n<p><a href=\"https://blog.csdn.net/shreck66/article/details/50412986\" target=\"_blank\" rel=\"noopener\">C++ 11简化线程池的实现</a></p>\n<p><a href=\"https://blog.csdn.net/gcola007/article/details/78750220\" target=\"_blank\" rel=\"noopener\">基于C++ 11的100行实现简单线程池</a></p>\n<p><a href=\"https://www.cnblogs.com/lidabo/p/3328402.html\" target=\"_blank\" rel=\"noopener\">线程池原理及创建（C++实现）</a></p>\n<p><a href=\"https://www.cnblogs.com/yangang92/p/5485868.html\" target=\"_blank\" rel=\"noopener\">c++简单线程池实现</a></p>\n"},{"title":"操作系统概述","urlname":"os-introduction","date":"2018-03-05T13:49:24.000Z","copyright":true,"mathjax":true,"_content":"\n## 操作系统的定义与作用\n\n操作系统是计算机中一个系统软件，操作系统尽量以**有效合理**的方式组织管理计算机硬件与软件资源，并合理地组织调度计算机的工作和资源的分配。使得用户能够灵活、方便地使用计算机，使计算机高效率运行。\n\n从操作系统作为资源管理者的角度，操作系统用来管理一个复杂系统的各个部分，包括硬件资源如CPU、内存、I/O设备、磁盘、时钟、网络卡等，软件资源如磁盘文件等。资源管理包括实现资源的多路复用（时间上复用、空间上复用）。\n\n操作系统在管理资源时，需要解决以下问题：\n\n- 资源使用状况记录\n- 资源分配策略\n- 资源分配与回收\n- 提高资源利用率\n- 保护资源的使用\n- 协调多个进程对资源请求的冲突\n\n从资源的管理角度，操作系统主要需要实现以下功能：\n\n- 进程/线程管理：进程线程状态、控制、同步互斥、通信、调度\n- 存储管理：内存分配回收、地址转换、存储保护、内存扩充\n- 文件管理：文件目录、文件操作、磁盘空间、文件存取控制\n- 设备管理：设备驱动、分配回收、缓冲技术\n- 用户接口：系统命令、编程接口\n\n操作系统的三个作用：\n\n- 资源的管理者：有效管理资源\n- 向用户提供服务：方便用户使用\n- 对硬件机器的扩展：屏蔽硬件细节\n\n## 操作系统的特征\n\n操作系统是一种系统软件，系统软件和哟应用软件存在很大的不同，其主要有如下四大基本特征：\n\n### 并发\n\n指具有在同一时间间隔内具有处理多个事件或者活动的能力，并发是一个宏观上的概念，在微观中，任何时刻只有一个程序正在执行。并发与并行不同的是，并行是指不同程序同时在多个CPU上执行，并发是一种伪并行。\n\n### 共享\n\n操作系统与多个程序共同使用计算机有限的的资源，同时操作系统需要实现合理的分配使得资源可被不同的进程轮流使用。共享可分为两种：互斥共享和同时共享，互斥共享指资源使用是独占排他的，而同时共享则是进程可以同时使用，比如可重入代码、只读数据等。\n\n### 虚拟\n\n虚拟是指操作系统通过分时复用或分空间复用将一个物理实体映射为多个对应的逻辑实体，虚拟是操作系统管理资源的重要手段，可提高资源利用率。\n\n### 随机（异步）\n\n由于多个进程之间的竞争制约关系，每个进程的运行速度是不预知的，而且系统某时刻的状态难以重现，因此操作系统必须能够应对随机事件。\n\n\n## 操作系统分类\n\n### 批处理操作系统\n\n工作方式：\n\n\t1. 用户将作业交给系统操作员\n\t2. 系统操作员将用户作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续的作业流\n\t3. 启动操作系统\n\t4. 系统自动、依次执行每个作业\n\t5. 由操作员将作业结果交给用户\n\n目标：\n\n\t1. 提高资源利用率，增加作业处理吞吐量\n\n存在的问题：\n\n\t1. 慢速的输入输出由主机完成，此时CPU处于空闲状态。（解决：采用卫星机完成面向用户的输入输出，中间结果暂在磁带或者磁盘上）\n\n分类：\n\n\t1. 单道批处理：一次处理一个作业，处理结束后再选择下一个\n\t2. 多道批处理：一次选择多个作业处理\n\n实现技术\n\n\t1. SPOOLING系统：全称（Simultaneous Peripheral Operation One-Line），同事的外围设备联机操作，又称假脱机技术。\n\n### 分时系统\n\n工作方式：\n\n\t1. 一台主机连接多个终端\n\t2. 终端输入命令，主机处理命令并把结果发送到终端上\n\n目标：\n\n\t1. 同时为多个用户提供服务\n\t2. 提高响应速度\n\n实现技术：\n\n\t1. 时间片：把CPU的时间划分成若干个片段，轮流为终端用户服务\n\n### 实时操作系统\n\n目标\n\n\t1. 计算机能够及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理并控制所有实时设备和任务协调一致运行\n\t2. 高可靠性\n\n分类：\n\n\t1. 第一类，实时过程控制：工业控制、航空、军事控制\n\t2. 第二类：实时通信处理：银行、订票系统、股市系统\n\t3. 硬实时系统：动作决定要在规定时间内完成\n\t4. 软实时系统：接受偶尔违反最终时限\n\n\n\n### 个人计算机操作系统\n\n目标：\n\n\t1. 界面友好，使用方便\n\t2. 丰富的应用软件\n\t3. 某一时间为单用户服务\n\n\n### 网络操作系统\n\n目标：\n\n\t1. 相互通信，资源共享\n\t2. 按照网络体系结构协议标准开发，完成网络管理、通信、安全\n\n\n### 分布式操作系统\n\n目标\n\n\t1. 以计算机网络或多处理机为基础，允许若干个计算机相互协作共同完成一项任务\n\n### 嵌入式操作系统\n\n目标\n\n\t1. 以各种硬件设备为参照，完成特定功能\n\t2. 对管理的资源进行统一的协调、调度、指挥和控制。\n\n","source":"_posts/操作系统/操作系统概述.md","raw":"---\ntitle: 操作系统概述\nurlname: os-introduction\ndate: 2018-03-5 21:49:24\ncopyright: true\nmathjax: true\ntags:\n- 操作系统\ncategories:\n- 操作系统\n---\n\n## 操作系统的定义与作用\n\n操作系统是计算机中一个系统软件，操作系统尽量以**有效合理**的方式组织管理计算机硬件与软件资源，并合理地组织调度计算机的工作和资源的分配。使得用户能够灵活、方便地使用计算机，使计算机高效率运行。\n\n从操作系统作为资源管理者的角度，操作系统用来管理一个复杂系统的各个部分，包括硬件资源如CPU、内存、I/O设备、磁盘、时钟、网络卡等，软件资源如磁盘文件等。资源管理包括实现资源的多路复用（时间上复用、空间上复用）。\n\n操作系统在管理资源时，需要解决以下问题：\n\n- 资源使用状况记录\n- 资源分配策略\n- 资源分配与回收\n- 提高资源利用率\n- 保护资源的使用\n- 协调多个进程对资源请求的冲突\n\n从资源的管理角度，操作系统主要需要实现以下功能：\n\n- 进程/线程管理：进程线程状态、控制、同步互斥、通信、调度\n- 存储管理：内存分配回收、地址转换、存储保护、内存扩充\n- 文件管理：文件目录、文件操作、磁盘空间、文件存取控制\n- 设备管理：设备驱动、分配回收、缓冲技术\n- 用户接口：系统命令、编程接口\n\n操作系统的三个作用：\n\n- 资源的管理者：有效管理资源\n- 向用户提供服务：方便用户使用\n- 对硬件机器的扩展：屏蔽硬件细节\n\n## 操作系统的特征\n\n操作系统是一种系统软件，系统软件和哟应用软件存在很大的不同，其主要有如下四大基本特征：\n\n### 并发\n\n指具有在同一时间间隔内具有处理多个事件或者活动的能力，并发是一个宏观上的概念，在微观中，任何时刻只有一个程序正在执行。并发与并行不同的是，并行是指不同程序同时在多个CPU上执行，并发是一种伪并行。\n\n### 共享\n\n操作系统与多个程序共同使用计算机有限的的资源，同时操作系统需要实现合理的分配使得资源可被不同的进程轮流使用。共享可分为两种：互斥共享和同时共享，互斥共享指资源使用是独占排他的，而同时共享则是进程可以同时使用，比如可重入代码、只读数据等。\n\n### 虚拟\n\n虚拟是指操作系统通过分时复用或分空间复用将一个物理实体映射为多个对应的逻辑实体，虚拟是操作系统管理资源的重要手段，可提高资源利用率。\n\n### 随机（异步）\n\n由于多个进程之间的竞争制约关系，每个进程的运行速度是不预知的，而且系统某时刻的状态难以重现，因此操作系统必须能够应对随机事件。\n\n\n## 操作系统分类\n\n### 批处理操作系统\n\n工作方式：\n\n\t1. 用户将作业交给系统操作员\n\t2. 系统操作员将用户作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续的作业流\n\t3. 启动操作系统\n\t4. 系统自动、依次执行每个作业\n\t5. 由操作员将作业结果交给用户\n\n目标：\n\n\t1. 提高资源利用率，增加作业处理吞吐量\n\n存在的问题：\n\n\t1. 慢速的输入输出由主机完成，此时CPU处于空闲状态。（解决：采用卫星机完成面向用户的输入输出，中间结果暂在磁带或者磁盘上）\n\n分类：\n\n\t1. 单道批处理：一次处理一个作业，处理结束后再选择下一个\n\t2. 多道批处理：一次选择多个作业处理\n\n实现技术\n\n\t1. SPOOLING系统：全称（Simultaneous Peripheral Operation One-Line），同事的外围设备联机操作，又称假脱机技术。\n\n### 分时系统\n\n工作方式：\n\n\t1. 一台主机连接多个终端\n\t2. 终端输入命令，主机处理命令并把结果发送到终端上\n\n目标：\n\n\t1. 同时为多个用户提供服务\n\t2. 提高响应速度\n\n实现技术：\n\n\t1. 时间片：把CPU的时间划分成若干个片段，轮流为终端用户服务\n\n### 实时操作系统\n\n目标\n\n\t1. 计算机能够及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理并控制所有实时设备和任务协调一致运行\n\t2. 高可靠性\n\n分类：\n\n\t1. 第一类，实时过程控制：工业控制、航空、军事控制\n\t2. 第二类：实时通信处理：银行、订票系统、股市系统\n\t3. 硬实时系统：动作决定要在规定时间内完成\n\t4. 软实时系统：接受偶尔违反最终时限\n\n\n\n### 个人计算机操作系统\n\n目标：\n\n\t1. 界面友好，使用方便\n\t2. 丰富的应用软件\n\t3. 某一时间为单用户服务\n\n\n### 网络操作系统\n\n目标：\n\n\t1. 相互通信，资源共享\n\t2. 按照网络体系结构协议标准开发，完成网络管理、通信、安全\n\n\n### 分布式操作系统\n\n目标\n\n\t1. 以计算机网络或多处理机为基础，允许若干个计算机相互协作共同完成一项任务\n\n### 嵌入式操作系统\n\n目标\n\n\t1. 以各种硬件设备为参照，完成特定功能\n\t2. 对管理的资源进行统一的协调、调度、指挥和控制。\n\n","slug":"操作系统/操作系统概述","published":1,"updated":"2018-06-13T14:21:19.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x4c002pgsvnnwzkoa1t","content":"<h2 id=\"操作系统的定义与作用\"><a href=\"#操作系统的定义与作用\" class=\"headerlink\" title=\"操作系统的定义与作用\"></a>操作系统的定义与作用</h2><p>操作系统是计算机中一个系统软件，操作系统尽量以<strong>有效合理</strong>的方式组织管理计算机硬件与软件资源，并合理地组织调度计算机的工作和资源的分配。使得用户能够灵活、方便地使用计算机，使计算机高效率运行。</p>\n<p>从操作系统作为资源管理者的角度，操作系统用来管理一个复杂系统的各个部分，包括硬件资源如CPU、内存、I/O设备、磁盘、时钟、网络卡等，软件资源如磁盘文件等。资源管理包括实现资源的多路复用（时间上复用、空间上复用）。</p>\n<p>操作系统在管理资源时，需要解决以下问题：</p>\n<ul>\n<li>资源使用状况记录</li>\n<li>资源分配策略</li>\n<li>资源分配与回收</li>\n<li>提高资源利用率</li>\n<li>保护资源的使用</li>\n<li>协调多个进程对资源请求的冲突</li>\n</ul>\n<p>从资源的管理角度，操作系统主要需要实现以下功能：</p>\n<ul>\n<li>进程/线程管理：进程线程状态、控制、同步互斥、通信、调度</li>\n<li>存储管理：内存分配回收、地址转换、存储保护、内存扩充</li>\n<li>文件管理：文件目录、文件操作、磁盘空间、文件存取控制</li>\n<li>设备管理：设备驱动、分配回收、缓冲技术</li>\n<li>用户接口：系统命令、编程接口</li>\n</ul>\n<p>操作系统的三个作用：</p>\n<ul>\n<li>资源的管理者：有效管理资源</li>\n<li>向用户提供服务：方便用户使用</li>\n<li>对硬件机器的扩展：屏蔽硬件细节</li>\n</ul>\n<h2 id=\"操作系统的特征\"><a href=\"#操作系统的特征\" class=\"headerlink\" title=\"操作系统的特征\"></a>操作系统的特征</h2><p>操作系统是一种系统软件，系统软件和哟应用软件存在很大的不同，其主要有如下四大基本特征：</p>\n<h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3><p>指具有在同一时间间隔内具有处理多个事件或者活动的能力，并发是一个宏观上的概念，在微观中，任何时刻只有一个程序正在执行。并发与并行不同的是，并行是指不同程序同时在多个CPU上执行，并发是一种伪并行。</p>\n<h3 id=\"共享\"><a href=\"#共享\" class=\"headerlink\" title=\"共享\"></a>共享</h3><p>操作系统与多个程序共同使用计算机有限的的资源，同时操作系统需要实现合理的分配使得资源可被不同的进程轮流使用。共享可分为两种：互斥共享和同时共享，互斥共享指资源使用是独占排他的，而同时共享则是进程可以同时使用，比如可重入代码、只读数据等。</p>\n<h3 id=\"虚拟\"><a href=\"#虚拟\" class=\"headerlink\" title=\"虚拟\"></a>虚拟</h3><p>虚拟是指操作系统通过分时复用或分空间复用将一个物理实体映射为多个对应的逻辑实体，虚拟是操作系统管理资源的重要手段，可提高资源利用率。</p>\n<h3 id=\"随机（异步）\"><a href=\"#随机（异步）\" class=\"headerlink\" title=\"随机（异步）\"></a>随机（异步）</h3><p>由于多个进程之间的竞争制约关系，每个进程的运行速度是不预知的，而且系统某时刻的状态难以重现，因此操作系统必须能够应对随机事件。</p>\n<h2 id=\"操作系统分类\"><a href=\"#操作系统分类\" class=\"headerlink\" title=\"操作系统分类\"></a>操作系统分类</h2><h3 id=\"批处理操作系统\"><a href=\"#批处理操作系统\" class=\"headerlink\" title=\"批处理操作系统\"></a>批处理操作系统</h3><p>工作方式：</p>\n<pre><code>1. 用户将作业交给系统操作员\n2. 系统操作员将用户作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续的作业流\n3. 启动操作系统\n4. 系统自动、依次执行每个作业\n5. 由操作员将作业结果交给用户\n</code></pre><p>目标：</p>\n<pre><code>1. 提高资源利用率，增加作业处理吞吐量\n</code></pre><p>存在的问题：</p>\n<pre><code>1. 慢速的输入输出由主机完成，此时CPU处于空闲状态。（解决：采用卫星机完成面向用户的输入输出，中间结果暂在磁带或者磁盘上）\n</code></pre><p>分类：</p>\n<pre><code>1. 单道批处理：一次处理一个作业，处理结束后再选择下一个\n2. 多道批处理：一次选择多个作业处理\n</code></pre><p>实现技术</p>\n<pre><code>1. SPOOLING系统：全称（Simultaneous Peripheral Operation One-Line），同事的外围设备联机操作，又称假脱机技术。\n</code></pre><h3 id=\"分时系统\"><a href=\"#分时系统\" class=\"headerlink\" title=\"分时系统\"></a>分时系统</h3><p>工作方式：</p>\n<pre><code>1. 一台主机连接多个终端\n2. 终端输入命令，主机处理命令并把结果发送到终端上\n</code></pre><p>目标：</p>\n<pre><code>1. 同时为多个用户提供服务\n2. 提高响应速度\n</code></pre><p>实现技术：</p>\n<pre><code>1. 时间片：把CPU的时间划分成若干个片段，轮流为终端用户服务\n</code></pre><h3 id=\"实时操作系统\"><a href=\"#实时操作系统\" class=\"headerlink\" title=\"实时操作系统\"></a>实时操作系统</h3><p>目标</p>\n<pre><code>1. 计算机能够及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理并控制所有实时设备和任务协调一致运行\n2. 高可靠性\n</code></pre><p>分类：</p>\n<pre><code>1. 第一类，实时过程控制：工业控制、航空、军事控制\n2. 第二类：实时通信处理：银行、订票系统、股市系统\n3. 硬实时系统：动作决定要在规定时间内完成\n4. 软实时系统：接受偶尔违反最终时限\n</code></pre><h3 id=\"个人计算机操作系统\"><a href=\"#个人计算机操作系统\" class=\"headerlink\" title=\"个人计算机操作系统\"></a>个人计算机操作系统</h3><p>目标：</p>\n<pre><code>1. 界面友好，使用方便\n2. 丰富的应用软件\n3. 某一时间为单用户服务\n</code></pre><h3 id=\"网络操作系统\"><a href=\"#网络操作系统\" class=\"headerlink\" title=\"网络操作系统\"></a>网络操作系统</h3><p>目标：</p>\n<pre><code>1. 相互通信，资源共享\n2. 按照网络体系结构协议标准开发，完成网络管理、通信、安全\n</code></pre><h3 id=\"分布式操作系统\"><a href=\"#分布式操作系统\" class=\"headerlink\" title=\"分布式操作系统\"></a>分布式操作系统</h3><p>目标</p>\n<pre><code>1. 以计算机网络或多处理机为基础，允许若干个计算机相互协作共同完成一项任务\n</code></pre><h3 id=\"嵌入式操作系统\"><a href=\"#嵌入式操作系统\" class=\"headerlink\" title=\"嵌入式操作系统\"></a>嵌入式操作系统</h3><p>目标</p>\n<pre><code>1. 以各种硬件设备为参照，完成特定功能\n2. 对管理的资源进行统一的协调、调度、指挥和控制。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"操作系统的定义与作用\"><a href=\"#操作系统的定义与作用\" class=\"headerlink\" title=\"操作系统的定义与作用\"></a>操作系统的定义与作用</h2><p>操作系统是计算机中一个系统软件，操作系统尽量以<strong>有效合理</strong>的方式组织管理计算机硬件与软件资源，并合理地组织调度计算机的工作和资源的分配。使得用户能够灵活、方便地使用计算机，使计算机高效率运行。</p>\n<p>从操作系统作为资源管理者的角度，操作系统用来管理一个复杂系统的各个部分，包括硬件资源如CPU、内存、I/O设备、磁盘、时钟、网络卡等，软件资源如磁盘文件等。资源管理包括实现资源的多路复用（时间上复用、空间上复用）。</p>\n<p>操作系统在管理资源时，需要解决以下问题：</p>\n<ul>\n<li>资源使用状况记录</li>\n<li>资源分配策略</li>\n<li>资源分配与回收</li>\n<li>提高资源利用率</li>\n<li>保护资源的使用</li>\n<li>协调多个进程对资源请求的冲突</li>\n</ul>\n<p>从资源的管理角度，操作系统主要需要实现以下功能：</p>\n<ul>\n<li>进程/线程管理：进程线程状态、控制、同步互斥、通信、调度</li>\n<li>存储管理：内存分配回收、地址转换、存储保护、内存扩充</li>\n<li>文件管理：文件目录、文件操作、磁盘空间、文件存取控制</li>\n<li>设备管理：设备驱动、分配回收、缓冲技术</li>\n<li>用户接口：系统命令、编程接口</li>\n</ul>\n<p>操作系统的三个作用：</p>\n<ul>\n<li>资源的管理者：有效管理资源</li>\n<li>向用户提供服务：方便用户使用</li>\n<li>对硬件机器的扩展：屏蔽硬件细节</li>\n</ul>\n<h2 id=\"操作系统的特征\"><a href=\"#操作系统的特征\" class=\"headerlink\" title=\"操作系统的特征\"></a>操作系统的特征</h2><p>操作系统是一种系统软件，系统软件和哟应用软件存在很大的不同，其主要有如下四大基本特征：</p>\n<h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3><p>指具有在同一时间间隔内具有处理多个事件或者活动的能力，并发是一个宏观上的概念，在微观中，任何时刻只有一个程序正在执行。并发与并行不同的是，并行是指不同程序同时在多个CPU上执行，并发是一种伪并行。</p>\n<h3 id=\"共享\"><a href=\"#共享\" class=\"headerlink\" title=\"共享\"></a>共享</h3><p>操作系统与多个程序共同使用计算机有限的的资源，同时操作系统需要实现合理的分配使得资源可被不同的进程轮流使用。共享可分为两种：互斥共享和同时共享，互斥共享指资源使用是独占排他的，而同时共享则是进程可以同时使用，比如可重入代码、只读数据等。</p>\n<h3 id=\"虚拟\"><a href=\"#虚拟\" class=\"headerlink\" title=\"虚拟\"></a>虚拟</h3><p>虚拟是指操作系统通过分时复用或分空间复用将一个物理实体映射为多个对应的逻辑实体，虚拟是操作系统管理资源的重要手段，可提高资源利用率。</p>\n<h3 id=\"随机（异步）\"><a href=\"#随机（异步）\" class=\"headerlink\" title=\"随机（异步）\"></a>随机（异步）</h3><p>由于多个进程之间的竞争制约关系，每个进程的运行速度是不预知的，而且系统某时刻的状态难以重现，因此操作系统必须能够应对随机事件。</p>\n<h2 id=\"操作系统分类\"><a href=\"#操作系统分类\" class=\"headerlink\" title=\"操作系统分类\"></a>操作系统分类</h2><h3 id=\"批处理操作系统\"><a href=\"#批处理操作系统\" class=\"headerlink\" title=\"批处理操作系统\"></a>批处理操作系统</h3><p>工作方式：</p>\n<pre><code>1. 用户将作业交给系统操作员\n2. 系统操作员将用户作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续的作业流\n3. 启动操作系统\n4. 系统自动、依次执行每个作业\n5. 由操作员将作业结果交给用户\n</code></pre><p>目标：</p>\n<pre><code>1. 提高资源利用率，增加作业处理吞吐量\n</code></pre><p>存在的问题：</p>\n<pre><code>1. 慢速的输入输出由主机完成，此时CPU处于空闲状态。（解决：采用卫星机完成面向用户的输入输出，中间结果暂在磁带或者磁盘上）\n</code></pre><p>分类：</p>\n<pre><code>1. 单道批处理：一次处理一个作业，处理结束后再选择下一个\n2. 多道批处理：一次选择多个作业处理\n</code></pre><p>实现技术</p>\n<pre><code>1. SPOOLING系统：全称（Simultaneous Peripheral Operation One-Line），同事的外围设备联机操作，又称假脱机技术。\n</code></pre><h3 id=\"分时系统\"><a href=\"#分时系统\" class=\"headerlink\" title=\"分时系统\"></a>分时系统</h3><p>工作方式：</p>\n<pre><code>1. 一台主机连接多个终端\n2. 终端输入命令，主机处理命令并把结果发送到终端上\n</code></pre><p>目标：</p>\n<pre><code>1. 同时为多个用户提供服务\n2. 提高响应速度\n</code></pre><p>实现技术：</p>\n<pre><code>1. 时间片：把CPU的时间划分成若干个片段，轮流为终端用户服务\n</code></pre><h3 id=\"实时操作系统\"><a href=\"#实时操作系统\" class=\"headerlink\" title=\"实时操作系统\"></a>实时操作系统</h3><p>目标</p>\n<pre><code>1. 计算机能够及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理并控制所有实时设备和任务协调一致运行\n2. 高可靠性\n</code></pre><p>分类：</p>\n<pre><code>1. 第一类，实时过程控制：工业控制、航空、军事控制\n2. 第二类：实时通信处理：银行、订票系统、股市系统\n3. 硬实时系统：动作决定要在规定时间内完成\n4. 软实时系统：接受偶尔违反最终时限\n</code></pre><h3 id=\"个人计算机操作系统\"><a href=\"#个人计算机操作系统\" class=\"headerlink\" title=\"个人计算机操作系统\"></a>个人计算机操作系统</h3><p>目标：</p>\n<pre><code>1. 界面友好，使用方便\n2. 丰富的应用软件\n3. 某一时间为单用户服务\n</code></pre><h3 id=\"网络操作系统\"><a href=\"#网络操作系统\" class=\"headerlink\" title=\"网络操作系统\"></a>网络操作系统</h3><p>目标：</p>\n<pre><code>1. 相互通信，资源共享\n2. 按照网络体系结构协议标准开发，完成网络管理、通信、安全\n</code></pre><h3 id=\"分布式操作系统\"><a href=\"#分布式操作系统\" class=\"headerlink\" title=\"分布式操作系统\"></a>分布式操作系统</h3><p>目标</p>\n<pre><code>1. 以计算机网络或多处理机为基础，允许若干个计算机相互协作共同完成一项任务\n</code></pre><h3 id=\"嵌入式操作系统\"><a href=\"#嵌入式操作系统\" class=\"headerlink\" title=\"嵌入式操作系统\"></a>嵌入式操作系统</h3><p>目标</p>\n<pre><code>1. 以各种硬件设备为参照，完成特定功能\n2. 对管理的资源进行统一的协调、调度、指挥和控制。\n</code></pre>"},{"title":"磁盘调度策略介绍与实现","urlname":"disk-scheduling","date":"2018-04-06T06:57:04.000Z","copyright":true,"mathjax":true,"_content":"\n## 磁盘调度基础\n\n磁盘是一种大容量低成本的存储设备，其支持随机存取。机械硬盘的物理结构如下所示：[图片来源](https://blog.csdn.net/idber/article/details/8087473)\n\n![磁盘物理结构](/images/disk-physical-structure.png)\n\n如图所示，磁盘由多个盘片和读写磁头臂组成。盘面被分为多个同心圆，称为磁道；每个磁道又被划分为多个独立的逻辑区域，被称为扇区，扇区容量一般是512byte，有些较大为4Kbyte。每个磁道上扇区的数量可能相同也可能不相同，由于外圈长度比较大，为了提高密度可以划分更多的扇区。\n\n磁盘在设计时根据磁头是否在磁道之间移动可大致分为以下两种：\n\n\t1. 固定头磁盘，每条磁道都有读写磁头，磁头被安装在刚性磁臂上，可并行读写磁道\n\t2. 移动头磁盘，每个盘面只有一个磁头，磁头需要能在不同磁道之间移动，读写速度较慢\n\n磁盘调度主要是针对移动头磁盘的读写时间优化。\n\n## 磁盘访问时间\n\n磁盘在读写的时候主要经历如下过程：启动磁臂->移动磁头到指定磁道->扇区移动到磁头下方->读取数据。因此磁盘访问时间主要如下几部分组成：\n\n\t1. 寻道时间Ts，Ts=m*n\"+s，s为启动磁臂时间，n为跨越磁道数，m为一常数，和具体磁盘有关\n\t2. 旋转延迟时间Tr，指扇区移动到磁头下花费的时间\n\t3. 传输时间Tt，为数据读写所花费的时间，如果每次读写字节数为b，旋转速度为r，磁道字节数为N，则Tt=b/(rN)\n\n从上述可得出整个读写期间共花费Ta=Ts+Tr+Tt，其中前两项一般与读取的数据量无关，且是整个时间中的大头。\n\n## 磁盘调度策略\n\n由于读写总花费时间中寻道时间和旋转延迟占比比较大，因此从这两方面出发优化读写效率。对于旋转延迟一般和磁盘转速有关，因此主要提高转速。寻道时间则主要从寻道策略中优化，因此主要形成如下几种磁盘调度策略：\n\n\t1. 先来先服务（FCFS，First Come First Served）\n\t2. 最短寻道时间优先（SSTF，Shortest Seek Time First）\n\t3. 扫描算法（SCAN）\n\t4. 循环扫描算法（CSCAN）\n\t5. NStepSCAN以及FSCAN算法\n\n一下分别详细介绍各种调度算法。\n\n### 先来先服务\n\n先来先服务是一种非常简单的算法，其按照请求的顺序依次处理，其优点是简单公平，但是由于没有对寻道时间进行任何优化，因此致使平均寻道时间比较大。这些特点使得FCFS算法不太适用于需要进行频繁读写的场合。其基本实现模拟代码如下所示。\n\n```cpp\nint FCFS(vector<int> &serveArray, int startPosition)\n{\n\tif (serveArray.size() <=0) return 0;\n\tint nowPosition = startPosition;\n\tint sum = 0;\n\tfor (size_t i = 0; i < serveArray.size(); i++) {\n\t\tint tmp = serveArray[i] - nowPosition;\n\t\tsum += tmp > 0 ?  tmp :-tmp;\n\t\tnowPosition = serveArray[i];\n\t}\n\treturn sum;\n}\n```\n\n### 最短寻道时间优先\n\n最短寻道时间优先是指在请求队列中优先满足离当前位置最近的磁道，使得每次寻道时间最短，即简单的贪心思想，但是这样并不能保证平均寻道时间最短。最短寻道时间优先策略一般优于先来先服务策略，但是可能发生饥饿现象，这是由于每次都选择离当前位置最近的磁道，对于离的比较的远的请求可能一直得不到服务。最短寻道时间优先模拟代码如下所示。\n\n```cpp\nint SSTF(vector<int> &serveArray, int startPosition)\n{\n\tif (serveArray.size() <= 0) return 0;\n\tint leftIndex = 0, rightIndex = 0;\n\tsort(serveArray.begin(), serveArray.end());\n\tfor (leftIndex = 0; leftIndex < int(serveArray.size()) && startPosition > serveArray[leftIndex]; leftIndex++) ;\n\trightIndex = leftIndex; --leftIndex;\n\n\tint sum = 0; int nowPosition = startPosition;\n\twhile (leftIndex >= 0 || rightIndex < int(serveArray.size())) {\n\t\tif (leftIndex >= 0 && rightIndex < int(serveArray.size())) {\n\t\t\tif (abs(serveArray[leftIndex]-nowPosition) < abs(serveArray[rightIndex]-nowPosition)) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex];\n\t\t\t\t--leftIndex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex];\n\t\t\t\t++rightIndex;\n\t\t\t}\n\t\t}\n\t\telse if (leftIndex >= 0) {\n\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[leftIndex];\n\t\t\t--leftIndex;\n\t\t}\n\t\telse if (rightIndex < int(serveArray.size())) {\n\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[rightIndex];\n\t\t\t++rightIndex;\n\t\t}\n\t}\n\treturn sum;\n}\n```\n\n### 扫描算法\n\n扫描算法又称为电梯调度算法，其考虑请求磁道与当前磁道的距离和磁头当前移动的方向，在某一方向上一直访问下去直到没有更远的请求磁道，接着才调转方向。这个过程非常类似于电梯运行方式。由于磁头会一直向一个方向移动直到无更远访问请求，因此扫描算法不会发生饥饿现象，但是可能发生磁臂粘滞现象。以下是基本的模拟代码。\n\n```cpp\nint SACN(vector<int> &serveArray, int startPosition)\n{\n\tif (serveArray.size() <= 0) return 0;\n\tint leftIndex = 0, rightIndex = 0;\n\tsort(serveArray.begin(), serveArray.end());\n\tfor (leftIndex = 0; leftIndex < int(serveArray.size()) && startPosition > serveArray[leftIndex]; leftIndex++) ;\n\trightIndex = leftIndex; --leftIndex;\n\n\tint sum = 0; int nowPosition = startPosition;\n\tif (leftIndex >= 0 && rightIndex < int(serveArray.size())) {\n\t\tif (abs(serveArray[leftIndex]-nowPosition) < abs(serveArray[rightIndex]-nowPosition)) {\n\t\t\twhile (leftIndex >= 0) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t\t}\n\n\t\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\telse {\n\t\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t\t}\n\n\t\t\twhile (leftIndex >= 0) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t\t}\n\t\t}\n\t}\n\telse if (leftIndex >= 0) {\n\t\twhile (leftIndex >= 0) {\n\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t}\n\t}\n\telse if (rightIndex < int(serveArray.size())) {\n\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t}\n\treturn sum;\n}\n```\n\n### 循环扫描算法\n\n循环扫描算法和扫描算法最大的区别是规定磁头采用单向移动的模式，比如规定从里向外移动。这种方式可以减少对刚越过磁道发生请求的响应时间。以下是基本的模拟代码，假定采用磁道号增加的方向的扫描方式。\n\n```cpp\nint CSACN(vector<int> &serveArray, int startPosition)\n{\n\tif (serveArray.size() <= 0) return 0;\n\tint leftIndex = 0, rightIndex = 0;\n\tsort(serveArray.begin(), serveArray.end());\n\tfor (leftIndex = 0; leftIndex < int(serveArray.size()) && startPosition > serveArray[leftIndex]; leftIndex++) ;\n\trightIndex = leftIndex; --leftIndex;\n\n\tint sum = 0; int nowPosition = startPosition;\n\tif (rightIndex < int(serveArray.size())) {\n\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t}\n\t\tint i = 0;\n\t\twhile (i <= leftIndex) {\n\t\t\tsum += abs(serveArray[i]-nowPosition);\n\t\t\tnowPosition = serveArray[i]; ++i;\n\t\t}\n\t}\n\telse {\n\t\tint i = 0;\n\t\twhile (i <= leftIndex) {\n\t\t\tsum += abs(serveArray[i]-nowPosition);\n\t\t\tnowPosition = serveArray[i]; ++i;\n\t\t}\n\t}\n\treturn sum;\n}\n```\n\n### NStepSCAN与FSCAN算法\n\n在SSTF、SCAN、CSCAN几种调度算法中，可能会由于频繁发生请求在当前磁道或附近致使磁头一直停留在附近或当前磁道中，导致对于某个磁道的请求垄断了整个磁盘设备，该现象称为磁盘粘滞，一般发生在高密度磁盘上。而NStepSCAN则将请求分成若干个长度为N的子队列，队列之间按照先来先服务的顺序，每个队列内按照SCAN算法处理，新请求插入其他队列（非当前处理队列）。如果N=1则退化成FCFS算法。\n\nFSCAN算法和NStepSCAN区别主要是FSCAN算法只将请求分为两个队列，一个是当前处理队列以及在处理过程中新的请求队列。\n\n两种算法的处理模拟代码如下：\n\n```cpp\nint SACN(vector<int> &serveArray, int &nowPosition)\n{\n\tif (serveArray.size() <= 0) return 0;\n\tint leftIndex = 0, rightIndex = 0;\n\tsort(serveArray.begin(), serveArray.end());\n\tfor (leftIndex = 0; leftIndex < int(serveArray.size()) && nowPosition > serveArray[leftIndex]; leftIndex++) ;\n\trightIndex = leftIndex; --leftIndex;\n\n\tint sum = 0;\n\tif (leftIndex >= 0 && rightIndex < int(serveArray.size())) {\n\t\tif (abs(serveArray[leftIndex]-nowPosition) < abs(serveArray[rightIndex]-nowPosition)) {\n\t\t\twhile (leftIndex >= 0) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t\t}\n\n\t\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\telse {\n\t\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t\t}\n\n\t\t\twhile (leftIndex >= 0) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t\t}\n\t\t}\n\t}\n\telse if (leftIndex >= 0) {\n\t\twhile (leftIndex >= 0) {\n\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t}\n\t}\n\telse if (rightIndex < int(serveArray.size())) {\n\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t}\n\treturn sum;\n}\n\nint NStepSCAN(vector<vector<int>> &serveArrays, int startPosition)\n{\n\tint sum = 0;\n\tif (serveArrays.size() <= 0) return sum;\n\t\n\tfor(size_t i = 0; i < serveArrays.size(); i++) {\n\t\tsum += SACN(serveArrays[i], startPosition);\n\t}\n\treturn sum;\n}\n\nint FSCAN(vector<int> &serveArray, vector<int> &newArray, int startPosition)\n{\n\tint sum = 0;\n\tsum += SACN(serveArray, startPosition);\n\tsum += SACN(newArray, startPosition);\n\treturn sum;\n}\n```\n\n## 磁盘调度总结\n\nFCFS算法、SSTF算法、SCAN算法、CSCAN算法、NStepSCAN算法、FSCAN算法各有其优缺点，总结如下：\n\n- FCFS算法\n\n\t1. 优点：算法实现简单，公平\n\t2. 缺点：效率不高，相邻请求不能快速处理，磁头反复移动\n\n- SSTF算法\n\n\t1. 优点：采取贪心策略，优化平均寻道时间\n\t2. 缺点：可能导致饥饿现象\n\n- SCAN算法\n\n\t1. 优点：可以防止饥饿现象同时考虑到优化寻道时间\n\t2. 缺点：可能发生磁臂粘滞现象，某些请求可能会被严重推迟\n\n- CSCAN算法\n\n\t1. 优点：解决SCAN算法某些请求可能会被严重推迟的问题\n\t2. 缺点：由于单向移动，对于请求较少可能会出现返回时间的浪费\n\n\n- NStepSCAN算法\n\n\t1. 优点：避免磁臂粘滞的情况同时继承SCAN的优点\n\t2. 缺点：编程稍微复杂\n\n- FSCAN算法\n\n\t1. 优点：简化处理，实现较NStepSCAN算法更为简单\n\t2. 缺点：两个队列可能会稍增加平均寻道时间","source":"_posts/操作系统/磁盘调度策略介绍与实现.md","raw":"---\ntitle: 磁盘调度策略介绍与实现\nurlname: disk-scheduling\ndate: 2018-04-6 14:57:04\ncopyright: true\nmathjax: true\ntags:\n- 操作系统\ncategories:\n- 操作系统\n---\n\n## 磁盘调度基础\n\n磁盘是一种大容量低成本的存储设备，其支持随机存取。机械硬盘的物理结构如下所示：[图片来源](https://blog.csdn.net/idber/article/details/8087473)\n\n![磁盘物理结构](/images/disk-physical-structure.png)\n\n如图所示，磁盘由多个盘片和读写磁头臂组成。盘面被分为多个同心圆，称为磁道；每个磁道又被划分为多个独立的逻辑区域，被称为扇区，扇区容量一般是512byte，有些较大为4Kbyte。每个磁道上扇区的数量可能相同也可能不相同，由于外圈长度比较大，为了提高密度可以划分更多的扇区。\n\n磁盘在设计时根据磁头是否在磁道之间移动可大致分为以下两种：\n\n\t1. 固定头磁盘，每条磁道都有读写磁头，磁头被安装在刚性磁臂上，可并行读写磁道\n\t2. 移动头磁盘，每个盘面只有一个磁头，磁头需要能在不同磁道之间移动，读写速度较慢\n\n磁盘调度主要是针对移动头磁盘的读写时间优化。\n\n## 磁盘访问时间\n\n磁盘在读写的时候主要经历如下过程：启动磁臂->移动磁头到指定磁道->扇区移动到磁头下方->读取数据。因此磁盘访问时间主要如下几部分组成：\n\n\t1. 寻道时间Ts，Ts=m*n\"+s，s为启动磁臂时间，n为跨越磁道数，m为一常数，和具体磁盘有关\n\t2. 旋转延迟时间Tr，指扇区移动到磁头下花费的时间\n\t3. 传输时间Tt，为数据读写所花费的时间，如果每次读写字节数为b，旋转速度为r，磁道字节数为N，则Tt=b/(rN)\n\n从上述可得出整个读写期间共花费Ta=Ts+Tr+Tt，其中前两项一般与读取的数据量无关，且是整个时间中的大头。\n\n## 磁盘调度策略\n\n由于读写总花费时间中寻道时间和旋转延迟占比比较大，因此从这两方面出发优化读写效率。对于旋转延迟一般和磁盘转速有关，因此主要提高转速。寻道时间则主要从寻道策略中优化，因此主要形成如下几种磁盘调度策略：\n\n\t1. 先来先服务（FCFS，First Come First Served）\n\t2. 最短寻道时间优先（SSTF，Shortest Seek Time First）\n\t3. 扫描算法（SCAN）\n\t4. 循环扫描算法（CSCAN）\n\t5. NStepSCAN以及FSCAN算法\n\n一下分别详细介绍各种调度算法。\n\n### 先来先服务\n\n先来先服务是一种非常简单的算法，其按照请求的顺序依次处理，其优点是简单公平，但是由于没有对寻道时间进行任何优化，因此致使平均寻道时间比较大。这些特点使得FCFS算法不太适用于需要进行频繁读写的场合。其基本实现模拟代码如下所示。\n\n```cpp\nint FCFS(vector<int> &serveArray, int startPosition)\n{\n\tif (serveArray.size() <=0) return 0;\n\tint nowPosition = startPosition;\n\tint sum = 0;\n\tfor (size_t i = 0; i < serveArray.size(); i++) {\n\t\tint tmp = serveArray[i] - nowPosition;\n\t\tsum += tmp > 0 ?  tmp :-tmp;\n\t\tnowPosition = serveArray[i];\n\t}\n\treturn sum;\n}\n```\n\n### 最短寻道时间优先\n\n最短寻道时间优先是指在请求队列中优先满足离当前位置最近的磁道，使得每次寻道时间最短，即简单的贪心思想，但是这样并不能保证平均寻道时间最短。最短寻道时间优先策略一般优于先来先服务策略，但是可能发生饥饿现象，这是由于每次都选择离当前位置最近的磁道，对于离的比较的远的请求可能一直得不到服务。最短寻道时间优先模拟代码如下所示。\n\n```cpp\nint SSTF(vector<int> &serveArray, int startPosition)\n{\n\tif (serveArray.size() <= 0) return 0;\n\tint leftIndex = 0, rightIndex = 0;\n\tsort(serveArray.begin(), serveArray.end());\n\tfor (leftIndex = 0; leftIndex < int(serveArray.size()) && startPosition > serveArray[leftIndex]; leftIndex++) ;\n\trightIndex = leftIndex; --leftIndex;\n\n\tint sum = 0; int nowPosition = startPosition;\n\twhile (leftIndex >= 0 || rightIndex < int(serveArray.size())) {\n\t\tif (leftIndex >= 0 && rightIndex < int(serveArray.size())) {\n\t\t\tif (abs(serveArray[leftIndex]-nowPosition) < abs(serveArray[rightIndex]-nowPosition)) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex];\n\t\t\t\t--leftIndex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex];\n\t\t\t\t++rightIndex;\n\t\t\t}\n\t\t}\n\t\telse if (leftIndex >= 0) {\n\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[leftIndex];\n\t\t\t--leftIndex;\n\t\t}\n\t\telse if (rightIndex < int(serveArray.size())) {\n\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[rightIndex];\n\t\t\t++rightIndex;\n\t\t}\n\t}\n\treturn sum;\n}\n```\n\n### 扫描算法\n\n扫描算法又称为电梯调度算法，其考虑请求磁道与当前磁道的距离和磁头当前移动的方向，在某一方向上一直访问下去直到没有更远的请求磁道，接着才调转方向。这个过程非常类似于电梯运行方式。由于磁头会一直向一个方向移动直到无更远访问请求，因此扫描算法不会发生饥饿现象，但是可能发生磁臂粘滞现象。以下是基本的模拟代码。\n\n```cpp\nint SACN(vector<int> &serveArray, int startPosition)\n{\n\tif (serveArray.size() <= 0) return 0;\n\tint leftIndex = 0, rightIndex = 0;\n\tsort(serveArray.begin(), serveArray.end());\n\tfor (leftIndex = 0; leftIndex < int(serveArray.size()) && startPosition > serveArray[leftIndex]; leftIndex++) ;\n\trightIndex = leftIndex; --leftIndex;\n\n\tint sum = 0; int nowPosition = startPosition;\n\tif (leftIndex >= 0 && rightIndex < int(serveArray.size())) {\n\t\tif (abs(serveArray[leftIndex]-nowPosition) < abs(serveArray[rightIndex]-nowPosition)) {\n\t\t\twhile (leftIndex >= 0) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t\t}\n\n\t\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\telse {\n\t\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t\t}\n\n\t\t\twhile (leftIndex >= 0) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t\t}\n\t\t}\n\t}\n\telse if (leftIndex >= 0) {\n\t\twhile (leftIndex >= 0) {\n\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t}\n\t}\n\telse if (rightIndex < int(serveArray.size())) {\n\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t}\n\treturn sum;\n}\n```\n\n### 循环扫描算法\n\n循环扫描算法和扫描算法最大的区别是规定磁头采用单向移动的模式，比如规定从里向外移动。这种方式可以减少对刚越过磁道发生请求的响应时间。以下是基本的模拟代码，假定采用磁道号增加的方向的扫描方式。\n\n```cpp\nint CSACN(vector<int> &serveArray, int startPosition)\n{\n\tif (serveArray.size() <= 0) return 0;\n\tint leftIndex = 0, rightIndex = 0;\n\tsort(serveArray.begin(), serveArray.end());\n\tfor (leftIndex = 0; leftIndex < int(serveArray.size()) && startPosition > serveArray[leftIndex]; leftIndex++) ;\n\trightIndex = leftIndex; --leftIndex;\n\n\tint sum = 0; int nowPosition = startPosition;\n\tif (rightIndex < int(serveArray.size())) {\n\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t}\n\t\tint i = 0;\n\t\twhile (i <= leftIndex) {\n\t\t\tsum += abs(serveArray[i]-nowPosition);\n\t\t\tnowPosition = serveArray[i]; ++i;\n\t\t}\n\t}\n\telse {\n\t\tint i = 0;\n\t\twhile (i <= leftIndex) {\n\t\t\tsum += abs(serveArray[i]-nowPosition);\n\t\t\tnowPosition = serveArray[i]; ++i;\n\t\t}\n\t}\n\treturn sum;\n}\n```\n\n### NStepSCAN与FSCAN算法\n\n在SSTF、SCAN、CSCAN几种调度算法中，可能会由于频繁发生请求在当前磁道或附近致使磁头一直停留在附近或当前磁道中，导致对于某个磁道的请求垄断了整个磁盘设备，该现象称为磁盘粘滞，一般发生在高密度磁盘上。而NStepSCAN则将请求分成若干个长度为N的子队列，队列之间按照先来先服务的顺序，每个队列内按照SCAN算法处理，新请求插入其他队列（非当前处理队列）。如果N=1则退化成FCFS算法。\n\nFSCAN算法和NStepSCAN区别主要是FSCAN算法只将请求分为两个队列，一个是当前处理队列以及在处理过程中新的请求队列。\n\n两种算法的处理模拟代码如下：\n\n```cpp\nint SACN(vector<int> &serveArray, int &nowPosition)\n{\n\tif (serveArray.size() <= 0) return 0;\n\tint leftIndex = 0, rightIndex = 0;\n\tsort(serveArray.begin(), serveArray.end());\n\tfor (leftIndex = 0; leftIndex < int(serveArray.size()) && nowPosition > serveArray[leftIndex]; leftIndex++) ;\n\trightIndex = leftIndex; --leftIndex;\n\n\tint sum = 0;\n\tif (leftIndex >= 0 && rightIndex < int(serveArray.size())) {\n\t\tif (abs(serveArray[leftIndex]-nowPosition) < abs(serveArray[rightIndex]-nowPosition)) {\n\t\t\twhile (leftIndex >= 0) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t\t}\n\n\t\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\telse {\n\t\t\twhile (rightIndex < int(serveArray.size())) {\n\t\t\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t\t\t}\n\n\t\t\twhile (leftIndex >= 0) {\n\t\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t\t}\n\t\t}\n\t}\n\telse if (leftIndex >= 0) {\n\t\twhile (leftIndex >= 0) {\n\t\t\tsum += abs(serveArray[leftIndex]-nowPosition); \n\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;\n\t\t}\n\t}\n\telse if (rightIndex < int(serveArray.size())) {\n\t\tsum += abs(serveArray[rightIndex]-nowPosition); \n\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;\n\t}\n\treturn sum;\n}\n\nint NStepSCAN(vector<vector<int>> &serveArrays, int startPosition)\n{\n\tint sum = 0;\n\tif (serveArrays.size() <= 0) return sum;\n\t\n\tfor(size_t i = 0; i < serveArrays.size(); i++) {\n\t\tsum += SACN(serveArrays[i], startPosition);\n\t}\n\treturn sum;\n}\n\nint FSCAN(vector<int> &serveArray, vector<int> &newArray, int startPosition)\n{\n\tint sum = 0;\n\tsum += SACN(serveArray, startPosition);\n\tsum += SACN(newArray, startPosition);\n\treturn sum;\n}\n```\n\n## 磁盘调度总结\n\nFCFS算法、SSTF算法、SCAN算法、CSCAN算法、NStepSCAN算法、FSCAN算法各有其优缺点，总结如下：\n\n- FCFS算法\n\n\t1. 优点：算法实现简单，公平\n\t2. 缺点：效率不高，相邻请求不能快速处理，磁头反复移动\n\n- SSTF算法\n\n\t1. 优点：采取贪心策略，优化平均寻道时间\n\t2. 缺点：可能导致饥饿现象\n\n- SCAN算法\n\n\t1. 优点：可以防止饥饿现象同时考虑到优化寻道时间\n\t2. 缺点：可能发生磁臂粘滞现象，某些请求可能会被严重推迟\n\n- CSCAN算法\n\n\t1. 优点：解决SCAN算法某些请求可能会被严重推迟的问题\n\t2. 缺点：由于单向移动，对于请求较少可能会出现返回时间的浪费\n\n\n- NStepSCAN算法\n\n\t1. 优点：避免磁臂粘滞的情况同时继承SCAN的优点\n\t2. 缺点：编程稍微复杂\n\n- FSCAN算法\n\n\t1. 优点：简化处理，实现较NStepSCAN算法更为简单\n\t2. 缺点：两个队列可能会稍增加平均寻道时间","slug":"操作系统/磁盘调度策略介绍与实现","published":1,"updated":"2018-06-13T14:21:15.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x4e002tgsvn4xhdxsmc","content":"<h2 id=\"磁盘调度基础\"><a href=\"#磁盘调度基础\" class=\"headerlink\" title=\"磁盘调度基础\"></a>磁盘调度基础</h2><p>磁盘是一种大容量低成本的存储设备，其支持随机存取。机械硬盘的物理结构如下所示：<a href=\"https://blog.csdn.net/idber/article/details/8087473\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/disk-physical-structure.png\" alt=\"磁盘物理结构\"></p>\n<p>如图所示，磁盘由多个盘片和读写磁头臂组成。盘面被分为多个同心圆，称为磁道；每个磁道又被划分为多个独立的逻辑区域，被称为扇区，扇区容量一般是512byte，有些较大为4Kbyte。每个磁道上扇区的数量可能相同也可能不相同，由于外圈长度比较大，为了提高密度可以划分更多的扇区。</p>\n<p>磁盘在设计时根据磁头是否在磁道之间移动可大致分为以下两种：</p>\n<pre><code>1. 固定头磁盘，每条磁道都有读写磁头，磁头被安装在刚性磁臂上，可并行读写磁道\n2. 移动头磁盘，每个盘面只有一个磁头，磁头需要能在不同磁道之间移动，读写速度较慢\n</code></pre><p>磁盘调度主要是针对移动头磁盘的读写时间优化。</p>\n<h2 id=\"磁盘访问时间\"><a href=\"#磁盘访问时间\" class=\"headerlink\" title=\"磁盘访问时间\"></a>磁盘访问时间</h2><p>磁盘在读写的时候主要经历如下过程：启动磁臂-&gt;移动磁头到指定磁道-&gt;扇区移动到磁头下方-&gt;读取数据。因此磁盘访问时间主要如下几部分组成：</p>\n<pre><code>1. 寻道时间Ts，Ts=m*n&quot;+s，s为启动磁臂时间，n为跨越磁道数，m为一常数，和具体磁盘有关\n2. 旋转延迟时间Tr，指扇区移动到磁头下花费的时间\n3. 传输时间Tt，为数据读写所花费的时间，如果每次读写字节数为b，旋转速度为r，磁道字节数为N，则Tt=b/(rN)\n</code></pre><p>从上述可得出整个读写期间共花费Ta=Ts+Tr+Tt，其中前两项一般与读取的数据量无关，且是整个时间中的大头。</p>\n<h2 id=\"磁盘调度策略\"><a href=\"#磁盘调度策略\" class=\"headerlink\" title=\"磁盘调度策略\"></a>磁盘调度策略</h2><p>由于读写总花费时间中寻道时间和旋转延迟占比比较大，因此从这两方面出发优化读写效率。对于旋转延迟一般和磁盘转速有关，因此主要提高转速。寻道时间则主要从寻道策略中优化，因此主要形成如下几种磁盘调度策略：</p>\n<pre><code>1. 先来先服务（FCFS，First Come First Served）\n2. 最短寻道时间优先（SSTF，Shortest Seek Time First）\n3. 扫描算法（SCAN）\n4. 循环扫描算法（CSCAN）\n5. NStepSCAN以及FSCAN算法\n</code></pre><p>一下分别详细介绍各种调度算法。</p>\n<h3 id=\"先来先服务\"><a href=\"#先来先服务\" class=\"headerlink\" title=\"先来先服务\"></a>先来先服务</h3><p>先来先服务是一种非常简单的算法，其按照请求的顺序依次处理，其优点是简单公平，但是由于没有对寻道时间进行任何优化，因此致使平均寻道时间比较大。这些特点使得FCFS算法不太适用于需要进行频繁读写的场合。其基本实现模拟代码如下所示。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FCFS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nowPosition = startPosition;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; serveArray.size(); i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp = serveArray[i] - nowPosition;</span><br><span class=\"line\">\t\tsum += tmp &gt; <span class=\"number\">0</span> ?  tmp :-tmp;</span><br><span class=\"line\">\t\tnowPosition = serveArray[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最短寻道时间优先\"><a href=\"#最短寻道时间优先\" class=\"headerlink\" title=\"最短寻道时间优先\"></a>最短寻道时间优先</h3><p>最短寻道时间优先是指在请求队列中优先满足离当前位置最近的磁道，使得每次寻道时间最短，即简单的贪心思想，但是这样并不能保证平均寻道时间最短。最短寻道时间优先策略一般优于先来先服务策略，但是可能发生饥饿现象，这是由于每次都选择离当前位置最近的磁道，对于离的比较的远的请求可能一直得不到服务。最短寻道时间优先模拟代码如下所示。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSTF</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsort(serveArray.begin(), serveArray.end());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (leftIndex = <span class=\"number\">0</span>; leftIndex &lt; <span class=\"keyword\">int</span>(serveArray.size()) &amp;&amp; startPosition &gt; serveArray[leftIndex]; leftIndex++) ;</span><br><span class=\"line\">\trightIndex = leftIndex; --leftIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> nowPosition = startPosition;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span> || rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span> &amp;&amp; rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition) &lt; <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition)) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex];</span><br><span class=\"line\">\t\t\t\t--leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex];</span><br><span class=\"line\">\t\t\t\t++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[leftIndex];</span><br><span class=\"line\">\t\t\t--leftIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[rightIndex];</span><br><span class=\"line\">\t\t\t++rightIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"扫描算法\"><a href=\"#扫描算法\" class=\"headerlink\" title=\"扫描算法\"></a>扫描算法</h3><p>扫描算法又称为电梯调度算法，其考虑请求磁道与当前磁道的距离和磁头当前移动的方向，在某一方向上一直访问下去直到没有更远的请求磁道，接着才调转方向。这个过程非常类似于电梯运行方式。由于磁头会一直向一个方向移动直到无更远访问请求，因此扫描算法不会发生饥饿现象，但是可能发生磁臂粘滞现象。以下是基本的模拟代码。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SACN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsort(serveArray.begin(), serveArray.end());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (leftIndex = <span class=\"number\">0</span>; leftIndex &lt; <span class=\"keyword\">int</span>(serveArray.size()) &amp;&amp; startPosition &gt; serveArray[leftIndex]; leftIndex++) ;</span><br><span class=\"line\">\trightIndex = leftIndex; --leftIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> nowPosition = startPosition;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span> &amp;&amp; rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition) &lt; <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环扫描算法\"><a href=\"#循环扫描算法\" class=\"headerlink\" title=\"循环扫描算法\"></a>循环扫描算法</h3><p>循环扫描算法和扫描算法最大的区别是规定磁头采用单向移动的模式，比如规定从里向外移动。这种方式可以减少对刚越过磁道发生请求的响应时间。以下是基本的模拟代码，假定采用磁道号增加的方向的扫描方式。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CSACN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsort(serveArray.begin(), serveArray.end());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (leftIndex = <span class=\"number\">0</span>; leftIndex &lt; <span class=\"keyword\">int</span>(serveArray.size()) &amp;&amp; startPosition &gt; serveArray[leftIndex]; leftIndex++) ;</span><br><span class=\"line\">\trightIndex = leftIndex; --leftIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> nowPosition = startPosition;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt;= leftIndex) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[i]-nowPosition);</span><br><span class=\"line\">\t\t\tnowPosition = serveArray[i]; ++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt;= leftIndex) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[i]-nowPosition);</span><br><span class=\"line\">\t\t\tnowPosition = serveArray[i]; ++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NStepSCAN与FSCAN算法\"><a href=\"#NStepSCAN与FSCAN算法\" class=\"headerlink\" title=\"NStepSCAN与FSCAN算法\"></a>NStepSCAN与FSCAN算法</h3><p>在SSTF、SCAN、CSCAN几种调度算法中，可能会由于频繁发生请求在当前磁道或附近致使磁头一直停留在附近或当前磁道中，导致对于某个磁道的请求垄断了整个磁盘设备，该现象称为磁盘粘滞，一般发生在高密度磁盘上。而NStepSCAN则将请求分成若干个长度为N的子队列，队列之间按照先来先服务的顺序，每个队列内按照SCAN算法处理，新请求插入其他队列（非当前处理队列）。如果N=1则退化成FCFS算法。</p>\n<p>FSCAN算法和NStepSCAN区别主要是FSCAN算法只将请求分为两个队列，一个是当前处理队列以及在处理过程中新的请求队列。</p>\n<p>两种算法的处理模拟代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SACN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> &amp;nowPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsort(serveArray.begin(), serveArray.end());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (leftIndex = <span class=\"number\">0</span>; leftIndex &lt; <span class=\"keyword\">int</span>(serveArray.size()) &amp;&amp; nowPosition &gt; serveArray[leftIndex]; leftIndex++) ;</span><br><span class=\"line\">\trightIndex = leftIndex; --leftIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span> &amp;&amp; rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition) &lt; <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NStepSCAN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;serveArrays, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArrays.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; serveArrays.size(); i++) &#123;</span><br><span class=\"line\">\t\tsum += SACN(serveArrays[i], startPosition);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FSCAN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;newArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsum += SACN(serveArray, startPosition);</span><br><span class=\"line\">\tsum += SACN(newArray, startPosition);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"磁盘调度总结\"><a href=\"#磁盘调度总结\" class=\"headerlink\" title=\"磁盘调度总结\"></a>磁盘调度总结</h2><p>FCFS算法、SSTF算法、SCAN算法、CSCAN算法、NStepSCAN算法、FSCAN算法各有其优缺点，总结如下：</p>\n<ul>\n<li><p>FCFS算法</p>\n<ol>\n<li>优点：算法实现简单，公平</li>\n<li>缺点：效率不高，相邻请求不能快速处理，磁头反复移动</li>\n</ol>\n</li>\n<li><p>SSTF算法</p>\n<ol>\n<li>优点：采取贪心策略，优化平均寻道时间</li>\n<li>缺点：可能导致饥饿现象</li>\n</ol>\n</li>\n<li><p>SCAN算法</p>\n<ol>\n<li>优点：可以防止饥饿现象同时考虑到优化寻道时间</li>\n<li>缺点：可能发生磁臂粘滞现象，某些请求可能会被严重推迟</li>\n</ol>\n</li>\n<li><p>CSCAN算法</p>\n<ol>\n<li>优点：解决SCAN算法某些请求可能会被严重推迟的问题</li>\n<li>缺点：由于单向移动，对于请求较少可能会出现返回时间的浪费</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>NStepSCAN算法</p>\n<ol>\n<li>优点：避免磁臂粘滞的情况同时继承SCAN的优点</li>\n<li>缺点：编程稍微复杂</li>\n</ol>\n</li>\n<li><p>FSCAN算法</p>\n<ol>\n<li>优点：简化处理，实现较NStepSCAN算法更为简单</li>\n<li>缺点：两个队列可能会稍增加平均寻道时间</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"磁盘调度基础\"><a href=\"#磁盘调度基础\" class=\"headerlink\" title=\"磁盘调度基础\"></a>磁盘调度基础</h2><p>磁盘是一种大容量低成本的存储设备，其支持随机存取。机械硬盘的物理结构如下所示：<a href=\"https://blog.csdn.net/idber/article/details/8087473\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/disk-physical-structure.png\" alt=\"磁盘物理结构\"></p>\n<p>如图所示，磁盘由多个盘片和读写磁头臂组成。盘面被分为多个同心圆，称为磁道；每个磁道又被划分为多个独立的逻辑区域，被称为扇区，扇区容量一般是512byte，有些较大为4Kbyte。每个磁道上扇区的数量可能相同也可能不相同，由于外圈长度比较大，为了提高密度可以划分更多的扇区。</p>\n<p>磁盘在设计时根据磁头是否在磁道之间移动可大致分为以下两种：</p>\n<pre><code>1. 固定头磁盘，每条磁道都有读写磁头，磁头被安装在刚性磁臂上，可并行读写磁道\n2. 移动头磁盘，每个盘面只有一个磁头，磁头需要能在不同磁道之间移动，读写速度较慢\n</code></pre><p>磁盘调度主要是针对移动头磁盘的读写时间优化。</p>\n<h2 id=\"磁盘访问时间\"><a href=\"#磁盘访问时间\" class=\"headerlink\" title=\"磁盘访问时间\"></a>磁盘访问时间</h2><p>磁盘在读写的时候主要经历如下过程：启动磁臂-&gt;移动磁头到指定磁道-&gt;扇区移动到磁头下方-&gt;读取数据。因此磁盘访问时间主要如下几部分组成：</p>\n<pre><code>1. 寻道时间Ts，Ts=m*n&quot;+s，s为启动磁臂时间，n为跨越磁道数，m为一常数，和具体磁盘有关\n2. 旋转延迟时间Tr，指扇区移动到磁头下花费的时间\n3. 传输时间Tt，为数据读写所花费的时间，如果每次读写字节数为b，旋转速度为r，磁道字节数为N，则Tt=b/(rN)\n</code></pre><p>从上述可得出整个读写期间共花费Ta=Ts+Tr+Tt，其中前两项一般与读取的数据量无关，且是整个时间中的大头。</p>\n<h2 id=\"磁盘调度策略\"><a href=\"#磁盘调度策略\" class=\"headerlink\" title=\"磁盘调度策略\"></a>磁盘调度策略</h2><p>由于读写总花费时间中寻道时间和旋转延迟占比比较大，因此从这两方面出发优化读写效率。对于旋转延迟一般和磁盘转速有关，因此主要提高转速。寻道时间则主要从寻道策略中优化，因此主要形成如下几种磁盘调度策略：</p>\n<pre><code>1. 先来先服务（FCFS，First Come First Served）\n2. 最短寻道时间优先（SSTF，Shortest Seek Time First）\n3. 扫描算法（SCAN）\n4. 循环扫描算法（CSCAN）\n5. NStepSCAN以及FSCAN算法\n</code></pre><p>一下分别详细介绍各种调度算法。</p>\n<h3 id=\"先来先服务\"><a href=\"#先来先服务\" class=\"headerlink\" title=\"先来先服务\"></a>先来先服务</h3><p>先来先服务是一种非常简单的算法，其按照请求的顺序依次处理，其优点是简单公平，但是由于没有对寻道时间进行任何优化，因此致使平均寻道时间比较大。这些特点使得FCFS算法不太适用于需要进行频繁读写的场合。其基本实现模拟代码如下所示。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FCFS</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nowPosition = startPosition;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; serveArray.size(); i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp = serveArray[i] - nowPosition;</span><br><span class=\"line\">\t\tsum += tmp &gt; <span class=\"number\">0</span> ?  tmp :-tmp;</span><br><span class=\"line\">\t\tnowPosition = serveArray[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最短寻道时间优先\"><a href=\"#最短寻道时间优先\" class=\"headerlink\" title=\"最短寻道时间优先\"></a>最短寻道时间优先</h3><p>最短寻道时间优先是指在请求队列中优先满足离当前位置最近的磁道，使得每次寻道时间最短，即简单的贪心思想，但是这样并不能保证平均寻道时间最短。最短寻道时间优先策略一般优于先来先服务策略，但是可能发生饥饿现象，这是由于每次都选择离当前位置最近的磁道，对于离的比较的远的请求可能一直得不到服务。最短寻道时间优先模拟代码如下所示。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SSTF</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsort(serveArray.begin(), serveArray.end());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (leftIndex = <span class=\"number\">0</span>; leftIndex &lt; <span class=\"keyword\">int</span>(serveArray.size()) &amp;&amp; startPosition &gt; serveArray[leftIndex]; leftIndex++) ;</span><br><span class=\"line\">\trightIndex = leftIndex; --leftIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> nowPosition = startPosition;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span> || rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span> &amp;&amp; rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition) &lt; <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition)) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex];</span><br><span class=\"line\">\t\t\t\t--leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex];</span><br><span class=\"line\">\t\t\t\t++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[leftIndex];</span><br><span class=\"line\">\t\t\t--leftIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[rightIndex];</span><br><span class=\"line\">\t\t\t++rightIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"扫描算法\"><a href=\"#扫描算法\" class=\"headerlink\" title=\"扫描算法\"></a>扫描算法</h3><p>扫描算法又称为电梯调度算法，其考虑请求磁道与当前磁道的距离和磁头当前移动的方向，在某一方向上一直访问下去直到没有更远的请求磁道，接着才调转方向。这个过程非常类似于电梯运行方式。由于磁头会一直向一个方向移动直到无更远访问请求，因此扫描算法不会发生饥饿现象，但是可能发生磁臂粘滞现象。以下是基本的模拟代码。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SACN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsort(serveArray.begin(), serveArray.end());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (leftIndex = <span class=\"number\">0</span>; leftIndex &lt; <span class=\"keyword\">int</span>(serveArray.size()) &amp;&amp; startPosition &gt; serveArray[leftIndex]; leftIndex++) ;</span><br><span class=\"line\">\trightIndex = leftIndex; --leftIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> nowPosition = startPosition;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span> &amp;&amp; rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition) &lt; <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环扫描算法\"><a href=\"#循环扫描算法\" class=\"headerlink\" title=\"循环扫描算法\"></a>循环扫描算法</h3><p>循环扫描算法和扫描算法最大的区别是规定磁头采用单向移动的模式，比如规定从里向外移动。这种方式可以减少对刚越过磁道发生请求的响应时间。以下是基本的模拟代码，假定采用磁道号增加的方向的扫描方式。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CSACN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsort(serveArray.begin(), serveArray.end());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (leftIndex = <span class=\"number\">0</span>; leftIndex &lt; <span class=\"keyword\">int</span>(serveArray.size()) &amp;&amp; startPosition &gt; serveArray[leftIndex]; leftIndex++) ;</span><br><span class=\"line\">\trightIndex = leftIndex; --leftIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> nowPosition = startPosition;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt;= leftIndex) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[i]-nowPosition);</span><br><span class=\"line\">\t\t\tnowPosition = serveArray[i]; ++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt;= leftIndex) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[i]-nowPosition);</span><br><span class=\"line\">\t\t\tnowPosition = serveArray[i]; ++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"NStepSCAN与FSCAN算法\"><a href=\"#NStepSCAN与FSCAN算法\" class=\"headerlink\" title=\"NStepSCAN与FSCAN算法\"></a>NStepSCAN与FSCAN算法</h3><p>在SSTF、SCAN、CSCAN几种调度算法中，可能会由于频繁发生请求在当前磁道或附近致使磁头一直停留在附近或当前磁道中，导致对于某个磁道的请求垄断了整个磁盘设备，该现象称为磁盘粘滞，一般发生在高密度磁盘上。而NStepSCAN则将请求分成若干个长度为N的子队列，队列之间按照先来先服务的顺序，每个队列内按照SCAN算法处理，新请求插入其他队列（非当前处理队列）。如果N=1则退化成FCFS算法。</p>\n<p>FSCAN算法和NStepSCAN区别主要是FSCAN算法只将请求分为两个队列，一个是当前处理队列以及在处理过程中新的请求队列。</p>\n<p>两种算法的处理模拟代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">SACN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"keyword\">int</span> &amp;nowPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArray.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> leftIndex = <span class=\"number\">0</span>, rightIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsort(serveArray.begin(), serveArray.end());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (leftIndex = <span class=\"number\">0</span>; leftIndex &lt; <span class=\"keyword\">int</span>(serveArray.size()) &amp;&amp; nowPosition &gt; serveArray[leftIndex]; leftIndex++) ;</span><br><span class=\"line\">\trightIndex = leftIndex; --leftIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span> &amp;&amp; rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition) &lt; <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (leftIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tsum += <span class=\"built_in\">abs</span>(serveArray[leftIndex]-nowPosition); </span><br><span class=\"line\">\t\t\tnowPosition = serveArray[leftIndex]; --leftIndex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rightIndex &lt; <span class=\"keyword\">int</span>(serveArray.size())) &#123;</span><br><span class=\"line\">\t\tsum += <span class=\"built_in\">abs</span>(serveArray[rightIndex]-nowPosition); </span><br><span class=\"line\">\t\tnowPosition = serveArray[rightIndex]; ++rightIndex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NStepSCAN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;serveArrays, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (serveArrays.size() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; serveArrays.size(); i++) &#123;</span><br><span class=\"line\">\t\tsum += SACN(serveArrays[i], startPosition);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FSCAN</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;serveArray, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;newArray, <span class=\"keyword\">int</span> startPosition)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsum += SACN(serveArray, startPosition);</span><br><span class=\"line\">\tsum += SACN(newArray, startPosition);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"磁盘调度总结\"><a href=\"#磁盘调度总结\" class=\"headerlink\" title=\"磁盘调度总结\"></a>磁盘调度总结</h2><p>FCFS算法、SSTF算法、SCAN算法、CSCAN算法、NStepSCAN算法、FSCAN算法各有其优缺点，总结如下：</p>\n<ul>\n<li><p>FCFS算法</p>\n<ol>\n<li>优点：算法实现简单，公平</li>\n<li>缺点：效率不高，相邻请求不能快速处理，磁头反复移动</li>\n</ol>\n</li>\n<li><p>SSTF算法</p>\n<ol>\n<li>优点：采取贪心策略，优化平均寻道时间</li>\n<li>缺点：可能导致饥饿现象</li>\n</ol>\n</li>\n<li><p>SCAN算法</p>\n<ol>\n<li>优点：可以防止饥饿现象同时考虑到优化寻道时间</li>\n<li>缺点：可能发生磁臂粘滞现象，某些请求可能会被严重推迟</li>\n</ol>\n</li>\n<li><p>CSCAN算法</p>\n<ol>\n<li>优点：解决SCAN算法某些请求可能会被严重推迟的问题</li>\n<li>缺点：由于单向移动，对于请求较少可能会出现返回时间的浪费</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>NStepSCAN算法</p>\n<ol>\n<li>优点：避免磁臂粘滞的情况同时继承SCAN的优点</li>\n<li>缺点：编程稍微复杂</li>\n</ol>\n</li>\n<li><p>FSCAN算法</p>\n<ol>\n<li>优点：简化处理，实现较NStepSCAN算法更为简单</li>\n<li>缺点：两个队列可能会稍增加平均寻道时间</li>\n</ol>\n</li>\n</ul>\n"},{"title":"进程与线程","urlname":"process-thread","date":"2018-03-06T02:09:21.000Z","copyright":true,"mathjax":true,"_content":"\n# 进程\n\n## 进程定义\n\n进程是操作系统最核心的概念，进程是对正在运行程序的一个抽象。\n\n进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进程资源分配和调度的独立单位。\n\n严格而言，在某一个瞬间CPU只能运行一个进程，但在较长时间间隔下，操作系统可能运行了多个进程，由此导致并行的错觉，实际上只能认为是并发而不是真正的并行。\n\n## 进程模型\n\n在进程模型中，计算机所有可运行的软件（包括）操作系统，被组织成若干个顺序进程（sequence process），简称进程。进程是正在执行程序的实例，包括程序计数器、寄存器、变量的当前值。进程和程序之间的区别就和做菜与菜谱之间的关系，进程是动态的，程序是静态的。\n\n## 进程创建\n\n- 系统初始化\n- 执行了正在运行的进程所调用的进程创建系统调用\n- 用户请求创建一个新进程\n- 一个批处理作业的初始化\n\n守护进程：停留在后台处理诸如电子邮件、Web页面、新闻、打印之类的进程。\n\nUnix创建新进程：fork, exec。\nWindows创建新进程：CreateProcess。\n\n在Unix和WIndows中，进程创建后父子进程各自有不同的地址空间。（实际实现中Linux有写时复制以及不可写内存共享）\n\n## 进程终止\n\n- 正常退出（资源）Unix,exit(); Windows,ExitProcess\n- 出错退出（自愿）不正确使用，进程可检测到的错误\n- 严重错误（非自愿）非法指令，引用不存在的内存，除零\n- 被其他进程杀死（非自愿）Unix,kill; Windows,TerminateProcess\n\n## 进程层次\n\nUnix中，进程和它的所有的子女以及后裔共同组成一个进程组。进程树以init进程为根的一棵树。Windows进程之间的地位是平等的。\n\n## 进程状态\n\n在多进程系统中，由于某一瞬间只有一个进程独占CPU，而进程在运行时可能需要等待某些条件满足后才能继续运行，此时进程必须暂停以等待条件满足，由此引出进程的三种基本状态：\n\n- 运行态：此时进程实际占用CPU\n- 就绪态：进程已经准备好可以运行，但是由于CPU正在使用而暂时停止\n- 阻塞态：进程在等待外部条件的满足或者外部事件的发生，否则进程不能运行\n\n如下图为三种基本状态之间的转换关系\n\n![进程状态转换](/images/process-status.png)\n\n1. 运行态->阻塞态：比如等待某种I/O操作，像等待用户输入，还有可能是进程调用等待函数主动进入阻塞\n2. 运行态->就绪态：调度程序调度另外一个进程使用CPU，一般为时间片用完、高优先级抢占等。\n3. 就绪态->运行态：调度程序选中当前进程上CPU\n4. 阻塞态->就绪态：外部事件已发生，进程由阻塞态转变为就绪态，如果此时CPU空闲可能立刻调度转变为运行态\n\n## 进程实现\n\n为了实现进程模型，系统维护一张进程表，每个进程占用一个项，该项被称为进程控制块（Process Control Block, PCB），进程控制块是操作系统用于管理进程而设计的专用数据结构，其主要内容可分为：\n\n- 进程描述信息\n\n用描述一个进程的基本信息，比如进程标识符（process ID, PID）、进程名、用户标识符、进程组关系等。\n\n- 进程控制信息\n\n用于操作系统控制进程的运行，包括当前状态、优先级、代码执行入口地址、程序磁盘地址、运行统计时间（执行时间、页面调度）、进程同步与通信、进程队列指针、进程消息队列指针。\n\n- 拥有资源及使用情况\n\n保存当前进程虚拟地址空间的状况、打开的文件等资源情况。\n\n- CPU现场信息\n\n保存CPU寄存器值（通用寄存器、程序计数器PC、程序状态字PSW、栈指针等）、进程页表指针。\n\n从操作系统作为资源管理者的角度而言，PCB的主要内容也可分为以下几类：\n\n- 进程管理\n\n保存进程基本管理信息，诸如寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、进程ID等\n\n- 存储管理\n\n保存正文段指针、数据段指针、堆栈段指针\n\n- 文件管理\n\n保存根目录、当前工作目录、文件描述符等\n\n## 进程控制\n\n进程控制是指控制进程完成不同状态之间的转换操作，使用特定功能的原语（又称为原子操作，是完成特定功能的一段程序，具有不可分割性或不可中断性，在实际实现中可通过屏蔽中断实现）完成。进程控制的原语主要有：\n\n- 进程创建原语\n\n  1. 给新进程分配一个唯一标识以及进程控制块\n  2. 分配地址空间\n  3. 初始化控制块\n  4. 将进程插入到就绪队列中\n\n- 进程撤销原语\n\n  1. 收回进程占用的资源，如关闭打开的文件、断开网络链接、回收内存\n  2. 撤销该进程的进程控制块PCB\n\n- 阻塞原语\n\n  1. 有进程自己执行阻塞原语，等待事件发生\n  2. Unix, wait; Windows, WaitForSingleObject\n \n- 唤醒原语\n\n- 挂起原语\n\n- 激活原语\n\n- 优先级改变原语\n\n## Unix进程控制操作\n\n- fork\n\nfork通过复制调用进程来新建一个进程，其基本过程如下\n\n  1. 为子进程分配一个空闲的进程描述符proc（即PCB）结构\n  2. 给子进程分配唯一进程标识PID\n  3. 以一次一页的方式复制父进程的地址空间（Linux使用COW技术，Copy On Write）\n  4. 从父进程出继承共享资源比如打开的文件和当前工作目录等\n  5. 将子进程设为就绪态并插入就绪队列\n  6. 在父进程中返回子进程的PID值，子进程中返回0，即一次调用两次返回\n\n- exec\n\n由一系列系统调用组成，通过一段新的程序代码覆盖掉原来的地址空间，实现执行代码的转换\n\n- wait\n\n提供初级的同步操作，使一个进程等待另外一个一个进程的结束\n\n- exit\n\n终止一个进程的运行\n\n## 进程分类\n\n1. 第一种分类\n  - 系统进程\n  - 用户进程\n\n2. 第二种分类\n\n  - 前台进程\n  - 后台进程\n\n3. 第三种分类\n\n  - CPU密集型进程\n  - IO密集型进程\n\n\n## 进程和程序的区别\n\n- 进程能够准确刻画并发，程序不能\n- 进程是动态的，而程序是静态的\n- 进程有生命周期，有创建终止，而程序则相对长久的\n- 一个进程能对应一个程序，而一个程序可以对应多个进程。\n\n## 进程地址空间\n\n每个进程有自己独立的地址空间，对于采用虚拟内存管理的操作系统，地址空间的地址是虚拟地址，需要进行映射以转换到实际物理内存地址。基本结构如下图所示：\n![进程地址空间](/images/process-address-space.png)\n\n## 进程映像（IMAGE）\n\n和进程地址空间关联的一个概念为进程映像，其是指对进程执行活动全过程的静态描述，由地址空间内容、硬件寄存器、相关的内核数据结构、内和栈组成。是某一瞬间进程的快照。具体内容有：\n\n- 用户相关:进程地址空间（代码段、数据段、堆和栈、共享库等）\n- 寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等\n- 内核相关\n  1. 静态部分：PCB以及各种资源结构\n  2. 动态部分：内和栈\n\n## 进程上下文（CONTEXT）切换\n\n将CPU硬件从一个进程换到另外一个进程的过程称为上下文切换。当进程运行时，其硬件状态保存在CPU的寄存器中；当进程不运行时，这些寄存器保存在进程控制块PCB中。如果切换进程则需要将PCB控制块保存的寄存器信息送入CPU寄存器中。\n\n# 线程基本概念\n\n进程是一个操作系统资源分配与调度的基本单位，但是在实际应用时，一个应用内部可以划分为多个不同的执行线路或者说细分为更小的任务，执行线路在某种程度上可以进行一定程度的并行，同时执行线路之间通过共享地址空间来协作完成整个任务。而进程作为资源分配与调度的基本单位，如果将这两者分离，让进程完成资源的集中，线程完成实际的执行过程。由此引入线程的概念。至此进程成为资源的分配单位而线程分别称为CPU的实际调度单位。也可以认为线程是进程中的一个运行的实体。\n\n## 线程的属性\n\n线程主要具有如下属性：\n\n- 有标识符ID\n- 有状态及状态转换\n- 需要保存上下文环境\n- 有自己的栈和指针\n- 共享进程的地址空间和其他资源\n- 线程可撤销和创建\n\n实际在进程创建后程序以单线程的方式运行，通过thread_create等系统调用可以创建新线程。\n\n## 线程的实现\n\n在线程的实际实现中，同有如下三种方法：\n\n- 用户级线程\n\n在用户空间建立线程库，通过运行时系统进行线程的管理，此时内核对于线程一无所知。由于线程也存在状态的转换，因此和进程类似，在每个进程中需要有专用的线程表来跟踪记录各个线程的属性（如程序计数器、堆栈指针、寄存器和状态等），线程表由运行时系统进行管理。\n\n用户级线程由于自身的特点，主要有如下优缺点：\n\n1. 优点\n  1. 线程与线程之间切换速度快，只需要切换堆栈指针程序计数器等，通常几条指令就可完成线程的切换\n  2. 线程调度算法可以由每个进程自己定制\n  3. 用户级线程可以方便在任何系统中实现，只需实现线程库即可\n\n2. 缺点\n  1. 由于内核对线程一无所知，此时系统调度的单位为进程，因此多线程只能在一个CPU上运行\n  2. 由于多数系统调用是阻塞的，一旦线程调用了阻塞的系统调用，内核将阻塞整个进程，即所有的线程被阻塞\n\n- 核心级线程\n\n核心级线程需要改造操作系统，由内核直接管理所有的线程。此时进程无需专用的线程表而改由内核来记录线程表。此时线程调度有内核完成，当一个线程被阻塞时，内核可以选择运行进程中的另外一个线程而不是直接将整个进程阻塞。在核心级线程实现中，内核需要维护进程表和线程表。\n\n核心级线程实现通常有如下优缺点：\n\n1. 优点\n  1. 内核无需新的非阻塞的系统调用\n  2. 线程阻塞不会导致整个进程的阻塞\n2. 缺点\n  1. 在内核中创建或者撤销线程的代价比较大\n  2. 需要改造操作系统\n\n- 混合实现\n\n由于用户级线程实现以及核心级线程实现均有其优缺点，通过综合两者的优点从而形成混合实现。在这种是实现中，由编程人员决定有多少个内核级线程与用户级线程，内核只识别内核级线程并进行调度。多个用户级线程通过多路复用来复用多个内核级线程，如下图为多路复用模型：\n\n![多路复用模型](/images/multiplexer.png)","source":"_posts/操作系统/进程与线程.md","raw":"---\ntitle: 进程与线程\nurlname: process-thread\ndate: 2018-03-6 10:09:21\ncopyright: true\nmathjax: true\ntags:\n- 操作系统\ncategories:\n- 操作系统\n---\n\n# 进程\n\n## 进程定义\n\n进程是操作系统最核心的概念，进程是对正在运行程序的一个抽象。\n\n进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进程资源分配和调度的独立单位。\n\n严格而言，在某一个瞬间CPU只能运行一个进程，但在较长时间间隔下，操作系统可能运行了多个进程，由此导致并行的错觉，实际上只能认为是并发而不是真正的并行。\n\n## 进程模型\n\n在进程模型中，计算机所有可运行的软件（包括）操作系统，被组织成若干个顺序进程（sequence process），简称进程。进程是正在执行程序的实例，包括程序计数器、寄存器、变量的当前值。进程和程序之间的区别就和做菜与菜谱之间的关系，进程是动态的，程序是静态的。\n\n## 进程创建\n\n- 系统初始化\n- 执行了正在运行的进程所调用的进程创建系统调用\n- 用户请求创建一个新进程\n- 一个批处理作业的初始化\n\n守护进程：停留在后台处理诸如电子邮件、Web页面、新闻、打印之类的进程。\n\nUnix创建新进程：fork, exec。\nWindows创建新进程：CreateProcess。\n\n在Unix和WIndows中，进程创建后父子进程各自有不同的地址空间。（实际实现中Linux有写时复制以及不可写内存共享）\n\n## 进程终止\n\n- 正常退出（资源）Unix,exit(); Windows,ExitProcess\n- 出错退出（自愿）不正确使用，进程可检测到的错误\n- 严重错误（非自愿）非法指令，引用不存在的内存，除零\n- 被其他进程杀死（非自愿）Unix,kill; Windows,TerminateProcess\n\n## 进程层次\n\nUnix中，进程和它的所有的子女以及后裔共同组成一个进程组。进程树以init进程为根的一棵树。Windows进程之间的地位是平等的。\n\n## 进程状态\n\n在多进程系统中，由于某一瞬间只有一个进程独占CPU，而进程在运行时可能需要等待某些条件满足后才能继续运行，此时进程必须暂停以等待条件满足，由此引出进程的三种基本状态：\n\n- 运行态：此时进程实际占用CPU\n- 就绪态：进程已经准备好可以运行，但是由于CPU正在使用而暂时停止\n- 阻塞态：进程在等待外部条件的满足或者外部事件的发生，否则进程不能运行\n\n如下图为三种基本状态之间的转换关系\n\n![进程状态转换](/images/process-status.png)\n\n1. 运行态->阻塞态：比如等待某种I/O操作，像等待用户输入，还有可能是进程调用等待函数主动进入阻塞\n2. 运行态->就绪态：调度程序调度另外一个进程使用CPU，一般为时间片用完、高优先级抢占等。\n3. 就绪态->运行态：调度程序选中当前进程上CPU\n4. 阻塞态->就绪态：外部事件已发生，进程由阻塞态转变为就绪态，如果此时CPU空闲可能立刻调度转变为运行态\n\n## 进程实现\n\n为了实现进程模型，系统维护一张进程表，每个进程占用一个项，该项被称为进程控制块（Process Control Block, PCB），进程控制块是操作系统用于管理进程而设计的专用数据结构，其主要内容可分为：\n\n- 进程描述信息\n\n用描述一个进程的基本信息，比如进程标识符（process ID, PID）、进程名、用户标识符、进程组关系等。\n\n- 进程控制信息\n\n用于操作系统控制进程的运行，包括当前状态、优先级、代码执行入口地址、程序磁盘地址、运行统计时间（执行时间、页面调度）、进程同步与通信、进程队列指针、进程消息队列指针。\n\n- 拥有资源及使用情况\n\n保存当前进程虚拟地址空间的状况、打开的文件等资源情况。\n\n- CPU现场信息\n\n保存CPU寄存器值（通用寄存器、程序计数器PC、程序状态字PSW、栈指针等）、进程页表指针。\n\n从操作系统作为资源管理者的角度而言，PCB的主要内容也可分为以下几类：\n\n- 进程管理\n\n保存进程基本管理信息，诸如寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、进程ID等\n\n- 存储管理\n\n保存正文段指针、数据段指针、堆栈段指针\n\n- 文件管理\n\n保存根目录、当前工作目录、文件描述符等\n\n## 进程控制\n\n进程控制是指控制进程完成不同状态之间的转换操作，使用特定功能的原语（又称为原子操作，是完成特定功能的一段程序，具有不可分割性或不可中断性，在实际实现中可通过屏蔽中断实现）完成。进程控制的原语主要有：\n\n- 进程创建原语\n\n  1. 给新进程分配一个唯一标识以及进程控制块\n  2. 分配地址空间\n  3. 初始化控制块\n  4. 将进程插入到就绪队列中\n\n- 进程撤销原语\n\n  1. 收回进程占用的资源，如关闭打开的文件、断开网络链接、回收内存\n  2. 撤销该进程的进程控制块PCB\n\n- 阻塞原语\n\n  1. 有进程自己执行阻塞原语，等待事件发生\n  2. Unix, wait; Windows, WaitForSingleObject\n \n- 唤醒原语\n\n- 挂起原语\n\n- 激活原语\n\n- 优先级改变原语\n\n## Unix进程控制操作\n\n- fork\n\nfork通过复制调用进程来新建一个进程，其基本过程如下\n\n  1. 为子进程分配一个空闲的进程描述符proc（即PCB）结构\n  2. 给子进程分配唯一进程标识PID\n  3. 以一次一页的方式复制父进程的地址空间（Linux使用COW技术，Copy On Write）\n  4. 从父进程出继承共享资源比如打开的文件和当前工作目录等\n  5. 将子进程设为就绪态并插入就绪队列\n  6. 在父进程中返回子进程的PID值，子进程中返回0，即一次调用两次返回\n\n- exec\n\n由一系列系统调用组成，通过一段新的程序代码覆盖掉原来的地址空间，实现执行代码的转换\n\n- wait\n\n提供初级的同步操作，使一个进程等待另外一个一个进程的结束\n\n- exit\n\n终止一个进程的运行\n\n## 进程分类\n\n1. 第一种分类\n  - 系统进程\n  - 用户进程\n\n2. 第二种分类\n\n  - 前台进程\n  - 后台进程\n\n3. 第三种分类\n\n  - CPU密集型进程\n  - IO密集型进程\n\n\n## 进程和程序的区别\n\n- 进程能够准确刻画并发，程序不能\n- 进程是动态的，而程序是静态的\n- 进程有生命周期，有创建终止，而程序则相对长久的\n- 一个进程能对应一个程序，而一个程序可以对应多个进程。\n\n## 进程地址空间\n\n每个进程有自己独立的地址空间，对于采用虚拟内存管理的操作系统，地址空间的地址是虚拟地址，需要进行映射以转换到实际物理内存地址。基本结构如下图所示：\n![进程地址空间](/images/process-address-space.png)\n\n## 进程映像（IMAGE）\n\n和进程地址空间关联的一个概念为进程映像，其是指对进程执行活动全过程的静态描述，由地址空间内容、硬件寄存器、相关的内核数据结构、内和栈组成。是某一瞬间进程的快照。具体内容有：\n\n- 用户相关:进程地址空间（代码段、数据段、堆和栈、共享库等）\n- 寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等\n- 内核相关\n  1. 静态部分：PCB以及各种资源结构\n  2. 动态部分：内和栈\n\n## 进程上下文（CONTEXT）切换\n\n将CPU硬件从一个进程换到另外一个进程的过程称为上下文切换。当进程运行时，其硬件状态保存在CPU的寄存器中；当进程不运行时，这些寄存器保存在进程控制块PCB中。如果切换进程则需要将PCB控制块保存的寄存器信息送入CPU寄存器中。\n\n# 线程基本概念\n\n进程是一个操作系统资源分配与调度的基本单位，但是在实际应用时，一个应用内部可以划分为多个不同的执行线路或者说细分为更小的任务，执行线路在某种程度上可以进行一定程度的并行，同时执行线路之间通过共享地址空间来协作完成整个任务。而进程作为资源分配与调度的基本单位，如果将这两者分离，让进程完成资源的集中，线程完成实际的执行过程。由此引入线程的概念。至此进程成为资源的分配单位而线程分别称为CPU的实际调度单位。也可以认为线程是进程中的一个运行的实体。\n\n## 线程的属性\n\n线程主要具有如下属性：\n\n- 有标识符ID\n- 有状态及状态转换\n- 需要保存上下文环境\n- 有自己的栈和指针\n- 共享进程的地址空间和其他资源\n- 线程可撤销和创建\n\n实际在进程创建后程序以单线程的方式运行，通过thread_create等系统调用可以创建新线程。\n\n## 线程的实现\n\n在线程的实际实现中，同有如下三种方法：\n\n- 用户级线程\n\n在用户空间建立线程库，通过运行时系统进行线程的管理，此时内核对于线程一无所知。由于线程也存在状态的转换，因此和进程类似，在每个进程中需要有专用的线程表来跟踪记录各个线程的属性（如程序计数器、堆栈指针、寄存器和状态等），线程表由运行时系统进行管理。\n\n用户级线程由于自身的特点，主要有如下优缺点：\n\n1. 优点\n  1. 线程与线程之间切换速度快，只需要切换堆栈指针程序计数器等，通常几条指令就可完成线程的切换\n  2. 线程调度算法可以由每个进程自己定制\n  3. 用户级线程可以方便在任何系统中实现，只需实现线程库即可\n\n2. 缺点\n  1. 由于内核对线程一无所知，此时系统调度的单位为进程，因此多线程只能在一个CPU上运行\n  2. 由于多数系统调用是阻塞的，一旦线程调用了阻塞的系统调用，内核将阻塞整个进程，即所有的线程被阻塞\n\n- 核心级线程\n\n核心级线程需要改造操作系统，由内核直接管理所有的线程。此时进程无需专用的线程表而改由内核来记录线程表。此时线程调度有内核完成，当一个线程被阻塞时，内核可以选择运行进程中的另外一个线程而不是直接将整个进程阻塞。在核心级线程实现中，内核需要维护进程表和线程表。\n\n核心级线程实现通常有如下优缺点：\n\n1. 优点\n  1. 内核无需新的非阻塞的系统调用\n  2. 线程阻塞不会导致整个进程的阻塞\n2. 缺点\n  1. 在内核中创建或者撤销线程的代价比较大\n  2. 需要改造操作系统\n\n- 混合实现\n\n由于用户级线程实现以及核心级线程实现均有其优缺点，通过综合两者的优点从而形成混合实现。在这种是实现中，由编程人员决定有多少个内核级线程与用户级线程，内核只识别内核级线程并进行调度。多个用户级线程通过多路复用来复用多个内核级线程，如下图为多路复用模型：\n\n![多路复用模型](/images/multiplexer.png)","slug":"操作系统/进程与线程","published":1,"updated":"2018-06-13T14:20:14.080Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x4f002wgsvn7s4ov9k3","content":"<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"进程定义\"><a href=\"#进程定义\" class=\"headerlink\" title=\"进程定义\"></a>进程定义</h2><p>进程是操作系统最核心的概念，进程是对正在运行程序的一个抽象。</p>\n<p>进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进程资源分配和调度的独立单位。</p>\n<p>严格而言，在某一个瞬间CPU只能运行一个进程，但在较长时间间隔下，操作系统可能运行了多个进程，由此导致并行的错觉，实际上只能认为是并发而不是真正的并行。</p>\n<h2 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h2><p>在进程模型中，计算机所有可运行的软件（包括）操作系统，被组织成若干个顺序进程（sequence process），简称进程。进程是正在执行程序的实例，包括程序计数器、寄存器、变量的当前值。进程和程序之间的区别就和做菜与菜谱之间的关系，进程是动态的，程序是静态的。</p>\n<h2 id=\"进程创建\"><a href=\"#进程创建\" class=\"headerlink\" title=\"进程创建\"></a>进程创建</h2><ul>\n<li>系统初始化</li>\n<li>执行了正在运行的进程所调用的进程创建系统调用</li>\n<li>用户请求创建一个新进程</li>\n<li>一个批处理作业的初始化</li>\n</ul>\n<p>守护进程：停留在后台处理诸如电子邮件、Web页面、新闻、打印之类的进程。</p>\n<p>Unix创建新进程：fork, exec。<br>Windows创建新进程：CreateProcess。</p>\n<p>在Unix和WIndows中，进程创建后父子进程各自有不同的地址空间。（实际实现中Linux有写时复制以及不可写内存共享）</p>\n<h2 id=\"进程终止\"><a href=\"#进程终止\" class=\"headerlink\" title=\"进程终止\"></a>进程终止</h2><ul>\n<li>正常退出（资源）Unix,exit(); Windows,ExitProcess</li>\n<li>出错退出（自愿）不正确使用，进程可检测到的错误</li>\n<li>严重错误（非自愿）非法指令，引用不存在的内存，除零</li>\n<li>被其他进程杀死（非自愿）Unix,kill; Windows,TerminateProcess</li>\n</ul>\n<h2 id=\"进程层次\"><a href=\"#进程层次\" class=\"headerlink\" title=\"进程层次\"></a>进程层次</h2><p>Unix中，进程和它的所有的子女以及后裔共同组成一个进程组。进程树以init进程为根的一棵树。Windows进程之间的地位是平等的。</p>\n<h2 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h2><p>在多进程系统中，由于某一瞬间只有一个进程独占CPU，而进程在运行时可能需要等待某些条件满足后才能继续运行，此时进程必须暂停以等待条件满足，由此引出进程的三种基本状态：</p>\n<ul>\n<li>运行态：此时进程实际占用CPU</li>\n<li>就绪态：进程已经准备好可以运行，但是由于CPU正在使用而暂时停止</li>\n<li>阻塞态：进程在等待外部条件的满足或者外部事件的发生，否则进程不能运行</li>\n</ul>\n<p>如下图为三种基本状态之间的转换关系</p>\n<p><img src=\"/images/process-status.png\" alt=\"进程状态转换\"></p>\n<ol>\n<li>运行态-&gt;阻塞态：比如等待某种I/O操作，像等待用户输入，还有可能是进程调用等待函数主动进入阻塞</li>\n<li>运行态-&gt;就绪态：调度程序调度另外一个进程使用CPU，一般为时间片用完、高优先级抢占等。</li>\n<li>就绪态-&gt;运行态：调度程序选中当前进程上CPU</li>\n<li>阻塞态-&gt;就绪态：外部事件已发生，进程由阻塞态转变为就绪态，如果此时CPU空闲可能立刻调度转变为运行态</li>\n</ol>\n<h2 id=\"进程实现\"><a href=\"#进程实现\" class=\"headerlink\" title=\"进程实现\"></a>进程实现</h2><p>为了实现进程模型，系统维护一张进程表，每个进程占用一个项，该项被称为进程控制块（Process Control Block, PCB），进程控制块是操作系统用于管理进程而设计的专用数据结构，其主要内容可分为：</p>\n<ul>\n<li>进程描述信息</li>\n</ul>\n<p>用描述一个进程的基本信息，比如进程标识符（process ID, PID）、进程名、用户标识符、进程组关系等。</p>\n<ul>\n<li>进程控制信息</li>\n</ul>\n<p>用于操作系统控制进程的运行，包括当前状态、优先级、代码执行入口地址、程序磁盘地址、运行统计时间（执行时间、页面调度）、进程同步与通信、进程队列指针、进程消息队列指针。</p>\n<ul>\n<li>拥有资源及使用情况</li>\n</ul>\n<p>保存当前进程虚拟地址空间的状况、打开的文件等资源情况。</p>\n<ul>\n<li>CPU现场信息</li>\n</ul>\n<p>保存CPU寄存器值（通用寄存器、程序计数器PC、程序状态字PSW、栈指针等）、进程页表指针。</p>\n<p>从操作系统作为资源管理者的角度而言，PCB的主要内容也可分为以下几类：</p>\n<ul>\n<li>进程管理</li>\n</ul>\n<p>保存进程基本管理信息，诸如寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、进程ID等</p>\n<ul>\n<li>存储管理</li>\n</ul>\n<p>保存正文段指针、数据段指针、堆栈段指针</p>\n<ul>\n<li>文件管理</li>\n</ul>\n<p>保存根目录、当前工作目录、文件描述符等</p>\n<h2 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><p>进程控制是指控制进程完成不同状态之间的转换操作，使用特定功能的原语（又称为原子操作，是完成特定功能的一段程序，具有不可分割性或不可中断性，在实际实现中可通过屏蔽中断实现）完成。进程控制的原语主要有：</p>\n<ul>\n<li><p>进程创建原语</p>\n<ol>\n<li>给新进程分配一个唯一标识以及进程控制块</li>\n<li>分配地址空间</li>\n<li>初始化控制块</li>\n<li>将进程插入到就绪队列中</li>\n</ol>\n</li>\n<li><p>进程撤销原语</p>\n<ol>\n<li>收回进程占用的资源，如关闭打开的文件、断开网络链接、回收内存</li>\n<li>撤销该进程的进程控制块PCB</li>\n</ol>\n</li>\n<li><p>阻塞原语</p>\n<ol>\n<li>有进程自己执行阻塞原语，等待事件发生</li>\n<li>Unix, wait; Windows, WaitForSingleObject</li>\n</ol>\n</li>\n<li><p>唤醒原语</p>\n</li>\n<li><p>挂起原语</p>\n</li>\n<li><p>激活原语</p>\n</li>\n<li><p>优先级改变原语</p>\n</li>\n</ul>\n<h2 id=\"Unix进程控制操作\"><a href=\"#Unix进程控制操作\" class=\"headerlink\" title=\"Unix进程控制操作\"></a>Unix进程控制操作</h2><ul>\n<li>fork</li>\n</ul>\n<p>fork通过复制调用进程来新建一个进程，其基本过程如下</p>\n<ol>\n<li>为子进程分配一个空闲的进程描述符proc（即PCB）结构</li>\n<li>给子进程分配唯一进程标识PID</li>\n<li>以一次一页的方式复制父进程的地址空间（Linux使用COW技术，Copy On Write）</li>\n<li>从父进程出继承共享资源比如打开的文件和当前工作目录等</li>\n<li>将子进程设为就绪态并插入就绪队列</li>\n<li>在父进程中返回子进程的PID值，子进程中返回0，即一次调用两次返回</li>\n</ol>\n<ul>\n<li>exec</li>\n</ul>\n<p>由一系列系统调用组成，通过一段新的程序代码覆盖掉原来的地址空间，实现执行代码的转换</p>\n<ul>\n<li>wait</li>\n</ul>\n<p>提供初级的同步操作，使一个进程等待另外一个一个进程的结束</p>\n<ul>\n<li>exit</li>\n</ul>\n<p>终止一个进程的运行</p>\n<h2 id=\"进程分类\"><a href=\"#进程分类\" class=\"headerlink\" title=\"进程分类\"></a>进程分类</h2><ol>\n<li><p>第一种分类</p>\n<ul>\n<li>系统进程</li>\n<li>用户进程</li>\n</ul>\n</li>\n<li><p>第二种分类</p>\n<ul>\n<li>前台进程</li>\n<li>后台进程</li>\n</ul>\n</li>\n<li><p>第三种分类</p>\n<ul>\n<li>CPU密集型进程</li>\n<li>IO密集型进程</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"进程和程序的区别\"><a href=\"#进程和程序的区别\" class=\"headerlink\" title=\"进程和程序的区别\"></a>进程和程序的区别</h2><ul>\n<li>进程能够准确刻画并发，程序不能</li>\n<li>进程是动态的，而程序是静态的</li>\n<li>进程有生命周期，有创建终止，而程序则相对长久的</li>\n<li>一个进程能对应一个程序，而一个程序可以对应多个进程。</li>\n</ul>\n<h2 id=\"进程地址空间\"><a href=\"#进程地址空间\" class=\"headerlink\" title=\"进程地址空间\"></a>进程地址空间</h2><p>每个进程有自己独立的地址空间，对于采用虚拟内存管理的操作系统，地址空间的地址是虚拟地址，需要进行映射以转换到实际物理内存地址。基本结构如下图所示：<br><img src=\"/images/process-address-space.png\" alt=\"进程地址空间\"></p>\n<h2 id=\"进程映像（IMAGE）\"><a href=\"#进程映像（IMAGE）\" class=\"headerlink\" title=\"进程映像（IMAGE）\"></a>进程映像（IMAGE）</h2><p>和进程地址空间关联的一个概念为进程映像，其是指对进程执行活动全过程的静态描述，由地址空间内容、硬件寄存器、相关的内核数据结构、内和栈组成。是某一瞬间进程的快照。具体内容有：</p>\n<ul>\n<li>用户相关:进程地址空间（代码段、数据段、堆和栈、共享库等）</li>\n<li>寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等</li>\n<li>内核相关<ol>\n<li>静态部分：PCB以及各种资源结构</li>\n<li>动态部分：内和栈</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"进程上下文（CONTEXT）切换\"><a href=\"#进程上下文（CONTEXT）切换\" class=\"headerlink\" title=\"进程上下文（CONTEXT）切换\"></a>进程上下文（CONTEXT）切换</h2><p>将CPU硬件从一个进程换到另外一个进程的过程称为上下文切换。当进程运行时，其硬件状态保存在CPU的寄存器中；当进程不运行时，这些寄存器保存在进程控制块PCB中。如果切换进程则需要将PCB控制块保存的寄存器信息送入CPU寄存器中。</p>\n<h1 id=\"线程基本概念\"><a href=\"#线程基本概念\" class=\"headerlink\" title=\"线程基本概念\"></a>线程基本概念</h1><p>进程是一个操作系统资源分配与调度的基本单位，但是在实际应用时，一个应用内部可以划分为多个不同的执行线路或者说细分为更小的任务，执行线路在某种程度上可以进行一定程度的并行，同时执行线路之间通过共享地址空间来协作完成整个任务。而进程作为资源分配与调度的基本单位，如果将这两者分离，让进程完成资源的集中，线程完成实际的执行过程。由此引入线程的概念。至此进程成为资源的分配单位而线程分别称为CPU的实际调度单位。也可以认为线程是进程中的一个运行的实体。</p>\n<h2 id=\"线程的属性\"><a href=\"#线程的属性\" class=\"headerlink\" title=\"线程的属性\"></a>线程的属性</h2><p>线程主要具有如下属性：</p>\n<ul>\n<li>有标识符ID</li>\n<li>有状态及状态转换</li>\n<li>需要保存上下文环境</li>\n<li>有自己的栈和指针</li>\n<li>共享进程的地址空间和其他资源</li>\n<li>线程可撤销和创建</li>\n</ul>\n<p>实际在进程创建后程序以单线程的方式运行，通过thread_create等系统调用可以创建新线程。</p>\n<h2 id=\"线程的实现\"><a href=\"#线程的实现\" class=\"headerlink\" title=\"线程的实现\"></a>线程的实现</h2><p>在线程的实际实现中，同有如下三种方法：</p>\n<ul>\n<li>用户级线程</li>\n</ul>\n<p>在用户空间建立线程库，通过运行时系统进行线程的管理，此时内核对于线程一无所知。由于线程也存在状态的转换，因此和进程类似，在每个进程中需要有专用的线程表来跟踪记录各个线程的属性（如程序计数器、堆栈指针、寄存器和状态等），线程表由运行时系统进行管理。</p>\n<p>用户级线程由于自身的特点，主要有如下优缺点：</p>\n<ol>\n<li><p>优点</p>\n<ol>\n<li>线程与线程之间切换速度快，只需要切换堆栈指针程序计数器等，通常几条指令就可完成线程的切换</li>\n<li>线程调度算法可以由每个进程自己定制</li>\n<li>用户级线程可以方便在任何系统中实现，只需实现线程库即可</li>\n</ol>\n</li>\n<li><p>缺点</p>\n<ol>\n<li>由于内核对线程一无所知，此时系统调度的单位为进程，因此多线程只能在一个CPU上运行</li>\n<li>由于多数系统调用是阻塞的，一旦线程调用了阻塞的系统调用，内核将阻塞整个进程，即所有的线程被阻塞</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>核心级线程</li>\n</ul>\n<p>核心级线程需要改造操作系统，由内核直接管理所有的线程。此时进程无需专用的线程表而改由内核来记录线程表。此时线程调度有内核完成，当一个线程被阻塞时，内核可以选择运行进程中的另外一个线程而不是直接将整个进程阻塞。在核心级线程实现中，内核需要维护进程表和线程表。</p>\n<p>核心级线程实现通常有如下优缺点：</p>\n<ol>\n<li>优点<ol>\n<li>内核无需新的非阻塞的系统调用</li>\n<li>线程阻塞不会导致整个进程的阻塞</li>\n</ol>\n</li>\n<li>缺点<ol>\n<li>在内核中创建或者撤销线程的代价比较大</li>\n<li>需要改造操作系统</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>混合实现</li>\n</ul>\n<p>由于用户级线程实现以及核心级线程实现均有其优缺点，通过综合两者的优点从而形成混合实现。在这种是实现中，由编程人员决定有多少个内核级线程与用户级线程，内核只识别内核级线程并进行调度。多个用户级线程通过多路复用来复用多个内核级线程，如下图为多路复用模型：</p>\n<p><img src=\"/images/multiplexer.png\" alt=\"多路复用模型\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"进程定义\"><a href=\"#进程定义\" class=\"headerlink\" title=\"进程定义\"></a>进程定义</h2><p>进程是操作系统最核心的概念，进程是对正在运行程序的一个抽象。</p>\n<p>进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进程资源分配和调度的独立单位。</p>\n<p>严格而言，在某一个瞬间CPU只能运行一个进程，但在较长时间间隔下，操作系统可能运行了多个进程，由此导致并行的错觉，实际上只能认为是并发而不是真正的并行。</p>\n<h2 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h2><p>在进程模型中，计算机所有可运行的软件（包括）操作系统，被组织成若干个顺序进程（sequence process），简称进程。进程是正在执行程序的实例，包括程序计数器、寄存器、变量的当前值。进程和程序之间的区别就和做菜与菜谱之间的关系，进程是动态的，程序是静态的。</p>\n<h2 id=\"进程创建\"><a href=\"#进程创建\" class=\"headerlink\" title=\"进程创建\"></a>进程创建</h2><ul>\n<li>系统初始化</li>\n<li>执行了正在运行的进程所调用的进程创建系统调用</li>\n<li>用户请求创建一个新进程</li>\n<li>一个批处理作业的初始化</li>\n</ul>\n<p>守护进程：停留在后台处理诸如电子邮件、Web页面、新闻、打印之类的进程。</p>\n<p>Unix创建新进程：fork, exec。<br>Windows创建新进程：CreateProcess。</p>\n<p>在Unix和WIndows中，进程创建后父子进程各自有不同的地址空间。（实际实现中Linux有写时复制以及不可写内存共享）</p>\n<h2 id=\"进程终止\"><a href=\"#进程终止\" class=\"headerlink\" title=\"进程终止\"></a>进程终止</h2><ul>\n<li>正常退出（资源）Unix,exit(); Windows,ExitProcess</li>\n<li>出错退出（自愿）不正确使用，进程可检测到的错误</li>\n<li>严重错误（非自愿）非法指令，引用不存在的内存，除零</li>\n<li>被其他进程杀死（非自愿）Unix,kill; Windows,TerminateProcess</li>\n</ul>\n<h2 id=\"进程层次\"><a href=\"#进程层次\" class=\"headerlink\" title=\"进程层次\"></a>进程层次</h2><p>Unix中，进程和它的所有的子女以及后裔共同组成一个进程组。进程树以init进程为根的一棵树。Windows进程之间的地位是平等的。</p>\n<h2 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h2><p>在多进程系统中，由于某一瞬间只有一个进程独占CPU，而进程在运行时可能需要等待某些条件满足后才能继续运行，此时进程必须暂停以等待条件满足，由此引出进程的三种基本状态：</p>\n<ul>\n<li>运行态：此时进程实际占用CPU</li>\n<li>就绪态：进程已经准备好可以运行，但是由于CPU正在使用而暂时停止</li>\n<li>阻塞态：进程在等待外部条件的满足或者外部事件的发生，否则进程不能运行</li>\n</ul>\n<p>如下图为三种基本状态之间的转换关系</p>\n<p><img src=\"/images/process-status.png\" alt=\"进程状态转换\"></p>\n<ol>\n<li>运行态-&gt;阻塞态：比如等待某种I/O操作，像等待用户输入，还有可能是进程调用等待函数主动进入阻塞</li>\n<li>运行态-&gt;就绪态：调度程序调度另外一个进程使用CPU，一般为时间片用完、高优先级抢占等。</li>\n<li>就绪态-&gt;运行态：调度程序选中当前进程上CPU</li>\n<li>阻塞态-&gt;就绪态：外部事件已发生，进程由阻塞态转变为就绪态，如果此时CPU空闲可能立刻调度转变为运行态</li>\n</ol>\n<h2 id=\"进程实现\"><a href=\"#进程实现\" class=\"headerlink\" title=\"进程实现\"></a>进程实现</h2><p>为了实现进程模型，系统维护一张进程表，每个进程占用一个项，该项被称为进程控制块（Process Control Block, PCB），进程控制块是操作系统用于管理进程而设计的专用数据结构，其主要内容可分为：</p>\n<ul>\n<li>进程描述信息</li>\n</ul>\n<p>用描述一个进程的基本信息，比如进程标识符（process ID, PID）、进程名、用户标识符、进程组关系等。</p>\n<ul>\n<li>进程控制信息</li>\n</ul>\n<p>用于操作系统控制进程的运行，包括当前状态、优先级、代码执行入口地址、程序磁盘地址、运行统计时间（执行时间、页面调度）、进程同步与通信、进程队列指针、进程消息队列指针。</p>\n<ul>\n<li>拥有资源及使用情况</li>\n</ul>\n<p>保存当前进程虚拟地址空间的状况、打开的文件等资源情况。</p>\n<ul>\n<li>CPU现场信息</li>\n</ul>\n<p>保存CPU寄存器值（通用寄存器、程序计数器PC、程序状态字PSW、栈指针等）、进程页表指针。</p>\n<p>从操作系统作为资源管理者的角度而言，PCB的主要内容也可分为以下几类：</p>\n<ul>\n<li>进程管理</li>\n</ul>\n<p>保存进程基本管理信息，诸如寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、进程ID等</p>\n<ul>\n<li>存储管理</li>\n</ul>\n<p>保存正文段指针、数据段指针、堆栈段指针</p>\n<ul>\n<li>文件管理</li>\n</ul>\n<p>保存根目录、当前工作目录、文件描述符等</p>\n<h2 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><p>进程控制是指控制进程完成不同状态之间的转换操作，使用特定功能的原语（又称为原子操作，是完成特定功能的一段程序，具有不可分割性或不可中断性，在实际实现中可通过屏蔽中断实现）完成。进程控制的原语主要有：</p>\n<ul>\n<li><p>进程创建原语</p>\n<ol>\n<li>给新进程分配一个唯一标识以及进程控制块</li>\n<li>分配地址空间</li>\n<li>初始化控制块</li>\n<li>将进程插入到就绪队列中</li>\n</ol>\n</li>\n<li><p>进程撤销原语</p>\n<ol>\n<li>收回进程占用的资源，如关闭打开的文件、断开网络链接、回收内存</li>\n<li>撤销该进程的进程控制块PCB</li>\n</ol>\n</li>\n<li><p>阻塞原语</p>\n<ol>\n<li>有进程自己执行阻塞原语，等待事件发生</li>\n<li>Unix, wait; Windows, WaitForSingleObject</li>\n</ol>\n</li>\n<li><p>唤醒原语</p>\n</li>\n<li><p>挂起原语</p>\n</li>\n<li><p>激活原语</p>\n</li>\n<li><p>优先级改变原语</p>\n</li>\n</ul>\n<h2 id=\"Unix进程控制操作\"><a href=\"#Unix进程控制操作\" class=\"headerlink\" title=\"Unix进程控制操作\"></a>Unix进程控制操作</h2><ul>\n<li>fork</li>\n</ul>\n<p>fork通过复制调用进程来新建一个进程，其基本过程如下</p>\n<ol>\n<li>为子进程分配一个空闲的进程描述符proc（即PCB）结构</li>\n<li>给子进程分配唯一进程标识PID</li>\n<li>以一次一页的方式复制父进程的地址空间（Linux使用COW技术，Copy On Write）</li>\n<li>从父进程出继承共享资源比如打开的文件和当前工作目录等</li>\n<li>将子进程设为就绪态并插入就绪队列</li>\n<li>在父进程中返回子进程的PID值，子进程中返回0，即一次调用两次返回</li>\n</ol>\n<ul>\n<li>exec</li>\n</ul>\n<p>由一系列系统调用组成，通过一段新的程序代码覆盖掉原来的地址空间，实现执行代码的转换</p>\n<ul>\n<li>wait</li>\n</ul>\n<p>提供初级的同步操作，使一个进程等待另外一个一个进程的结束</p>\n<ul>\n<li>exit</li>\n</ul>\n<p>终止一个进程的运行</p>\n<h2 id=\"进程分类\"><a href=\"#进程分类\" class=\"headerlink\" title=\"进程分类\"></a>进程分类</h2><ol>\n<li><p>第一种分类</p>\n<ul>\n<li>系统进程</li>\n<li>用户进程</li>\n</ul>\n</li>\n<li><p>第二种分类</p>\n<ul>\n<li>前台进程</li>\n<li>后台进程</li>\n</ul>\n</li>\n<li><p>第三种分类</p>\n<ul>\n<li>CPU密集型进程</li>\n<li>IO密集型进程</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"进程和程序的区别\"><a href=\"#进程和程序的区别\" class=\"headerlink\" title=\"进程和程序的区别\"></a>进程和程序的区别</h2><ul>\n<li>进程能够准确刻画并发，程序不能</li>\n<li>进程是动态的，而程序是静态的</li>\n<li>进程有生命周期，有创建终止，而程序则相对长久的</li>\n<li>一个进程能对应一个程序，而一个程序可以对应多个进程。</li>\n</ul>\n<h2 id=\"进程地址空间\"><a href=\"#进程地址空间\" class=\"headerlink\" title=\"进程地址空间\"></a>进程地址空间</h2><p>每个进程有自己独立的地址空间，对于采用虚拟内存管理的操作系统，地址空间的地址是虚拟地址，需要进行映射以转换到实际物理内存地址。基本结构如下图所示：<br><img src=\"/images/process-address-space.png\" alt=\"进程地址空间\"></p>\n<h2 id=\"进程映像（IMAGE）\"><a href=\"#进程映像（IMAGE）\" class=\"headerlink\" title=\"进程映像（IMAGE）\"></a>进程映像（IMAGE）</h2><p>和进程地址空间关联的一个概念为进程映像，其是指对进程执行活动全过程的静态描述，由地址空间内容、硬件寄存器、相关的内核数据结构、内和栈组成。是某一瞬间进程的快照。具体内容有：</p>\n<ul>\n<li>用户相关:进程地址空间（代码段、数据段、堆和栈、共享库等）</li>\n<li>寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等</li>\n<li>内核相关<ol>\n<li>静态部分：PCB以及各种资源结构</li>\n<li>动态部分：内和栈</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"进程上下文（CONTEXT）切换\"><a href=\"#进程上下文（CONTEXT）切换\" class=\"headerlink\" title=\"进程上下文（CONTEXT）切换\"></a>进程上下文（CONTEXT）切换</h2><p>将CPU硬件从一个进程换到另外一个进程的过程称为上下文切换。当进程运行时，其硬件状态保存在CPU的寄存器中；当进程不运行时，这些寄存器保存在进程控制块PCB中。如果切换进程则需要将PCB控制块保存的寄存器信息送入CPU寄存器中。</p>\n<h1 id=\"线程基本概念\"><a href=\"#线程基本概念\" class=\"headerlink\" title=\"线程基本概念\"></a>线程基本概念</h1><p>进程是一个操作系统资源分配与调度的基本单位，但是在实际应用时，一个应用内部可以划分为多个不同的执行线路或者说细分为更小的任务，执行线路在某种程度上可以进行一定程度的并行，同时执行线路之间通过共享地址空间来协作完成整个任务。而进程作为资源分配与调度的基本单位，如果将这两者分离，让进程完成资源的集中，线程完成实际的执行过程。由此引入线程的概念。至此进程成为资源的分配单位而线程分别称为CPU的实际调度单位。也可以认为线程是进程中的一个运行的实体。</p>\n<h2 id=\"线程的属性\"><a href=\"#线程的属性\" class=\"headerlink\" title=\"线程的属性\"></a>线程的属性</h2><p>线程主要具有如下属性：</p>\n<ul>\n<li>有标识符ID</li>\n<li>有状态及状态转换</li>\n<li>需要保存上下文环境</li>\n<li>有自己的栈和指针</li>\n<li>共享进程的地址空间和其他资源</li>\n<li>线程可撤销和创建</li>\n</ul>\n<p>实际在进程创建后程序以单线程的方式运行，通过thread_create等系统调用可以创建新线程。</p>\n<h2 id=\"线程的实现\"><a href=\"#线程的实现\" class=\"headerlink\" title=\"线程的实现\"></a>线程的实现</h2><p>在线程的实际实现中，同有如下三种方法：</p>\n<ul>\n<li>用户级线程</li>\n</ul>\n<p>在用户空间建立线程库，通过运行时系统进行线程的管理，此时内核对于线程一无所知。由于线程也存在状态的转换，因此和进程类似，在每个进程中需要有专用的线程表来跟踪记录各个线程的属性（如程序计数器、堆栈指针、寄存器和状态等），线程表由运行时系统进行管理。</p>\n<p>用户级线程由于自身的特点，主要有如下优缺点：</p>\n<ol>\n<li><p>优点</p>\n<ol>\n<li>线程与线程之间切换速度快，只需要切换堆栈指针程序计数器等，通常几条指令就可完成线程的切换</li>\n<li>线程调度算法可以由每个进程自己定制</li>\n<li>用户级线程可以方便在任何系统中实现，只需实现线程库即可</li>\n</ol>\n</li>\n<li><p>缺点</p>\n<ol>\n<li>由于内核对线程一无所知，此时系统调度的单位为进程，因此多线程只能在一个CPU上运行</li>\n<li>由于多数系统调用是阻塞的，一旦线程调用了阻塞的系统调用，内核将阻塞整个进程，即所有的线程被阻塞</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>核心级线程</li>\n</ul>\n<p>核心级线程需要改造操作系统，由内核直接管理所有的线程。此时进程无需专用的线程表而改由内核来记录线程表。此时线程调度有内核完成，当一个线程被阻塞时，内核可以选择运行进程中的另外一个线程而不是直接将整个进程阻塞。在核心级线程实现中，内核需要维护进程表和线程表。</p>\n<p>核心级线程实现通常有如下优缺点：</p>\n<ol>\n<li>优点<ol>\n<li>内核无需新的非阻塞的系统调用</li>\n<li>线程阻塞不会导致整个进程的阻塞</li>\n</ol>\n</li>\n<li>缺点<ol>\n<li>在内核中创建或者撤销线程的代价比较大</li>\n<li>需要改造操作系统</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>混合实现</li>\n</ul>\n<p>由于用户级线程实现以及核心级线程实现均有其优缺点，通过综合两者的优点从而形成混合实现。在这种是实现中，由编程人员决定有多少个内核级线程与用户级线程，内核只识别内核级线程并进行调度。多个用户级线程通过多路复用来复用多个内核级线程，如下图为多路复用模型：</p>\n<p><img src=\"/images/multiplexer.png\" alt=\"多路复用模型\"></p>\n"},{"title":"进程或线程死锁","urlname":"dead-lock","date":"2018-03-24T02:56:31.000Z","copyright":true,"mathjax":true,"_content":"\n## 死锁基本概念\n\n死锁是指在一组进程中，每个进程都无限等待该组进程中另一个进程所占有的资源而导致永远无法等到资源的现象，这一组进程被称为死锁进程。死锁一旦发生，将会极大浪费系统资源以及可能造成系统崩溃。\n\n## 死锁原因\n\n从死锁的基本概念可以得知，死锁是发生在进程申请资源而得不到满足同时又互相僵持导致的，因此死锁原因可以归纳为两种：\n\n\t1. 资源数量有限，进程之间需要竞争资源\n\t2. 进程请求释放资源顺序不合理，即进程间推进顺序不合理\n\n### 资源有限导致资源竞争引起死锁\n\n在操作系统中，资源可分为可重用资源以及可消耗资源。可重用资源是指资源可以被重复利用，如CPU、I/O设备、内存、文件、信号量等；而可消耗资源则是只能使用一次，如中断、信号、消息等。可重用资源按照资源属性又可分为以下两种：\n\n- 可剥夺性资源\n\n指进程在获得某资源后可以其他进程或者系统被剥夺，主要有CPU、IO设备、内存、文件、数据库、信号量等\n\n- 不可剥夺资源\n\n不可剥夺资源是指资源被分配后不能被强行收回，比如打印机、磁带机等，因为这些资源如果可以被剥夺将会导致输出结果错误\n\n### 活锁\n\n假设两个资源R1、R2和两个进程P1、P2。P1已经给资源R1加锁，同时申请资源R2；P2已经已经给资源R2加锁，同时申请资源R1。由于资源已被加锁，进程P1、P2不断轮询资源尝试加锁，两个进程即没有推进也没有阻塞，这种情况称为活锁。\n\n### 饥饿\n\n假设有资源R1，进程P1正在使用资源R1，接着有进程P2、P3、P4也在申请R1，此时系统决定依次将资源R1分配给P3、P4而导致进程P2一直得不到资源的情况。\n\n## 死锁必要条件\n\n### 互斥条件\n\n互斥条件又可以称为资源独占，是指在一段时间内资源只能被一个进程中占有，其他进程只能等待直到占有进程把资源释放掉。\n\n### 占有且等待\n\n又称为请求和保持条件，是指进程在申请其他资源而资源被占用时，申请进程阻塞但是并不释放自己已占有的资源。\n\n### 不可抢占\n\n又称为不可剥夺条件，指进程已获得资源后，除非使用结束或者主动释放，其他进程不可以抢占\n\n### 循环等待\n\n是指有一个进程组P1、P2、P3....Pn。P1等待P2占有的资源，P2等待P3占有的资源.....，Pn等待P1资源。形成一个等待环路\n\n## 死锁资源分配图描述\n\n### 资源分配图基本定义\n\n为了检测是否有死锁发生，可以使用资源分配图来判断。资源分配图由一组结点N和一组边E所组成的对偶G=(N,E)。结点N分为两个互斥的子集，包括一组进程结点和一组资源结点。边由资源节点与进程结点连线构成，如果进程申请资源则边的方向为进程结点指向资源节点，反之则由资源结点指向进程结点。\n\n如下图为一个简单的资源分配图：[图片来源](http://c.biancheng.net/cpp/html/2607.html)\n\n![资源分配图](/images/resource-assignment.jpg)\n\n其中圆圈代表某一个进程，方框代表某一组同类资源。\n\n### 死锁定理\n\n对于一个确定的资源分配图，死锁定理指出如果图中不存在环路，则一定不会发生死锁，否则**有可能**发生死锁（每类资源实例有多个）。如果每类资源的个数为1，则环路是否存在将成为死锁存在的充分必要条件，即环路存在可以推断出发生死锁，发生死锁也可以推断出环路存在。\n\n### 资源分配图简化\n\n在分析复杂的资源分配图时，可以使用简化方式去判断是否存在死锁，简化过程如下：\n\n\t1. 在资源分配图中找到一个只有分配边的进程结点Pi，由于Pi有全部需要的资源，其可运行结束并释放所有资源，即将分配边删除。\n\t2. 在第一步释放资源后将占有资源分配给等待进程，接着找到只有分配边的进程结点，也将分配边删除\n\t3. 重复上述两步知道所有的边都可以被删除则称资源分配图时可以完全简化的，否则称为不可完全简化的\n\n上诉简化完成后死锁的充分必要条件有：如果资源图是可以完全简化的则不存在死锁，否则存死锁。\n\n\n## 死锁解决\n\n根据死锁解决的思想，死锁解决可分为几种情况\n\n\t1. 不考虑死锁问题，即鸵鸟算法\n\t2. 不让死锁发生，有死锁预防（静态策略）与死锁避免（动态策略）\n\t3. 让死锁发生，然后解除死锁\n\n### 死锁预防\n\n死锁预防是指在设计资源分配算法时就考虑不发生死锁，是一种静态的死锁解决方案。其通过设定某些限制条件去破坏死锁的四个必要条件，但是可能由于施加的限制过于严格而导致系统资源利用率低下，减少资源吞吐量。\n\n根据破坏四个条件不同有如下做法：\n\n\t1. 破坏互斥条件，虚拟化技术将互斥资源虚拟成共享资源，如打印机的SPOOLing技术\n\t2. 破坏占有且等待，比如一次性申请所需资源或者再申请新资源得不到满足时释放已占有的资源\n\t3. 破坏不可抢占条件，优先级抢占等，需要保证资源易于恢复\n\t4. 破坏循环等待条件，系统给资源进行线性排队，进程资源申请只能按照线性顺序逐步申请，可能会造成资源浪费\n\n\n### 死锁避免\n\n死锁避免是指算法跟踪资源的分配情况，评估系统的安全状态，使得资源分配不会使系统进入不安全状态，死锁避免的限制较弱，可以获得较高的资源利用率和系统吞吐量。死锁避免经典算法有银行家算法。\n\n安全序列是指这样一个进程序列{P1,P2,P3...Pn}，对于每一个进程Pi，Pi所需要的资源总数不大于系统剩余资源总数以及进程Pi之前进程占有资源总数之和，则称为安全序列。\n\n银行家算法应用有系列的条件，如下所示：\n\n\t1. 在固定数量的进程中共享数量固定的资源\n\t2. 每个进程预先指定完成工作量所需的最大资源数量\n\t3. 进程不允许申请比系统可用资源总数还多的资源\n\t4. 进程等待资源时间有限\n\t5. 如果系统满足了进程的资源请求，进程应该在有限时间内归还\n\n银行家基本数据结构如下：\n\n\t1. 可用资源数量available，含有m个元素，表示第i个元素的可用资源数量\n\t2. 最大需求矩阵maxNeed，是一个n*m的矩阵，maxNeed[i][j]代表第i个进程对第j个资源的最大需求量\n\t3. 分配矩阵allocation，是一个n*m的矩阵，allocation[i][j]代表第i个进程已获得第j个资源数量\n\t4. 需求矩阵need，是一个n*m的矩阵，need[i][j]代表第i个进程还需要第j个资源数量\n\t5. 请求资源矩阵request，是一个n*m的矩阵，request[i][j]代表第i个进程向系统请求第j个资源数量\n\n银行家算法实现基本步骤如下：\n\n\t1. 先检查request[i][0~m-1]<=need[i][0~m-1]，如果不满足则出错返回\n\t2. 再检查request[i][0~m-1]<=available[0~m-1]，如果不满足则出错返回\n\t3. 系统尝试将资源分配给进程，并修改available、allocation、need矩阵\n\t4. 运行安全状态检查算法，检查如果按照当前分配是否会导致不安全状态出现，如果不安全则恢复，否则完成分配\n\n银行家安全状态检查算法基本步骤如下：\n\n\t1. 定义工作向量work[m]表示系统可提供的资源数量，安全算法执行初态work=available\n\t2. 定义finish[n]向量，初始值为false，当有足够资源分配给进程i时令finish[i]=true\n\t3. 在进程集合中找到满足以下条件的进程i：finish[i]=false，need[i][0~m]<=work[0~m]\n\t4. 若第三步成功更新work[j]=work[j]+allocation[i][j]，finish[i]=true\n\t5. 如果所有进程最后finish[i]=true，则系统处于安全状态，否则处于不安全状态，不能分配资源\n\n以下为银行家算法的实现代码\n\n```cpp\n//数据结构\nconst int m = 3; //资源类别数\nconst int n = 5; //进程数\n\nstruct Banker\n{\n\tint available[m]; //可用资源数向量\n\tint maxNeed[n][m]; //每个进程最大资源需求量\n\tint allocation[n][m]; //已分配资源\n\tint need[n][m]; //还需要的资源数\n};\n\nint request[n][m]; //进程请求资源矩阵\n\n\nbool SafeStatusCheck(Banker &inStatus)\n{\n\tint work[m];\n\tfor (int i = 0; i < m; i++) {\n\t\twork[i] = inStatus.available[i];\n\t}\n\tbool finish[n] = {false};\n\tset<int> okSet;\n\twhile (1) {\n\t\tbool hasOne = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ((okSet.find(i)) != okSet.end()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (inStatus.need[i][j] > work[j]) {\n\t\t\t\t\tok = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tokSet.insert(okSet.end(), i);\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\twork[j] += inStatus.allocation[i][j];\n\t\t\t\t}\n\t\t\t\thasOne = true; break;\n\t\t\t}\n\t\t}\n\t\tif (okSet.size() >= n) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!hasOne) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool BankerAllocate(Banker &inStatus, int pid, int request[m])\n{\n\tfor (int i = 0; i < m; i++) {\n\t\tif (inStatus.need[pid][i] < request[i] || request[i] > inStatus.available[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tinStatus.available[i] -= request[i];\n\t\tinStatus.allocation[pid][i] += request[i];\n\t\tinStatus.need[pid][i] -= request[i];\n\t}\n\tbool canAlloc = SafeStatusCheck(inStatus);\n\tif (canAlloc) {\n\t\treturn true;\n\t}\n\telse {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tinStatus.available[m] += request[i];\n\t\t\tinStatus.allocation[pid][i] -= request[i];\n\t\t\tinStatus.need[pid][i] += request[i];\n\t\t}\n\t\treturn false;\n\t}\n\t\n}\n\n\nvoid CopyData(Banker &inStatus, int inAv[m], int inMax[n][m], int inAlloc[n][m], int inNeed[n][m])\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tinStatus.available[j] = inAv[j];\n\t\t\tinStatus.maxNeed[i][j] = inMax[i][j];\n\t\t\tinStatus.allocation[i][j] = inAlloc[i][j];\n\t\t\tinStatus.need[i][j] = inNeed[i][j];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tBanker TestStatus = {0};\n\tint tmpAv[m] = {3,3,2};\n\tint tmpMax[n][m] = {{7,5,3},{3,2,2},{9,0,2},{2,2,2},{4,3,3}};\n\tint tmpAlloc[n][m] = {{0,1,0},{2,0,0},{3,0,2},{2,1,1},{0,0,2}};\n\tint tmpNeed[n][m] = {{7,4,3},{1,2,2},{6,0,0},{0,1,1},{4,3,1}};\n\tCopyData(TestStatus, tmpAv, tmpMax, tmpAlloc, tmpNeed);\n\n\t//初始状态\n\tint request1[m] = {0};\n\tcout << \"ini status(true):\" << BankerAllocate(TestStatus, 0, request1) << endl;\n\n\t//进程P1发出资源请求1,0,2\n\tint request2[m] = {1,0,2};\n\tcout << \"P1 can satisfied(true):\" << BankerAllocate(TestStatus, 1, request2) << endl;\n\n\t//进程P4再发出资源请求3,3,0\n\tint request3[m] = {3,3,0};\n\tcout << \"P4 can satisfied(false):\" << BankerAllocate(TestStatus, 4, request3) << endl;\n\treturn 0;\n}\n```\n\n### 死锁检测与解除\n\n如果系统没有采用策略去防止死锁的产生，那么系统必须要能够检测死锁的发生同时能够解除掉死锁。系统检测死锁可以使用资源分配图结合死锁定理完成。系统检测死锁时机可以是发现进程长时间等待或者定时检测或者检测到资源利用率下降时检测死锁。由于使用资源分配图判断死锁需要系统记录资源分配使用情况，因此系统要能够统计这些信息。在解除死锁时，在尽可能以最小代价的方式下解除，主要有撤销所有死锁进程（代价大）、进程回退再启动（代价大）、剥夺资源分配给死锁进程、逐步撤销死锁进程直到解除死锁。\n\n在死锁检测中，数据结构与银行家算法基本类似，可以直接调用SafeStatusCheck函数完成。","source":"_posts/操作系统/进程或线程死锁.md","raw":"---\ntitle: 进程或线程死锁\nurlname: dead-lock\ndate: 2018-03-24 10:56:31\ncopyright: true\nmathjax: true\ntags:\n- 操作系统\ncategories:\n- 操作系统\n---\n\n## 死锁基本概念\n\n死锁是指在一组进程中，每个进程都无限等待该组进程中另一个进程所占有的资源而导致永远无法等到资源的现象，这一组进程被称为死锁进程。死锁一旦发生，将会极大浪费系统资源以及可能造成系统崩溃。\n\n## 死锁原因\n\n从死锁的基本概念可以得知，死锁是发生在进程申请资源而得不到满足同时又互相僵持导致的，因此死锁原因可以归纳为两种：\n\n\t1. 资源数量有限，进程之间需要竞争资源\n\t2. 进程请求释放资源顺序不合理，即进程间推进顺序不合理\n\n### 资源有限导致资源竞争引起死锁\n\n在操作系统中，资源可分为可重用资源以及可消耗资源。可重用资源是指资源可以被重复利用，如CPU、I/O设备、内存、文件、信号量等；而可消耗资源则是只能使用一次，如中断、信号、消息等。可重用资源按照资源属性又可分为以下两种：\n\n- 可剥夺性资源\n\n指进程在获得某资源后可以其他进程或者系统被剥夺，主要有CPU、IO设备、内存、文件、数据库、信号量等\n\n- 不可剥夺资源\n\n不可剥夺资源是指资源被分配后不能被强行收回，比如打印机、磁带机等，因为这些资源如果可以被剥夺将会导致输出结果错误\n\n### 活锁\n\n假设两个资源R1、R2和两个进程P1、P2。P1已经给资源R1加锁，同时申请资源R2；P2已经已经给资源R2加锁，同时申请资源R1。由于资源已被加锁，进程P1、P2不断轮询资源尝试加锁，两个进程即没有推进也没有阻塞，这种情况称为活锁。\n\n### 饥饿\n\n假设有资源R1，进程P1正在使用资源R1，接着有进程P2、P3、P4也在申请R1，此时系统决定依次将资源R1分配给P3、P4而导致进程P2一直得不到资源的情况。\n\n## 死锁必要条件\n\n### 互斥条件\n\n互斥条件又可以称为资源独占，是指在一段时间内资源只能被一个进程中占有，其他进程只能等待直到占有进程把资源释放掉。\n\n### 占有且等待\n\n又称为请求和保持条件，是指进程在申请其他资源而资源被占用时，申请进程阻塞但是并不释放自己已占有的资源。\n\n### 不可抢占\n\n又称为不可剥夺条件，指进程已获得资源后，除非使用结束或者主动释放，其他进程不可以抢占\n\n### 循环等待\n\n是指有一个进程组P1、P2、P3....Pn。P1等待P2占有的资源，P2等待P3占有的资源.....，Pn等待P1资源。形成一个等待环路\n\n## 死锁资源分配图描述\n\n### 资源分配图基本定义\n\n为了检测是否有死锁发生，可以使用资源分配图来判断。资源分配图由一组结点N和一组边E所组成的对偶G=(N,E)。结点N分为两个互斥的子集，包括一组进程结点和一组资源结点。边由资源节点与进程结点连线构成，如果进程申请资源则边的方向为进程结点指向资源节点，反之则由资源结点指向进程结点。\n\n如下图为一个简单的资源分配图：[图片来源](http://c.biancheng.net/cpp/html/2607.html)\n\n![资源分配图](/images/resource-assignment.jpg)\n\n其中圆圈代表某一个进程，方框代表某一组同类资源。\n\n### 死锁定理\n\n对于一个确定的资源分配图，死锁定理指出如果图中不存在环路，则一定不会发生死锁，否则**有可能**发生死锁（每类资源实例有多个）。如果每类资源的个数为1，则环路是否存在将成为死锁存在的充分必要条件，即环路存在可以推断出发生死锁，发生死锁也可以推断出环路存在。\n\n### 资源分配图简化\n\n在分析复杂的资源分配图时，可以使用简化方式去判断是否存在死锁，简化过程如下：\n\n\t1. 在资源分配图中找到一个只有分配边的进程结点Pi，由于Pi有全部需要的资源，其可运行结束并释放所有资源，即将分配边删除。\n\t2. 在第一步释放资源后将占有资源分配给等待进程，接着找到只有分配边的进程结点，也将分配边删除\n\t3. 重复上述两步知道所有的边都可以被删除则称资源分配图时可以完全简化的，否则称为不可完全简化的\n\n上诉简化完成后死锁的充分必要条件有：如果资源图是可以完全简化的则不存在死锁，否则存死锁。\n\n\n## 死锁解决\n\n根据死锁解决的思想，死锁解决可分为几种情况\n\n\t1. 不考虑死锁问题，即鸵鸟算法\n\t2. 不让死锁发生，有死锁预防（静态策略）与死锁避免（动态策略）\n\t3. 让死锁发生，然后解除死锁\n\n### 死锁预防\n\n死锁预防是指在设计资源分配算法时就考虑不发生死锁，是一种静态的死锁解决方案。其通过设定某些限制条件去破坏死锁的四个必要条件，但是可能由于施加的限制过于严格而导致系统资源利用率低下，减少资源吞吐量。\n\n根据破坏四个条件不同有如下做法：\n\n\t1. 破坏互斥条件，虚拟化技术将互斥资源虚拟成共享资源，如打印机的SPOOLing技术\n\t2. 破坏占有且等待，比如一次性申请所需资源或者再申请新资源得不到满足时释放已占有的资源\n\t3. 破坏不可抢占条件，优先级抢占等，需要保证资源易于恢复\n\t4. 破坏循环等待条件，系统给资源进行线性排队，进程资源申请只能按照线性顺序逐步申请，可能会造成资源浪费\n\n\n### 死锁避免\n\n死锁避免是指算法跟踪资源的分配情况，评估系统的安全状态，使得资源分配不会使系统进入不安全状态，死锁避免的限制较弱，可以获得较高的资源利用率和系统吞吐量。死锁避免经典算法有银行家算法。\n\n安全序列是指这样一个进程序列{P1,P2,P3...Pn}，对于每一个进程Pi，Pi所需要的资源总数不大于系统剩余资源总数以及进程Pi之前进程占有资源总数之和，则称为安全序列。\n\n银行家算法应用有系列的条件，如下所示：\n\n\t1. 在固定数量的进程中共享数量固定的资源\n\t2. 每个进程预先指定完成工作量所需的最大资源数量\n\t3. 进程不允许申请比系统可用资源总数还多的资源\n\t4. 进程等待资源时间有限\n\t5. 如果系统满足了进程的资源请求，进程应该在有限时间内归还\n\n银行家基本数据结构如下：\n\n\t1. 可用资源数量available，含有m个元素，表示第i个元素的可用资源数量\n\t2. 最大需求矩阵maxNeed，是一个n*m的矩阵，maxNeed[i][j]代表第i个进程对第j个资源的最大需求量\n\t3. 分配矩阵allocation，是一个n*m的矩阵，allocation[i][j]代表第i个进程已获得第j个资源数量\n\t4. 需求矩阵need，是一个n*m的矩阵，need[i][j]代表第i个进程还需要第j个资源数量\n\t5. 请求资源矩阵request，是一个n*m的矩阵，request[i][j]代表第i个进程向系统请求第j个资源数量\n\n银行家算法实现基本步骤如下：\n\n\t1. 先检查request[i][0~m-1]<=need[i][0~m-1]，如果不满足则出错返回\n\t2. 再检查request[i][0~m-1]<=available[0~m-1]，如果不满足则出错返回\n\t3. 系统尝试将资源分配给进程，并修改available、allocation、need矩阵\n\t4. 运行安全状态检查算法，检查如果按照当前分配是否会导致不安全状态出现，如果不安全则恢复，否则完成分配\n\n银行家安全状态检查算法基本步骤如下：\n\n\t1. 定义工作向量work[m]表示系统可提供的资源数量，安全算法执行初态work=available\n\t2. 定义finish[n]向量，初始值为false，当有足够资源分配给进程i时令finish[i]=true\n\t3. 在进程集合中找到满足以下条件的进程i：finish[i]=false，need[i][0~m]<=work[0~m]\n\t4. 若第三步成功更新work[j]=work[j]+allocation[i][j]，finish[i]=true\n\t5. 如果所有进程最后finish[i]=true，则系统处于安全状态，否则处于不安全状态，不能分配资源\n\n以下为银行家算法的实现代码\n\n```cpp\n//数据结构\nconst int m = 3; //资源类别数\nconst int n = 5; //进程数\n\nstruct Banker\n{\n\tint available[m]; //可用资源数向量\n\tint maxNeed[n][m]; //每个进程最大资源需求量\n\tint allocation[n][m]; //已分配资源\n\tint need[n][m]; //还需要的资源数\n};\n\nint request[n][m]; //进程请求资源矩阵\n\n\nbool SafeStatusCheck(Banker &inStatus)\n{\n\tint work[m];\n\tfor (int i = 0; i < m; i++) {\n\t\twork[i] = inStatus.available[i];\n\t}\n\tbool finish[n] = {false};\n\tset<int> okSet;\n\twhile (1) {\n\t\tbool hasOne = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ((okSet.find(i)) != okSet.end()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (inStatus.need[i][j] > work[j]) {\n\t\t\t\t\tok = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tokSet.insert(okSet.end(), i);\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\twork[j] += inStatus.allocation[i][j];\n\t\t\t\t}\n\t\t\t\thasOne = true; break;\n\t\t\t}\n\t\t}\n\t\tif (okSet.size() >= n) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!hasOne) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool BankerAllocate(Banker &inStatus, int pid, int request[m])\n{\n\tfor (int i = 0; i < m; i++) {\n\t\tif (inStatus.need[pid][i] < request[i] || request[i] > inStatus.available[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tinStatus.available[i] -= request[i];\n\t\tinStatus.allocation[pid][i] += request[i];\n\t\tinStatus.need[pid][i] -= request[i];\n\t}\n\tbool canAlloc = SafeStatusCheck(inStatus);\n\tif (canAlloc) {\n\t\treturn true;\n\t}\n\telse {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tinStatus.available[m] += request[i];\n\t\t\tinStatus.allocation[pid][i] -= request[i];\n\t\t\tinStatus.need[pid][i] += request[i];\n\t\t}\n\t\treturn false;\n\t}\n\t\n}\n\n\nvoid CopyData(Banker &inStatus, int inAv[m], int inMax[n][m], int inAlloc[n][m], int inNeed[n][m])\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tinStatus.available[j] = inAv[j];\n\t\t\tinStatus.maxNeed[i][j] = inMax[i][j];\n\t\t\tinStatus.allocation[i][j] = inAlloc[i][j];\n\t\t\tinStatus.need[i][j] = inNeed[i][j];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tBanker TestStatus = {0};\n\tint tmpAv[m] = {3,3,2};\n\tint tmpMax[n][m] = {{7,5,3},{3,2,2},{9,0,2},{2,2,2},{4,3,3}};\n\tint tmpAlloc[n][m] = {{0,1,0},{2,0,0},{3,0,2},{2,1,1},{0,0,2}};\n\tint tmpNeed[n][m] = {{7,4,3},{1,2,2},{6,0,0},{0,1,1},{4,3,1}};\n\tCopyData(TestStatus, tmpAv, tmpMax, tmpAlloc, tmpNeed);\n\n\t//初始状态\n\tint request1[m] = {0};\n\tcout << \"ini status(true):\" << BankerAllocate(TestStatus, 0, request1) << endl;\n\n\t//进程P1发出资源请求1,0,2\n\tint request2[m] = {1,0,2};\n\tcout << \"P1 can satisfied(true):\" << BankerAllocate(TestStatus, 1, request2) << endl;\n\n\t//进程P4再发出资源请求3,3,0\n\tint request3[m] = {3,3,0};\n\tcout << \"P4 can satisfied(false):\" << BankerAllocate(TestStatus, 4, request3) << endl;\n\treturn 0;\n}\n```\n\n### 死锁检测与解除\n\n如果系统没有采用策略去防止死锁的产生，那么系统必须要能够检测死锁的发生同时能够解除掉死锁。系统检测死锁可以使用资源分配图结合死锁定理完成。系统检测死锁时机可以是发现进程长时间等待或者定时检测或者检测到资源利用率下降时检测死锁。由于使用资源分配图判断死锁需要系统记录资源分配使用情况，因此系统要能够统计这些信息。在解除死锁时，在尽可能以最小代价的方式下解除，主要有撤销所有死锁进程（代价大）、进程回退再启动（代价大）、剥夺资源分配给死锁进程、逐步撤销死锁进程直到解除死锁。\n\n在死锁检测中，数据结构与银行家算法基本类似，可以直接调用SafeStatusCheck函数完成。","slug":"操作系统/进程或线程死锁","published":1,"updated":"2018-06-13T14:21:10.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x4i0030gsvn7bx7kc4k","content":"<h2 id=\"死锁基本概念\"><a href=\"#死锁基本概念\" class=\"headerlink\" title=\"死锁基本概念\"></a>死锁基本概念</h2><p>死锁是指在一组进程中，每个进程都无限等待该组进程中另一个进程所占有的资源而导致永远无法等到资源的现象，这一组进程被称为死锁进程。死锁一旦发生，将会极大浪费系统资源以及可能造成系统崩溃。</p>\n<h2 id=\"死锁原因\"><a href=\"#死锁原因\" class=\"headerlink\" title=\"死锁原因\"></a>死锁原因</h2><p>从死锁的基本概念可以得知，死锁是发生在进程申请资源而得不到满足同时又互相僵持导致的，因此死锁原因可以归纳为两种：</p>\n<pre><code>1. 资源数量有限，进程之间需要竞争资源\n2. 进程请求释放资源顺序不合理，即进程间推进顺序不合理\n</code></pre><h3 id=\"资源有限导致资源竞争引起死锁\"><a href=\"#资源有限导致资源竞争引起死锁\" class=\"headerlink\" title=\"资源有限导致资源竞争引起死锁\"></a>资源有限导致资源竞争引起死锁</h3><p>在操作系统中，资源可分为可重用资源以及可消耗资源。可重用资源是指资源可以被重复利用，如CPU、I/O设备、内存、文件、信号量等；而可消耗资源则是只能使用一次，如中断、信号、消息等。可重用资源按照资源属性又可分为以下两种：</p>\n<ul>\n<li>可剥夺性资源</li>\n</ul>\n<p>指进程在获得某资源后可以其他进程或者系统被剥夺，主要有CPU、IO设备、内存、文件、数据库、信号量等</p>\n<ul>\n<li>不可剥夺资源</li>\n</ul>\n<p>不可剥夺资源是指资源被分配后不能被强行收回，比如打印机、磁带机等，因为这些资源如果可以被剥夺将会导致输出结果错误</p>\n<h3 id=\"活锁\"><a href=\"#活锁\" class=\"headerlink\" title=\"活锁\"></a>活锁</h3><p>假设两个资源R1、R2和两个进程P1、P2。P1已经给资源R1加锁，同时申请资源R2；P2已经已经给资源R2加锁，同时申请资源R1。由于资源已被加锁，进程P1、P2不断轮询资源尝试加锁，两个进程即没有推进也没有阻塞，这种情况称为活锁。</p>\n<h3 id=\"饥饿\"><a href=\"#饥饿\" class=\"headerlink\" title=\"饥饿\"></a>饥饿</h3><p>假设有资源R1，进程P1正在使用资源R1，接着有进程P2、P3、P4也在申请R1，此时系统决定依次将资源R1分配给P3、P4而导致进程P2一直得不到资源的情况。</p>\n<h2 id=\"死锁必要条件\"><a href=\"#死锁必要条件\" class=\"headerlink\" title=\"死锁必要条件\"></a>死锁必要条件</h2><h3 id=\"互斥条件\"><a href=\"#互斥条件\" class=\"headerlink\" title=\"互斥条件\"></a>互斥条件</h3><p>互斥条件又可以称为资源独占，是指在一段时间内资源只能被一个进程中占有，其他进程只能等待直到占有进程把资源释放掉。</p>\n<h3 id=\"占有且等待\"><a href=\"#占有且等待\" class=\"headerlink\" title=\"占有且等待\"></a>占有且等待</h3><p>又称为请求和保持条件，是指进程在申请其他资源而资源被占用时，申请进程阻塞但是并不释放自己已占有的资源。</p>\n<h3 id=\"不可抢占\"><a href=\"#不可抢占\" class=\"headerlink\" title=\"不可抢占\"></a>不可抢占</h3><p>又称为不可剥夺条件，指进程已获得资源后，除非使用结束或者主动释放，其他进程不可以抢占</p>\n<h3 id=\"循环等待\"><a href=\"#循环等待\" class=\"headerlink\" title=\"循环等待\"></a>循环等待</h3><p>是指有一个进程组P1、P2、P3….Pn。P1等待P2占有的资源，P2等待P3占有的资源…..，Pn等待P1资源。形成一个等待环路</p>\n<h2 id=\"死锁资源分配图描述\"><a href=\"#死锁资源分配图描述\" class=\"headerlink\" title=\"死锁资源分配图描述\"></a>死锁资源分配图描述</h2><h3 id=\"资源分配图基本定义\"><a href=\"#资源分配图基本定义\" class=\"headerlink\" title=\"资源分配图基本定义\"></a>资源分配图基本定义</h3><p>为了检测是否有死锁发生，可以使用资源分配图来判断。资源分配图由一组结点N和一组边E所组成的对偶G=(N,E)。结点N分为两个互斥的子集，包括一组进程结点和一组资源结点。边由资源节点与进程结点连线构成，如果进程申请资源则边的方向为进程结点指向资源节点，反之则由资源结点指向进程结点。</p>\n<p>如下图为一个简单的资源分配图：<a href=\"http://c.biancheng.net/cpp/html/2607.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/resource-assignment.jpg\" alt=\"资源分配图\"></p>\n<p>其中圆圈代表某一个进程，方框代表某一组同类资源。</p>\n<h3 id=\"死锁定理\"><a href=\"#死锁定理\" class=\"headerlink\" title=\"死锁定理\"></a>死锁定理</h3><p>对于一个确定的资源分配图，死锁定理指出如果图中不存在环路，则一定不会发生死锁，否则<strong>有可能</strong>发生死锁（每类资源实例有多个）。如果每类资源的个数为1，则环路是否存在将成为死锁存在的充分必要条件，即环路存在可以推断出发生死锁，发生死锁也可以推断出环路存在。</p>\n<h3 id=\"资源分配图简化\"><a href=\"#资源分配图简化\" class=\"headerlink\" title=\"资源分配图简化\"></a>资源分配图简化</h3><p>在分析复杂的资源分配图时，可以使用简化方式去判断是否存在死锁，简化过程如下：</p>\n<pre><code>1. 在资源分配图中找到一个只有分配边的进程结点Pi，由于Pi有全部需要的资源，其可运行结束并释放所有资源，即将分配边删除。\n2. 在第一步释放资源后将占有资源分配给等待进程，接着找到只有分配边的进程结点，也将分配边删除\n3. 重复上述两步知道所有的边都可以被删除则称资源分配图时可以完全简化的，否则称为不可完全简化的\n</code></pre><p>上诉简化完成后死锁的充分必要条件有：如果资源图是可以完全简化的则不存在死锁，否则存死锁。</p>\n<h2 id=\"死锁解决\"><a href=\"#死锁解决\" class=\"headerlink\" title=\"死锁解决\"></a>死锁解决</h2><p>根据死锁解决的思想，死锁解决可分为几种情况</p>\n<pre><code>1. 不考虑死锁问题，即鸵鸟算法\n2. 不让死锁发生，有死锁预防（静态策略）与死锁避免（动态策略）\n3. 让死锁发生，然后解除死锁\n</code></pre><h3 id=\"死锁预防\"><a href=\"#死锁预防\" class=\"headerlink\" title=\"死锁预防\"></a>死锁预防</h3><p>死锁预防是指在设计资源分配算法时就考虑不发生死锁，是一种静态的死锁解决方案。其通过设定某些限制条件去破坏死锁的四个必要条件，但是可能由于施加的限制过于严格而导致系统资源利用率低下，减少资源吞吐量。</p>\n<p>根据破坏四个条件不同有如下做法：</p>\n<pre><code>1. 破坏互斥条件，虚拟化技术将互斥资源虚拟成共享资源，如打印机的SPOOLing技术\n2. 破坏占有且等待，比如一次性申请所需资源或者再申请新资源得不到满足时释放已占有的资源\n3. 破坏不可抢占条件，优先级抢占等，需要保证资源易于恢复\n4. 破坏循环等待条件，系统给资源进行线性排队，进程资源申请只能按照线性顺序逐步申请，可能会造成资源浪费\n</code></pre><h3 id=\"死锁避免\"><a href=\"#死锁避免\" class=\"headerlink\" title=\"死锁避免\"></a>死锁避免</h3><p>死锁避免是指算法跟踪资源的分配情况，评估系统的安全状态，使得资源分配不会使系统进入不安全状态，死锁避免的限制较弱，可以获得较高的资源利用率和系统吞吐量。死锁避免经典算法有银行家算法。</p>\n<p>安全序列是指这样一个进程序列{P1,P2,P3…Pn}，对于每一个进程Pi，Pi所需要的资源总数不大于系统剩余资源总数以及进程Pi之前进程占有资源总数之和，则称为安全序列。</p>\n<p>银行家算法应用有系列的条件，如下所示：</p>\n<pre><code>1. 在固定数量的进程中共享数量固定的资源\n2. 每个进程预先指定完成工作量所需的最大资源数量\n3. 进程不允许申请比系统可用资源总数还多的资源\n4. 进程等待资源时间有限\n5. 如果系统满足了进程的资源请求，进程应该在有限时间内归还\n</code></pre><p>银行家基本数据结构如下：</p>\n<pre><code>1. 可用资源数量available，含有m个元素，表示第i个元素的可用资源数量\n2. 最大需求矩阵maxNeed，是一个n*m的矩阵，maxNeed[i][j]代表第i个进程对第j个资源的最大需求量\n3. 分配矩阵allocation，是一个n*m的矩阵，allocation[i][j]代表第i个进程已获得第j个资源数量\n4. 需求矩阵need，是一个n*m的矩阵，need[i][j]代表第i个进程还需要第j个资源数量\n5. 请求资源矩阵request，是一个n*m的矩阵，request[i][j]代表第i个进程向系统请求第j个资源数量\n</code></pre><p>银行家算法实现基本步骤如下：</p>\n<pre><code>1. 先检查request[i][0~m-1]&lt;=need[i][0~m-1]，如果不满足则出错返回\n2. 再检查request[i][0~m-1]&lt;=available[0~m-1]，如果不满足则出错返回\n3. 系统尝试将资源分配给进程，并修改available、allocation、need矩阵\n4. 运行安全状态检查算法，检查如果按照当前分配是否会导致不安全状态出现，如果不安全则恢复，否则完成分配\n</code></pre><p>银行家安全状态检查算法基本步骤如下：</p>\n<pre><code>1. 定义工作向量work[m]表示系统可提供的资源数量，安全算法执行初态work=available\n2. 定义finish[n]向量，初始值为false，当有足够资源分配给进程i时令finish[i]=true\n3. 在进程集合中找到满足以下条件的进程i：finish[i]=false，need[i][0~m]&lt;=work[0~m]\n4. 若第三步成功更新work[j]=work[j]+allocation[i][j]，finish[i]=true\n5. 如果所有进程最后finish[i]=true，则系统处于安全状态，否则处于不安全状态，不能分配资源\n</code></pre><p>以下为银行家算法的实现代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m = <span class=\"number\">3</span>; <span class=\"comment\">//资源类别数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = <span class=\"number\">5</span>; <span class=\"comment\">//进程数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Banker</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> available[m]; <span class=\"comment\">//可用资源数向量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxNeed[n][m]; <span class=\"comment\">//每个进程最大资源需求量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> allocation[n][m]; <span class=\"comment\">//已分配资源</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> need[n][m]; <span class=\"comment\">//还需要的资源数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> request[n][m]; <span class=\"comment\">//进程请求资源矩阵</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SafeStatusCheck</span><span class=\"params\">(Banker &amp;inStatus)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> work[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\twork[i] = inStatus.available[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> finish[n] = &#123;<span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; okSet;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> hasOne = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((okSet.find(i)) != okSet.end()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">bool</span> ok = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (inStatus.need[i][j] &gt; work[j]) &#123;</span><br><span class=\"line\">\t\t\t\t\tok = <span class=\"literal\">false</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ok) &#123;</span><br><span class=\"line\">\t\t\t\tokSet.insert(okSet.end(), i);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">\t\t\t\t\twork[j] += inStatus.allocation[i][j];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\thasOne = <span class=\"literal\">true</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (okSet.size() &gt;= n) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!hasOne) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">BankerAllocate</span><span class=\"params\">(Banker &amp;inStatus, <span class=\"keyword\">int</span> pid, <span class=\"keyword\">int</span> request[m])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inStatus.need[pid][i] &lt; request[i] || request[i] &gt; inStatus.available[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\tinStatus.available[i] -= request[i];</span><br><span class=\"line\">\t\tinStatus.allocation[pid][i] += request[i];</span><br><span class=\"line\">\t\tinStatus.need[pid][i] -= request[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> canAlloc = SafeStatusCheck(inStatus);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (canAlloc) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\t\tinStatus.available[m] += request[i];</span><br><span class=\"line\">\t\t\tinStatus.allocation[pid][i] -= request[i];</span><br><span class=\"line\">\t\t\tinStatus.need[pid][i] += request[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CopyData</span><span class=\"params\">(Banker &amp;inStatus, <span class=\"keyword\">int</span> inAv[m], <span class=\"keyword\">int</span> inMax[n][m], <span class=\"keyword\">int</span> inAlloc[n][m], <span class=\"keyword\">int</span> inNeed[n][m])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">\t\t\tinStatus.available[j] = inAv[j];</span><br><span class=\"line\">\t\t\tinStatus.maxNeed[i][j] = inMax[i][j];</span><br><span class=\"line\">\t\t\tinStatus.allocation[i][j] = inAlloc[i][j];</span><br><span class=\"line\">\t\t\tinStatus.need[i][j] = inNeed[i][j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tBanker TestStatus = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmpAv[m] = &#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmpMax[n][m] = &#123;&#123;<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>&#125;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmpAlloc[n][m] = &#123;&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmpNeed[n][m] = &#123;&#123;<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">6</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\">\tCopyData(TestStatus, tmpAv, tmpMax, tmpAlloc, tmpNeed);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始状态</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> request1[m] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ini status(true):\"</span> &lt;&lt; BankerAllocate(TestStatus, <span class=\"number\">0</span>, request1) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//进程P1发出资源请求1,0,2</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> request2[m] = &#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"P1 can satisfied(true):\"</span> &lt;&lt; BankerAllocate(TestStatus, <span class=\"number\">1</span>, request2) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//进程P4再发出资源请求3,3,0</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> request3[m] = &#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"P4 can satisfied(false):\"</span> &lt;&lt; BankerAllocate(TestStatus, <span class=\"number\">4</span>, request3) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁检测与解除\"><a href=\"#死锁检测与解除\" class=\"headerlink\" title=\"死锁检测与解除\"></a>死锁检测与解除</h3><p>如果系统没有采用策略去防止死锁的产生，那么系统必须要能够检测死锁的发生同时能够解除掉死锁。系统检测死锁可以使用资源分配图结合死锁定理完成。系统检测死锁时机可以是发现进程长时间等待或者定时检测或者检测到资源利用率下降时检测死锁。由于使用资源分配图判断死锁需要系统记录资源分配使用情况，因此系统要能够统计这些信息。在解除死锁时，在尽可能以最小代价的方式下解除，主要有撤销所有死锁进程（代价大）、进程回退再启动（代价大）、剥夺资源分配给死锁进程、逐步撤销死锁进程直到解除死锁。</p>\n<p>在死锁检测中，数据结构与银行家算法基本类似，可以直接调用SafeStatusCheck函数完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"死锁基本概念\"><a href=\"#死锁基本概念\" class=\"headerlink\" title=\"死锁基本概念\"></a>死锁基本概念</h2><p>死锁是指在一组进程中，每个进程都无限等待该组进程中另一个进程所占有的资源而导致永远无法等到资源的现象，这一组进程被称为死锁进程。死锁一旦发生，将会极大浪费系统资源以及可能造成系统崩溃。</p>\n<h2 id=\"死锁原因\"><a href=\"#死锁原因\" class=\"headerlink\" title=\"死锁原因\"></a>死锁原因</h2><p>从死锁的基本概念可以得知，死锁是发生在进程申请资源而得不到满足同时又互相僵持导致的，因此死锁原因可以归纳为两种：</p>\n<pre><code>1. 资源数量有限，进程之间需要竞争资源\n2. 进程请求释放资源顺序不合理，即进程间推进顺序不合理\n</code></pre><h3 id=\"资源有限导致资源竞争引起死锁\"><a href=\"#资源有限导致资源竞争引起死锁\" class=\"headerlink\" title=\"资源有限导致资源竞争引起死锁\"></a>资源有限导致资源竞争引起死锁</h3><p>在操作系统中，资源可分为可重用资源以及可消耗资源。可重用资源是指资源可以被重复利用，如CPU、I/O设备、内存、文件、信号量等；而可消耗资源则是只能使用一次，如中断、信号、消息等。可重用资源按照资源属性又可分为以下两种：</p>\n<ul>\n<li>可剥夺性资源</li>\n</ul>\n<p>指进程在获得某资源后可以其他进程或者系统被剥夺，主要有CPU、IO设备、内存、文件、数据库、信号量等</p>\n<ul>\n<li>不可剥夺资源</li>\n</ul>\n<p>不可剥夺资源是指资源被分配后不能被强行收回，比如打印机、磁带机等，因为这些资源如果可以被剥夺将会导致输出结果错误</p>\n<h3 id=\"活锁\"><a href=\"#活锁\" class=\"headerlink\" title=\"活锁\"></a>活锁</h3><p>假设两个资源R1、R2和两个进程P1、P2。P1已经给资源R1加锁，同时申请资源R2；P2已经已经给资源R2加锁，同时申请资源R1。由于资源已被加锁，进程P1、P2不断轮询资源尝试加锁，两个进程即没有推进也没有阻塞，这种情况称为活锁。</p>\n<h3 id=\"饥饿\"><a href=\"#饥饿\" class=\"headerlink\" title=\"饥饿\"></a>饥饿</h3><p>假设有资源R1，进程P1正在使用资源R1，接着有进程P2、P3、P4也在申请R1，此时系统决定依次将资源R1分配给P3、P4而导致进程P2一直得不到资源的情况。</p>\n<h2 id=\"死锁必要条件\"><a href=\"#死锁必要条件\" class=\"headerlink\" title=\"死锁必要条件\"></a>死锁必要条件</h2><h3 id=\"互斥条件\"><a href=\"#互斥条件\" class=\"headerlink\" title=\"互斥条件\"></a>互斥条件</h3><p>互斥条件又可以称为资源独占，是指在一段时间内资源只能被一个进程中占有，其他进程只能等待直到占有进程把资源释放掉。</p>\n<h3 id=\"占有且等待\"><a href=\"#占有且等待\" class=\"headerlink\" title=\"占有且等待\"></a>占有且等待</h3><p>又称为请求和保持条件，是指进程在申请其他资源而资源被占用时，申请进程阻塞但是并不释放自己已占有的资源。</p>\n<h3 id=\"不可抢占\"><a href=\"#不可抢占\" class=\"headerlink\" title=\"不可抢占\"></a>不可抢占</h3><p>又称为不可剥夺条件，指进程已获得资源后，除非使用结束或者主动释放，其他进程不可以抢占</p>\n<h3 id=\"循环等待\"><a href=\"#循环等待\" class=\"headerlink\" title=\"循环等待\"></a>循环等待</h3><p>是指有一个进程组P1、P2、P3….Pn。P1等待P2占有的资源，P2等待P3占有的资源…..，Pn等待P1资源。形成一个等待环路</p>\n<h2 id=\"死锁资源分配图描述\"><a href=\"#死锁资源分配图描述\" class=\"headerlink\" title=\"死锁资源分配图描述\"></a>死锁资源分配图描述</h2><h3 id=\"资源分配图基本定义\"><a href=\"#资源分配图基本定义\" class=\"headerlink\" title=\"资源分配图基本定义\"></a>资源分配图基本定义</h3><p>为了检测是否有死锁发生，可以使用资源分配图来判断。资源分配图由一组结点N和一组边E所组成的对偶G=(N,E)。结点N分为两个互斥的子集，包括一组进程结点和一组资源结点。边由资源节点与进程结点连线构成，如果进程申请资源则边的方向为进程结点指向资源节点，反之则由资源结点指向进程结点。</p>\n<p>如下图为一个简单的资源分配图：<a href=\"http://c.biancheng.net/cpp/html/2607.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/resource-assignment.jpg\" alt=\"资源分配图\"></p>\n<p>其中圆圈代表某一个进程，方框代表某一组同类资源。</p>\n<h3 id=\"死锁定理\"><a href=\"#死锁定理\" class=\"headerlink\" title=\"死锁定理\"></a>死锁定理</h3><p>对于一个确定的资源分配图，死锁定理指出如果图中不存在环路，则一定不会发生死锁，否则<strong>有可能</strong>发生死锁（每类资源实例有多个）。如果每类资源的个数为1，则环路是否存在将成为死锁存在的充分必要条件，即环路存在可以推断出发生死锁，发生死锁也可以推断出环路存在。</p>\n<h3 id=\"资源分配图简化\"><a href=\"#资源分配图简化\" class=\"headerlink\" title=\"资源分配图简化\"></a>资源分配图简化</h3><p>在分析复杂的资源分配图时，可以使用简化方式去判断是否存在死锁，简化过程如下：</p>\n<pre><code>1. 在资源分配图中找到一个只有分配边的进程结点Pi，由于Pi有全部需要的资源，其可运行结束并释放所有资源，即将分配边删除。\n2. 在第一步释放资源后将占有资源分配给等待进程，接着找到只有分配边的进程结点，也将分配边删除\n3. 重复上述两步知道所有的边都可以被删除则称资源分配图时可以完全简化的，否则称为不可完全简化的\n</code></pre><p>上诉简化完成后死锁的充分必要条件有：如果资源图是可以完全简化的则不存在死锁，否则存死锁。</p>\n<h2 id=\"死锁解决\"><a href=\"#死锁解决\" class=\"headerlink\" title=\"死锁解决\"></a>死锁解决</h2><p>根据死锁解决的思想，死锁解决可分为几种情况</p>\n<pre><code>1. 不考虑死锁问题，即鸵鸟算法\n2. 不让死锁发生，有死锁预防（静态策略）与死锁避免（动态策略）\n3. 让死锁发生，然后解除死锁\n</code></pre><h3 id=\"死锁预防\"><a href=\"#死锁预防\" class=\"headerlink\" title=\"死锁预防\"></a>死锁预防</h3><p>死锁预防是指在设计资源分配算法时就考虑不发生死锁，是一种静态的死锁解决方案。其通过设定某些限制条件去破坏死锁的四个必要条件，但是可能由于施加的限制过于严格而导致系统资源利用率低下，减少资源吞吐量。</p>\n<p>根据破坏四个条件不同有如下做法：</p>\n<pre><code>1. 破坏互斥条件，虚拟化技术将互斥资源虚拟成共享资源，如打印机的SPOOLing技术\n2. 破坏占有且等待，比如一次性申请所需资源或者再申请新资源得不到满足时释放已占有的资源\n3. 破坏不可抢占条件，优先级抢占等，需要保证资源易于恢复\n4. 破坏循环等待条件，系统给资源进行线性排队，进程资源申请只能按照线性顺序逐步申请，可能会造成资源浪费\n</code></pre><h3 id=\"死锁避免\"><a href=\"#死锁避免\" class=\"headerlink\" title=\"死锁避免\"></a>死锁避免</h3><p>死锁避免是指算法跟踪资源的分配情况，评估系统的安全状态，使得资源分配不会使系统进入不安全状态，死锁避免的限制较弱，可以获得较高的资源利用率和系统吞吐量。死锁避免经典算法有银行家算法。</p>\n<p>安全序列是指这样一个进程序列{P1,P2,P3…Pn}，对于每一个进程Pi，Pi所需要的资源总数不大于系统剩余资源总数以及进程Pi之前进程占有资源总数之和，则称为安全序列。</p>\n<p>银行家算法应用有系列的条件，如下所示：</p>\n<pre><code>1. 在固定数量的进程中共享数量固定的资源\n2. 每个进程预先指定完成工作量所需的最大资源数量\n3. 进程不允许申请比系统可用资源总数还多的资源\n4. 进程等待资源时间有限\n5. 如果系统满足了进程的资源请求，进程应该在有限时间内归还\n</code></pre><p>银行家基本数据结构如下：</p>\n<pre><code>1. 可用资源数量available，含有m个元素，表示第i个元素的可用资源数量\n2. 最大需求矩阵maxNeed，是一个n*m的矩阵，maxNeed[i][j]代表第i个进程对第j个资源的最大需求量\n3. 分配矩阵allocation，是一个n*m的矩阵，allocation[i][j]代表第i个进程已获得第j个资源数量\n4. 需求矩阵need，是一个n*m的矩阵，need[i][j]代表第i个进程还需要第j个资源数量\n5. 请求资源矩阵request，是一个n*m的矩阵，request[i][j]代表第i个进程向系统请求第j个资源数量\n</code></pre><p>银行家算法实现基本步骤如下：</p>\n<pre><code>1. 先检查request[i][0~m-1]&lt;=need[i][0~m-1]，如果不满足则出错返回\n2. 再检查request[i][0~m-1]&lt;=available[0~m-1]，如果不满足则出错返回\n3. 系统尝试将资源分配给进程，并修改available、allocation、need矩阵\n4. 运行安全状态检查算法，检查如果按照当前分配是否会导致不安全状态出现，如果不安全则恢复，否则完成分配\n</code></pre><p>银行家安全状态检查算法基本步骤如下：</p>\n<pre><code>1. 定义工作向量work[m]表示系统可提供的资源数量，安全算法执行初态work=available\n2. 定义finish[n]向量，初始值为false，当有足够资源分配给进程i时令finish[i]=true\n3. 在进程集合中找到满足以下条件的进程i：finish[i]=false，need[i][0~m]&lt;=work[0~m]\n4. 若第三步成功更新work[j]=work[j]+allocation[i][j]，finish[i]=true\n5. 如果所有进程最后finish[i]=true，则系统处于安全状态，否则处于不安全状态，不能分配资源\n</code></pre><p>以下为银行家算法的实现代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m = <span class=\"number\">3</span>; <span class=\"comment\">//资源类别数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = <span class=\"number\">5</span>; <span class=\"comment\">//进程数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Banker</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> available[m]; <span class=\"comment\">//可用资源数向量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxNeed[n][m]; <span class=\"comment\">//每个进程最大资源需求量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> allocation[n][m]; <span class=\"comment\">//已分配资源</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> need[n][m]; <span class=\"comment\">//还需要的资源数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> request[n][m]; <span class=\"comment\">//进程请求资源矩阵</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SafeStatusCheck</span><span class=\"params\">(Banker &amp;inStatus)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> work[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\twork[i] = inStatus.available[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> finish[n] = &#123;<span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; okSet;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> hasOne = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((okSet.find(i)) != okSet.end()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">bool</span> ok = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (inStatus.need[i][j] &gt; work[j]) &#123;</span><br><span class=\"line\">\t\t\t\t\tok = <span class=\"literal\">false</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ok) &#123;</span><br><span class=\"line\">\t\t\t\tokSet.insert(okSet.end(), i);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">\t\t\t\t\twork[j] += inStatus.allocation[i][j];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\thasOne = <span class=\"literal\">true</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (okSet.size() &gt;= n) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!hasOne) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">BankerAllocate</span><span class=\"params\">(Banker &amp;inStatus, <span class=\"keyword\">int</span> pid, <span class=\"keyword\">int</span> request[m])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (inStatus.need[pid][i] &lt; request[i] || request[i] &gt; inStatus.available[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\tinStatus.available[i] -= request[i];</span><br><span class=\"line\">\t\tinStatus.allocation[pid][i] += request[i];</span><br><span class=\"line\">\t\tinStatus.need[pid][i] -= request[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> canAlloc = SafeStatusCheck(inStatus);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (canAlloc) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">\t\t\tinStatus.available[m] += request[i];</span><br><span class=\"line\">\t\t\tinStatus.allocation[pid][i] -= request[i];</span><br><span class=\"line\">\t\t\tinStatus.need[pid][i] += request[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CopyData</span><span class=\"params\">(Banker &amp;inStatus, <span class=\"keyword\">int</span> inAv[m], <span class=\"keyword\">int</span> inMax[n][m], <span class=\"keyword\">int</span> inAlloc[n][m], <span class=\"keyword\">int</span> inNeed[n][m])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">\t\t\tinStatus.available[j] = inAv[j];</span><br><span class=\"line\">\t\t\tinStatus.maxNeed[i][j] = inMax[i][j];</span><br><span class=\"line\">\t\t\tinStatus.allocation[i][j] = inAlloc[i][j];</span><br><span class=\"line\">\t\t\tinStatus.need[i][j] = inNeed[i][j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tBanker TestStatus = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmpAv[m] = &#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmpMax[n][m] = &#123;&#123;<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>&#125;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmpAlloc[n][m] = &#123;&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmpNeed[n][m] = &#123;&#123;<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;,&#123;<span class=\"number\">6</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\">\tCopyData(TestStatus, tmpAv, tmpMax, tmpAlloc, tmpNeed);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始状态</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> request1[m] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ini status(true):\"</span> &lt;&lt; BankerAllocate(TestStatus, <span class=\"number\">0</span>, request1) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//进程P1发出资源请求1,0,2</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> request2[m] = &#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"P1 can satisfied(true):\"</span> &lt;&lt; BankerAllocate(TestStatus, <span class=\"number\">1</span>, request2) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//进程P4再发出资源请求3,3,0</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> request3[m] = &#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"P4 can satisfied(false):\"</span> &lt;&lt; BankerAllocate(TestStatus, <span class=\"number\">4</span>, request3) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁检测与解除\"><a href=\"#死锁检测与解除\" class=\"headerlink\" title=\"死锁检测与解除\"></a>死锁检测与解除</h3><p>如果系统没有采用策略去防止死锁的产生，那么系统必须要能够检测死锁的发生同时能够解除掉死锁。系统检测死锁可以使用资源分配图结合死锁定理完成。系统检测死锁时机可以是发现进程长时间等待或者定时检测或者检测到资源利用率下降时检测死锁。由于使用资源分配图判断死锁需要系统记录资源分配使用情况，因此系统要能够统计这些信息。在解除死锁时，在尽可能以最小代价的方式下解除，主要有撤销所有死锁进程（代价大）、进程回退再启动（代价大）、剥夺资源分配给死锁进程、逐步撤销死锁进程直到解除死锁。</p>\n<p>在死锁检测中，数据结构与银行家算法基本类似，可以直接调用SafeStatusCheck函数完成。</p>\n"},{"title":"进程状态模型","urlname":"process-state-model","date":"2018-03-06T02:49:57.000Z","copyright":true,"mathjax":true,"_content":"\n## 简述\n\n进程在整个生命周期中，由于各进程之间的相互制约关系以及外部运行环境的变化，进程需要在不同的状态之间进行切换，进程状态模型通常如下三种：\n\n- 三状态模型：包含运行态、就绪态、阻塞态三种基本状态模型\n- 五状态模型：除三状态模型中的三种基本状态外，由于进程需要经过创建过程并且最终结束运行，因此添加创建态、终止态\n- 七状态模型：除五状态模型五种状态外，在引入挂起概念后，多出了就绪挂起、阻塞挂起两种状态\n\n## 三状态模型\n\n三状态模型包含的是进程最基本的状态。运行态是指当前进程正在占用CPU；就绪态是指当前进程已经具有运行的条件，只是当前没有空闲CPU而暂时无法运行的状态；阻塞态是指当前进程因等待某一事件的发生而无法运行的状态，其又称为等待态、封锁态、睡眠态等。状态之间的转换如下图所示：\n![进程三状态转换模型](/images/process-status.png)\n\n- 就绪态->运行态\n\n调度程序选择程序进入CPU运行\n\n- 运行态->就绪态\n\n当前进程的时间片用完或者CPU被高优先级进程抢占导致被剥夺CPU使用权而转入就绪态\n\n- 运行态->阻塞态\n\n当前进程由于需要等待某个事件的发生或者调用类似pause等系统调用来进入阻塞态。事件可是请求OS服务、请求资源且暂时不可用、等待I/O、等待其他进程提供信息等。\n\n- 阻塞态->就绪态\n\n当进程等待的事件完成后（如I/O操作结束、中断结束时），中断处理程序必须把相应的进程状态由阻塞态转换为就绪态。\n\n## 五状态模型\n\n进程在整个生命周期中，除了就绪态、运行态、阻塞态以外，还包含创建态以及终止态。创建态是因为系统在创建进程时，需要填写PCB里面的相关信息，但是由于当前系统资源有限暂未同意执行；终止态是进程在结束运行时，系统需要处理资源释放和回收以及一些数据统计工作而处于的状态。下图为五状态之间的转换图：\n![进程五状态转换模型](/images/process-five-status.png)\n\n- 创建态->就绪态\n\n当系统创建进程的主要工作完成后（申请PCB并填写相关信息），通过提交进入就绪态\n\n- 运行态->终止态\n\n进程运行结束后进程进入终止态\n\n其余状态转换和三状态模型相似。\n\n## 七状态模型\n\n由于系统的资源是有限的，如果当前有大量的进程在运行时，系统负载大，内存可能出现不足，此时就需要将一部分进程暂时保存到磁盘上，当进程再次运行时再调入内存。此时就会多出就绪挂起态以及阻塞挂起态，其互相转换图如下：\n\n![进程七状态转换模型](/images/process-seven-status.png)\n\n- 创建态->就绪挂起态\n\n此时进程创建完毕后，系统可能没有足够内存来运行该进程，因此进入就绪挂起态\n\n- 就绪态->就绪挂起态\n\n系统负载过重时，可能会将一部分进程换出到磁盘中以腾出空间。\n\n- 阻塞态->阻塞挂起态\n\n原因和就绪态被挂起的原因一致，减轻系统负载。\n\n- 运行态->就绪挂起态\n\n直接被系统换出内存而不经历就绪态\n\n- 就绪挂起态->就绪态\n\n在条件允许时激活就绪挂起态使其进入内存，成为就绪态\n\n- 阻塞挂起->阻塞态\n\n激活使其进入内存，成为阻塞态\n\n## 进程队列\n\n由于进程在不同的状态之间转换，因此操作系统为每一类进程建立一个或多个PCB队列，随着进程状态的转变，PCB由一个队列转换到另外一个队列。对于一个五状态模型，其队列模型如下图所示：\n\n![进程五状态队列模型](/images/process-queue-model.png)\n\n如图所示，等待队列可以有多个，每个等待队列等待不同的事件发生。实际就绪队列也可以实现为多个，比如不同的优先级进程在不同的就绪队列中。\n\n\n\n\n\n","source":"_posts/操作系统/进程状态模型.md","raw":"---\ntitle: 进程状态模型\nurlname: process-state-model\ndate: 2018-03-6 10:49:57\ncopyright: true\nmathjax: true\ntags:\n- 操作系统\ncategories:\n- 操作系统\n---\n\n## 简述\n\n进程在整个生命周期中，由于各进程之间的相互制约关系以及外部运行环境的变化，进程需要在不同的状态之间进行切换，进程状态模型通常如下三种：\n\n- 三状态模型：包含运行态、就绪态、阻塞态三种基本状态模型\n- 五状态模型：除三状态模型中的三种基本状态外，由于进程需要经过创建过程并且最终结束运行，因此添加创建态、终止态\n- 七状态模型：除五状态模型五种状态外，在引入挂起概念后，多出了就绪挂起、阻塞挂起两种状态\n\n## 三状态模型\n\n三状态模型包含的是进程最基本的状态。运行态是指当前进程正在占用CPU；就绪态是指当前进程已经具有运行的条件，只是当前没有空闲CPU而暂时无法运行的状态；阻塞态是指当前进程因等待某一事件的发生而无法运行的状态，其又称为等待态、封锁态、睡眠态等。状态之间的转换如下图所示：\n![进程三状态转换模型](/images/process-status.png)\n\n- 就绪态->运行态\n\n调度程序选择程序进入CPU运行\n\n- 运行态->就绪态\n\n当前进程的时间片用完或者CPU被高优先级进程抢占导致被剥夺CPU使用权而转入就绪态\n\n- 运行态->阻塞态\n\n当前进程由于需要等待某个事件的发生或者调用类似pause等系统调用来进入阻塞态。事件可是请求OS服务、请求资源且暂时不可用、等待I/O、等待其他进程提供信息等。\n\n- 阻塞态->就绪态\n\n当进程等待的事件完成后（如I/O操作结束、中断结束时），中断处理程序必须把相应的进程状态由阻塞态转换为就绪态。\n\n## 五状态模型\n\n进程在整个生命周期中，除了就绪态、运行态、阻塞态以外，还包含创建态以及终止态。创建态是因为系统在创建进程时，需要填写PCB里面的相关信息，但是由于当前系统资源有限暂未同意执行；终止态是进程在结束运行时，系统需要处理资源释放和回收以及一些数据统计工作而处于的状态。下图为五状态之间的转换图：\n![进程五状态转换模型](/images/process-five-status.png)\n\n- 创建态->就绪态\n\n当系统创建进程的主要工作完成后（申请PCB并填写相关信息），通过提交进入就绪态\n\n- 运行态->终止态\n\n进程运行结束后进程进入终止态\n\n其余状态转换和三状态模型相似。\n\n## 七状态模型\n\n由于系统的资源是有限的，如果当前有大量的进程在运行时，系统负载大，内存可能出现不足，此时就需要将一部分进程暂时保存到磁盘上，当进程再次运行时再调入内存。此时就会多出就绪挂起态以及阻塞挂起态，其互相转换图如下：\n\n![进程七状态转换模型](/images/process-seven-status.png)\n\n- 创建态->就绪挂起态\n\n此时进程创建完毕后，系统可能没有足够内存来运行该进程，因此进入就绪挂起态\n\n- 就绪态->就绪挂起态\n\n系统负载过重时，可能会将一部分进程换出到磁盘中以腾出空间。\n\n- 阻塞态->阻塞挂起态\n\n原因和就绪态被挂起的原因一致，减轻系统负载。\n\n- 运行态->就绪挂起态\n\n直接被系统换出内存而不经历就绪态\n\n- 就绪挂起态->就绪态\n\n在条件允许时激活就绪挂起态使其进入内存，成为就绪态\n\n- 阻塞挂起->阻塞态\n\n激活使其进入内存，成为阻塞态\n\n## 进程队列\n\n由于进程在不同的状态之间转换，因此操作系统为每一类进程建立一个或多个PCB队列，随着进程状态的转变，PCB由一个队列转换到另外一个队列。对于一个五状态模型，其队列模型如下图所示：\n\n![进程五状态队列模型](/images/process-queue-model.png)\n\n如图所示，等待队列可以有多个，每个等待队列等待不同的事件发生。实际就绪队列也可以实现为多个，比如不同的优先级进程在不同的就绪队列中。\n\n\n\n\n\n","slug":"操作系统/进程状态模型","published":1,"updated":"2018-06-13T14:21:30.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x4k0033gsvn1p69b0r4","content":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>进程在整个生命周期中，由于各进程之间的相互制约关系以及外部运行环境的变化，进程需要在不同的状态之间进行切换，进程状态模型通常如下三种：</p>\n<ul>\n<li>三状态模型：包含运行态、就绪态、阻塞态三种基本状态模型</li>\n<li>五状态模型：除三状态模型中的三种基本状态外，由于进程需要经过创建过程并且最终结束运行，因此添加创建态、终止态</li>\n<li>七状态模型：除五状态模型五种状态外，在引入挂起概念后，多出了就绪挂起、阻塞挂起两种状态</li>\n</ul>\n<h2 id=\"三状态模型\"><a href=\"#三状态模型\" class=\"headerlink\" title=\"三状态模型\"></a>三状态模型</h2><p>三状态模型包含的是进程最基本的状态。运行态是指当前进程正在占用CPU；就绪态是指当前进程已经具有运行的条件，只是当前没有空闲CPU而暂时无法运行的状态；阻塞态是指当前进程因等待某一事件的发生而无法运行的状态，其又称为等待态、封锁态、睡眠态等。状态之间的转换如下图所示：<br><img src=\"/images/process-status.png\" alt=\"进程三状态转换模型\"></p>\n<ul>\n<li>就绪态-&gt;运行态</li>\n</ul>\n<p>调度程序选择程序进入CPU运行</p>\n<ul>\n<li>运行态-&gt;就绪态</li>\n</ul>\n<p>当前进程的时间片用完或者CPU被高优先级进程抢占导致被剥夺CPU使用权而转入就绪态</p>\n<ul>\n<li>运行态-&gt;阻塞态</li>\n</ul>\n<p>当前进程由于需要等待某个事件的发生或者调用类似pause等系统调用来进入阻塞态。事件可是请求OS服务、请求资源且暂时不可用、等待I/O、等待其他进程提供信息等。</p>\n<ul>\n<li>阻塞态-&gt;就绪态</li>\n</ul>\n<p>当进程等待的事件完成后（如I/O操作结束、中断结束时），中断处理程序必须把相应的进程状态由阻塞态转换为就绪态。</p>\n<h2 id=\"五状态模型\"><a href=\"#五状态模型\" class=\"headerlink\" title=\"五状态模型\"></a>五状态模型</h2><p>进程在整个生命周期中，除了就绪态、运行态、阻塞态以外，还包含创建态以及终止态。创建态是因为系统在创建进程时，需要填写PCB里面的相关信息，但是由于当前系统资源有限暂未同意执行；终止态是进程在结束运行时，系统需要处理资源释放和回收以及一些数据统计工作而处于的状态。下图为五状态之间的转换图：<br><img src=\"/images/process-five-status.png\" alt=\"进程五状态转换模型\"></p>\n<ul>\n<li>创建态-&gt;就绪态</li>\n</ul>\n<p>当系统创建进程的主要工作完成后（申请PCB并填写相关信息），通过提交进入就绪态</p>\n<ul>\n<li>运行态-&gt;终止态</li>\n</ul>\n<p>进程运行结束后进程进入终止态</p>\n<p>其余状态转换和三状态模型相似。</p>\n<h2 id=\"七状态模型\"><a href=\"#七状态模型\" class=\"headerlink\" title=\"七状态模型\"></a>七状态模型</h2><p>由于系统的资源是有限的，如果当前有大量的进程在运行时，系统负载大，内存可能出现不足，此时就需要将一部分进程暂时保存到磁盘上，当进程再次运行时再调入内存。此时就会多出就绪挂起态以及阻塞挂起态，其互相转换图如下：</p>\n<p><img src=\"/images/process-seven-status.png\" alt=\"进程七状态转换模型\"></p>\n<ul>\n<li>创建态-&gt;就绪挂起态</li>\n</ul>\n<p>此时进程创建完毕后，系统可能没有足够内存来运行该进程，因此进入就绪挂起态</p>\n<ul>\n<li>就绪态-&gt;就绪挂起态</li>\n</ul>\n<p>系统负载过重时，可能会将一部分进程换出到磁盘中以腾出空间。</p>\n<ul>\n<li>阻塞态-&gt;阻塞挂起态</li>\n</ul>\n<p>原因和就绪态被挂起的原因一致，减轻系统负载。</p>\n<ul>\n<li>运行态-&gt;就绪挂起态</li>\n</ul>\n<p>直接被系统换出内存而不经历就绪态</p>\n<ul>\n<li>就绪挂起态-&gt;就绪态</li>\n</ul>\n<p>在条件允许时激活就绪挂起态使其进入内存，成为就绪态</p>\n<ul>\n<li>阻塞挂起-&gt;阻塞态</li>\n</ul>\n<p>激活使其进入内存，成为阻塞态</p>\n<h2 id=\"进程队列\"><a href=\"#进程队列\" class=\"headerlink\" title=\"进程队列\"></a>进程队列</h2><p>由于进程在不同的状态之间转换，因此操作系统为每一类进程建立一个或多个PCB队列，随着进程状态的转变，PCB由一个队列转换到另外一个队列。对于一个五状态模型，其队列模型如下图所示：</p>\n<p><img src=\"/images/process-queue-model.png\" alt=\"进程五状态队列模型\"></p>\n<p>如图所示，等待队列可以有多个，每个等待队列等待不同的事件发生。实际就绪队列也可以实现为多个，比如不同的优先级进程在不同的就绪队列中。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>进程在整个生命周期中，由于各进程之间的相互制约关系以及外部运行环境的变化，进程需要在不同的状态之间进行切换，进程状态模型通常如下三种：</p>\n<ul>\n<li>三状态模型：包含运行态、就绪态、阻塞态三种基本状态模型</li>\n<li>五状态模型：除三状态模型中的三种基本状态外，由于进程需要经过创建过程并且最终结束运行，因此添加创建态、终止态</li>\n<li>七状态模型：除五状态模型五种状态外，在引入挂起概念后，多出了就绪挂起、阻塞挂起两种状态</li>\n</ul>\n<h2 id=\"三状态模型\"><a href=\"#三状态模型\" class=\"headerlink\" title=\"三状态模型\"></a>三状态模型</h2><p>三状态模型包含的是进程最基本的状态。运行态是指当前进程正在占用CPU；就绪态是指当前进程已经具有运行的条件，只是当前没有空闲CPU而暂时无法运行的状态；阻塞态是指当前进程因等待某一事件的发生而无法运行的状态，其又称为等待态、封锁态、睡眠态等。状态之间的转换如下图所示：<br><img src=\"/images/process-status.png\" alt=\"进程三状态转换模型\"></p>\n<ul>\n<li>就绪态-&gt;运行态</li>\n</ul>\n<p>调度程序选择程序进入CPU运行</p>\n<ul>\n<li>运行态-&gt;就绪态</li>\n</ul>\n<p>当前进程的时间片用完或者CPU被高优先级进程抢占导致被剥夺CPU使用权而转入就绪态</p>\n<ul>\n<li>运行态-&gt;阻塞态</li>\n</ul>\n<p>当前进程由于需要等待某个事件的发生或者调用类似pause等系统调用来进入阻塞态。事件可是请求OS服务、请求资源且暂时不可用、等待I/O、等待其他进程提供信息等。</p>\n<ul>\n<li>阻塞态-&gt;就绪态</li>\n</ul>\n<p>当进程等待的事件完成后（如I/O操作结束、中断结束时），中断处理程序必须把相应的进程状态由阻塞态转换为就绪态。</p>\n<h2 id=\"五状态模型\"><a href=\"#五状态模型\" class=\"headerlink\" title=\"五状态模型\"></a>五状态模型</h2><p>进程在整个生命周期中，除了就绪态、运行态、阻塞态以外，还包含创建态以及终止态。创建态是因为系统在创建进程时，需要填写PCB里面的相关信息，但是由于当前系统资源有限暂未同意执行；终止态是进程在结束运行时，系统需要处理资源释放和回收以及一些数据统计工作而处于的状态。下图为五状态之间的转换图：<br><img src=\"/images/process-five-status.png\" alt=\"进程五状态转换模型\"></p>\n<ul>\n<li>创建态-&gt;就绪态</li>\n</ul>\n<p>当系统创建进程的主要工作完成后（申请PCB并填写相关信息），通过提交进入就绪态</p>\n<ul>\n<li>运行态-&gt;终止态</li>\n</ul>\n<p>进程运行结束后进程进入终止态</p>\n<p>其余状态转换和三状态模型相似。</p>\n<h2 id=\"七状态模型\"><a href=\"#七状态模型\" class=\"headerlink\" title=\"七状态模型\"></a>七状态模型</h2><p>由于系统的资源是有限的，如果当前有大量的进程在运行时，系统负载大，内存可能出现不足，此时就需要将一部分进程暂时保存到磁盘上，当进程再次运行时再调入内存。此时就会多出就绪挂起态以及阻塞挂起态，其互相转换图如下：</p>\n<p><img src=\"/images/process-seven-status.png\" alt=\"进程七状态转换模型\"></p>\n<ul>\n<li>创建态-&gt;就绪挂起态</li>\n</ul>\n<p>此时进程创建完毕后，系统可能没有足够内存来运行该进程，因此进入就绪挂起态</p>\n<ul>\n<li>就绪态-&gt;就绪挂起态</li>\n</ul>\n<p>系统负载过重时，可能会将一部分进程换出到磁盘中以腾出空间。</p>\n<ul>\n<li>阻塞态-&gt;阻塞挂起态</li>\n</ul>\n<p>原因和就绪态被挂起的原因一致，减轻系统负载。</p>\n<ul>\n<li>运行态-&gt;就绪挂起态</li>\n</ul>\n<p>直接被系统换出内存而不经历就绪态</p>\n<ul>\n<li>就绪挂起态-&gt;就绪态</li>\n</ul>\n<p>在条件允许时激活就绪挂起态使其进入内存，成为就绪态</p>\n<ul>\n<li>阻塞挂起-&gt;阻塞态</li>\n</ul>\n<p>激活使其进入内存，成为阻塞态</p>\n<h2 id=\"进程队列\"><a href=\"#进程队列\" class=\"headerlink\" title=\"进程队列\"></a>进程队列</h2><p>由于进程在不同的状态之间转换，因此操作系统为每一类进程建立一个或多个PCB队列，随着进程状态的转变，PCB由一个队列转换到另外一个队列。对于一个五状态模型，其队列模型如下图所示：</p>\n<p><img src=\"/images/process-queue-model.png\" alt=\"进程五状态队列模型\"></p>\n<p>如图所示，等待队列可以有多个，每个等待队列等待不同的事件发生。实际就绪队列也可以实现为多个，比如不同的优先级进程在不同的就绪队列中。</p>\n"},{"title":"TCP-UDP基础以及区别","urlname":"tcp-up-foundation","date":"2018-04-15T13:24:44.000Z","copyright":true,"mathjax":true,"_content":"\n## TCP-UDP基础知识\n\nTCP全称传输控制协议（Transmission Control Protocol），是一种面向连接、可靠的、基于字节流的传输层通信协议。面向连接意味着TCP在进行数据交换时需要先建立一个TCP连接（三次握手）；可靠意味着TCP协议需要保证数据可靠的传送到对方，TCP可靠性体现在数据分割成合适长度（MTU限制）、序号确认机制（累积确认，注意回绕问题）、超时重传机制、快速重传（连续收到三次对同一个包的确认）、数据校验（校验和）、失序重排、重复数据处理、流量控制机制（滑动窗口机制）、拥塞控制机制（慢开始等）。\n\nUDP全称用户数据包协议（User Datagram Protocol），是一种简单的面向数据报的无连接、不可靠、基于数据报的传输层协议。UDP每次发送整个数据报，不关心是否超过MTU（由应用层协议处理）。UDP数据报发出后并不保证到达目的地，因此如果UDP需要保证可靠性，可以通过应用层处理。\n\n## TCP-UDP首部解析\n\nTCP首部图如下所示：[图片来源](https://blog.csdn.net/zhanglong_daniel/article/details/50749098)\n\n![TCP首部](/images/tcp-head.png)\n\nUDP首部图如下所示：[图片来源](https://blog.csdn.net/nestler/article/details/28668153)\n\n![UDP首部](/images/udp-head.png)\n\n由于TCP的可靠传输机制，TCP首部由固定的20字节+可选的40字节组成（4位首部长度2^3-1个4字节）；UDP首部由固定的8字节组成。TCP和UDP首部都含有16位源端口、目的端口号（端口号和IP地址组成一个socket）。TCP中的32位序号和32位确认序号用于完成序号确认、失序重排等。TCP和UDP的16校验和计算过程类似，都需要添加12字节伪首部，TCP伪首部和UDP伪首部不同的地方为8位协议部分（TCP为6，UDP为17），长度项均为首部+数据部分长度，TCP校验和计算是强制的，UDP是可选的。TCP首部特有的6个标志比特位置位后用来完成连接过程以及使某些字段有效等，以下为各字段作用：\n\n\t1. SYN字段，用于建立连接，前两次握手置为1，建立连接后该字段始终置为0，SYN占用一个序号\n\t2. FIN，终止连接，TCP连接是全双工的，需要4次挥手关闭一个完整的TCP连接，FIN也占用一个序号\n\t3. URG，表示紧急指针有效，紧急指针是一个正的偏移量，和TCP首部序号相加可以得出紧急数据位置\n\t4. ACK，表明确认序号有效，连接建立后必须始终置为1\n\t5. PSH，提醒接收方快速将数据转交给应用层\n\t6. RST，表明需要重新建立连接\n\nTCP还有一个窗口大小，其用来进行流量控制，建立连接和通信过程均可以通告窗口大小，窗口大小和可选段的窗口比例组成最终的窗口大小。\n\n在TCP的可选段中，主要有如下：\n\n\t1. MSS（Maxium Segment Size），最大报文段长度，表示数据段最大长度，MSS只出现在SYN报文中，用于避免IP分片\n\t2. 窗口扩大选项（Windows Scaling），表示窗口大小左移位数，即窗口大小*2^(窗口扩大值)\n\t3. SACK选择确认项（Selective Acknowledgements），由于启用选择确认机制而不是累计确认，减少重发数据量\n\t4. 时间戳选项（Timestamps），用来计算RTT往返时间或者解决序号回绕的问题\n\t5. NOP（NO-Operation），用来填充使可选段长度为4字节倍数\n\n## TCP连接建立与终止\n\nTCP由于预先建立连接，同时在断开时也需要经历四次挥手过程，其状态迁移图如下所示：[图片来源](http://www.cnblogs.com/missmzt/p/5308149.html)\n\n![TCP状态转移](/images/tcp-state-change.png)\n\n整个连接通信终止过程的转移如下图所示：[图片来源](http://www.cnblogs.com/wujing-hubei/p/5699773.html)\n\n![TCP状态转移](/images/tcp-socket.png)\n\n### 三次握手建立TCP连接\n\n由于TCP在通信前需要先建立连接，其过程是由称为三次握手建立，其基本步骤为:\n\n\t1. 发起方置SYN为1，序列号为x\n\t2. 接收方返回一个SYN置为1和ACK置为1的连接确认包，序号为y，确认号为x+1（SYN占用一个序号）\n\t3. 发起方发送一个ACK置为1的确认包，序号为x+1，确认号为y+1\n\n下图为使用WIRESHARK抓取的三次握手过程：\n\n![三次握手](/images/three-way-handshake.png)\n\n三次握手过程中会通告MSS以及窗口大小。\n\nTCP在设计过程中考虑到了同时打开的情况，考虑以下情况：主机A以本地端口portA向主机B端口portB发送SYN执行主动打开，同时主机B以本地端口portB向主机A端口portA发送SYN执行主动打开，然后双方回复ACK包，此时TCP只会建立一个TCP连接，共发生4次数据交换。其状态转移图如下所示：[图片来源](https://blog.csdn.net/huoqubing/article/details/6126189)\n\n![同时打开](/images/tcp-open-at-same-time.png)\n\n### 四次挥手终止TCP连接\n\n由于TCP连接是一个全双工连接，两个方向可以同时传递数据，因此在终止连接时需要经历四次挥手过程，其状态转移如下图所示：[图片来源](https://blog.csdn.net/huoqubing/article/details/6126189)\n\n四次挥手步骤如下：（假设主动发送最后被确认号为x，被动方发送最后被确认号为y）\n\n\t1. 主动关闭方发送FIN包，ACK置为1时确认号为y，序号为x（FIN包占有一个序号）\n\t2. 被动关闭方发送ACK包，ACK确认号置为x+1，序号为y\n\t3. 被动方发送FIN包，ACK确认号置为x+1，序号为y（FIN包占有一个序号）\n\t4. 主动关闭方发送ACK包，ACK确认号置为y+1，序号为x+1\n\n考虑一种情况，TCP连接双方同时发出关闭请求，此时状态转移图如下：[图片来源](https://blog.csdn.net/huoqubing/article/details/6126189)\n\n![同时关闭](/images/tcp-close-at-same-time.png)\n\n在主动发起关闭连接方最后会处于一个TIME_WAIT状态（也称为2MSL，Maximum Segment Lifetime），该状态的主要作用是确保最后发出的ACK被对方接收，否则需要重新发送。在2MSL等待期，本socket对将不能被使用，除非设置某些参数。2MSL收到的报文将会被丢弃。\n\n### TCP半关闭以及半打开\n\n半关闭是指某一方主动发起关闭连接后，另外一方还有数据需要发送，此时另外一方并不关闭连接，此时数据只能在一个方向上进行流动，半关闭示意图如下：[图片来源](https://blog.csdn.net/ericzhong83/article/details/8123420)\n\n![半关闭](/images/tcp-half-close.png)\n\n半打开是指TCP连接一方以及关闭连接或者异常终止而另外一方却不知情，处于半打开状态的TCP连接如果不发生数据交换一般很难发现连接出现问题，而一旦正常一方向异常一方发送数据，此时一般会回复一个RST包。\n\n## TCP的超时与重传\n\nTCP由于需要提供可靠的数据传输服务，因此其需要对数据接收进行确认，但是确认包也可能出现丢失的情况，这便是TCP需要使用超时与重传机制的原因。如果发送方在一段时间内没有收到对方确认包，则启动数据重传（此时可能在另外一方出现数据重复的情况）。在实现具体的超时重传时，需要确定具体超时间隔以及重传频率。为此，TCP含有7个不同的定时器来实现超超时与重传机制，分别是建立连接定时器（Connection-establishment Timer）、延迟应答定时器（Delayed ACK Timer）、重传定时器（Retransmission Timer）、坚持定时器（Persist Timer）、保活定时器（Keepalive Timer）、FIN\\_WAIT\\_2定时器（FIN\\_WAIT\\_2 Timer）、2MSL定时器（TIME_WAIT Timer）。以下分别介绍。\n\n### TCP定时器\n\n#### 建立连接定时器\n\nTCP建立连接需要进行三次握手，在发送SYN包后启动定时器，如果在定时器溢出之前没有收到ACK包则重发SYN包。定时器间隔一般采用指数退避，一般在75s尝试后依然没有收到ACK包则放弃本此连接。\n\n#### 延迟应答定时器\n\n由于TCP在发送数据后对方需要发送ACK包，如果每次接收到数据后立马发送ACK包可能会加重网络负担，如果等待一段时间可以接收到更多的数据则累计确认可以提高网络传输效率，或者可能在定时器内需要发送数据则可以捎带发送ACK包，也可以提高传输效率。\n\n#### 重传定时器\n\n在TCP发送数据后，会启动一个定时器，如果在定时器溢出前没有收到确认包，将会重发数据。定时间隔采用指数退避的方式且和RTT估值有关，在多次重传依然失败后将会发送RST包。\n\n#### 坚持定时器\n\nTCP在传输数据时，接收方会发送接收窗口，如果窗口的大小变为0则发送方将停止发送数据直到窗口打开。如果此时窗口打开的数据包丢失，那么会发生接收方在等待接收数据而发送方在等待窗口打开的死锁情况。为了防止这一情况的出现，发送方维持了一个坚持定时器向接收方查询窗口是否打开，这种报文段被称为窗口探查（探查数据一般不占用序列号）。计时器一般也采用了TCP的指数退避方式。和重传不同，TCP从不放弃窗口探查，直到窗口打开或者连接被关闭。\n\n#### 保活定时器\n\nTCP在建立连接后任意一方可以不发送任何数据，此时称为一个空闲的TCP连接。双方可以维持一个TCP连接数小时、数天甚至数年只要双方主机没有崩溃或者重启，而不管中间的路由器是否崩溃或者重启。但是如果一方已经崩溃或者关机或者重启，此时需要一种机制能够探测连接是否正常。保活定时器便用来实现这种探测，一般用于服务器。\n\n一般一个TCP连接如果2小时没有任何活动，服务器就会向客户发送一个探查。服务器探查时客户端可能存在以下几种情况：\n\n    1. 客户端正常并可达：两小时后定时器复位\n    2. 客户端已崩溃或者已关闭或者重启：发送多个探查后失败后服务器终止TCP连接\n    3. 客户端崩溃或者重启处于正常状态：客户端收到一个未知数据，向服务器发送RST复位包，服务器终止该连接\n    4. 客户端正常但是不可达（中间路由崩溃）：发送多个探查后失败后服务器终止TCP连接，即终止了一个良好的连接\n\n正是由于保活的上述特点，其主要有耗费带宽、关闭一个良好连接的缺点。优点是可以一定程度解决无效TCP连接，节省服务器维持连接需要的资源。\n\n#### FIN\\_WAIT\\_2定时器\n\n在TCP主动关闭连接并收到ACK包时进入改状态，如果此时对方既不发送数据也不发送FIN包终止连接，此时主动关闭一方会在等待一段时间后直接关闭该连接，这样可以防止对方崩溃后一直等待FIN包的情况。\n\n#### 2MSL定时器\n\n2MSL定时器也称为TIME_WAIT定时器，是主动关闭以方出现的状态，在主动一方接收到FIN包后处于的一个状态。该状态主要用来防止丢失ACK包（对方没有收到ACK会重发FIN包）。在该期间收到的任何报文均会被丢弃，防止旧TCP连接出现在新TCP连接中。\n\n### 重传RTT时间测量\n\nTCP超时重传需要确认重传超时时间，由于数据包以及确认包往返需要时间，因此为了确定合适的超时时间需要测量TCP连接的往返时间。RTT时间和网络状态密切相关，因此一般是一个动态变化的值。（相关：Karn算法）\n\n## TCP的流量控制\n\n由于接收方的缓冲区大小是有限的，因此必须提供一种机制防止发送方发送太快而接收方来不及接收而造成的数据丢失，这就是滑动窗口协议提供的流量控制功能。\n\n### TCP的滑动窗口协议\n\n滑动窗口的示意图如下：[图片来源](http://www.cnblogs.com/hupp/p/4857093.html)\n\n![滑动窗口示意图](/images/sliding-window.png)\n\n从图中可以看出，数据流有三大部分组成：窗口左边发送已确认数据、窗口内数据、窗口右边未发送数据。在窗口内部又可以分为两部分为：已发送待确认数据、可发送未发送数据。根据窗口的运动情况可分为以下几种几种移动方式：\n\n    1. 窗口左边向右移动导致窗口合拢，表明已发送数据被确认\n    2. 窗口右边向右移动导致窗口张开，此时表明对方处理接收缓冲区数据导致接收窗口变大\n    3. 窗口右边向左移动导致窗口收缩，该情况一般发生在糊涂窗口处理时，一般该行为不被建议。\n\n接收窗口的大小可以通过API设置发送或者接收缓冲的方式设定。\n\n### 糊涂窗口综合症（Silly Window Syndrome）\n\n在基于窗口的流量控制方式中，会导致一种称为“糊涂窗口综合症SWS”的情况。该情况是指当前少量的数据（没有满报文长度）进行了交换，使得数据传输效率大大降低。一般发生原因有如下几种：\n\n    1. 发送方缓慢创建数据，解决方式为Nagle算法\n    2. 接收方缓慢消耗数据致使接收窗口很小，解决方式为David D Clark算法\n\n解决接收方的主要方式是接收方不通告小的窗口，发送方可以采用当满足一个满报文长度时才发送或者至少是通告窗口的一半等。\n\n## TCP的拥塞控制\n\n在进行数据传输时不仅需要考虑接收方的接收能力，也需要考虑网络负担问题，网络一旦拥塞将会极大降低传输效率，这既是拥塞控制需要解决的。在进行拥塞控制需要了解网络负载情况，拥塞控制主要有慢启动、拥塞避免、快重传、快恢复，以下分别介绍。\n\n### 慢启动算法\n\n慢启动机制定义了一个拥塞窗口（cwnd），当建立TCP连接时，拥塞窗口初始化为1个报文段，每收到一个ACK包，拥塞窗口就增加一个报文段，发送方在确定发送窗口时取通告接收窗口和拥塞窗口较小的一个。拥塞窗口的增长方式为指数级增长。随着拥塞窗口的增长，最后发送接收之间的管道被填满，此时无论拥塞窗口还是通告窗口大小，管道不能再容纳更多数据，只能是接收方没小号一个单位的数据而发送方发送一个单位的数据，此时返回路径上的的ACK包数量是固定的，这既是连接的理想稳定状态。\n\n### 拥塞避免算法\n\n在使用慢启动算法时，可能很快数据传输达到中间路由器能力的极限，此时数据将会被丢弃。为了防止这一情况出现，在慢启动算法上提出了拥塞避免算法，这两个算法是两个独立的算法，但实现中常常结合在一起。\n\n拥塞避免算法需要维护一个慢启动门限ssthresh，算法的基本流程为：\n\n    1. 对于一个连接，初始化cwnd为1个报文段，ssthresh初始化65535个字节\n    2. 当cwnd<ssthresh使用慢启动，cwnd>ssthresh使用拥塞避免算法，两者相等可随意选择一个\n    3. 发生拥塞时（超时或者重复确认），ssthresh设置为当前窗口的一半，如果超时造成拥塞则将cwnd设置为1\n    4. 拥塞避免时cwnd以线性方式增长\n\n### 快重传与快速恢复\n\n在TCP收到一个失序的报文时，TCP需要立刻产生一个重复的ACK包，该ACK包告诉对方接收失序，期望接受的序列号。由于重复ACK包不一定是接收失序造成，因此只有在连续收到3个以上的重复ACK包再进行快速重传。快速重传无需等待超时定时器溢出。接下来不再执行慢启动算法而是拥塞避免算法，这就是快速恢复算法，既不把cwnd设为1。\n\n快速恢复算实现如下：\n\n    1. 收到三个重复确认后将ssthresh设置为cwnd的一半，重传丢失的报文，设置cwnd为ssthresh+3倍报文段大小\n    2. 每次收到另外一个重复ACK时，cwnd增加一个1个报文段，并发送分组\n    3. 收到确认新报文的ACK包后cwnd设置为ssthresh\n\n## TCP-UDP对比\n\n由于UDP自身协议比较简单，而且没有很多控制方法，因此UDP对系统资源要求较少，且效率也更高。由于UDP头部是固定的8字节，相比于TCP头部更加简单，因此传输效率也比较高。但是UDP不对可靠性做任何保证。\n\n\n\n\n## 参考文章\n\n[TCP/IP详解 卷1：协议](https://book.douban.com/subject/1088054/)\n\n[TCP中的7种定时器详解](https://blog.csdn.net/hyman_yx/article/details/52086389)\n\n[计算机网络相关](https://www.jianshu.com/p/7178d5c3716e)\n\n[TCP中的定时器](https://blog.csdn.net/sicofield/article/details/9672457)\n\n[糊涂窗口综合症-维基百科](https://zh.wikipedia.org/wiki/糊涂窗口综合症)\n\n[TCP/IP协议族之运输层：TCP流量控制和拥塞控制1](http://www.cnblogs.com/way_testlife/archive/2010/10/11/1848241.html)\n\n[TCP/IP协议族之运输层：TCP流量控制和拥塞控制2](http://www.cnblogs.com/way_testlife/archive/2010/10/11/1848333.html)\n\n[慢启动与拥塞窗口](https://blog.csdn.net/nestler/article/details/30237529)\n\n[SYN攻击及防范](https://www.jianshu.com/p/8331aeb193d9)\n","source":"_posts/计算机网络/TCP-UDP基础以及区别.md","raw":"---\ntitle: TCP-UDP基础以及区别\nurlname: tcp-up-foundation\ndate: 2018-04-15 21:24:44\ncopyright: true\nmathjax: true\ntags:\n- 计算机网络\ncategories:\n- 计算机网络\n---\n\n## TCP-UDP基础知识\n\nTCP全称传输控制协议（Transmission Control Protocol），是一种面向连接、可靠的、基于字节流的传输层通信协议。面向连接意味着TCP在进行数据交换时需要先建立一个TCP连接（三次握手）；可靠意味着TCP协议需要保证数据可靠的传送到对方，TCP可靠性体现在数据分割成合适长度（MTU限制）、序号确认机制（累积确认，注意回绕问题）、超时重传机制、快速重传（连续收到三次对同一个包的确认）、数据校验（校验和）、失序重排、重复数据处理、流量控制机制（滑动窗口机制）、拥塞控制机制（慢开始等）。\n\nUDP全称用户数据包协议（User Datagram Protocol），是一种简单的面向数据报的无连接、不可靠、基于数据报的传输层协议。UDP每次发送整个数据报，不关心是否超过MTU（由应用层协议处理）。UDP数据报发出后并不保证到达目的地，因此如果UDP需要保证可靠性，可以通过应用层处理。\n\n## TCP-UDP首部解析\n\nTCP首部图如下所示：[图片来源](https://blog.csdn.net/zhanglong_daniel/article/details/50749098)\n\n![TCP首部](/images/tcp-head.png)\n\nUDP首部图如下所示：[图片来源](https://blog.csdn.net/nestler/article/details/28668153)\n\n![UDP首部](/images/udp-head.png)\n\n由于TCP的可靠传输机制，TCP首部由固定的20字节+可选的40字节组成（4位首部长度2^3-1个4字节）；UDP首部由固定的8字节组成。TCP和UDP首部都含有16位源端口、目的端口号（端口号和IP地址组成一个socket）。TCP中的32位序号和32位确认序号用于完成序号确认、失序重排等。TCP和UDP的16校验和计算过程类似，都需要添加12字节伪首部，TCP伪首部和UDP伪首部不同的地方为8位协议部分（TCP为6，UDP为17），长度项均为首部+数据部分长度，TCP校验和计算是强制的，UDP是可选的。TCP首部特有的6个标志比特位置位后用来完成连接过程以及使某些字段有效等，以下为各字段作用：\n\n\t1. SYN字段，用于建立连接，前两次握手置为1，建立连接后该字段始终置为0，SYN占用一个序号\n\t2. FIN，终止连接，TCP连接是全双工的，需要4次挥手关闭一个完整的TCP连接，FIN也占用一个序号\n\t3. URG，表示紧急指针有效，紧急指针是一个正的偏移量，和TCP首部序号相加可以得出紧急数据位置\n\t4. ACK，表明确认序号有效，连接建立后必须始终置为1\n\t5. PSH，提醒接收方快速将数据转交给应用层\n\t6. RST，表明需要重新建立连接\n\nTCP还有一个窗口大小，其用来进行流量控制，建立连接和通信过程均可以通告窗口大小，窗口大小和可选段的窗口比例组成最终的窗口大小。\n\n在TCP的可选段中，主要有如下：\n\n\t1. MSS（Maxium Segment Size），最大报文段长度，表示数据段最大长度，MSS只出现在SYN报文中，用于避免IP分片\n\t2. 窗口扩大选项（Windows Scaling），表示窗口大小左移位数，即窗口大小*2^(窗口扩大值)\n\t3. SACK选择确认项（Selective Acknowledgements），由于启用选择确认机制而不是累计确认，减少重发数据量\n\t4. 时间戳选项（Timestamps），用来计算RTT往返时间或者解决序号回绕的问题\n\t5. NOP（NO-Operation），用来填充使可选段长度为4字节倍数\n\n## TCP连接建立与终止\n\nTCP由于预先建立连接，同时在断开时也需要经历四次挥手过程，其状态迁移图如下所示：[图片来源](http://www.cnblogs.com/missmzt/p/5308149.html)\n\n![TCP状态转移](/images/tcp-state-change.png)\n\n整个连接通信终止过程的转移如下图所示：[图片来源](http://www.cnblogs.com/wujing-hubei/p/5699773.html)\n\n![TCP状态转移](/images/tcp-socket.png)\n\n### 三次握手建立TCP连接\n\n由于TCP在通信前需要先建立连接，其过程是由称为三次握手建立，其基本步骤为:\n\n\t1. 发起方置SYN为1，序列号为x\n\t2. 接收方返回一个SYN置为1和ACK置为1的连接确认包，序号为y，确认号为x+1（SYN占用一个序号）\n\t3. 发起方发送一个ACK置为1的确认包，序号为x+1，确认号为y+1\n\n下图为使用WIRESHARK抓取的三次握手过程：\n\n![三次握手](/images/three-way-handshake.png)\n\n三次握手过程中会通告MSS以及窗口大小。\n\nTCP在设计过程中考虑到了同时打开的情况，考虑以下情况：主机A以本地端口portA向主机B端口portB发送SYN执行主动打开，同时主机B以本地端口portB向主机A端口portA发送SYN执行主动打开，然后双方回复ACK包，此时TCP只会建立一个TCP连接，共发生4次数据交换。其状态转移图如下所示：[图片来源](https://blog.csdn.net/huoqubing/article/details/6126189)\n\n![同时打开](/images/tcp-open-at-same-time.png)\n\n### 四次挥手终止TCP连接\n\n由于TCP连接是一个全双工连接，两个方向可以同时传递数据，因此在终止连接时需要经历四次挥手过程，其状态转移如下图所示：[图片来源](https://blog.csdn.net/huoqubing/article/details/6126189)\n\n四次挥手步骤如下：（假设主动发送最后被确认号为x，被动方发送最后被确认号为y）\n\n\t1. 主动关闭方发送FIN包，ACK置为1时确认号为y，序号为x（FIN包占有一个序号）\n\t2. 被动关闭方发送ACK包，ACK确认号置为x+1，序号为y\n\t3. 被动方发送FIN包，ACK确认号置为x+1，序号为y（FIN包占有一个序号）\n\t4. 主动关闭方发送ACK包，ACK确认号置为y+1，序号为x+1\n\n考虑一种情况，TCP连接双方同时发出关闭请求，此时状态转移图如下：[图片来源](https://blog.csdn.net/huoqubing/article/details/6126189)\n\n![同时关闭](/images/tcp-close-at-same-time.png)\n\n在主动发起关闭连接方最后会处于一个TIME_WAIT状态（也称为2MSL，Maximum Segment Lifetime），该状态的主要作用是确保最后发出的ACK被对方接收，否则需要重新发送。在2MSL等待期，本socket对将不能被使用，除非设置某些参数。2MSL收到的报文将会被丢弃。\n\n### TCP半关闭以及半打开\n\n半关闭是指某一方主动发起关闭连接后，另外一方还有数据需要发送，此时另外一方并不关闭连接，此时数据只能在一个方向上进行流动，半关闭示意图如下：[图片来源](https://blog.csdn.net/ericzhong83/article/details/8123420)\n\n![半关闭](/images/tcp-half-close.png)\n\n半打开是指TCP连接一方以及关闭连接或者异常终止而另外一方却不知情，处于半打开状态的TCP连接如果不发生数据交换一般很难发现连接出现问题，而一旦正常一方向异常一方发送数据，此时一般会回复一个RST包。\n\n## TCP的超时与重传\n\nTCP由于需要提供可靠的数据传输服务，因此其需要对数据接收进行确认，但是确认包也可能出现丢失的情况，这便是TCP需要使用超时与重传机制的原因。如果发送方在一段时间内没有收到对方确认包，则启动数据重传（此时可能在另外一方出现数据重复的情况）。在实现具体的超时重传时，需要确定具体超时间隔以及重传频率。为此，TCP含有7个不同的定时器来实现超超时与重传机制，分别是建立连接定时器（Connection-establishment Timer）、延迟应答定时器（Delayed ACK Timer）、重传定时器（Retransmission Timer）、坚持定时器（Persist Timer）、保活定时器（Keepalive Timer）、FIN\\_WAIT\\_2定时器（FIN\\_WAIT\\_2 Timer）、2MSL定时器（TIME_WAIT Timer）。以下分别介绍。\n\n### TCP定时器\n\n#### 建立连接定时器\n\nTCP建立连接需要进行三次握手，在发送SYN包后启动定时器，如果在定时器溢出之前没有收到ACK包则重发SYN包。定时器间隔一般采用指数退避，一般在75s尝试后依然没有收到ACK包则放弃本此连接。\n\n#### 延迟应答定时器\n\n由于TCP在发送数据后对方需要发送ACK包，如果每次接收到数据后立马发送ACK包可能会加重网络负担，如果等待一段时间可以接收到更多的数据则累计确认可以提高网络传输效率，或者可能在定时器内需要发送数据则可以捎带发送ACK包，也可以提高传输效率。\n\n#### 重传定时器\n\n在TCP发送数据后，会启动一个定时器，如果在定时器溢出前没有收到确认包，将会重发数据。定时间隔采用指数退避的方式且和RTT估值有关，在多次重传依然失败后将会发送RST包。\n\n#### 坚持定时器\n\nTCP在传输数据时，接收方会发送接收窗口，如果窗口的大小变为0则发送方将停止发送数据直到窗口打开。如果此时窗口打开的数据包丢失，那么会发生接收方在等待接收数据而发送方在等待窗口打开的死锁情况。为了防止这一情况的出现，发送方维持了一个坚持定时器向接收方查询窗口是否打开，这种报文段被称为窗口探查（探查数据一般不占用序列号）。计时器一般也采用了TCP的指数退避方式。和重传不同，TCP从不放弃窗口探查，直到窗口打开或者连接被关闭。\n\n#### 保活定时器\n\nTCP在建立连接后任意一方可以不发送任何数据，此时称为一个空闲的TCP连接。双方可以维持一个TCP连接数小时、数天甚至数年只要双方主机没有崩溃或者重启，而不管中间的路由器是否崩溃或者重启。但是如果一方已经崩溃或者关机或者重启，此时需要一种机制能够探测连接是否正常。保活定时器便用来实现这种探测，一般用于服务器。\n\n一般一个TCP连接如果2小时没有任何活动，服务器就会向客户发送一个探查。服务器探查时客户端可能存在以下几种情况：\n\n    1. 客户端正常并可达：两小时后定时器复位\n    2. 客户端已崩溃或者已关闭或者重启：发送多个探查后失败后服务器终止TCP连接\n    3. 客户端崩溃或者重启处于正常状态：客户端收到一个未知数据，向服务器发送RST复位包，服务器终止该连接\n    4. 客户端正常但是不可达（中间路由崩溃）：发送多个探查后失败后服务器终止TCP连接，即终止了一个良好的连接\n\n正是由于保活的上述特点，其主要有耗费带宽、关闭一个良好连接的缺点。优点是可以一定程度解决无效TCP连接，节省服务器维持连接需要的资源。\n\n#### FIN\\_WAIT\\_2定时器\n\n在TCP主动关闭连接并收到ACK包时进入改状态，如果此时对方既不发送数据也不发送FIN包终止连接，此时主动关闭一方会在等待一段时间后直接关闭该连接，这样可以防止对方崩溃后一直等待FIN包的情况。\n\n#### 2MSL定时器\n\n2MSL定时器也称为TIME_WAIT定时器，是主动关闭以方出现的状态，在主动一方接收到FIN包后处于的一个状态。该状态主要用来防止丢失ACK包（对方没有收到ACK会重发FIN包）。在该期间收到的任何报文均会被丢弃，防止旧TCP连接出现在新TCP连接中。\n\n### 重传RTT时间测量\n\nTCP超时重传需要确认重传超时时间，由于数据包以及确认包往返需要时间，因此为了确定合适的超时时间需要测量TCP连接的往返时间。RTT时间和网络状态密切相关，因此一般是一个动态变化的值。（相关：Karn算法）\n\n## TCP的流量控制\n\n由于接收方的缓冲区大小是有限的，因此必须提供一种机制防止发送方发送太快而接收方来不及接收而造成的数据丢失，这就是滑动窗口协议提供的流量控制功能。\n\n### TCP的滑动窗口协议\n\n滑动窗口的示意图如下：[图片来源](http://www.cnblogs.com/hupp/p/4857093.html)\n\n![滑动窗口示意图](/images/sliding-window.png)\n\n从图中可以看出，数据流有三大部分组成：窗口左边发送已确认数据、窗口内数据、窗口右边未发送数据。在窗口内部又可以分为两部分为：已发送待确认数据、可发送未发送数据。根据窗口的运动情况可分为以下几种几种移动方式：\n\n    1. 窗口左边向右移动导致窗口合拢，表明已发送数据被确认\n    2. 窗口右边向右移动导致窗口张开，此时表明对方处理接收缓冲区数据导致接收窗口变大\n    3. 窗口右边向左移动导致窗口收缩，该情况一般发生在糊涂窗口处理时，一般该行为不被建议。\n\n接收窗口的大小可以通过API设置发送或者接收缓冲的方式设定。\n\n### 糊涂窗口综合症（Silly Window Syndrome）\n\n在基于窗口的流量控制方式中，会导致一种称为“糊涂窗口综合症SWS”的情况。该情况是指当前少量的数据（没有满报文长度）进行了交换，使得数据传输效率大大降低。一般发生原因有如下几种：\n\n    1. 发送方缓慢创建数据，解决方式为Nagle算法\n    2. 接收方缓慢消耗数据致使接收窗口很小，解决方式为David D Clark算法\n\n解决接收方的主要方式是接收方不通告小的窗口，发送方可以采用当满足一个满报文长度时才发送或者至少是通告窗口的一半等。\n\n## TCP的拥塞控制\n\n在进行数据传输时不仅需要考虑接收方的接收能力，也需要考虑网络负担问题，网络一旦拥塞将会极大降低传输效率，这既是拥塞控制需要解决的。在进行拥塞控制需要了解网络负载情况，拥塞控制主要有慢启动、拥塞避免、快重传、快恢复，以下分别介绍。\n\n### 慢启动算法\n\n慢启动机制定义了一个拥塞窗口（cwnd），当建立TCP连接时，拥塞窗口初始化为1个报文段，每收到一个ACK包，拥塞窗口就增加一个报文段，发送方在确定发送窗口时取通告接收窗口和拥塞窗口较小的一个。拥塞窗口的增长方式为指数级增长。随着拥塞窗口的增长，最后发送接收之间的管道被填满，此时无论拥塞窗口还是通告窗口大小，管道不能再容纳更多数据，只能是接收方没小号一个单位的数据而发送方发送一个单位的数据，此时返回路径上的的ACK包数量是固定的，这既是连接的理想稳定状态。\n\n### 拥塞避免算法\n\n在使用慢启动算法时，可能很快数据传输达到中间路由器能力的极限，此时数据将会被丢弃。为了防止这一情况出现，在慢启动算法上提出了拥塞避免算法，这两个算法是两个独立的算法，但实现中常常结合在一起。\n\n拥塞避免算法需要维护一个慢启动门限ssthresh，算法的基本流程为：\n\n    1. 对于一个连接，初始化cwnd为1个报文段，ssthresh初始化65535个字节\n    2. 当cwnd<ssthresh使用慢启动，cwnd>ssthresh使用拥塞避免算法，两者相等可随意选择一个\n    3. 发生拥塞时（超时或者重复确认），ssthresh设置为当前窗口的一半，如果超时造成拥塞则将cwnd设置为1\n    4. 拥塞避免时cwnd以线性方式增长\n\n### 快重传与快速恢复\n\n在TCP收到一个失序的报文时，TCP需要立刻产生一个重复的ACK包，该ACK包告诉对方接收失序，期望接受的序列号。由于重复ACK包不一定是接收失序造成，因此只有在连续收到3个以上的重复ACK包再进行快速重传。快速重传无需等待超时定时器溢出。接下来不再执行慢启动算法而是拥塞避免算法，这就是快速恢复算法，既不把cwnd设为1。\n\n快速恢复算实现如下：\n\n    1. 收到三个重复确认后将ssthresh设置为cwnd的一半，重传丢失的报文，设置cwnd为ssthresh+3倍报文段大小\n    2. 每次收到另外一个重复ACK时，cwnd增加一个1个报文段，并发送分组\n    3. 收到确认新报文的ACK包后cwnd设置为ssthresh\n\n## TCP-UDP对比\n\n由于UDP自身协议比较简单，而且没有很多控制方法，因此UDP对系统资源要求较少，且效率也更高。由于UDP头部是固定的8字节，相比于TCP头部更加简单，因此传输效率也比较高。但是UDP不对可靠性做任何保证。\n\n\n\n\n## 参考文章\n\n[TCP/IP详解 卷1：协议](https://book.douban.com/subject/1088054/)\n\n[TCP中的7种定时器详解](https://blog.csdn.net/hyman_yx/article/details/52086389)\n\n[计算机网络相关](https://www.jianshu.com/p/7178d5c3716e)\n\n[TCP中的定时器](https://blog.csdn.net/sicofield/article/details/9672457)\n\n[糊涂窗口综合症-维基百科](https://zh.wikipedia.org/wiki/糊涂窗口综合症)\n\n[TCP/IP协议族之运输层：TCP流量控制和拥塞控制1](http://www.cnblogs.com/way_testlife/archive/2010/10/11/1848241.html)\n\n[TCP/IP协议族之运输层：TCP流量控制和拥塞控制2](http://www.cnblogs.com/way_testlife/archive/2010/10/11/1848333.html)\n\n[慢启动与拥塞窗口](https://blog.csdn.net/nestler/article/details/30237529)\n\n[SYN攻击及防范](https://www.jianshu.com/p/8331aeb193d9)\n","slug":"计算机网络/TCP-UDP基础以及区别","published":1,"updated":"2018-06-13T14:19:57.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x4m0037gsvnb25z1o86","content":"<h2 id=\"TCP-UDP基础知识\"><a href=\"#TCP-UDP基础知识\" class=\"headerlink\" title=\"TCP-UDP基础知识\"></a>TCP-UDP基础知识</h2><p>TCP全称传输控制协议（Transmission Control Protocol），是一种面向连接、可靠的、基于字节流的传输层通信协议。面向连接意味着TCP在进行数据交换时需要先建立一个TCP连接（三次握手）；可靠意味着TCP协议需要保证数据可靠的传送到对方，TCP可靠性体现在数据分割成合适长度（MTU限制）、序号确认机制（累积确认，注意回绕问题）、超时重传机制、快速重传（连续收到三次对同一个包的确认）、数据校验（校验和）、失序重排、重复数据处理、流量控制机制（滑动窗口机制）、拥塞控制机制（慢开始等）。</p>\n<p>UDP全称用户数据包协议（User Datagram Protocol），是一种简单的面向数据报的无连接、不可靠、基于数据报的传输层协议。UDP每次发送整个数据报，不关心是否超过MTU（由应用层协议处理）。UDP数据报发出后并不保证到达目的地，因此如果UDP需要保证可靠性，可以通过应用层处理。</p>\n<h2 id=\"TCP-UDP首部解析\"><a href=\"#TCP-UDP首部解析\" class=\"headerlink\" title=\"TCP-UDP首部解析\"></a>TCP-UDP首部解析</h2><p>TCP首部图如下所示：<a href=\"https://blog.csdn.net/zhanglong_daniel/article/details/50749098\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-head.png\" alt=\"TCP首部\"></p>\n<p>UDP首部图如下所示：<a href=\"https://blog.csdn.net/nestler/article/details/28668153\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/udp-head.png\" alt=\"UDP首部\"></p>\n<p>由于TCP的可靠传输机制，TCP首部由固定的20字节+可选的40字节组成（4位首部长度2^3-1个4字节）；UDP首部由固定的8字节组成。TCP和UDP首部都含有16位源端口、目的端口号（端口号和IP地址组成一个socket）。TCP中的32位序号和32位确认序号用于完成序号确认、失序重排等。TCP和UDP的16校验和计算过程类似，都需要添加12字节伪首部，TCP伪首部和UDP伪首部不同的地方为8位协议部分（TCP为6，UDP为17），长度项均为首部+数据部分长度，TCP校验和计算是强制的，UDP是可选的。TCP首部特有的6个标志比特位置位后用来完成连接过程以及使某些字段有效等，以下为各字段作用：</p>\n<pre><code>1. SYN字段，用于建立连接，前两次握手置为1，建立连接后该字段始终置为0，SYN占用一个序号\n2. FIN，终止连接，TCP连接是全双工的，需要4次挥手关闭一个完整的TCP连接，FIN也占用一个序号\n3. URG，表示紧急指针有效，紧急指针是一个正的偏移量，和TCP首部序号相加可以得出紧急数据位置\n4. ACK，表明确认序号有效，连接建立后必须始终置为1\n5. PSH，提醒接收方快速将数据转交给应用层\n6. RST，表明需要重新建立连接\n</code></pre><p>TCP还有一个窗口大小，其用来进行流量控制，建立连接和通信过程均可以通告窗口大小，窗口大小和可选段的窗口比例组成最终的窗口大小。</p>\n<p>在TCP的可选段中，主要有如下：</p>\n<pre><code>1. MSS（Maxium Segment Size），最大报文段长度，表示数据段最大长度，MSS只出现在SYN报文中，用于避免IP分片\n2. 窗口扩大选项（Windows Scaling），表示窗口大小左移位数，即窗口大小*2^(窗口扩大值)\n3. SACK选择确认项（Selective Acknowledgements），由于启用选择确认机制而不是累计确认，减少重发数据量\n4. 时间戳选项（Timestamps），用来计算RTT往返时间或者解决序号回绕的问题\n5. NOP（NO-Operation），用来填充使可选段长度为4字节倍数\n</code></pre><h2 id=\"TCP连接建立与终止\"><a href=\"#TCP连接建立与终止\" class=\"headerlink\" title=\"TCP连接建立与终止\"></a>TCP连接建立与终止</h2><p>TCP由于预先建立连接，同时在断开时也需要经历四次挥手过程，其状态迁移图如下所示：<a href=\"http://www.cnblogs.com/missmzt/p/5308149.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-state-change.png\" alt=\"TCP状态转移\"></p>\n<p>整个连接通信终止过程的转移如下图所示：<a href=\"http://www.cnblogs.com/wujing-hubei/p/5699773.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-socket.png\" alt=\"TCP状态转移\"></p>\n<h3 id=\"三次握手建立TCP连接\"><a href=\"#三次握手建立TCP连接\" class=\"headerlink\" title=\"三次握手建立TCP连接\"></a>三次握手建立TCP连接</h3><p>由于TCP在通信前需要先建立连接，其过程是由称为三次握手建立，其基本步骤为:</p>\n<pre><code>1. 发起方置SYN为1，序列号为x\n2. 接收方返回一个SYN置为1和ACK置为1的连接确认包，序号为y，确认号为x+1（SYN占用一个序号）\n3. 发起方发送一个ACK置为1的确认包，序号为x+1，确认号为y+1\n</code></pre><p>下图为使用WIRESHARK抓取的三次握手过程：</p>\n<p><img src=\"/images/three-way-handshake.png\" alt=\"三次握手\"></p>\n<p>三次握手过程中会通告MSS以及窗口大小。</p>\n<p>TCP在设计过程中考虑到了同时打开的情况，考虑以下情况：主机A以本地端口portA向主机B端口portB发送SYN执行主动打开，同时主机B以本地端口portB向主机A端口portA发送SYN执行主动打开，然后双方回复ACK包，此时TCP只会建立一个TCP连接，共发生4次数据交换。其状态转移图如下所示：<a href=\"https://blog.csdn.net/huoqubing/article/details/6126189\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-open-at-same-time.png\" alt=\"同时打开\"></p>\n<h3 id=\"四次挥手终止TCP连接\"><a href=\"#四次挥手终止TCP连接\" class=\"headerlink\" title=\"四次挥手终止TCP连接\"></a>四次挥手终止TCP连接</h3><p>由于TCP连接是一个全双工连接，两个方向可以同时传递数据，因此在终止连接时需要经历四次挥手过程，其状态转移如下图所示：<a href=\"https://blog.csdn.net/huoqubing/article/details/6126189\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p>四次挥手步骤如下：（假设主动发送最后被确认号为x，被动方发送最后被确认号为y）</p>\n<pre><code>1. 主动关闭方发送FIN包，ACK置为1时确认号为y，序号为x（FIN包占有一个序号）\n2. 被动关闭方发送ACK包，ACK确认号置为x+1，序号为y\n3. 被动方发送FIN包，ACK确认号置为x+1，序号为y（FIN包占有一个序号）\n4. 主动关闭方发送ACK包，ACK确认号置为y+1，序号为x+1\n</code></pre><p>考虑一种情况，TCP连接双方同时发出关闭请求，此时状态转移图如下：<a href=\"https://blog.csdn.net/huoqubing/article/details/6126189\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-close-at-same-time.png\" alt=\"同时关闭\"></p>\n<p>在主动发起关闭连接方最后会处于一个TIME_WAIT状态（也称为2MSL，Maximum Segment Lifetime），该状态的主要作用是确保最后发出的ACK被对方接收，否则需要重新发送。在2MSL等待期，本socket对将不能被使用，除非设置某些参数。2MSL收到的报文将会被丢弃。</p>\n<h3 id=\"TCP半关闭以及半打开\"><a href=\"#TCP半关闭以及半打开\" class=\"headerlink\" title=\"TCP半关闭以及半打开\"></a>TCP半关闭以及半打开</h3><p>半关闭是指某一方主动发起关闭连接后，另外一方还有数据需要发送，此时另外一方并不关闭连接，此时数据只能在一个方向上进行流动，半关闭示意图如下：<a href=\"https://blog.csdn.net/ericzhong83/article/details/8123420\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-half-close.png\" alt=\"半关闭\"></p>\n<p>半打开是指TCP连接一方以及关闭连接或者异常终止而另外一方却不知情，处于半打开状态的TCP连接如果不发生数据交换一般很难发现连接出现问题，而一旦正常一方向异常一方发送数据，此时一般会回复一个RST包。</p>\n<h2 id=\"TCP的超时与重传\"><a href=\"#TCP的超时与重传\" class=\"headerlink\" title=\"TCP的超时与重传\"></a>TCP的超时与重传</h2><p>TCP由于需要提供可靠的数据传输服务，因此其需要对数据接收进行确认，但是确认包也可能出现丢失的情况，这便是TCP需要使用超时与重传机制的原因。如果发送方在一段时间内没有收到对方确认包，则启动数据重传（此时可能在另外一方出现数据重复的情况）。在实现具体的超时重传时，需要确定具体超时间隔以及重传频率。为此，TCP含有7个不同的定时器来实现超超时与重传机制，分别是建立连接定时器（Connection-establishment Timer）、延迟应答定时器（Delayed ACK Timer）、重传定时器（Retransmission Timer）、坚持定时器（Persist Timer）、保活定时器（Keepalive Timer）、FIN_WAIT_2定时器（FIN_WAIT_2 Timer）、2MSL定时器（TIME_WAIT Timer）。以下分别介绍。</p>\n<h3 id=\"TCP定时器\"><a href=\"#TCP定时器\" class=\"headerlink\" title=\"TCP定时器\"></a>TCP定时器</h3><h4 id=\"建立连接定时器\"><a href=\"#建立连接定时器\" class=\"headerlink\" title=\"建立连接定时器\"></a>建立连接定时器</h4><p>TCP建立连接需要进行三次握手，在发送SYN包后启动定时器，如果在定时器溢出之前没有收到ACK包则重发SYN包。定时器间隔一般采用指数退避，一般在75s尝试后依然没有收到ACK包则放弃本此连接。</p>\n<h4 id=\"延迟应答定时器\"><a href=\"#延迟应答定时器\" class=\"headerlink\" title=\"延迟应答定时器\"></a>延迟应答定时器</h4><p>由于TCP在发送数据后对方需要发送ACK包，如果每次接收到数据后立马发送ACK包可能会加重网络负担，如果等待一段时间可以接收到更多的数据则累计确认可以提高网络传输效率，或者可能在定时器内需要发送数据则可以捎带发送ACK包，也可以提高传输效率。</p>\n<h4 id=\"重传定时器\"><a href=\"#重传定时器\" class=\"headerlink\" title=\"重传定时器\"></a>重传定时器</h4><p>在TCP发送数据后，会启动一个定时器，如果在定时器溢出前没有收到确认包，将会重发数据。定时间隔采用指数退避的方式且和RTT估值有关，在多次重传依然失败后将会发送RST包。</p>\n<h4 id=\"坚持定时器\"><a href=\"#坚持定时器\" class=\"headerlink\" title=\"坚持定时器\"></a>坚持定时器</h4><p>TCP在传输数据时，接收方会发送接收窗口，如果窗口的大小变为0则发送方将停止发送数据直到窗口打开。如果此时窗口打开的数据包丢失，那么会发生接收方在等待接收数据而发送方在等待窗口打开的死锁情况。为了防止这一情况的出现，发送方维持了一个坚持定时器向接收方查询窗口是否打开，这种报文段被称为窗口探查（探查数据一般不占用序列号）。计时器一般也采用了TCP的指数退避方式。和重传不同，TCP从不放弃窗口探查，直到窗口打开或者连接被关闭。</p>\n<h4 id=\"保活定时器\"><a href=\"#保活定时器\" class=\"headerlink\" title=\"保活定时器\"></a>保活定时器</h4><p>TCP在建立连接后任意一方可以不发送任何数据，此时称为一个空闲的TCP连接。双方可以维持一个TCP连接数小时、数天甚至数年只要双方主机没有崩溃或者重启，而不管中间的路由器是否崩溃或者重启。但是如果一方已经崩溃或者关机或者重启，此时需要一种机制能够探测连接是否正常。保活定时器便用来实现这种探测，一般用于服务器。</p>\n<p>一般一个TCP连接如果2小时没有任何活动，服务器就会向客户发送一个探查。服务器探查时客户端可能存在以下几种情况：</p>\n<pre><code>1. 客户端正常并可达：两小时后定时器复位\n2. 客户端已崩溃或者已关闭或者重启：发送多个探查后失败后服务器终止TCP连接\n3. 客户端崩溃或者重启处于正常状态：客户端收到一个未知数据，向服务器发送RST复位包，服务器终止该连接\n4. 客户端正常但是不可达（中间路由崩溃）：发送多个探查后失败后服务器终止TCP连接，即终止了一个良好的连接\n</code></pre><p>正是由于保活的上述特点，其主要有耗费带宽、关闭一个良好连接的缺点。优点是可以一定程度解决无效TCP连接，节省服务器维持连接需要的资源。</p>\n<h4 id=\"FIN-WAIT-2定时器\"><a href=\"#FIN-WAIT-2定时器\" class=\"headerlink\" title=\"FIN_WAIT_2定时器\"></a>FIN_WAIT_2定时器</h4><p>在TCP主动关闭连接并收到ACK包时进入改状态，如果此时对方既不发送数据也不发送FIN包终止连接，此时主动关闭一方会在等待一段时间后直接关闭该连接，这样可以防止对方崩溃后一直等待FIN包的情况。</p>\n<h4 id=\"2MSL定时器\"><a href=\"#2MSL定时器\" class=\"headerlink\" title=\"2MSL定时器\"></a>2MSL定时器</h4><p>2MSL定时器也称为TIME_WAIT定时器，是主动关闭以方出现的状态，在主动一方接收到FIN包后处于的一个状态。该状态主要用来防止丢失ACK包（对方没有收到ACK会重发FIN包）。在该期间收到的任何报文均会被丢弃，防止旧TCP连接出现在新TCP连接中。</p>\n<h3 id=\"重传RTT时间测量\"><a href=\"#重传RTT时间测量\" class=\"headerlink\" title=\"重传RTT时间测量\"></a>重传RTT时间测量</h3><p>TCP超时重传需要确认重传超时时间，由于数据包以及确认包往返需要时间，因此为了确定合适的超时时间需要测量TCP连接的往返时间。RTT时间和网络状态密切相关，因此一般是一个动态变化的值。（相关：Karn算法）</p>\n<h2 id=\"TCP的流量控制\"><a href=\"#TCP的流量控制\" class=\"headerlink\" title=\"TCP的流量控制\"></a>TCP的流量控制</h2><p>由于接收方的缓冲区大小是有限的，因此必须提供一种机制防止发送方发送太快而接收方来不及接收而造成的数据丢失，这就是滑动窗口协议提供的流量控制功能。</p>\n<h3 id=\"TCP的滑动窗口协议\"><a href=\"#TCP的滑动窗口协议\" class=\"headerlink\" title=\"TCP的滑动窗口协议\"></a>TCP的滑动窗口协议</h3><p>滑动窗口的示意图如下：<a href=\"http://www.cnblogs.com/hupp/p/4857093.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/sliding-window.png\" alt=\"滑动窗口示意图\"></p>\n<p>从图中可以看出，数据流有三大部分组成：窗口左边发送已确认数据、窗口内数据、窗口右边未发送数据。在窗口内部又可以分为两部分为：已发送待确认数据、可发送未发送数据。根据窗口的运动情况可分为以下几种几种移动方式：</p>\n<pre><code>1. 窗口左边向右移动导致窗口合拢，表明已发送数据被确认\n2. 窗口右边向右移动导致窗口张开，此时表明对方处理接收缓冲区数据导致接收窗口变大\n3. 窗口右边向左移动导致窗口收缩，该情况一般发生在糊涂窗口处理时，一般该行为不被建议。\n</code></pre><p>接收窗口的大小可以通过API设置发送或者接收缓冲的方式设定。</p>\n<h3 id=\"糊涂窗口综合症（Silly-Window-Syndrome）\"><a href=\"#糊涂窗口综合症（Silly-Window-Syndrome）\" class=\"headerlink\" title=\"糊涂窗口综合症（Silly Window Syndrome）\"></a>糊涂窗口综合症（Silly Window Syndrome）</h3><p>在基于窗口的流量控制方式中，会导致一种称为“糊涂窗口综合症SWS”的情况。该情况是指当前少量的数据（没有满报文长度）进行了交换，使得数据传输效率大大降低。一般发生原因有如下几种：</p>\n<pre><code>1. 发送方缓慢创建数据，解决方式为Nagle算法\n2. 接收方缓慢消耗数据致使接收窗口很小，解决方式为David D Clark算法\n</code></pre><p>解决接收方的主要方式是接收方不通告小的窗口，发送方可以采用当满足一个满报文长度时才发送或者至少是通告窗口的一半等。</p>\n<h2 id=\"TCP的拥塞控制\"><a href=\"#TCP的拥塞控制\" class=\"headerlink\" title=\"TCP的拥塞控制\"></a>TCP的拥塞控制</h2><p>在进行数据传输时不仅需要考虑接收方的接收能力，也需要考虑网络负担问题，网络一旦拥塞将会极大降低传输效率，这既是拥塞控制需要解决的。在进行拥塞控制需要了解网络负载情况，拥塞控制主要有慢启动、拥塞避免、快重传、快恢复，以下分别介绍。</p>\n<h3 id=\"慢启动算法\"><a href=\"#慢启动算法\" class=\"headerlink\" title=\"慢启动算法\"></a>慢启动算法</h3><p>慢启动机制定义了一个拥塞窗口（cwnd），当建立TCP连接时，拥塞窗口初始化为1个报文段，每收到一个ACK包，拥塞窗口就增加一个报文段，发送方在确定发送窗口时取通告接收窗口和拥塞窗口较小的一个。拥塞窗口的增长方式为指数级增长。随着拥塞窗口的增长，最后发送接收之间的管道被填满，此时无论拥塞窗口还是通告窗口大小，管道不能再容纳更多数据，只能是接收方没小号一个单位的数据而发送方发送一个单位的数据，此时返回路径上的的ACK包数量是固定的，这既是连接的理想稳定状态。</p>\n<h3 id=\"拥塞避免算法\"><a href=\"#拥塞避免算法\" class=\"headerlink\" title=\"拥塞避免算法\"></a>拥塞避免算法</h3><p>在使用慢启动算法时，可能很快数据传输达到中间路由器能力的极限，此时数据将会被丢弃。为了防止这一情况出现，在慢启动算法上提出了拥塞避免算法，这两个算法是两个独立的算法，但实现中常常结合在一起。</p>\n<p>拥塞避免算法需要维护一个慢启动门限ssthresh，算法的基本流程为：</p>\n<pre><code>1. 对于一个连接，初始化cwnd为1个报文段，ssthresh初始化65535个字节\n2. 当cwnd&lt;ssthresh使用慢启动，cwnd&gt;ssthresh使用拥塞避免算法，两者相等可随意选择一个\n3. 发生拥塞时（超时或者重复确认），ssthresh设置为当前窗口的一半，如果超时造成拥塞则将cwnd设置为1\n4. 拥塞避免时cwnd以线性方式增长\n</code></pre><h3 id=\"快重传与快速恢复\"><a href=\"#快重传与快速恢复\" class=\"headerlink\" title=\"快重传与快速恢复\"></a>快重传与快速恢复</h3><p>在TCP收到一个失序的报文时，TCP需要立刻产生一个重复的ACK包，该ACK包告诉对方接收失序，期望接受的序列号。由于重复ACK包不一定是接收失序造成，因此只有在连续收到3个以上的重复ACK包再进行快速重传。快速重传无需等待超时定时器溢出。接下来不再执行慢启动算法而是拥塞避免算法，这就是快速恢复算法，既不把cwnd设为1。</p>\n<p>快速恢复算实现如下：</p>\n<pre><code>1. 收到三个重复确认后将ssthresh设置为cwnd的一半，重传丢失的报文，设置cwnd为ssthresh+3倍报文段大小\n2. 每次收到另外一个重复ACK时，cwnd增加一个1个报文段，并发送分组\n3. 收到确认新报文的ACK包后cwnd设置为ssthresh\n</code></pre><h2 id=\"TCP-UDP对比\"><a href=\"#TCP-UDP对比\" class=\"headerlink\" title=\"TCP-UDP对比\"></a>TCP-UDP对比</h2><p>由于UDP自身协议比较简单，而且没有很多控制方法，因此UDP对系统资源要求较少，且效率也更高。由于UDP头部是固定的8字节，相比于TCP头部更加简单，因此传输效率也比较高。但是UDP不对可靠性做任何保证。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"noopener\">TCP/IP详解 卷1：协议</a></p>\n<p><a href=\"https://blog.csdn.net/hyman_yx/article/details/52086389\" target=\"_blank\" rel=\"noopener\">TCP中的7种定时器详解</a></p>\n<p><a href=\"https://www.jianshu.com/p/7178d5c3716e\" target=\"_blank\" rel=\"noopener\">计算机网络相关</a></p>\n<p><a href=\"https://blog.csdn.net/sicofield/article/details/9672457\" target=\"_blank\" rel=\"noopener\">TCP中的定时器</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/糊涂窗口综合症\" target=\"_blank\" rel=\"noopener\">糊涂窗口综合症-维基百科</a></p>\n<p><a href=\"http://www.cnblogs.com/way_testlife/archive/2010/10/11/1848241.html\" target=\"_blank\" rel=\"noopener\">TCP/IP协议族之运输层：TCP流量控制和拥塞控制1</a></p>\n<p><a href=\"http://www.cnblogs.com/way_testlife/archive/2010/10/11/1848333.html\" target=\"_blank\" rel=\"noopener\">TCP/IP协议族之运输层：TCP流量控制和拥塞控制2</a></p>\n<p><a href=\"https://blog.csdn.net/nestler/article/details/30237529\" target=\"_blank\" rel=\"noopener\">慢启动与拥塞窗口</a></p>\n<p><a href=\"https://www.jianshu.com/p/8331aeb193d9\" target=\"_blank\" rel=\"noopener\">SYN攻击及防范</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TCP-UDP基础知识\"><a href=\"#TCP-UDP基础知识\" class=\"headerlink\" title=\"TCP-UDP基础知识\"></a>TCP-UDP基础知识</h2><p>TCP全称传输控制协议（Transmission Control Protocol），是一种面向连接、可靠的、基于字节流的传输层通信协议。面向连接意味着TCP在进行数据交换时需要先建立一个TCP连接（三次握手）；可靠意味着TCP协议需要保证数据可靠的传送到对方，TCP可靠性体现在数据分割成合适长度（MTU限制）、序号确认机制（累积确认，注意回绕问题）、超时重传机制、快速重传（连续收到三次对同一个包的确认）、数据校验（校验和）、失序重排、重复数据处理、流量控制机制（滑动窗口机制）、拥塞控制机制（慢开始等）。</p>\n<p>UDP全称用户数据包协议（User Datagram Protocol），是一种简单的面向数据报的无连接、不可靠、基于数据报的传输层协议。UDP每次发送整个数据报，不关心是否超过MTU（由应用层协议处理）。UDP数据报发出后并不保证到达目的地，因此如果UDP需要保证可靠性，可以通过应用层处理。</p>\n<h2 id=\"TCP-UDP首部解析\"><a href=\"#TCP-UDP首部解析\" class=\"headerlink\" title=\"TCP-UDP首部解析\"></a>TCP-UDP首部解析</h2><p>TCP首部图如下所示：<a href=\"https://blog.csdn.net/zhanglong_daniel/article/details/50749098\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-head.png\" alt=\"TCP首部\"></p>\n<p>UDP首部图如下所示：<a href=\"https://blog.csdn.net/nestler/article/details/28668153\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/udp-head.png\" alt=\"UDP首部\"></p>\n<p>由于TCP的可靠传输机制，TCP首部由固定的20字节+可选的40字节组成（4位首部长度2^3-1个4字节）；UDP首部由固定的8字节组成。TCP和UDP首部都含有16位源端口、目的端口号（端口号和IP地址组成一个socket）。TCP中的32位序号和32位确认序号用于完成序号确认、失序重排等。TCP和UDP的16校验和计算过程类似，都需要添加12字节伪首部，TCP伪首部和UDP伪首部不同的地方为8位协议部分（TCP为6，UDP为17），长度项均为首部+数据部分长度，TCP校验和计算是强制的，UDP是可选的。TCP首部特有的6个标志比特位置位后用来完成连接过程以及使某些字段有效等，以下为各字段作用：</p>\n<pre><code>1. SYN字段，用于建立连接，前两次握手置为1，建立连接后该字段始终置为0，SYN占用一个序号\n2. FIN，终止连接，TCP连接是全双工的，需要4次挥手关闭一个完整的TCP连接，FIN也占用一个序号\n3. URG，表示紧急指针有效，紧急指针是一个正的偏移量，和TCP首部序号相加可以得出紧急数据位置\n4. ACK，表明确认序号有效，连接建立后必须始终置为1\n5. PSH，提醒接收方快速将数据转交给应用层\n6. RST，表明需要重新建立连接\n</code></pre><p>TCP还有一个窗口大小，其用来进行流量控制，建立连接和通信过程均可以通告窗口大小，窗口大小和可选段的窗口比例组成最终的窗口大小。</p>\n<p>在TCP的可选段中，主要有如下：</p>\n<pre><code>1. MSS（Maxium Segment Size），最大报文段长度，表示数据段最大长度，MSS只出现在SYN报文中，用于避免IP分片\n2. 窗口扩大选项（Windows Scaling），表示窗口大小左移位数，即窗口大小*2^(窗口扩大值)\n3. SACK选择确认项（Selective Acknowledgements），由于启用选择确认机制而不是累计确认，减少重发数据量\n4. 时间戳选项（Timestamps），用来计算RTT往返时间或者解决序号回绕的问题\n5. NOP（NO-Operation），用来填充使可选段长度为4字节倍数\n</code></pre><h2 id=\"TCP连接建立与终止\"><a href=\"#TCP连接建立与终止\" class=\"headerlink\" title=\"TCP连接建立与终止\"></a>TCP连接建立与终止</h2><p>TCP由于预先建立连接，同时在断开时也需要经历四次挥手过程，其状态迁移图如下所示：<a href=\"http://www.cnblogs.com/missmzt/p/5308149.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-state-change.png\" alt=\"TCP状态转移\"></p>\n<p>整个连接通信终止过程的转移如下图所示：<a href=\"http://www.cnblogs.com/wujing-hubei/p/5699773.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-socket.png\" alt=\"TCP状态转移\"></p>\n<h3 id=\"三次握手建立TCP连接\"><a href=\"#三次握手建立TCP连接\" class=\"headerlink\" title=\"三次握手建立TCP连接\"></a>三次握手建立TCP连接</h3><p>由于TCP在通信前需要先建立连接，其过程是由称为三次握手建立，其基本步骤为:</p>\n<pre><code>1. 发起方置SYN为1，序列号为x\n2. 接收方返回一个SYN置为1和ACK置为1的连接确认包，序号为y，确认号为x+1（SYN占用一个序号）\n3. 发起方发送一个ACK置为1的确认包，序号为x+1，确认号为y+1\n</code></pre><p>下图为使用WIRESHARK抓取的三次握手过程：</p>\n<p><img src=\"/images/three-way-handshake.png\" alt=\"三次握手\"></p>\n<p>三次握手过程中会通告MSS以及窗口大小。</p>\n<p>TCP在设计过程中考虑到了同时打开的情况，考虑以下情况：主机A以本地端口portA向主机B端口portB发送SYN执行主动打开，同时主机B以本地端口portB向主机A端口portA发送SYN执行主动打开，然后双方回复ACK包，此时TCP只会建立一个TCP连接，共发生4次数据交换。其状态转移图如下所示：<a href=\"https://blog.csdn.net/huoqubing/article/details/6126189\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-open-at-same-time.png\" alt=\"同时打开\"></p>\n<h3 id=\"四次挥手终止TCP连接\"><a href=\"#四次挥手终止TCP连接\" class=\"headerlink\" title=\"四次挥手终止TCP连接\"></a>四次挥手终止TCP连接</h3><p>由于TCP连接是一个全双工连接，两个方向可以同时传递数据，因此在终止连接时需要经历四次挥手过程，其状态转移如下图所示：<a href=\"https://blog.csdn.net/huoqubing/article/details/6126189\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p>四次挥手步骤如下：（假设主动发送最后被确认号为x，被动方发送最后被确认号为y）</p>\n<pre><code>1. 主动关闭方发送FIN包，ACK置为1时确认号为y，序号为x（FIN包占有一个序号）\n2. 被动关闭方发送ACK包，ACK确认号置为x+1，序号为y\n3. 被动方发送FIN包，ACK确认号置为x+1，序号为y（FIN包占有一个序号）\n4. 主动关闭方发送ACK包，ACK确认号置为y+1，序号为x+1\n</code></pre><p>考虑一种情况，TCP连接双方同时发出关闭请求，此时状态转移图如下：<a href=\"https://blog.csdn.net/huoqubing/article/details/6126189\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-close-at-same-time.png\" alt=\"同时关闭\"></p>\n<p>在主动发起关闭连接方最后会处于一个TIME_WAIT状态（也称为2MSL，Maximum Segment Lifetime），该状态的主要作用是确保最后发出的ACK被对方接收，否则需要重新发送。在2MSL等待期，本socket对将不能被使用，除非设置某些参数。2MSL收到的报文将会被丢弃。</p>\n<h3 id=\"TCP半关闭以及半打开\"><a href=\"#TCP半关闭以及半打开\" class=\"headerlink\" title=\"TCP半关闭以及半打开\"></a>TCP半关闭以及半打开</h3><p>半关闭是指某一方主动发起关闭连接后，另外一方还有数据需要发送，此时另外一方并不关闭连接，此时数据只能在一个方向上进行流动，半关闭示意图如下：<a href=\"https://blog.csdn.net/ericzhong83/article/details/8123420\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/tcp-half-close.png\" alt=\"半关闭\"></p>\n<p>半打开是指TCP连接一方以及关闭连接或者异常终止而另外一方却不知情，处于半打开状态的TCP连接如果不发生数据交换一般很难发现连接出现问题，而一旦正常一方向异常一方发送数据，此时一般会回复一个RST包。</p>\n<h2 id=\"TCP的超时与重传\"><a href=\"#TCP的超时与重传\" class=\"headerlink\" title=\"TCP的超时与重传\"></a>TCP的超时与重传</h2><p>TCP由于需要提供可靠的数据传输服务，因此其需要对数据接收进行确认，但是确认包也可能出现丢失的情况，这便是TCP需要使用超时与重传机制的原因。如果发送方在一段时间内没有收到对方确认包，则启动数据重传（此时可能在另外一方出现数据重复的情况）。在实现具体的超时重传时，需要确定具体超时间隔以及重传频率。为此，TCP含有7个不同的定时器来实现超超时与重传机制，分别是建立连接定时器（Connection-establishment Timer）、延迟应答定时器（Delayed ACK Timer）、重传定时器（Retransmission Timer）、坚持定时器（Persist Timer）、保活定时器（Keepalive Timer）、FIN_WAIT_2定时器（FIN_WAIT_2 Timer）、2MSL定时器（TIME_WAIT Timer）。以下分别介绍。</p>\n<h3 id=\"TCP定时器\"><a href=\"#TCP定时器\" class=\"headerlink\" title=\"TCP定时器\"></a>TCP定时器</h3><h4 id=\"建立连接定时器\"><a href=\"#建立连接定时器\" class=\"headerlink\" title=\"建立连接定时器\"></a>建立连接定时器</h4><p>TCP建立连接需要进行三次握手，在发送SYN包后启动定时器，如果在定时器溢出之前没有收到ACK包则重发SYN包。定时器间隔一般采用指数退避，一般在75s尝试后依然没有收到ACK包则放弃本此连接。</p>\n<h4 id=\"延迟应答定时器\"><a href=\"#延迟应答定时器\" class=\"headerlink\" title=\"延迟应答定时器\"></a>延迟应答定时器</h4><p>由于TCP在发送数据后对方需要发送ACK包，如果每次接收到数据后立马发送ACK包可能会加重网络负担，如果等待一段时间可以接收到更多的数据则累计确认可以提高网络传输效率，或者可能在定时器内需要发送数据则可以捎带发送ACK包，也可以提高传输效率。</p>\n<h4 id=\"重传定时器\"><a href=\"#重传定时器\" class=\"headerlink\" title=\"重传定时器\"></a>重传定时器</h4><p>在TCP发送数据后，会启动一个定时器，如果在定时器溢出前没有收到确认包，将会重发数据。定时间隔采用指数退避的方式且和RTT估值有关，在多次重传依然失败后将会发送RST包。</p>\n<h4 id=\"坚持定时器\"><a href=\"#坚持定时器\" class=\"headerlink\" title=\"坚持定时器\"></a>坚持定时器</h4><p>TCP在传输数据时，接收方会发送接收窗口，如果窗口的大小变为0则发送方将停止发送数据直到窗口打开。如果此时窗口打开的数据包丢失，那么会发生接收方在等待接收数据而发送方在等待窗口打开的死锁情况。为了防止这一情况的出现，发送方维持了一个坚持定时器向接收方查询窗口是否打开，这种报文段被称为窗口探查（探查数据一般不占用序列号）。计时器一般也采用了TCP的指数退避方式。和重传不同，TCP从不放弃窗口探查，直到窗口打开或者连接被关闭。</p>\n<h4 id=\"保活定时器\"><a href=\"#保活定时器\" class=\"headerlink\" title=\"保活定时器\"></a>保活定时器</h4><p>TCP在建立连接后任意一方可以不发送任何数据，此时称为一个空闲的TCP连接。双方可以维持一个TCP连接数小时、数天甚至数年只要双方主机没有崩溃或者重启，而不管中间的路由器是否崩溃或者重启。但是如果一方已经崩溃或者关机或者重启，此时需要一种机制能够探测连接是否正常。保活定时器便用来实现这种探测，一般用于服务器。</p>\n<p>一般一个TCP连接如果2小时没有任何活动，服务器就会向客户发送一个探查。服务器探查时客户端可能存在以下几种情况：</p>\n<pre><code>1. 客户端正常并可达：两小时后定时器复位\n2. 客户端已崩溃或者已关闭或者重启：发送多个探查后失败后服务器终止TCP连接\n3. 客户端崩溃或者重启处于正常状态：客户端收到一个未知数据，向服务器发送RST复位包，服务器终止该连接\n4. 客户端正常但是不可达（中间路由崩溃）：发送多个探查后失败后服务器终止TCP连接，即终止了一个良好的连接\n</code></pre><p>正是由于保活的上述特点，其主要有耗费带宽、关闭一个良好连接的缺点。优点是可以一定程度解决无效TCP连接，节省服务器维持连接需要的资源。</p>\n<h4 id=\"FIN-WAIT-2定时器\"><a href=\"#FIN-WAIT-2定时器\" class=\"headerlink\" title=\"FIN_WAIT_2定时器\"></a>FIN_WAIT_2定时器</h4><p>在TCP主动关闭连接并收到ACK包时进入改状态，如果此时对方既不发送数据也不发送FIN包终止连接，此时主动关闭一方会在等待一段时间后直接关闭该连接，这样可以防止对方崩溃后一直等待FIN包的情况。</p>\n<h4 id=\"2MSL定时器\"><a href=\"#2MSL定时器\" class=\"headerlink\" title=\"2MSL定时器\"></a>2MSL定时器</h4><p>2MSL定时器也称为TIME_WAIT定时器，是主动关闭以方出现的状态，在主动一方接收到FIN包后处于的一个状态。该状态主要用来防止丢失ACK包（对方没有收到ACK会重发FIN包）。在该期间收到的任何报文均会被丢弃，防止旧TCP连接出现在新TCP连接中。</p>\n<h3 id=\"重传RTT时间测量\"><a href=\"#重传RTT时间测量\" class=\"headerlink\" title=\"重传RTT时间测量\"></a>重传RTT时间测量</h3><p>TCP超时重传需要确认重传超时时间，由于数据包以及确认包往返需要时间，因此为了确定合适的超时时间需要测量TCP连接的往返时间。RTT时间和网络状态密切相关，因此一般是一个动态变化的值。（相关：Karn算法）</p>\n<h2 id=\"TCP的流量控制\"><a href=\"#TCP的流量控制\" class=\"headerlink\" title=\"TCP的流量控制\"></a>TCP的流量控制</h2><p>由于接收方的缓冲区大小是有限的，因此必须提供一种机制防止发送方发送太快而接收方来不及接收而造成的数据丢失，这就是滑动窗口协议提供的流量控制功能。</p>\n<h3 id=\"TCP的滑动窗口协议\"><a href=\"#TCP的滑动窗口协议\" class=\"headerlink\" title=\"TCP的滑动窗口协议\"></a>TCP的滑动窗口协议</h3><p>滑动窗口的示意图如下：<a href=\"http://www.cnblogs.com/hupp/p/4857093.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/sliding-window.png\" alt=\"滑动窗口示意图\"></p>\n<p>从图中可以看出，数据流有三大部分组成：窗口左边发送已确认数据、窗口内数据、窗口右边未发送数据。在窗口内部又可以分为两部分为：已发送待确认数据、可发送未发送数据。根据窗口的运动情况可分为以下几种几种移动方式：</p>\n<pre><code>1. 窗口左边向右移动导致窗口合拢，表明已发送数据被确认\n2. 窗口右边向右移动导致窗口张开，此时表明对方处理接收缓冲区数据导致接收窗口变大\n3. 窗口右边向左移动导致窗口收缩，该情况一般发生在糊涂窗口处理时，一般该行为不被建议。\n</code></pre><p>接收窗口的大小可以通过API设置发送或者接收缓冲的方式设定。</p>\n<h3 id=\"糊涂窗口综合症（Silly-Window-Syndrome）\"><a href=\"#糊涂窗口综合症（Silly-Window-Syndrome）\" class=\"headerlink\" title=\"糊涂窗口综合症（Silly Window Syndrome）\"></a>糊涂窗口综合症（Silly Window Syndrome）</h3><p>在基于窗口的流量控制方式中，会导致一种称为“糊涂窗口综合症SWS”的情况。该情况是指当前少量的数据（没有满报文长度）进行了交换，使得数据传输效率大大降低。一般发生原因有如下几种：</p>\n<pre><code>1. 发送方缓慢创建数据，解决方式为Nagle算法\n2. 接收方缓慢消耗数据致使接收窗口很小，解决方式为David D Clark算法\n</code></pre><p>解决接收方的主要方式是接收方不通告小的窗口，发送方可以采用当满足一个满报文长度时才发送或者至少是通告窗口的一半等。</p>\n<h2 id=\"TCP的拥塞控制\"><a href=\"#TCP的拥塞控制\" class=\"headerlink\" title=\"TCP的拥塞控制\"></a>TCP的拥塞控制</h2><p>在进行数据传输时不仅需要考虑接收方的接收能力，也需要考虑网络负担问题，网络一旦拥塞将会极大降低传输效率，这既是拥塞控制需要解决的。在进行拥塞控制需要了解网络负载情况，拥塞控制主要有慢启动、拥塞避免、快重传、快恢复，以下分别介绍。</p>\n<h3 id=\"慢启动算法\"><a href=\"#慢启动算法\" class=\"headerlink\" title=\"慢启动算法\"></a>慢启动算法</h3><p>慢启动机制定义了一个拥塞窗口（cwnd），当建立TCP连接时，拥塞窗口初始化为1个报文段，每收到一个ACK包，拥塞窗口就增加一个报文段，发送方在确定发送窗口时取通告接收窗口和拥塞窗口较小的一个。拥塞窗口的增长方式为指数级增长。随着拥塞窗口的增长，最后发送接收之间的管道被填满，此时无论拥塞窗口还是通告窗口大小，管道不能再容纳更多数据，只能是接收方没小号一个单位的数据而发送方发送一个单位的数据，此时返回路径上的的ACK包数量是固定的，这既是连接的理想稳定状态。</p>\n<h3 id=\"拥塞避免算法\"><a href=\"#拥塞避免算法\" class=\"headerlink\" title=\"拥塞避免算法\"></a>拥塞避免算法</h3><p>在使用慢启动算法时，可能很快数据传输达到中间路由器能力的极限，此时数据将会被丢弃。为了防止这一情况出现，在慢启动算法上提出了拥塞避免算法，这两个算法是两个独立的算法，但实现中常常结合在一起。</p>\n<p>拥塞避免算法需要维护一个慢启动门限ssthresh，算法的基本流程为：</p>\n<pre><code>1. 对于一个连接，初始化cwnd为1个报文段，ssthresh初始化65535个字节\n2. 当cwnd&lt;ssthresh使用慢启动，cwnd&gt;ssthresh使用拥塞避免算法，两者相等可随意选择一个\n3. 发生拥塞时（超时或者重复确认），ssthresh设置为当前窗口的一半，如果超时造成拥塞则将cwnd设置为1\n4. 拥塞避免时cwnd以线性方式增长\n</code></pre><h3 id=\"快重传与快速恢复\"><a href=\"#快重传与快速恢复\" class=\"headerlink\" title=\"快重传与快速恢复\"></a>快重传与快速恢复</h3><p>在TCP收到一个失序的报文时，TCP需要立刻产生一个重复的ACK包，该ACK包告诉对方接收失序，期望接受的序列号。由于重复ACK包不一定是接收失序造成，因此只有在连续收到3个以上的重复ACK包再进行快速重传。快速重传无需等待超时定时器溢出。接下来不再执行慢启动算法而是拥塞避免算法，这就是快速恢复算法，既不把cwnd设为1。</p>\n<p>快速恢复算实现如下：</p>\n<pre><code>1. 收到三个重复确认后将ssthresh设置为cwnd的一半，重传丢失的报文，设置cwnd为ssthresh+3倍报文段大小\n2. 每次收到另外一个重复ACK时，cwnd增加一个1个报文段，并发送分组\n3. 收到确认新报文的ACK包后cwnd设置为ssthresh\n</code></pre><h2 id=\"TCP-UDP对比\"><a href=\"#TCP-UDP对比\" class=\"headerlink\" title=\"TCP-UDP对比\"></a>TCP-UDP对比</h2><p>由于UDP自身协议比较简单，而且没有很多控制方法，因此UDP对系统资源要求较少，且效率也更高。由于UDP头部是固定的8字节，相比于TCP头部更加简单，因此传输效率也比较高。但是UDP不对可靠性做任何保证。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"noopener\">TCP/IP详解 卷1：协议</a></p>\n<p><a href=\"https://blog.csdn.net/hyman_yx/article/details/52086389\" target=\"_blank\" rel=\"noopener\">TCP中的7种定时器详解</a></p>\n<p><a href=\"https://www.jianshu.com/p/7178d5c3716e\" target=\"_blank\" rel=\"noopener\">计算机网络相关</a></p>\n<p><a href=\"https://blog.csdn.net/sicofield/article/details/9672457\" target=\"_blank\" rel=\"noopener\">TCP中的定时器</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/糊涂窗口综合症\" target=\"_blank\" rel=\"noopener\">糊涂窗口综合症-维基百科</a></p>\n<p><a href=\"http://www.cnblogs.com/way_testlife/archive/2010/10/11/1848241.html\" target=\"_blank\" rel=\"noopener\">TCP/IP协议族之运输层：TCP流量控制和拥塞控制1</a></p>\n<p><a href=\"http://www.cnblogs.com/way_testlife/archive/2010/10/11/1848333.html\" target=\"_blank\" rel=\"noopener\">TCP/IP协议族之运输层：TCP流量控制和拥塞控制2</a></p>\n<p><a href=\"https://blog.csdn.net/nestler/article/details/30237529\" target=\"_blank\" rel=\"noopener\">慢启动与拥塞窗口</a></p>\n<p><a href=\"https://www.jianshu.com/p/8331aeb193d9\" target=\"_blank\" rel=\"noopener\">SYN攻击及防范</a></p>\n"},{"title":"选择问题-TopK问题：N个元素的数组找到最大K个数","urlname":"top-k-problem","date":"2018-04-16T15:05:40.000Z","copyright":true,"mathjax":true,"_content":"\n## 问题描述\n\n选择问题或者说TopK问题是指给一堆无序的含有N个元素的数组，找出里面的最大的K个数（也可以是找出最小的K个数）。在本问题的基础上可以加上诸如元素数量较多，无法完整放入整个内存中，此时常规的先排序的思路是无效的。TopK问题的解决思路主要有如下几种，分别介绍如下。\n\n## 常规排序思路\n\n当不存在内存限制时，最先想到就是采用常规的排序算法了，目前基于比较的算法最好能够优化到O(nlgn)。如果要求稳定性则可以采用归并排序，否则可以使用堆排序或者快速排序，具体排序算法可见本人博客：[各大排序算法的分析与实现](https://hsuloong.github.io/algorithms-design/sort-algorithm.html)\n\n如果元素范围比较小还可以采用非比较的算法如计数排序，时间复杂度可以优化到O(N)。\n\n## 部分排序思路\n\n部分排序的思路是不对整个数组进行排序，只对K个元素进行排序，其基本思路如下：\n\n    1. 先读入K个元素并以非递增顺序排序\n    2. 读入新数据，如果新数据小于K个元素最小的数据，则直接丢弃，否则插入到正确的位置\n    3. 在结束后保存下来的K个元素的数组即为最大的K个数\n\n在进行排序可以使用插入排序、堆排序思想。插入排序较为简单，以下实现采用堆排序的算法代码。采用堆排序的思路时间复杂度为建堆O(K)+更新堆O((N-K)logk)，合计为O(NlogK)。\n\n```cpp\n#include <vector>\nusing std::vector;\n\n//end指向最后元素的下一个元素，和STL保持一致,最小堆\nvoid PerDown(vector<int> &intVec, int index, int end)\n{\n        int tmp = intVec[index], i = index;\n        while (2*i + 1 < end) {\n                int child = 2*i+1;\n                if (child + 1 < end && intVec[child] > intVec[child+1]) {\n                        ++child;\n                }\n                if (intVec[child] < tmp) {\n                        intVec[i] = intVec[child];\n                        i = child;\n                }\n                else {\n                        break;\n                }\n        }\n        intVec[i] = tmp;\n}\n\nvector<int> TopK(vector<int> &intVec, int k)\n{\n\n        if (k > int(intVec.size()) || k <= 0) {\n                return intVec;\n        }\n        vector<int> result(k);\n        for (int i = 0; i < k; i++) {\n                result[i] = intVec[i];\n        }\n        //建堆\n        for (int i = int(result.size())/2; i >= 0; i--) {\n                PerDown(result, i, k);\n        }\n        for (int i = k; i < int(intVec.size()); i++) {\n                if (intVec[i] > result[0]) {\n                        result[0] = intVec[i];\n                        PerDown(result, 0, k);\n                }\n        }\n        return result;\n}\n```\n\n## 快速排序思路下的快速选择\n\n快速排序会把比基准元素大的部分放到一边，其他放在另外一边，如果分割元素刚好处在分割K个最大元素的位置则可以直接返回结果。快速选择最好时间复杂度为O(N)，最坏情况发生在每次分割元素取的最大或最小值，使得元素全部被分到一边，此时递推式为T(N)=T(N-1)+O(N)=O(N<sup>2</sup>)。\n\n由于TopK问题特点，将比基准元素大的一方放到左边，当基准元素下标为K是则停止算法，实现代码如下。\n\n```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//会修改原数组，end和STL保持一致\nvoid SelectCore(vector<int> &intVec, int start, int end, int k)\n{\n        int middle = start + (end-start)/2;\n        //选择中间元素作为分割元素，有一种称为五分化中项的中项的选择方式\n        swap(intVec[middle], intVec[end-1]);\n        int i = start, j = end-2;\n        while (i <= j) {\n                while (i < end && intVec[i] > intVec[end-1]) {\n                        ++i;\n                }\n\n                while (j > start && intVec[j] < intVec[end-1]) {\n                        --j;\n                }\n\n                if (i < j) {\n                        swap(intVec[i], intVec[j]);\n                        ++i; --j;\n                }\n                else {\n\t\t\tbreak;\n\t\t}\n        }\n\n        swap(intVec[i], intVec[end-1]);\n\n        if (i == k) {\n                return;\n        }\n        else if (i < k) {\n                SelectCore(intVec,i+1, end, k);\n        }\n        else {\n                SelectCore(intVec,start, i, k);\n        }\n}\n\nvector<int> QuickSelect(vector<int> &intVec, int k)\n{\n        if (k > int(intVec.size()) || k <= 0) {\n                return intVec;\n        }\n\n        SelectCore(intVec, 0, int(intVec.size()), k);\n\n        vector<int> result(k, 0);\n        copy(intVec.begin(), intVec.begin() + k, result.begin());\n        return result;\n}\n```\n\n## 算法测试\n\n上述代码的测试程序如下：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n        const int testNum[] = { 20, 100, 1000, 10000, 100000, 1000000, 10000000 };\n\n        default_random_engine randEngine(unsigned(time(nullptr)));\n        uniform_int_distribution<int> intDis(int(-10e4), int(10e4));\n\n        int testTimes = 5;\n\n        while ((testTimes--) > 0) {\n                for (size_t i = 0; i < sizeof(testNum) / sizeof(testNum[0]); i++) {\n                        vector<int> testData1, testData2;\n\n                        for (int j = 0; j < testNum[i]; j++) {\n                                int tmp = intDis(randEngine);\n                                testData1.push_back(tmp); testData2.push_back(tmp);\n                        }\n\n                        auto startTime = system_clock::now();\n\n                        vector<int> result = QuickSelect(testData1, 10); //调用具体的TopK算法\n                        sort(result.begin(), result.end(), greater<int>());\n\n                        auto endTime = system_clock::now();\n\n                        sort(testData2.begin(), testData2.end(), greater<int>());\n\n                        vector<int> correctResult(result.size(), 0);\n                        copy(testData2.begin(), testData2.begin() + 10, correctResult.begin());\n                        sort(correctResult.begin(), correctResult.end(), greater<int>());\n\n                        cout << ((result == correctResult) ? \"Correct;\" : \"Wrong;\");\n\n                        auto duration = duration_cast<microseconds>(endTime - startTime);\n                        cout << \"TimeCost:\" << duration.count() << endl;\n                }\n        }\n\treturn 0;\n}\n```\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n\n[快速选择select算法-五分化中项的中项](https://blog.csdn.net/hgqqtql/article/details/42157767)\n","source":"_posts/算法设计/选择问题-TopK问题：N个元素的数组找到最大K个数.md","raw":"---\ntitle: 选择问题-TopK问题：N个元素的数组找到最大K个数\nurlname: top-k-problem\ndate: 2018-04-16 23:05:40\ncopyright: true\nmathjax: true\ntags:\n- 算法设计\ncategories:\n- 算法设计\n---\n\n## 问题描述\n\n选择问题或者说TopK问题是指给一堆无序的含有N个元素的数组，找出里面的最大的K个数（也可以是找出最小的K个数）。在本问题的基础上可以加上诸如元素数量较多，无法完整放入整个内存中，此时常规的先排序的思路是无效的。TopK问题的解决思路主要有如下几种，分别介绍如下。\n\n## 常规排序思路\n\n当不存在内存限制时，最先想到就是采用常规的排序算法了，目前基于比较的算法最好能够优化到O(nlgn)。如果要求稳定性则可以采用归并排序，否则可以使用堆排序或者快速排序，具体排序算法可见本人博客：[各大排序算法的分析与实现](https://hsuloong.github.io/algorithms-design/sort-algorithm.html)\n\n如果元素范围比较小还可以采用非比较的算法如计数排序，时间复杂度可以优化到O(N)。\n\n## 部分排序思路\n\n部分排序的思路是不对整个数组进行排序，只对K个元素进行排序，其基本思路如下：\n\n    1. 先读入K个元素并以非递增顺序排序\n    2. 读入新数据，如果新数据小于K个元素最小的数据，则直接丢弃，否则插入到正确的位置\n    3. 在结束后保存下来的K个元素的数组即为最大的K个数\n\n在进行排序可以使用插入排序、堆排序思想。插入排序较为简单，以下实现采用堆排序的算法代码。采用堆排序的思路时间复杂度为建堆O(K)+更新堆O((N-K)logk)，合计为O(NlogK)。\n\n```cpp\n#include <vector>\nusing std::vector;\n\n//end指向最后元素的下一个元素，和STL保持一致,最小堆\nvoid PerDown(vector<int> &intVec, int index, int end)\n{\n        int tmp = intVec[index], i = index;\n        while (2*i + 1 < end) {\n                int child = 2*i+1;\n                if (child + 1 < end && intVec[child] > intVec[child+1]) {\n                        ++child;\n                }\n                if (intVec[child] < tmp) {\n                        intVec[i] = intVec[child];\n                        i = child;\n                }\n                else {\n                        break;\n                }\n        }\n        intVec[i] = tmp;\n}\n\nvector<int> TopK(vector<int> &intVec, int k)\n{\n\n        if (k > int(intVec.size()) || k <= 0) {\n                return intVec;\n        }\n        vector<int> result(k);\n        for (int i = 0; i < k; i++) {\n                result[i] = intVec[i];\n        }\n        //建堆\n        for (int i = int(result.size())/2; i >= 0; i--) {\n                PerDown(result, i, k);\n        }\n        for (int i = k; i < int(intVec.size()); i++) {\n                if (intVec[i] > result[0]) {\n                        result[0] = intVec[i];\n                        PerDown(result, 0, k);\n                }\n        }\n        return result;\n}\n```\n\n## 快速排序思路下的快速选择\n\n快速排序会把比基准元素大的部分放到一边，其他放在另外一边，如果分割元素刚好处在分割K个最大元素的位置则可以直接返回结果。快速选择最好时间复杂度为O(N)，最坏情况发生在每次分割元素取的最大或最小值，使得元素全部被分到一边，此时递推式为T(N)=T(N-1)+O(N)=O(N<sup>2</sup>)。\n\n由于TopK问题特点，将比基准元素大的一方放到左边，当基准元素下标为K是则停止算法，实现代码如下。\n\n```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//会修改原数组，end和STL保持一致\nvoid SelectCore(vector<int> &intVec, int start, int end, int k)\n{\n        int middle = start + (end-start)/2;\n        //选择中间元素作为分割元素，有一种称为五分化中项的中项的选择方式\n        swap(intVec[middle], intVec[end-1]);\n        int i = start, j = end-2;\n        while (i <= j) {\n                while (i < end && intVec[i] > intVec[end-1]) {\n                        ++i;\n                }\n\n                while (j > start && intVec[j] < intVec[end-1]) {\n                        --j;\n                }\n\n                if (i < j) {\n                        swap(intVec[i], intVec[j]);\n                        ++i; --j;\n                }\n                else {\n\t\t\tbreak;\n\t\t}\n        }\n\n        swap(intVec[i], intVec[end-1]);\n\n        if (i == k) {\n                return;\n        }\n        else if (i < k) {\n                SelectCore(intVec,i+1, end, k);\n        }\n        else {\n                SelectCore(intVec,start, i, k);\n        }\n}\n\nvector<int> QuickSelect(vector<int> &intVec, int k)\n{\n        if (k > int(intVec.size()) || k <= 0) {\n                return intVec;\n        }\n\n        SelectCore(intVec, 0, int(intVec.size()), k);\n\n        vector<int> result(k, 0);\n        copy(intVec.begin(), intVec.begin() + k, result.begin());\n        return result;\n}\n```\n\n## 算法测试\n\n上述代码的测试程序如下：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n        const int testNum[] = { 20, 100, 1000, 10000, 100000, 1000000, 10000000 };\n\n        default_random_engine randEngine(unsigned(time(nullptr)));\n        uniform_int_distribution<int> intDis(int(-10e4), int(10e4));\n\n        int testTimes = 5;\n\n        while ((testTimes--) > 0) {\n                for (size_t i = 0; i < sizeof(testNum) / sizeof(testNum[0]); i++) {\n                        vector<int> testData1, testData2;\n\n                        for (int j = 0; j < testNum[i]; j++) {\n                                int tmp = intDis(randEngine);\n                                testData1.push_back(tmp); testData2.push_back(tmp);\n                        }\n\n                        auto startTime = system_clock::now();\n\n                        vector<int> result = QuickSelect(testData1, 10); //调用具体的TopK算法\n                        sort(result.begin(), result.end(), greater<int>());\n\n                        auto endTime = system_clock::now();\n\n                        sort(testData2.begin(), testData2.end(), greater<int>());\n\n                        vector<int> correctResult(result.size(), 0);\n                        copy(testData2.begin(), testData2.begin() + 10, correctResult.begin());\n                        sort(correctResult.begin(), correctResult.end(), greater<int>());\n\n                        cout << ((result == correctResult) ? \"Correct;\" : \"Wrong;\");\n\n                        auto duration = duration_cast<microseconds>(endTime - startTime);\n                        cout << \"TimeCost:\" << duration.count() << endl;\n                }\n        }\n\treturn 0;\n}\n```\n\n## 参考文章\n\n[数据结构与算法分析](https://book.douban.com/subject/1139426/)\n\n[快速选择select算法-五分化中项的中项](https://blog.csdn.net/hgqqtql/article/details/42157767)\n","slug":"算法设计/选择问题-TopK问题：N个元素的数组找到最大K个数","published":1,"updated":"2018-06-13T14:32:07.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjida4x4o003agsvnnbamvobc","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>选择问题或者说TopK问题是指给一堆无序的含有N个元素的数组，找出里面的最大的K个数（也可以是找出最小的K个数）。在本问题的基础上可以加上诸如元素数量较多，无法完整放入整个内存中，此时常规的先排序的思路是无效的。TopK问题的解决思路主要有如下几种，分别介绍如下。</p>\n<h2 id=\"常规排序思路\"><a href=\"#常规排序思路\" class=\"headerlink\" title=\"常规排序思路\"></a>常规排序思路</h2><p>当不存在内存限制时，最先想到就是采用常规的排序算法了，目前基于比较的算法最好能够优化到O(nlgn)。如果要求稳定性则可以采用归并排序，否则可以使用堆排序或者快速排序，具体排序算法可见本人博客：<a href=\"https://hsuloong.github.io/algorithms-design/sort-algorithm.html\" target=\"_blank\" rel=\"noopener\">各大排序算法的分析与实现</a></p>\n<p>如果元素范围比较小还可以采用非比较的算法如计数排序，时间复杂度可以优化到O(N)。</p>\n<h2 id=\"部分排序思路\"><a href=\"#部分排序思路\" class=\"headerlink\" title=\"部分排序思路\"></a>部分排序思路</h2><p>部分排序的思路是不对整个数组进行排序，只对K个元素进行排序，其基本思路如下：</p>\n<pre><code>1. 先读入K个元素并以非递增顺序排序\n2. 读入新数据，如果新数据小于K个元素最小的数据，则直接丢弃，否则插入到正确的位置\n3. 在结束后保存下来的K个元素的数组即为最大的K个数\n</code></pre><p>在进行排序可以使用插入排序、堆排序思想。插入排序较为简单，以下实现采用堆排序的算法代码。采用堆排序的思路时间复杂度为建堆O(K)+更新堆O((N-K)logk)，合计为O(NlogK)。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//end指向最后元素的下一个元素，和STL保持一致,最小堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PerDown</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;intVec, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = intVec[index], i = index;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"number\">2</span>*i + <span class=\"number\">1</span> &lt; end) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child = <span class=\"number\">2</span>*i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; end &amp;&amp; intVec[child] &gt; intVec[child+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                        ++child;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (intVec[child] &lt; tmp) &#123;</span><br><span class=\"line\">                        intVec[i] = intVec[child];</span><br><span class=\"line\">                        i = child;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        intVec[i] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; TopK(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;intVec, <span class=\"keyword\">int</span> k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &gt; <span class=\"keyword\">int</span>(intVec.size()) || k &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> intVec;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result(k);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">                result[i] = intVec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//建堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"keyword\">int</span>(result.size())/<span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                PerDown(result, i, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = k; i &lt; <span class=\"keyword\">int</span>(intVec.size()); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (intVec[i] &gt; result[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                        result[<span class=\"number\">0</span>] = intVec[i];</span><br><span class=\"line\">                        PerDown(result, <span class=\"number\">0</span>, k);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序思路下的快速选择\"><a href=\"#快速排序思路下的快速选择\" class=\"headerlink\" title=\"快速排序思路下的快速选择\"></a>快速排序思路下的快速选择</h2><p>快速排序会把比基准元素大的部分放到一边，其他放在另外一边，如果分割元素刚好处在分割K个最大元素的位置则可以直接返回结果。快速选择最好时间复杂度为O(N)，最坏情况发生在每次分割元素取的最大或最小值，使得元素全部被分到一边，此时递推式为T(N)=T(N-1)+O(N)=O(N<sup>2</sup>)。</p>\n<p>由于TopK问题特点，将比基准元素大的一方放到左边，当基准元素下标为K是则停止算法，实现代码如下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//会修改原数组，end和STL保持一致</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SelectCore</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;intVec, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> middle = start + (end-start)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//选择中间元素作为分割元素，有一种称为五分化中项的中项的选择方式</span></span><br><span class=\"line\">        swap(intVec[middle], intVec[end<span class=\"number\">-1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = start, j = end<span class=\"number\">-2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; end &amp;&amp; intVec[i] &gt; intVec[end<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                        ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (j &gt; start &amp;&amp; intVec[j] &lt; intVec[end<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                        --j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                        swap(intVec[i], intVec[j]);</span><br><span class=\"line\">                        ++i; --j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        swap(intVec[i], intVec[end<span class=\"number\">-1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &lt; k) &#123;</span><br><span class=\"line\">                SelectCore(intVec,i+<span class=\"number\">1</span>, end, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                SelectCore(intVec,start, i, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; QuickSelect(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;intVec, <span class=\"keyword\">int</span> k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &gt; <span class=\"keyword\">int</span>(intVec.size()) || k &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> intVec;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SelectCore(intVec, <span class=\"number\">0</span>, <span class=\"keyword\">int</span>(intVec.size()), k);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result(k, <span class=\"number\">0</span>);</span><br><span class=\"line\">        copy(intVec.begin(), intVec.begin() + k, result.begin());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"算法测试\"><a href=\"#算法测试\" class=\"headerlink\" title=\"算法测试\"></a>算法测试</h2><p>上述代码的测试程序如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> testNum[] = &#123; <span class=\"number\">20</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        default_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">        uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-10e4</span>), <span class=\"keyword\">int</span>(<span class=\"number\">10e4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(testNum) / <span class=\"keyword\">sizeof</span>(testNum[<span class=\"number\">0</span>]); i++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; testData1, testData2;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; testNum[i]; j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> tmp = intDis(randEngine);</span><br><span class=\"line\">                                testData1.push_back(tmp); testData2.push_back(tmp);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result = QuickSelect(testData1, <span class=\"number\">10</span>); <span class=\"comment\">//调用具体的TopK算法</span></span><br><span class=\"line\">                        sort(result.begin(), result.end(), greater&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        sort(testData2.begin(), testData2.end(), greater&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; correctResult(result.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                        copy(testData2.begin(), testData2.begin() + <span class=\"number\">10</span>, correctResult.begin());</span><br><span class=\"line\">                        sort(correctResult.begin(), correctResult.end(), greater&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; ((result == correctResult) ? <span class=\"string\">\"Correct;\"</span> : <span class=\"string\">\"Wrong;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n<p><a href=\"https://blog.csdn.net/hgqqtql/article/details/42157767\" target=\"_blank\" rel=\"noopener\">快速选择select算法-五分化中项的中项</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>选择问题或者说TopK问题是指给一堆无序的含有N个元素的数组，找出里面的最大的K个数（也可以是找出最小的K个数）。在本问题的基础上可以加上诸如元素数量较多，无法完整放入整个内存中，此时常规的先排序的思路是无效的。TopK问题的解决思路主要有如下几种，分别介绍如下。</p>\n<h2 id=\"常规排序思路\"><a href=\"#常规排序思路\" class=\"headerlink\" title=\"常规排序思路\"></a>常规排序思路</h2><p>当不存在内存限制时，最先想到就是采用常规的排序算法了，目前基于比较的算法最好能够优化到O(nlgn)。如果要求稳定性则可以采用归并排序，否则可以使用堆排序或者快速排序，具体排序算法可见本人博客：<a href=\"https://hsuloong.github.io/algorithms-design/sort-algorithm.html\" target=\"_blank\" rel=\"noopener\">各大排序算法的分析与实现</a></p>\n<p>如果元素范围比较小还可以采用非比较的算法如计数排序，时间复杂度可以优化到O(N)。</p>\n<h2 id=\"部分排序思路\"><a href=\"#部分排序思路\" class=\"headerlink\" title=\"部分排序思路\"></a>部分排序思路</h2><p>部分排序的思路是不对整个数组进行排序，只对K个元素进行排序，其基本思路如下：</p>\n<pre><code>1. 先读入K个元素并以非递增顺序排序\n2. 读入新数据，如果新数据小于K个元素最小的数据，则直接丢弃，否则插入到正确的位置\n3. 在结束后保存下来的K个元素的数组即为最大的K个数\n</code></pre><p>在进行排序可以使用插入排序、堆排序思想。插入排序较为简单，以下实现采用堆排序的算法代码。采用堆排序的思路时间复杂度为建堆O(K)+更新堆O((N-K)logk)，合计为O(NlogK)。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//end指向最后元素的下一个元素，和STL保持一致,最小堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PerDown</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;intVec, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = intVec[index], i = index;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"number\">2</span>*i + <span class=\"number\">1</span> &lt; end) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child = <span class=\"number\">2</span>*i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (child + <span class=\"number\">1</span> &lt; end &amp;&amp; intVec[child] &gt; intVec[child+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                        ++child;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (intVec[child] &lt; tmp) &#123;</span><br><span class=\"line\">                        intVec[i] = intVec[child];</span><br><span class=\"line\">                        i = child;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        intVec[i] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; TopK(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;intVec, <span class=\"keyword\">int</span> k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &gt; <span class=\"keyword\">int</span>(intVec.size()) || k &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> intVec;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result(k);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">                result[i] = intVec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//建堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"keyword\">int</span>(result.size())/<span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                PerDown(result, i, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = k; i &lt; <span class=\"keyword\">int</span>(intVec.size()); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (intVec[i] &gt; result[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                        result[<span class=\"number\">0</span>] = intVec[i];</span><br><span class=\"line\">                        PerDown(result, <span class=\"number\">0</span>, k);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序思路下的快速选择\"><a href=\"#快速排序思路下的快速选择\" class=\"headerlink\" title=\"快速排序思路下的快速选择\"></a>快速排序思路下的快速选择</h2><p>快速排序会把比基准元素大的部分放到一边，其他放在另外一边，如果分割元素刚好处在分割K个最大元素的位置则可以直接返回结果。快速选择最好时间复杂度为O(N)，最坏情况发生在每次分割元素取的最大或最小值，使得元素全部被分到一边，此时递推式为T(N)=T(N-1)+O(N)=O(N<sup>2</sup>)。</p>\n<p>由于TopK问题特点，将比基准元素大的一方放到左边，当基准元素下标为K是则停止算法，实现代码如下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//会修改原数组，end和STL保持一致</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SelectCore</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;intVec, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> middle = start + (end-start)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//选择中间元素作为分割元素，有一种称为五分化中项的中项的选择方式</span></span><br><span class=\"line\">        swap(intVec[middle], intVec[end<span class=\"number\">-1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = start, j = end<span class=\"number\">-2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; end &amp;&amp; intVec[i] &gt; intVec[end<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                        ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (j &gt; start &amp;&amp; intVec[j] &lt; intVec[end<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                        --j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                        swap(intVec[i], intVec[j]);</span><br><span class=\"line\">                        ++i; --j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        swap(intVec[i], intVec[end<span class=\"number\">-1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &lt; k) &#123;</span><br><span class=\"line\">                SelectCore(intVec,i+<span class=\"number\">1</span>, end, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                SelectCore(intVec,start, i, k);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; QuickSelect(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;intVec, <span class=\"keyword\">int</span> k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &gt; <span class=\"keyword\">int</span>(intVec.size()) || k &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> intVec;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SelectCore(intVec, <span class=\"number\">0</span>, <span class=\"keyword\">int</span>(intVec.size()), k);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result(k, <span class=\"number\">0</span>);</span><br><span class=\"line\">        copy(intVec.begin(), intVec.begin() + k, result.begin());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"算法测试\"><a href=\"#算法测试\" class=\"headerlink\" title=\"算法测试\"></a>算法测试</h2><p>上述代码的测试程序如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> testNum[] = &#123; <span class=\"number\">20</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        default_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">        uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-10e4</span>), <span class=\"keyword\">int</span>(<span class=\"number\">10e4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(testNum) / <span class=\"keyword\">sizeof</span>(testNum[<span class=\"number\">0</span>]); i++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; testData1, testData2;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; testNum[i]; j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> tmp = intDis(randEngine);</span><br><span class=\"line\">                                testData1.push_back(tmp); testData2.push_back(tmp);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> startTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result = QuickSelect(testData1, <span class=\"number\">10</span>); <span class=\"comment\">//调用具体的TopK算法</span></span><br><span class=\"line\">                        sort(result.begin(), result.end(), greater&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> endTime = system_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">                        sort(testData2.begin(), testData2.end(), greater&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; correctResult(result.size(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                        copy(testData2.begin(), testData2.begin() + <span class=\"number\">10</span>, correctResult.begin());</span><br><span class=\"line\">                        sort(correctResult.begin(), correctResult.end(), greater&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; ((result == correctResult) ? <span class=\"string\">\"Correct;\"</span> : <span class=\"string\">\"Wrong;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> duration = duration_cast&lt;microseconds&gt;(endTime - startTime);</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"TimeCost:\"</span> &lt;&lt; duration.count() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"noopener\">数据结构与算法分析</a></p>\n<p><a href=\"https://blog.csdn.net/hgqqtql/article/details/42157767\" target=\"_blank\" rel=\"noopener\">快速选择select算法-五分化中项的中项</a></p>\n"},{"title":"数据结构之多维数组及特殊矩阵的压缩存储","urlname":"multi-dimensional-arrays","date":"2018-03-05T08:13:03.000Z","mathjax":true,"copyright":true,"_content":"\n## 基本知识\n\n多维数组可以认为是线性表的一种推广，其元素本身可以是具有某种结构的数据，但必须是同种元素。数组在实际存储时采取的顺序存储，因此数组可以以$O(1)$的时间复杂度进行访问。对于一维数组，其元素内存地址可通过起始地址+偏移地址的方式直接计算得到；而对于多维数组，根据存储方式的不同，计算元素地址的方式也有细微的差别。目前存储方式主要有：\n\n- 行优先存储：即每行存放完后再存放下一行\n- 列优先存储：即一列一列地分配\n\n假设有一$m*n$二维数组定义为$A_{m,n}$，每个元素的大小为$d$个字节，数组任意元素$A_{i,j}$的地址为（下标从$1$开始）：\n\n- 按行优先存储：$LOC(A_{i,j}) = LOC(A_{1,1})+((i-1)\\*n+j-1)\\*d$\n- 按列优先存储：$LOC(A_{i,j}) = LOC(A_{1,1}) + ((j-1)\\*m + i-1)\\*d$\n\n## 特殊矩阵\n\n由于矩阵本身结构就是二维的，因此采用二维数组存储矩阵是非常合理的，但是有一类矩阵其有效元素数量占整个矩阵元素数量比重不大，因此从节约空间的角度，希望通过压缩存储无效元素（一般为$0$）的方式来存储该矩阵。先简要介绍几种特殊矩阵以及其压缩方法。\n\n## 对称矩阵\n\n对称矩阵是指元素值关于对角线对称，即$A^T=A$，由于有一半左右的元素是相同，因此可采用只保存上半部分或者下半部分元素的方式将对称矩阵存入特别设计的一维数组，同时给出元素访问映射公式。\n\n注：详细对称矩阵定义见：[对称矩阵](https://zh.wikipedia.org/wiki/對稱矩陣)\n\n以存储对称矩阵的下半部分且以行优先存储方式为例分析映射公式。（矩阵为n阶方阵，数组下标从0开始，矩阵下标从1开始）\n\n在第一行需要存储的元素个数为$1$，第二行为$2$，依次类推总共需要存储$1+2+3....+n=(n+1)\\*n/2$个元素，因此数组元素的大小可定义为$(n+1)\\*n/2$。而对于位置为$A_{i,j}$的元素，我们分两种情况分析：\n\n- 第一种情况：$i>=j$，此时元素在下半部分，在该元素前面的元素个数有$Before=1+2+....+(i-1)+j-1$个，因此该元素的位置为第$Before+1=(i-1)\\*i/2+j$个，考虑到下标从$0$开始，则$A_{i,j}$在数组中的下标为$k=(i-1)\\*i/2+j-1$\n- 第二种情况：$i<j$，此时元素在上半部分，其值和$A_{i,j}$相等，根据上一步分析有数组下标$k=(j-1)\\*j/2+i-1$\n\n合并上述两种情况即可得出统一的下标计算公式\n\n$k=(max(i,j)-1)\\*max(i,j)/2+min(i,j)-1$\n\n注：$max(i,j)$表示$i、j$中较大的一个，$min(i,j)$表示$i、j$中较小的一个。\n\n\n## 三角矩阵\n\n三角矩阵分为上三角矩阵以及下三角矩阵，其存储模式思想和对称矩阵类似，不过有大约一半（不算对角线）元素值相等，因此可以使用比对称矩阵存储个数$+1$的数组来存放整个矩阵。\n\n注：详细三角矩阵定义见：[三角矩阵](https://zh.wikipedia.org/wiki/三角矩阵)\n\n对于的一个元素用来存放相同的那个元素。下三角矩阵的分析过程和对称矩阵相似，以下为结论：\n\n注：矩阵为n阶方阵，数组下标从$0$开始，矩阵下标从$1$开始，行优先存储\n\n对于$i>=j$，下标$k=k=(i-1)\\*i/2+j-1；i<j$，下标$k=(n+1)\\*n/2$\n\n对于上三角矩阵，分为两种情况讨论，\n\n- 第一种情况：$i<=j$，此时元素在上半部分，在该元素前面共有$Before=n+n-1+....+(n-(i-1)+1)+j-i$个元素，因此该元素的位置为第$Before+1=(2n-i+1)\\*(i-1)/2+j-i+1$个，考虑到下标从$0$开始，则$A_{i,j}$在数组中的下标为$k=(n+i-1)\\*(i-1)/2+j-i$。\n- 第二种情况：$i>j$，此时元素在下半部分，元素值相同，全部存到数组最后一个元素中，因此下标$k=(n+1)\\*n/2$\n\n\n\n## 对角矩阵\n\n对角矩阵也称为带状矩阵，其对角带（以对角线为中心的带状区域内）元素非零，其余元素全部为零。对于$k$（$k$为奇数）对角矩阵，当$|i-j|<=k/2$时，元素为带内元素，否则元素值为$0$。由此可根据每行元素数量求取元素位置。比如三对角矩阵，只有第一行和最后一行非零元素个数为$2$，其余非零元素为$3$。我们可以使用部分冗余，使得每一行数量均为$3$个，这样可以极大减少计算复杂度。以下推导三对角矩阵的压缩存储。\n\n由于第一行第前面和最后一行后面分别补一个零凑足$3$个元素，因此对于每一行其前面一共存储$3\\*(i-1)$个元素。而每行的第一个元素下标为$A_{i,i-1}$，因此对于第$A_{i,j}$元素在一维数组中的下标为$k=3\\*(i-1)+j-(i-1)=2\\*i+j-2$。其中第一个元素为$0$。\n\n注：详细对角矩阵定义见：[对角矩阵](https://zh.wikipedia.org/wiki/對角矩陣)\n\n## 稀疏矩阵\n\n稀疏矩阵是元素大部分为零的矩阵，其有效元素的个数非常稀少，因此如果重复存储零元素是非常不合理的，目前常用来存储稀疏矩阵的数据结构为三元组和十字链表，三元组基本定义如下：\n\n```cpp\n#define MAXSIZE 1000\n\n//以下为三元组的定义\ntemplate <typename DataType>\nstruct TripleNode\n{\n\tint i; //行下标\n\tint j; //列下标\n\tDataType element; //实际元素值\n};\n\n//以下为稀疏矩阵存储结构定义\ntemplate <typename DataType>\nstruct SparseMatrix\n{\n\tint mu; //矩阵行数\n\tint nu; //矩阵列数\n\tint tu; //矩阵非零个数\n\tTripleNode<DataType> matrix[MAXSIZE]; //TripleNode数组\n};\n```\n\n稀疏矩阵在按行优先存储时遵循一下规则\n\n- 同一行内非零元素依次放置\n- 一行元素放完再放第二行元素\n\n注：详细稀疏矩阵定义见：[稀疏矩阵](https://zh.wikipedia.org/wiki/稀疏矩阵)\n","source":"_posts/数据结构/数据结构之多维数组以及特殊矩阵的压缩存储.md","raw":"---\ntitle: 数据结构之多维数组及特殊矩阵的压缩存储\nurlname: multi-dimensional-arrays\ndate: 2018-03-5 16:13:03\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 基本知识\n\n多维数组可以认为是线性表的一种推广，其元素本身可以是具有某种结构的数据，但必须是同种元素。数组在实际存储时采取的顺序存储，因此数组可以以$O(1)$的时间复杂度进行访问。对于一维数组，其元素内存地址可通过起始地址+偏移地址的方式直接计算得到；而对于多维数组，根据存储方式的不同，计算元素地址的方式也有细微的差别。目前存储方式主要有：\n\n- 行优先存储：即每行存放完后再存放下一行\n- 列优先存储：即一列一列地分配\n\n假设有一$m*n$二维数组定义为$A_{m,n}$，每个元素的大小为$d$个字节，数组任意元素$A_{i,j}$的地址为（下标从$1$开始）：\n\n- 按行优先存储：$LOC(A_{i,j}) = LOC(A_{1,1})+((i-1)\\*n+j-1)\\*d$\n- 按列优先存储：$LOC(A_{i,j}) = LOC(A_{1,1}) + ((j-1)\\*m + i-1)\\*d$\n\n## 特殊矩阵\n\n由于矩阵本身结构就是二维的，因此采用二维数组存储矩阵是非常合理的，但是有一类矩阵其有效元素数量占整个矩阵元素数量比重不大，因此从节约空间的角度，希望通过压缩存储无效元素（一般为$0$）的方式来存储该矩阵。先简要介绍几种特殊矩阵以及其压缩方法。\n\n## 对称矩阵\n\n对称矩阵是指元素值关于对角线对称，即$A^T=A$，由于有一半左右的元素是相同，因此可采用只保存上半部分或者下半部分元素的方式将对称矩阵存入特别设计的一维数组，同时给出元素访问映射公式。\n\n注：详细对称矩阵定义见：[对称矩阵](https://zh.wikipedia.org/wiki/對稱矩陣)\n\n以存储对称矩阵的下半部分且以行优先存储方式为例分析映射公式。（矩阵为n阶方阵，数组下标从0开始，矩阵下标从1开始）\n\n在第一行需要存储的元素个数为$1$，第二行为$2$，依次类推总共需要存储$1+2+3....+n=(n+1)\\*n/2$个元素，因此数组元素的大小可定义为$(n+1)\\*n/2$。而对于位置为$A_{i,j}$的元素，我们分两种情况分析：\n\n- 第一种情况：$i>=j$，此时元素在下半部分，在该元素前面的元素个数有$Before=1+2+....+(i-1)+j-1$个，因此该元素的位置为第$Before+1=(i-1)\\*i/2+j$个，考虑到下标从$0$开始，则$A_{i,j}$在数组中的下标为$k=(i-1)\\*i/2+j-1$\n- 第二种情况：$i<j$，此时元素在上半部分，其值和$A_{i,j}$相等，根据上一步分析有数组下标$k=(j-1)\\*j/2+i-1$\n\n合并上述两种情况即可得出统一的下标计算公式\n\n$k=(max(i,j)-1)\\*max(i,j)/2+min(i,j)-1$\n\n注：$max(i,j)$表示$i、j$中较大的一个，$min(i,j)$表示$i、j$中较小的一个。\n\n\n## 三角矩阵\n\n三角矩阵分为上三角矩阵以及下三角矩阵，其存储模式思想和对称矩阵类似，不过有大约一半（不算对角线）元素值相等，因此可以使用比对称矩阵存储个数$+1$的数组来存放整个矩阵。\n\n注：详细三角矩阵定义见：[三角矩阵](https://zh.wikipedia.org/wiki/三角矩阵)\n\n对于的一个元素用来存放相同的那个元素。下三角矩阵的分析过程和对称矩阵相似，以下为结论：\n\n注：矩阵为n阶方阵，数组下标从$0$开始，矩阵下标从$1$开始，行优先存储\n\n对于$i>=j$，下标$k=k=(i-1)\\*i/2+j-1；i<j$，下标$k=(n+1)\\*n/2$\n\n对于上三角矩阵，分为两种情况讨论，\n\n- 第一种情况：$i<=j$，此时元素在上半部分，在该元素前面共有$Before=n+n-1+....+(n-(i-1)+1)+j-i$个元素，因此该元素的位置为第$Before+1=(2n-i+1)\\*(i-1)/2+j-i+1$个，考虑到下标从$0$开始，则$A_{i,j}$在数组中的下标为$k=(n+i-1)\\*(i-1)/2+j-i$。\n- 第二种情况：$i>j$，此时元素在下半部分，元素值相同，全部存到数组最后一个元素中，因此下标$k=(n+1)\\*n/2$\n\n\n\n## 对角矩阵\n\n对角矩阵也称为带状矩阵，其对角带（以对角线为中心的带状区域内）元素非零，其余元素全部为零。对于$k$（$k$为奇数）对角矩阵，当$|i-j|<=k/2$时，元素为带内元素，否则元素值为$0$。由此可根据每行元素数量求取元素位置。比如三对角矩阵，只有第一行和最后一行非零元素个数为$2$，其余非零元素为$3$。我们可以使用部分冗余，使得每一行数量均为$3$个，这样可以极大减少计算复杂度。以下推导三对角矩阵的压缩存储。\n\n由于第一行第前面和最后一行后面分别补一个零凑足$3$个元素，因此对于每一行其前面一共存储$3\\*(i-1)$个元素。而每行的第一个元素下标为$A_{i,i-1}$，因此对于第$A_{i,j}$元素在一维数组中的下标为$k=3\\*(i-1)+j-(i-1)=2\\*i+j-2$。其中第一个元素为$0$。\n\n注：详细对角矩阵定义见：[对角矩阵](https://zh.wikipedia.org/wiki/對角矩陣)\n\n## 稀疏矩阵\n\n稀疏矩阵是元素大部分为零的矩阵，其有效元素的个数非常稀少，因此如果重复存储零元素是非常不合理的，目前常用来存储稀疏矩阵的数据结构为三元组和十字链表，三元组基本定义如下：\n\n```cpp\n#define MAXSIZE 1000\n\n//以下为三元组的定义\ntemplate <typename DataType>\nstruct TripleNode\n{\n\tint i; //行下标\n\tint j; //列下标\n\tDataType element; //实际元素值\n};\n\n//以下为稀疏矩阵存储结构定义\ntemplate <typename DataType>\nstruct SparseMatrix\n{\n\tint mu; //矩阵行数\n\tint nu; //矩阵列数\n\tint tu; //矩阵非零个数\n\tTripleNode<DataType> matrix[MAXSIZE]; //TripleNode数组\n};\n```\n\n稀疏矩阵在按行优先存储时遵循一下规则\n\n- 同一行内非零元素依次放置\n- 一行元素放完再放第二行元素\n\n注：详细稀疏矩阵定义见：[稀疏矩阵](https://zh.wikipedia.org/wiki/稀疏矩阵)\n","slug":"数据结构/数据结构之多维数组以及特殊矩阵的压缩存储","published":1,"updated":"2018-06-21T07:36:52.606Z","_id":"cjida4x4q003egsvn1hdcdv6n","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>多维数组可以认为是线性表的一种推广，其元素本身可以是具有某种结构的数据，但必须是同种元素。数组在实际存储时采取的顺序存储，因此数组可以以$O(1)$的时间复杂度进行访问。对于一维数组，其元素内存地址可通过起始地址+偏移地址的方式直接计算得到；而对于多维数组，根据存储方式的不同，计算元素地址的方式也有细微的差别。目前存储方式主要有：</p>\n<ul>\n<li>行优先存储：即每行存放完后再存放下一行</li>\n<li>列优先存储：即一列一列地分配</li>\n</ul>\n<p>假设有一$m*n$二维数组定义为$A_{m,n}$，每个元素的大小为$d$个字节，数组任意元素$A_{i,j}$的地址为（下标从$1$开始）：</p>\n<ul>\n<li>按行优先存储：$LOC(A_{i,j}) = LOC(A_{1,1})+((i-1)*n+j-1)*d$</li>\n<li>按列优先存储：$LOC(A_{i,j}) = LOC(A_{1,1}) + ((j-1)*m + i-1)*d$</li>\n</ul>\n<h2 id=\"特殊矩阵\"><a href=\"#特殊矩阵\" class=\"headerlink\" title=\"特殊矩阵\"></a>特殊矩阵</h2><p>由于矩阵本身结构就是二维的，因此采用二维数组存储矩阵是非常合理的，但是有一类矩阵其有效元素数量占整个矩阵元素数量比重不大，因此从节约空间的角度，希望通过压缩存储无效元素（一般为$0$）的方式来存储该矩阵。先简要介绍几种特殊矩阵以及其压缩方法。</p>\n<h2 id=\"对称矩阵\"><a href=\"#对称矩阵\" class=\"headerlink\" title=\"对称矩阵\"></a>对称矩阵</h2><p>对称矩阵是指元素值关于对角线对称，即$A^T=A$，由于有一半左右的元素是相同，因此可采用只保存上半部分或者下半部分元素的方式将对称矩阵存入特别设计的一维数组，同时给出元素访问映射公式。</p>\n<p>注：详细对称矩阵定义见：<a href=\"https://zh.wikipedia.org/wiki/對稱矩陣\" target=\"_blank\" rel=\"noopener\">对称矩阵</a></p>\n<p>以存储对称矩阵的下半部分且以行优先存储方式为例分析映射公式。（矩阵为n阶方阵，数组下标从0开始，矩阵下标从1开始）</p>\n<p>在第一行需要存储的元素个数为$1$，第二行为$2$，依次类推总共需要存储$1+2+3….+n=(n+1)*n/2$个元素，因此数组元素的大小可定义为$(n+1)*n/2$。而对于位置为$A_{i,j}$的元素，我们分两种情况分析：</p>\n<ul>\n<li>第一种情况：$i&gt;=j$，此时元素在下半部分，在该元素前面的元素个数有$Before=1+2+….+(i-1)+j-1$个，因此该元素的位置为第$Before+1=(i-1)*i/2+j$个，考虑到下标从$0$开始，则$A_{i,j}$在数组中的下标为$k=(i-1)*i/2+j-1$</li>\n<li>第二种情况：$i&lt;j$，此时元素在上半部分，其值和$A_{i,j}$相等，根据上一步分析有数组下标$k=(j-1)*j/2+i-1$</li>\n</ul>\n<p>合并上述两种情况即可得出统一的下标计算公式</p>\n<p>$k=(max(i,j)-1)*max(i,j)/2+min(i,j)-1$</p>\n<p>注：$max(i,j)$表示$i、j$中较大的一个，$min(i,j)$表示$i、j$中较小的一个。</p>\n<h2 id=\"三角矩阵\"><a href=\"#三角矩阵\" class=\"headerlink\" title=\"三角矩阵\"></a>三角矩阵</h2><p>三角矩阵分为上三角矩阵以及下三角矩阵，其存储模式思想和对称矩阵类似，不过有大约一半（不算对角线）元素值相等，因此可以使用比对称矩阵存储个数$+1$的数组来存放整个矩阵。</p>\n<p>注：详细三角矩阵定义见：<a href=\"https://zh.wikipedia.org/wiki/三角矩阵\" target=\"_blank\" rel=\"noopener\">三角矩阵</a></p>\n<p>对于的一个元素用来存放相同的那个元素。下三角矩阵的分析过程和对称矩阵相似，以下为结论：</p>\n<p>注：矩阵为n阶方阵，数组下标从$0$开始，矩阵下标从$1$开始，行优先存储</p>\n<p>对于$i&gt;=j$，下标$k=k=(i-1)*i/2+j-1；i&lt;j$，下标$k=(n+1)*n/2$</p>\n<p>对于上三角矩阵，分为两种情况讨论，</p>\n<ul>\n<li>第一种情况：$i&lt;=j$，此时元素在上半部分，在该元素前面共有$Before=n+n-1+….+(n-(i-1)+1)+j-i$个元素，因此该元素的位置为第$Before+1=(2n-i+1)*(i-1)/2+j-i+1$个，考虑到下标从$0$开始，则$A_{i,j}$在数组中的下标为$k=(n+i-1)*(i-1)/2+j-i$。</li>\n<li>第二种情况：$i&gt;j$，此时元素在下半部分，元素值相同，全部存到数组最后一个元素中，因此下标$k=(n+1)*n/2$</li>\n</ul>\n<h2 id=\"对角矩阵\"><a href=\"#对角矩阵\" class=\"headerlink\" title=\"对角矩阵\"></a>对角矩阵</h2><p>对角矩阵也称为带状矩阵，其对角带（以对角线为中心的带状区域内）元素非零，其余元素全部为零。对于$k$（$k$为奇数）对角矩阵，当$|i-j|&lt;=k/2$时，元素为带内元素，否则元素值为$0$。由此可根据每行元素数量求取元素位置。比如三对角矩阵，只有第一行和最后一行非零元素个数为$2$，其余非零元素为$3$。我们可以使用部分冗余，使得每一行数量均为$3$个，这样可以极大减少计算复杂度。以下推导三对角矩阵的压缩存储。</p>\n<p>由于第一行第前面和最后一行后面分别补一个零凑足$3$个元素，因此对于每一行其前面一共存储$3*(i-1)$个元素。而每行的第一个元素下标为$A_{i,i-1}$，因此对于第$A_{i,j}$元素在一维数组中的下标为$k=3*(i-1)+j-(i-1)=2*i+j-2$。其中第一个元素为$0$。</p>\n<p>注：详细对角矩阵定义见：<a href=\"https://zh.wikipedia.org/wiki/對角矩陣\" target=\"_blank\" rel=\"noopener\">对角矩阵</a></p>\n<h2 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h2><p>稀疏矩阵是元素大部分为零的矩阵，其有效元素的个数非常稀少，因此如果重复存储零元素是非常不合理的，目前常用来存储稀疏矩阵的数据结构为三元组和十字链表，三元组基本定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 1000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以下为三元组的定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TripleNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i; <span class=\"comment\">//行下标</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j; <span class=\"comment\">//列下标</span></span><br><span class=\"line\">\tDataType element; <span class=\"comment\">//实际元素值</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以下为稀疏矩阵存储结构定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SparseMatrix</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mu; <span class=\"comment\">//矩阵行数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nu; <span class=\"comment\">//矩阵列数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tu; <span class=\"comment\">//矩阵非零个数</span></span><br><span class=\"line\">\tTripleNode&lt;DataType&gt; matrix[MAXSIZE]; <span class=\"comment\">//TripleNode数组</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>稀疏矩阵在按行优先存储时遵循一下规则</p>\n<ul>\n<li>同一行内非零元素依次放置</li>\n<li>一行元素放完再放第二行元素</li>\n</ul>\n<p>注：详细稀疏矩阵定义见：<a href=\"https://zh.wikipedia.org/wiki/稀疏矩阵\" target=\"_blank\" rel=\"noopener\">稀疏矩阵</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><p>多维数组可以认为是线性表的一种推广，其元素本身可以是具有某种结构的数据，但必须是同种元素。数组在实际存储时采取的顺序存储，因此数组可以以$O(1)$的时间复杂度进行访问。对于一维数组，其元素内存地址可通过起始地址+偏移地址的方式直接计算得到；而对于多维数组，根据存储方式的不同，计算元素地址的方式也有细微的差别。目前存储方式主要有：</p>\n<ul>\n<li>行优先存储：即每行存放完后再存放下一行</li>\n<li>列优先存储：即一列一列地分配</li>\n</ul>\n<p>假设有一$m*n$二维数组定义为$A_{m,n}$，每个元素的大小为$d$个字节，数组任意元素$A_{i,j}$的地址为（下标从$1$开始）：</p>\n<ul>\n<li>按行优先存储：$LOC(A_{i,j}) = LOC(A_{1,1})+((i-1)*n+j-1)*d$</li>\n<li>按列优先存储：$LOC(A_{i,j}) = LOC(A_{1,1}) + ((j-1)*m + i-1)*d$</li>\n</ul>\n<h2 id=\"特殊矩阵\"><a href=\"#特殊矩阵\" class=\"headerlink\" title=\"特殊矩阵\"></a>特殊矩阵</h2><p>由于矩阵本身结构就是二维的，因此采用二维数组存储矩阵是非常合理的，但是有一类矩阵其有效元素数量占整个矩阵元素数量比重不大，因此从节约空间的角度，希望通过压缩存储无效元素（一般为$0$）的方式来存储该矩阵。先简要介绍几种特殊矩阵以及其压缩方法。</p>\n<h2 id=\"对称矩阵\"><a href=\"#对称矩阵\" class=\"headerlink\" title=\"对称矩阵\"></a>对称矩阵</h2><p>对称矩阵是指元素值关于对角线对称，即$A^T=A$，由于有一半左右的元素是相同，因此可采用只保存上半部分或者下半部分元素的方式将对称矩阵存入特别设计的一维数组，同时给出元素访问映射公式。</p>\n<p>注：详细对称矩阵定义见：<a href=\"https://zh.wikipedia.org/wiki/對稱矩陣\" target=\"_blank\" rel=\"noopener\">对称矩阵</a></p>\n<p>以存储对称矩阵的下半部分且以行优先存储方式为例分析映射公式。（矩阵为n阶方阵，数组下标从0开始，矩阵下标从1开始）</p>\n<p>在第一行需要存储的元素个数为$1$，第二行为$2$，依次类推总共需要存储$1+2+3….+n=(n+1)*n/2$个元素，因此数组元素的大小可定义为$(n+1)*n/2$。而对于位置为$A_{i,j}$的元素，我们分两种情况分析：</p>\n<ul>\n<li>第一种情况：$i&gt;=j$，此时元素在下半部分，在该元素前面的元素个数有$Before=1+2+….+(i-1)+j-1$个，因此该元素的位置为第$Before+1=(i-1)*i/2+j$个，考虑到下标从$0$开始，则$A_{i,j}$在数组中的下标为$k=(i-1)*i/2+j-1$</li>\n<li>第二种情况：$i&lt;j$，此时元素在上半部分，其值和$A_{i,j}$相等，根据上一步分析有数组下标$k=(j-1)*j/2+i-1$</li>\n</ul>\n<p>合并上述两种情况即可得出统一的下标计算公式</p>\n<p>$k=(max(i,j)-1)*max(i,j)/2+min(i,j)-1$</p>\n<p>注：$max(i,j)$表示$i、j$中较大的一个，$min(i,j)$表示$i、j$中较小的一个。</p>\n<h2 id=\"三角矩阵\"><a href=\"#三角矩阵\" class=\"headerlink\" title=\"三角矩阵\"></a>三角矩阵</h2><p>三角矩阵分为上三角矩阵以及下三角矩阵，其存储模式思想和对称矩阵类似，不过有大约一半（不算对角线）元素值相等，因此可以使用比对称矩阵存储个数$+1$的数组来存放整个矩阵。</p>\n<p>注：详细三角矩阵定义见：<a href=\"https://zh.wikipedia.org/wiki/三角矩阵\" target=\"_blank\" rel=\"noopener\">三角矩阵</a></p>\n<p>对于的一个元素用来存放相同的那个元素。下三角矩阵的分析过程和对称矩阵相似，以下为结论：</p>\n<p>注：矩阵为n阶方阵，数组下标从$0$开始，矩阵下标从$1$开始，行优先存储</p>\n<p>对于$i&gt;=j$，下标$k=k=(i-1)*i/2+j-1；i&lt;j$，下标$k=(n+1)*n/2$</p>\n<p>对于上三角矩阵，分为两种情况讨论，</p>\n<ul>\n<li>第一种情况：$i&lt;=j$，此时元素在上半部分，在该元素前面共有$Before=n+n-1+….+(n-(i-1)+1)+j-i$个元素，因此该元素的位置为第$Before+1=(2n-i+1)*(i-1)/2+j-i+1$个，考虑到下标从$0$开始，则$A_{i,j}$在数组中的下标为$k=(n+i-1)*(i-1)/2+j-i$。</li>\n<li>第二种情况：$i&gt;j$，此时元素在下半部分，元素值相同，全部存到数组最后一个元素中，因此下标$k=(n+1)*n/2$</li>\n</ul>\n<h2 id=\"对角矩阵\"><a href=\"#对角矩阵\" class=\"headerlink\" title=\"对角矩阵\"></a>对角矩阵</h2><p>对角矩阵也称为带状矩阵，其对角带（以对角线为中心的带状区域内）元素非零，其余元素全部为零。对于$k$（$k$为奇数）对角矩阵，当$|i-j|&lt;=k/2$时，元素为带内元素，否则元素值为$0$。由此可根据每行元素数量求取元素位置。比如三对角矩阵，只有第一行和最后一行非零元素个数为$2$，其余非零元素为$3$。我们可以使用部分冗余，使得每一行数量均为$3$个，这样可以极大减少计算复杂度。以下推导三对角矩阵的压缩存储。</p>\n<p>由于第一行第前面和最后一行后面分别补一个零凑足$3$个元素，因此对于每一行其前面一共存储$3*(i-1)$个元素。而每行的第一个元素下标为$A_{i,i-1}$，因此对于第$A_{i,j}$元素在一维数组中的下标为$k=3*(i-1)+j-(i-1)=2*i+j-2$。其中第一个元素为$0$。</p>\n<p>注：详细对角矩阵定义见：<a href=\"https://zh.wikipedia.org/wiki/對角矩陣\" target=\"_blank\" rel=\"noopener\">对角矩阵</a></p>\n<h2 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h2><p>稀疏矩阵是元素大部分为零的矩阵，其有效元素的个数非常稀少，因此如果重复存储零元素是非常不合理的，目前常用来存储稀疏矩阵的数据结构为三元组和十字链表，三元组基本定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 1000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以下为三元组的定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TripleNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i; <span class=\"comment\">//行下标</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j; <span class=\"comment\">//列下标</span></span><br><span class=\"line\">\tDataType element; <span class=\"comment\">//实际元素值</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以下为稀疏矩阵存储结构定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SparseMatrix</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mu; <span class=\"comment\">//矩阵行数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nu; <span class=\"comment\">//矩阵列数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tu; <span class=\"comment\">//矩阵非零个数</span></span><br><span class=\"line\">\tTripleNode&lt;DataType&gt; matrix[MAXSIZE]; <span class=\"comment\">//TripleNode数组</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>稀疏矩阵在按行优先存储时遵循一下规则</p>\n<ul>\n<li>同一行内非零元素依次放置</li>\n<li>一行元素放完再放第二行元素</li>\n</ul>\n<p>注：详细稀疏矩阵定义见：<a href=\"https://zh.wikipedia.org/wiki/稀疏矩阵\" target=\"_blank\" rel=\"noopener\">稀疏矩阵</a></p>\n"},{"title":"中、后缀转前缀表达式以及前缀表达式求值的实现","urlname":"infix-postfix-to-prefix","date":"2018-06-14T13:16:41.000Z","copyright":true,"mathjax":true,"_content":"\n## 前言\n\n前中后缀表达式的基本介绍可见上篇文章：[前中转后缀](https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html)，本文不再赘述。\n\n本文将实现将中缀、后缀表达式转变为前缀表达式并且实现一个简单的前缀表达式计算器。同时本文依旧约定表达式的基本数据结构如下：\n\n```cpp\nenum OperType\n{\n        /*OPERAND-操作数，OPERATOR-操作符*/\n        OPERAND, OPERATOR\n};\n\ntemplate <typename DataType>\nunion OperData\n{\n        char operatorCh;\n        DataType operand;\n};\n\ntemplate <typename DataType>\nstruct ExpressionAtom\n{\n        OperType operFlag;\n        OperData<DataType> operValue;\n};\n```\n\n**注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。**\n\n\n## 中缀转前缀表达式\n\n前缀表达式在表达式树中的遍历顺序为：根->左->右，而后缀表达式的遍历顺序为：左->右->根。如果把后缀表达式逆序（即采用栈来存放结果），此时得到的表达式操作数和结合顺序均发生反向，如果我们采用从中缀表达式右端向左端扫描的方式则可以抵消这个影响。中缀表达式转后缀表达式中有一个经典的调度场算法，我们综合上述考虑和修改该算法便可以得到中缀转前缀表达式的算法。算法对于括号处理也需要反向。同时在操作符压栈时和中缀转后缀略有区别的是如果优先级相等也需要接着入栈（左结合）。具体实现代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\nbool isGreater(char oper1, char oper2)\n{\n        if (oper2 == ')') {\n                return true;\n        }\n\n        if (oper1 == '+' || oper1 == '-') {\n                if (oper2 == '*' || oper2 == '/') {\n                        return false;\n                }\n                else {\n                        return true;\n                }\n        }\n        return true;\n}\n\ntemplate <typename DataType>\nvoid PopOperatorUntilRightBracket(stack<ExpressionAtom<DataType>> &operatorStack,\n         stack<ExpressionAtom<DataType>> &resultStack)\n{\n        while (operatorStack.top().operValue.operatorCh != ')') {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop();\n        }\n        operatorStack.pop(); /*弹出右括号*/\n}\n\ntemplate <typename DataType>\nvoid PopOperatorUntilLowPriority(stack<ExpressionAtom<DataType>> &operatorStack,\n         stack<ExpressionAtom<DataType>> &resultStack, char nowOperator)\n{\n        while (!operatorStack.empty() &&\n                        !isGreater(nowOperator, operatorStack.top().operValue.operatorCh)) {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop();\n        }\n}\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> InfixToPrefix(vector<ExpressionAtom<DataType>> &inInfix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n\n        stack<ExpressionAtom<DataType>> resultStack;\n\n        /*不做差错检测*/\n        for (int i = (int)inInfix.size() - 1; i >= 0; i--) {\n                if (inInfix[i].operFlag == OPERATOR) {\n                        if (inInfix[i].operValue.operatorCh == '(') {\n                                PopOperatorUntilRightBracket(operatorStack, resultStack);\n                        }\n                        else if (inInfix[i].operValue.operatorCh == ')') {\n                                operatorStack.push(inInfix[i]);\n                        }\n                        else {\n                                PopOperatorUntilLowPriority(operatorStack, resultStack,\n                                        inInfix[i].operValue.operatorCh);\n                                operatorStack.push(inInfix[i]);\n                        }\n                }\n                else {\n                        resultStack.push(inInfix[i]);\n                }\n        }\n\n\n        /*清空栈中操作符*/\n        while (!operatorStack.empty()) {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultStack.empty()) {\n                result.push_back(resultStack.top());\n                resultStack.pop();\n        }\n        return result;\n}\n```\n\n## 中缀转前缀代码测试\n\n使用如下图所示表达式树生成的中缀表达式来进行测试：[图片来源](http://www.cnblogs.com/lulipro/p/7563217.html)\n![表达式树](/images/expression-tree-test.png)\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        /*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n\n        PrintExpression(testVec);\n\n        auto result = InfixToPrefix(testVec); /*调用函数*/\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 后缀转前缀表达式\n\n前缀和后缀表达式在表达式树中的遍历顺序：前缀，根->左->右；后缀，左->右->根。分析和前缀转中缀类似，但是考虑后缀顺序反向，因此我们采取从后往前扫描的策略，同时采用栈存放操作数操作符以及根访问次数。只需将前缀转后缀代码稍加修改即可，具体代码如下所示：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> PostfixToPrefix(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n        stack<int> visitTimesStack;\n        stack<ExpressionAtom<DataType>> resultStack;\n\n        /*不做差错检测*/\n        for (int i = (int)inPostfix.size() - 1; i >= 0; i--) {\n                /*前序遍历在第一次访问时弹出*/\n                while (!visitTimesStack.empty() && visitTimesStack.top() <= 0) {\n                        resultStack.push(operatorStack.top());\n                        operatorStack.pop(); visitTimesStack.pop();\n                }\n                /*每访问一次-1*/\n                if (!visitTimesStack.empty()) {\n                        --visitTimesStack.top();\n                }\n                if (inPostfix[i].operFlag == OPERATOR) {\n                        operatorStack.push(inPostfix[i]);\n                        visitTimesStack.push(2); /*后序遍历为最后一次访问*/\n                }\n                else {\n                        resultStack.push(inPostfix[i]);\n                }\n        }\n\n        /*清空栈中操作符*/\n        while (!visitTimesStack.empty() && visitTimesStack.top() <= 0) {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop(); visitTimesStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultStack.empty()) {\n                result.push_back(resultStack.top());\n                resultStack.pop();\n        }\n        return result;\n}\n```\n\n## 后缀转前缀代码测试\n\n\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        PrintExpression(testVec);\n\n        auto result = PostfixToPrefix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n\n\n## 前缀表达式求值\n\n前缀表达式可以快速转变成后缀表达式然后通过后缀表达式间接进行求值，但是前缀表达式也是可以直接求值，前缀表达式正确地表达了运算优先顺序，后缀表达式是从前往后依次求值，那么考虑到前缀表达式操作符在运算符前面，因此我们只需从后往前扫描前缀表达式即可，其余部分和后缀表达式求值类似，其代码稍作修改既可用于前缀求值，具体代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nDataType Calculate(DataType inData1, DataType inData2, char operatorCh)\n{\n        if (operatorCh == '+') {\n                return inData1 + inData2;\n        }\n        else if (operatorCh == '-') {\n                return inData1 - inData2;\n        }\n        else if (operatorCh == '*') {\n                return inData1 * inData2;\n        }\n        else if (operatorCh == '/') {\n                return inData1 / inData2;\n        }\n        else {\n                return DataType(0);\n        }\n}\n\ntemplate <typename DataType>\nDataType CalculatePrefixValue(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        stack<DataType> operandStack;\n\n        /*不做差错检测*/\n        for (int i = (int)inPrefix.size() - 1; i >= 0; i--) {\n                if (inPrefix[i].operFlag == OPERATOR) {\n                        int tmp1 = operandStack.top(); operandStack.pop();\n                        int tmp2 = operandStack.top(); operandStack.pop();\n                        int result = Calculate(tmp1, tmp2, inPrefix[i].operValue.operatorCh);\n                        operandStack.push(result);\n                }\n                else {\n                        operandStack.push(inPrefix[i].operValue.operand);\n                }\n        }\n        return operandStack.top();\n}\n```\n\n## 后缀表达式求值代码测试\n\n在进行测试时直接使用上节求出的后缀表达式，具体代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\nusing std::vector;\nusing std::stack;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        /*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n\n        PrintExpression(testVec);\n\n        auto result = InfixToPrefix(testVec); /*调用函数*/\n\n        PrintExpression(result);\n\n        cout << CalculatePrefixValue(result) << endl; /*测试代码*/\n\n        return 0;\n}\n```\n\n## 参考资料\n\n[波兰表示法-维基百科](https://zh.wikipedia.org/wiki/波兰表示法)\n\n[中缀表示法-维基百科](https://zh.wikipedia.org/wiki/中缀表示法)\n\n[逆波兰表示法-维基百科](https://zh.wikipedia.org/wiki/逆波兰表示法)\n\n[调度场算法-维基百科](https://zh.wikipedia.org/wiki/调度场算法)\n\n[中缀/后缀/前缀表达式求值](https://www.jianshu.com/p/a908f067670b)\n","source":"_posts/算法设计/中_后缀表达式转前缀表达式和前缀表达式求值.md","raw":"---\ntitle: 中、后缀转前缀表达式以及前缀表达式求值的实现\nurlname: infix-postfix-to-prefix\ndate: 2018-06-14 21:16:41\ncopyright: true\nmathjax: true\ntags:\n- 算法设计\ncategories:\n- 算法设计\n---\n\n## 前言\n\n前中后缀表达式的基本介绍可见上篇文章：[前中转后缀](https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html)，本文不再赘述。\n\n本文将实现将中缀、后缀表达式转变为前缀表达式并且实现一个简单的前缀表达式计算器。同时本文依旧约定表达式的基本数据结构如下：\n\n```cpp\nenum OperType\n{\n        /*OPERAND-操作数，OPERATOR-操作符*/\n        OPERAND, OPERATOR\n};\n\ntemplate <typename DataType>\nunion OperData\n{\n        char operatorCh;\n        DataType operand;\n};\n\ntemplate <typename DataType>\nstruct ExpressionAtom\n{\n        OperType operFlag;\n        OperData<DataType> operValue;\n};\n```\n\n**注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。**\n\n\n## 中缀转前缀表达式\n\n前缀表达式在表达式树中的遍历顺序为：根->左->右，而后缀表达式的遍历顺序为：左->右->根。如果把后缀表达式逆序（即采用栈来存放结果），此时得到的表达式操作数和结合顺序均发生反向，如果我们采用从中缀表达式右端向左端扫描的方式则可以抵消这个影响。中缀表达式转后缀表达式中有一个经典的调度场算法，我们综合上述考虑和修改该算法便可以得到中缀转前缀表达式的算法。算法对于括号处理也需要反向。同时在操作符压栈时和中缀转后缀略有区别的是如果优先级相等也需要接着入栈（左结合）。具体实现代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\nbool isGreater(char oper1, char oper2)\n{\n        if (oper2 == ')') {\n                return true;\n        }\n\n        if (oper1 == '+' || oper1 == '-') {\n                if (oper2 == '*' || oper2 == '/') {\n                        return false;\n                }\n                else {\n                        return true;\n                }\n        }\n        return true;\n}\n\ntemplate <typename DataType>\nvoid PopOperatorUntilRightBracket(stack<ExpressionAtom<DataType>> &operatorStack,\n         stack<ExpressionAtom<DataType>> &resultStack)\n{\n        while (operatorStack.top().operValue.operatorCh != ')') {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop();\n        }\n        operatorStack.pop(); /*弹出右括号*/\n}\n\ntemplate <typename DataType>\nvoid PopOperatorUntilLowPriority(stack<ExpressionAtom<DataType>> &operatorStack,\n         stack<ExpressionAtom<DataType>> &resultStack, char nowOperator)\n{\n        while (!operatorStack.empty() &&\n                        !isGreater(nowOperator, operatorStack.top().operValue.operatorCh)) {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop();\n        }\n}\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> InfixToPrefix(vector<ExpressionAtom<DataType>> &inInfix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n\n        stack<ExpressionAtom<DataType>> resultStack;\n\n        /*不做差错检测*/\n        for (int i = (int)inInfix.size() - 1; i >= 0; i--) {\n                if (inInfix[i].operFlag == OPERATOR) {\n                        if (inInfix[i].operValue.operatorCh == '(') {\n                                PopOperatorUntilRightBracket(operatorStack, resultStack);\n                        }\n                        else if (inInfix[i].operValue.operatorCh == ')') {\n                                operatorStack.push(inInfix[i]);\n                        }\n                        else {\n                                PopOperatorUntilLowPriority(operatorStack, resultStack,\n                                        inInfix[i].operValue.operatorCh);\n                                operatorStack.push(inInfix[i]);\n                        }\n                }\n                else {\n                        resultStack.push(inInfix[i]);\n                }\n        }\n\n\n        /*清空栈中操作符*/\n        while (!operatorStack.empty()) {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultStack.empty()) {\n                result.push_back(resultStack.top());\n                resultStack.pop();\n        }\n        return result;\n}\n```\n\n## 中缀转前缀代码测试\n\n使用如下图所示表达式树生成的中缀表达式来进行测试：[图片来源](http://www.cnblogs.com/lulipro/p/7563217.html)\n![表达式树](/images/expression-tree-test.png)\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        /*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n\n        PrintExpression(testVec);\n\n        auto result = InfixToPrefix(testVec); /*调用函数*/\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 后缀转前缀表达式\n\n前缀和后缀表达式在表达式树中的遍历顺序：前缀，根->左->右；后缀，左->右->根。分析和前缀转中缀类似，但是考虑后缀顺序反向，因此我们采取从后往前扫描的策略，同时采用栈存放操作数操作符以及根访问次数。只需将前缀转后缀代码稍加修改即可，具体代码如下所示：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> PostfixToPrefix(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n        stack<int> visitTimesStack;\n        stack<ExpressionAtom<DataType>> resultStack;\n\n        /*不做差错检测*/\n        for (int i = (int)inPostfix.size() - 1; i >= 0; i--) {\n                /*前序遍历在第一次访问时弹出*/\n                while (!visitTimesStack.empty() && visitTimesStack.top() <= 0) {\n                        resultStack.push(operatorStack.top());\n                        operatorStack.pop(); visitTimesStack.pop();\n                }\n                /*每访问一次-1*/\n                if (!visitTimesStack.empty()) {\n                        --visitTimesStack.top();\n                }\n                if (inPostfix[i].operFlag == OPERATOR) {\n                        operatorStack.push(inPostfix[i]);\n                        visitTimesStack.push(2); /*后序遍历为最后一次访问*/\n                }\n                else {\n                        resultStack.push(inPostfix[i]);\n                }\n        }\n\n        /*清空栈中操作符*/\n        while (!visitTimesStack.empty() && visitTimesStack.top() <= 0) {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop(); visitTimesStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultStack.empty()) {\n                result.push_back(resultStack.top());\n                resultStack.pop();\n        }\n        return result;\n}\n```\n\n## 后缀转前缀代码测试\n\n\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        PrintExpression(testVec);\n\n        auto result = PostfixToPrefix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n\n\n## 前缀表达式求值\n\n前缀表达式可以快速转变成后缀表达式然后通过后缀表达式间接进行求值，但是前缀表达式也是可以直接求值，前缀表达式正确地表达了运算优先顺序，后缀表达式是从前往后依次求值，那么考虑到前缀表达式操作符在运算符前面，因此我们只需从后往前扫描前缀表达式即可，其余部分和后缀表达式求值类似，其代码稍作修改既可用于前缀求值，具体代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nDataType Calculate(DataType inData1, DataType inData2, char operatorCh)\n{\n        if (operatorCh == '+') {\n                return inData1 + inData2;\n        }\n        else if (operatorCh == '-') {\n                return inData1 - inData2;\n        }\n        else if (operatorCh == '*') {\n                return inData1 * inData2;\n        }\n        else if (operatorCh == '/') {\n                return inData1 / inData2;\n        }\n        else {\n                return DataType(0);\n        }\n}\n\ntemplate <typename DataType>\nDataType CalculatePrefixValue(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        stack<DataType> operandStack;\n\n        /*不做差错检测*/\n        for (int i = (int)inPrefix.size() - 1; i >= 0; i--) {\n                if (inPrefix[i].operFlag == OPERATOR) {\n                        int tmp1 = operandStack.top(); operandStack.pop();\n                        int tmp2 = operandStack.top(); operandStack.pop();\n                        int result = Calculate(tmp1, tmp2, inPrefix[i].operValue.operatorCh);\n                        operandStack.push(result);\n                }\n                else {\n                        operandStack.push(inPrefix[i].operValue.operand);\n                }\n        }\n        return operandStack.top();\n}\n```\n\n## 后缀表达式求值代码测试\n\n在进行测试时直接使用上节求出的后缀表达式，具体代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\nusing std::vector;\nusing std::stack;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        /*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '(';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = ')';\n        testVec.push_back(manualData);\n\n\n        PrintExpression(testVec);\n\n        auto result = InfixToPrefix(testVec); /*调用函数*/\n\n        PrintExpression(result);\n\n        cout << CalculatePrefixValue(result) << endl; /*测试代码*/\n\n        return 0;\n}\n```\n\n## 参考资料\n\n[波兰表示法-维基百科](https://zh.wikipedia.org/wiki/波兰表示法)\n\n[中缀表示法-维基百科](https://zh.wikipedia.org/wiki/中缀表示法)\n\n[逆波兰表示法-维基百科](https://zh.wikipedia.org/wiki/逆波兰表示法)\n\n[调度场算法-维基百科](https://zh.wikipedia.org/wiki/调度场算法)\n\n[中缀/后缀/前缀表达式求值](https://www.jianshu.com/p/a908f067670b)\n","slug":"算法设计/中_后缀表达式转前缀表达式和前缀表达式求值","published":1,"updated":"2018-06-14T13:19:13.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjiemwkrl00007wvnn7c2ku14","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前中后缀表达式的基本介绍可见上篇文章：<a href=\"https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html\" target=\"_blank\" rel=\"noopener\">前中转后缀</a>，本文不再赘述。</p>\n<p>本文将实现将中缀、后缀表达式转变为前缀表达式并且实现一个简单的前缀表达式计算器。同时本文依旧约定表达式的基本数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> OperType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*OPERAND-操作数，OPERATOR-操作符*/</span></span><br><span class=\"line\">        OPERAND, OPERATOR</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">union</span> OperData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> operatorCh;</span><br><span class=\"line\">        DataType operand;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ExpressionAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        OperType operFlag;</span><br><span class=\"line\">        OperData&lt;DataType&gt; operValue;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。</strong></p>\n<h2 id=\"中缀转前缀表达式\"><a href=\"#中缀转前缀表达式\" class=\"headerlink\" title=\"中缀转前缀表达式\"></a>中缀转前缀表达式</h2><p>前缀表达式在表达式树中的遍历顺序为：根-&gt;左-&gt;右，而后缀表达式的遍历顺序为：左-&gt;右-&gt;根。如果把后缀表达式逆序（即采用栈来存放结果），此时得到的表达式操作数和结合顺序均发生反向，如果我们采用从中缀表达式右端向左端扫描的方式则可以抵消这个影响。中缀表达式转后缀表达式中有一个经典的调度场算法，我们综合上述考虑和修改该算法便可以得到中缀转前缀表达式的算法。算法对于括号处理也需要反向。同时在操作符压栈时和中缀转后缀略有区别的是如果优先级相等也需要接着入栈（左结合）。具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isGreater</span><span class=\"params\">(<span class=\"keyword\">char</span> oper1, <span class=\"keyword\">char</span> oper2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oper2 == <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oper1 == <span class=\"string\">'+'</span> || oper1 == <span class=\"string\">'-'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oper2 == <span class=\"string\">'*'</span> || oper2 == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PopOperatorUntilRightBracket</span><span class=\"params\">(<span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;operatorStack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;resultStack)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (operatorStack.top().operValue.operatorCh != <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        operatorStack.pop(); <span class=\"comment\">/*弹出右括号*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PopOperatorUntilLowPriority</span><span class=\"params\">(<span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;operatorStack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;resultStack, <span class=\"keyword\">char</span> nowOperator)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!operatorStack.empty() &amp;&amp;</span><br><span class=\"line\">                        !isGreater(nowOperator, operatorStack.top().operValue.operatorCh)) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; InfixToPrefix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inInfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)inInfix.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inInfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (inInfix[i].operValue.operatorCh == <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                                PopOperatorUntilRightBracket(operatorStack, resultStack);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inInfix[i].operValue.operatorCh == <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">                                operatorStack.push(inInfix[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                PopOperatorUntilLowPriority(operatorStack, resultStack,</span><br><span class=\"line\">                                        inInfix[i].operValue.operatorCh);</span><br><span class=\"line\">                                operatorStack.push(inInfix[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        resultStack.push(inInfix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!operatorStack.empty()) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultStack.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultStack.top());</span><br><span class=\"line\">                resultStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中缀转前缀代码测试\"><a href=\"#中缀转前缀代码测试\" class=\"headerlink\" title=\"中缀转前缀代码测试\"></a>中缀转前缀代码测试</h2><p>使用如下图所示表达式树生成的中缀表达式来进行测试：<a href=\"http://www.cnblogs.com/lulipro/p/7563217.html\" target=\"_blank\" rel=\"noopener\">图片来源</a><br><img src=\"/images/expression-tree-test.png\" alt=\"表达式树\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = InfixToPrefix(testVec); <span class=\"comment\">/*调用函数*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀转前缀表达式\"><a href=\"#后缀转前缀表达式\" class=\"headerlink\" title=\"后缀转前缀表达式\"></a>后缀转前缀表达式</h2><p>前缀和后缀表达式在表达式树中的遍历顺序：前缀，根-&gt;左-&gt;右；后缀，左-&gt;右-&gt;根。分析和前缀转中缀类似，但是考虑后缀顺序反向，因此我们采取从后往前扫描的策略，同时采用栈存放操作数操作符以及根访问次数。只需将前缀转后缀代码稍加修改即可，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; PostfixToPrefix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; visitTimesStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)inPostfix.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*前序遍历在第一次访问时弹出*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        resultStack.push(operatorStack.top());</span><br><span class=\"line\">                        operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/*每访问一次-1*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!visitTimesStack.empty()) &#123;</span><br><span class=\"line\">                        --visitTimesStack.top();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPostfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        operatorStack.push(inPostfix[i]);</span><br><span class=\"line\">                        visitTimesStack.push(<span class=\"number\">2</span>); <span class=\"comment\">/*后序遍历为最后一次访问*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        resultStack.push(inPostfix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultStack.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultStack.top());</span><br><span class=\"line\">                resultStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀转前缀代码测试\"><a href=\"#后缀转前缀代码测试\" class=\"headerlink\" title=\"后缀转前缀代码测试\"></a>后缀转前缀代码测试</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PostfixToPrefix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀表达式求值\"><a href=\"#前缀表达式求值\" class=\"headerlink\" title=\"前缀表达式求值\"></a>前缀表达式求值</h2><p>前缀表达式可以快速转变成后缀表达式然后通过后缀表达式间接进行求值，但是前缀表达式也是可以直接求值，前缀表达式正确地表达了运算优先顺序，后缀表达式是从前往后依次求值，那么考虑到前缀表达式操作符在运算符前面，因此我们只需从后往前扫描前缀表达式即可，其余部分和后缀表达式求值类似，其代码稍作修改既可用于前缀求值，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\">DataType <span class=\"title\">Calculate</span><span class=\"params\">(DataType inData1, DataType inData2, <span class=\"keyword\">char</span> operatorCh)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'+'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 + inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'-'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 - inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'*'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 * inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 / inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> DataType(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\">DataType <span class=\"title\">CalculatePrefixValue</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;DataType&gt; operandStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)inPrefix.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPrefix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmp1 = operandStack.top(); operandStack.pop();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmp2 = operandStack.top(); operandStack.pop();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> result = Calculate(tmp1, tmp2, inPrefix[i].operValue.operatorCh);</span><br><span class=\"line\">                        operandStack.push(result);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        operandStack.push(inPrefix[i].operValue.operand);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> operandStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀表达式求值代码测试\"><a href=\"#后缀表达式求值代码测试\" class=\"headerlink\" title=\"后缀表达式求值代码测试\"></a>后缀表达式求值代码测试</h2><p>在进行测试时直接使用上节求出的后缀表达式，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = InfixToPrefix(testVec); <span class=\"comment\">/*调用函数*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; CalculatePrefixValue(result) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">/*测试代码*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/波兰表示法\" target=\"_blank\" rel=\"noopener\">波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/中缀表示法\" target=\"_blank\" rel=\"noopener\">中缀表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/逆波兰表示法\" target=\"_blank\" rel=\"noopener\">逆波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/调度场算法\" target=\"_blank\" rel=\"noopener\">调度场算法-维基百科</a></p>\n<p><a href=\"https://www.jianshu.com/p/a908f067670b\" target=\"_blank\" rel=\"noopener\">中缀/后缀/前缀表达式求值</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前中后缀表达式的基本介绍可见上篇文章：<a href=\"https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html\" target=\"_blank\" rel=\"noopener\">前中转后缀</a>，本文不再赘述。</p>\n<p>本文将实现将中缀、后缀表达式转变为前缀表达式并且实现一个简单的前缀表达式计算器。同时本文依旧约定表达式的基本数据结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> OperType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*OPERAND-操作数，OPERATOR-操作符*/</span></span><br><span class=\"line\">        OPERAND, OPERATOR</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">union</span> OperData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> operatorCh;</span><br><span class=\"line\">        DataType operand;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ExpressionAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        OperType operFlag;</span><br><span class=\"line\">        OperData&lt;DataType&gt; operValue;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。</strong></p>\n<h2 id=\"中缀转前缀表达式\"><a href=\"#中缀转前缀表达式\" class=\"headerlink\" title=\"中缀转前缀表达式\"></a>中缀转前缀表达式</h2><p>前缀表达式在表达式树中的遍历顺序为：根-&gt;左-&gt;右，而后缀表达式的遍历顺序为：左-&gt;右-&gt;根。如果把后缀表达式逆序（即采用栈来存放结果），此时得到的表达式操作数和结合顺序均发生反向，如果我们采用从中缀表达式右端向左端扫描的方式则可以抵消这个影响。中缀表达式转后缀表达式中有一个经典的调度场算法，我们综合上述考虑和修改该算法便可以得到中缀转前缀表达式的算法。算法对于括号处理也需要反向。同时在操作符压栈时和中缀转后缀略有区别的是如果优先级相等也需要接着入栈（左结合）。具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isGreater</span><span class=\"params\">(<span class=\"keyword\">char</span> oper1, <span class=\"keyword\">char</span> oper2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oper2 == <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oper1 == <span class=\"string\">'+'</span> || oper1 == <span class=\"string\">'-'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oper2 == <span class=\"string\">'*'</span> || oper2 == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PopOperatorUntilRightBracket</span><span class=\"params\">(<span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;operatorStack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;resultStack)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (operatorStack.top().operValue.operatorCh != <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        operatorStack.pop(); <span class=\"comment\">/*弹出右括号*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PopOperatorUntilLowPriority</span><span class=\"params\">(<span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;operatorStack,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;resultStack, <span class=\"keyword\">char</span> nowOperator)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!operatorStack.empty() &amp;&amp;</span><br><span class=\"line\">                        !isGreater(nowOperator, operatorStack.top().operValue.operatorCh)) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; InfixToPrefix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inInfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)inInfix.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inInfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (inInfix[i].operValue.operatorCh == <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">                                PopOperatorUntilRightBracket(operatorStack, resultStack);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inInfix[i].operValue.operatorCh == <span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">                                operatorStack.push(inInfix[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                PopOperatorUntilLowPriority(operatorStack, resultStack,</span><br><span class=\"line\">                                        inInfix[i].operValue.operatorCh);</span><br><span class=\"line\">                                operatorStack.push(inInfix[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        resultStack.push(inInfix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!operatorStack.empty()) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultStack.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultStack.top());</span><br><span class=\"line\">                resultStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中缀转前缀代码测试\"><a href=\"#中缀转前缀代码测试\" class=\"headerlink\" title=\"中缀转前缀代码测试\"></a>中缀转前缀代码测试</h2><p>使用如下图所示表达式树生成的中缀表达式来进行测试：<a href=\"http://www.cnblogs.com/lulipro/p/7563217.html\" target=\"_blank\" rel=\"noopener\">图片来源</a><br><img src=\"/images/expression-tree-test.png\" alt=\"表达式树\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = InfixToPrefix(testVec); <span class=\"comment\">/*调用函数*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀转前缀表达式\"><a href=\"#后缀转前缀表达式\" class=\"headerlink\" title=\"后缀转前缀表达式\"></a>后缀转前缀表达式</h2><p>前缀和后缀表达式在表达式树中的遍历顺序：前缀，根-&gt;左-&gt;右；后缀，左-&gt;右-&gt;根。分析和前缀转中缀类似，但是考虑后缀顺序反向，因此我们采取从后往前扫描的策略，同时采用栈存放操作数操作符以及根访问次数。只需将前缀转后缀代码稍加修改即可，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; PostfixToPrefix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; visitTimesStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)inPostfix.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*前序遍历在第一次访问时弹出*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        resultStack.push(operatorStack.top());</span><br><span class=\"line\">                        operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/*每访问一次-1*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!visitTimesStack.empty()) &#123;</span><br><span class=\"line\">                        --visitTimesStack.top();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPostfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        operatorStack.push(inPostfix[i]);</span><br><span class=\"line\">                        visitTimesStack.push(<span class=\"number\">2</span>); <span class=\"comment\">/*后序遍历为最后一次访问*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        resultStack.push(inPostfix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultStack.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultStack.top());</span><br><span class=\"line\">                resultStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀转前缀代码测试\"><a href=\"#后缀转前缀代码测试\" class=\"headerlink\" title=\"后缀转前缀代码测试\"></a>后缀转前缀代码测试</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PostfixToPrefix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀表达式求值\"><a href=\"#前缀表达式求值\" class=\"headerlink\" title=\"前缀表达式求值\"></a>前缀表达式求值</h2><p>前缀表达式可以快速转变成后缀表达式然后通过后缀表达式间接进行求值，但是前缀表达式也是可以直接求值，前缀表达式正确地表达了运算优先顺序，后缀表达式是从前往后依次求值，那么考虑到前缀表达式操作符在运算符前面，因此我们只需从后往前扫描前缀表达式即可，其余部分和后缀表达式求值类似，其代码稍作修改既可用于前缀求值，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\">DataType <span class=\"title\">Calculate</span><span class=\"params\">(DataType inData1, DataType inData2, <span class=\"keyword\">char</span> operatorCh)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'+'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 + inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'-'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 - inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'*'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 * inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operatorCh == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> inData1 / inData2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> DataType(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\">DataType <span class=\"title\">CalculatePrefixValue</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;DataType&gt; operandStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)inPrefix.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPrefix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmp1 = operandStack.top(); operandStack.pop();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> tmp2 = operandStack.top(); operandStack.pop();</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> result = Calculate(tmp1, tmp2, inPrefix[i].operValue.operatorCh);</span><br><span class=\"line\">                        operandStack.push(result);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        operandStack.push(inPrefix[i].operValue.operand);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> operandStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀表达式求值代码测试\"><a href=\"#后缀表达式求值代码测试\" class=\"headerlink\" title=\"后缀表达式求值代码测试\"></a>后缀表达式求值代码测试</h2><p>在进行测试时直接使用上节求出的后缀表达式，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*表达式为(3+1)*3/(9-5-2)-(3*(7-4)+6)*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'('</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">')'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = InfixToPrefix(testVec); <span class=\"comment\">/*调用函数*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; CalculatePrefixValue(result) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">/*测试代码*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/波兰表示法\" target=\"_blank\" rel=\"noopener\">波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/中缀表示法\" target=\"_blank\" rel=\"noopener\">中缀表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/逆波兰表示法\" target=\"_blank\" rel=\"noopener\">逆波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/调度场算法\" target=\"_blank\" rel=\"noopener\">调度场算法-维基百科</a></p>\n<p><a href=\"https://www.jianshu.com/p/a908f067670b\" target=\"_blank\" rel=\"noopener\">中缀/后缀/前缀表达式求值</a></p>\n"},{"title":"前、后缀表达式转中缀表达式的实现","urlname":"prefix-postfix-to-infix","date":"2018-06-14T14:17:57.000Z","copyright":true,"mathjax":true,"_content":"\n## 前言\n\n前中后缀表达式的基本介绍可见文章：[前中转后缀](https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html)，本文不再赘述。\n\n本文将实现将前缀、后缀表达式转变为中缀表达式。约定放置表达式的基本数据结构依然如下所示：\n\n```cpp\nenum OperType\n{\n        /*OPERAND-操作数，OPERATOR-操作符*/\n        OPERAND, OPERATOR\n};\n\ntemplate <typename DataType>\nunion OperData {\n        char operatorCh;\n        DataType operand;\n};\n\ntemplate <typename DataType>\nstruct ExpressionAtom\n{\n        OperType operFlag;\n        OperData<DataType> operValue;\n};\n```\n\n**注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。**\n\n## 前缀转中缀表达式\n\n前缀表达式不包含括号却表达了正确的运算顺序，因此在转成中缀表达式时将会完全丢失这些信息。由于前缀表达式在第一次访问时输出，而中缀在第二次访问时输出，因此我么可以仿照前缀转后缀代码来实现前缀转中缀，基本实现代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\n#include <queue>\nusing std::vector;\nusing std::stack;\nusing std::queue;\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> PrefixToInfix(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n        stack<int> visitTimesStack;\n        queue<ExpressionAtom<DataType>> resultQueue;\n\n        /*不做差错检测*/\n        for (size_t i = 0; i < inPrefix.size(); i++) {\n                /*中序遍历在第二次访问时弹出*/\n                while (!visitTimesStack.empty() && visitTimesStack.top() >= 1) {\n                        resultQueue.push(operatorStack.top());\n                        operatorStack.pop(); visitTimesStack.pop();\n                }\n\n                if (inPrefix[i].operFlag == OPERATOR) {\n                        operatorStack.push(inPrefix[i]);\n                        visitTimesStack.push(0); /*初始化访问数据*/\n                }\n                else {\n                        /*每访问一次+1*/\n                        if (!visitTimesStack.empty()) {\n                                ++visitTimesStack.top();\n                        }\n                        resultQueue.push(inPrefix[i]);\n                }\n        }\n\n        /*清空栈中操作符*/\n        while (!visitTimesStack.empty() && visitTimesStack.top() >= 2) {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop(); visitTimesStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultQueue.empty()) {\n                result.push_back(resultQueue.front());\n                resultQueue.pop();\n        }\n        return result;\n}\n```\n\n## 前缀转中缀代码测试\n\n使用如下图所示表达式树生成的前缀表达式来进行测试：[图片来源](http://www.cnblogs.com/lulipro/p/7563217.html)\n![表达式树](/images/expression-tree-test.png)\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        PrintExpression(testVec);\n\n        auto result = PrefixToInfix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 后缀转中缀表达式\n\n参考后缀转前缀代码，后缀是在第三次访问时输出，而中缀是在第二次访问时输出，同时考虑后缀因该从后往前的扫描，，因此采用栈存放操作数操作符以及根访问次数。只需将后缀转前缀代码稍加修改即可，具体代码如下所示：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> PostfixToInfix(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n        stack<int> visitTimesStack;\n        stack<ExpressionAtom<DataType>> resultStack;\n\n        /*不做差错检测*/\n        for (int i = (int)inPostfix.size() - 1; i >= 0; i--) {\n                /*前序遍历在第一次访问时弹出*/\n                while (!visitTimesStack.empty() && visitTimesStack.top() <= 0) {\n                        resultStack.push(operatorStack.top());\n                        operatorStack.pop(); visitTimesStack.pop();\n                }\n\n                if (inPostfix[i].operFlag == OPERATOR) {\n                        operatorStack.push(inPostfix[i]);\n                        visitTimesStack.push(1); /*中序遍历为第二次访问*/\n                }\n                else {\n                        /*每访问一次-1*/\n                        if (!visitTimesStack.empty()) {\n                                --visitTimesStack.top();\n                        }\n                        resultStack.push(inPostfix[i]);\n                }\n        }\n\n        /*清空栈中操作符*/\n        while (!visitTimesStack.empty() && visitTimesStack.top() <= 0) {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop(); visitTimesStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultStack.empty()) {\n                result.push_back(resultStack.top());\n                resultStack.pop();\n        }\n        return result;\n}\n```\n\n## 后缀转中缀代码测试\n\n使用前缀中的表达式树，同时使用括号改变优先级，具体测试代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        PrintExpression(testVec);\n\n        auto result = PostfixToInfix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 参考资料\n\n[波兰表示法-维基百科](https://zh.wikipedia.org/wiki/波兰表示法)\n\n[中缀表示法-维基百科](https://zh.wikipedia.org/wiki/中缀表示法)\n\n[逆波兰表示法-维基百科](https://zh.wikipedia.org/wiki/逆波兰表示法)\n\n[调度场算法-维基百科](https://zh.wikipedia.org/wiki/调度场算法)\n","source":"_posts/算法设计/前_后缀表达式转中缀表达式.md","raw":"---\ntitle: 前、后缀表达式转中缀表达式的实现\nurlname: prefix-postfix-to-infix\ndate: 2018-06-14 22:17:57\ncopyright: true\nmathjax: true\ntags:\n- 算法设计\ncategories:\n- 算法设计\n---\n\n## 前言\n\n前中后缀表达式的基本介绍可见文章：[前中转后缀](https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html)，本文不再赘述。\n\n本文将实现将前缀、后缀表达式转变为中缀表达式。约定放置表达式的基本数据结构依然如下所示：\n\n```cpp\nenum OperType\n{\n        /*OPERAND-操作数，OPERATOR-操作符*/\n        OPERAND, OPERATOR\n};\n\ntemplate <typename DataType>\nunion OperData {\n        char operatorCh;\n        DataType operand;\n};\n\ntemplate <typename DataType>\nstruct ExpressionAtom\n{\n        OperType operFlag;\n        OperData<DataType> operValue;\n};\n```\n\n**注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。**\n\n## 前缀转中缀表达式\n\n前缀表达式不包含括号却表达了正确的运算顺序，因此在转成中缀表达式时将会完全丢失这些信息。由于前缀表达式在第一次访问时输出，而中缀在第二次访问时输出，因此我么可以仿照前缀转后缀代码来实现前缀转中缀，基本实现代码如下：\n\n```cpp\n#include <vector>\n#include <stack>\n#include <queue>\nusing std::vector;\nusing std::stack;\nusing std::queue;\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> PrefixToInfix(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n        stack<int> visitTimesStack;\n        queue<ExpressionAtom<DataType>> resultQueue;\n\n        /*不做差错检测*/\n        for (size_t i = 0; i < inPrefix.size(); i++) {\n                /*中序遍历在第二次访问时弹出*/\n                while (!visitTimesStack.empty() && visitTimesStack.top() >= 1) {\n                        resultQueue.push(operatorStack.top());\n                        operatorStack.pop(); visitTimesStack.pop();\n                }\n\n                if (inPrefix[i].operFlag == OPERATOR) {\n                        operatorStack.push(inPrefix[i]);\n                        visitTimesStack.push(0); /*初始化访问数据*/\n                }\n                else {\n                        /*每访问一次+1*/\n                        if (!visitTimesStack.empty()) {\n                                ++visitTimesStack.top();\n                        }\n                        resultQueue.push(inPrefix[i]);\n                }\n        }\n\n        /*清空栈中操作符*/\n        while (!visitTimesStack.empty() && visitTimesStack.top() >= 2) {\n                resultQueue.push(operatorStack.top());\n                operatorStack.pop(); visitTimesStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultQueue.empty()) {\n                result.push_back(resultQueue.front());\n                resultQueue.pop();\n        }\n        return result;\n}\n```\n\n## 前缀转中缀代码测试\n\n使用如下图所示表达式树生成的前缀表达式来进行测试：[图片来源](http://www.cnblogs.com/lulipro/p/7563217.html)\n![表达式树](/images/expression-tree-test.png)\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        PrintExpression(testVec);\n\n        auto result = PrefixToInfix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 后缀转中缀表达式\n\n参考后缀转前缀代码，后缀是在第三次访问时输出，而中缀是在第二次访问时输出，同时考虑后缀因该从后往前的扫描，，因此采用栈存放操作数操作符以及根访问次数。只需将后缀转前缀代码稍加修改即可，具体代码如下所示：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nvector<ExpressionAtom<DataType>> PostfixToInfix(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        stack<ExpressionAtom<DataType>> operatorStack;\n        stack<int> visitTimesStack;\n        stack<ExpressionAtom<DataType>> resultStack;\n\n        /*不做差错检测*/\n        for (int i = (int)inPostfix.size() - 1; i >= 0; i--) {\n                /*前序遍历在第一次访问时弹出*/\n                while (!visitTimesStack.empty() && visitTimesStack.top() <= 0) {\n                        resultStack.push(operatorStack.top());\n                        operatorStack.pop(); visitTimesStack.pop();\n                }\n\n                if (inPostfix[i].operFlag == OPERATOR) {\n                        operatorStack.push(inPostfix[i]);\n                        visitTimesStack.push(1); /*中序遍历为第二次访问*/\n                }\n                else {\n                        /*每访问一次-1*/\n                        if (!visitTimesStack.empty()) {\n                                --visitTimesStack.top();\n                        }\n                        resultStack.push(inPostfix[i]);\n                }\n        }\n\n        /*清空栈中操作符*/\n        while (!visitTimesStack.empty() && visitTimesStack.top() <= 0) {\n                resultStack.push(operatorStack.top());\n                operatorStack.pop(); visitTimesStack.pop();\n        }\n\n        vector<ExpressionAtom<DataType>> result;\n        while (!resultStack.empty()) {\n                result.push_back(resultStack.top());\n                resultStack.pop();\n        }\n        return result;\n}\n```\n\n## 后缀转中缀代码测试\n\n使用前缀中的表达式树，同时使用括号改变优先级，具体测试代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\nusing std::vector;\nusing std::queue;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nvoid PrintExpression(vector<ExpressionAtom<DataType>> &inExpr)\n{\n        for (size_t i = 0; i < inExpr.size(); i++) {\n                if (inExpr[i].operFlag == OPERAND) {\n                        cout << inExpr[i].operValue.operand << \";\";\n                }\n                else {\n                        cout << inExpr[i].operValue.operatorCh << \";\";\n                }\n        }\n        cout << endl;\n}\n\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        PrintExpression(testVec);\n\n        auto result = PostfixToInfix(testVec);\n\n        PrintExpression(result);\n\n        return 0;\n}\n```\n\n## 参考资料\n\n[波兰表示法-维基百科](https://zh.wikipedia.org/wiki/波兰表示法)\n\n[中缀表示法-维基百科](https://zh.wikipedia.org/wiki/中缀表示法)\n\n[逆波兰表示法-维基百科](https://zh.wikipedia.org/wiki/逆波兰表示法)\n\n[调度场算法-维基百科](https://zh.wikipedia.org/wiki/调度场算法)\n","slug":"算法设计/前_后缀表达式转中缀表达式","published":1,"updated":"2018-06-20T15:39:44.631Z","_id":"cjiemwkrv00017wvn7g0owvwn","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前中后缀表达式的基本介绍可见文章：<a href=\"https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html\" target=\"_blank\" rel=\"noopener\">前中转后缀</a>，本文不再赘述。</p>\n<p>本文将实现将前缀、后缀表达式转变为中缀表达式。约定放置表达式的基本数据结构依然如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> OperType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*OPERAND-操作数，OPERATOR-操作符*/</span></span><br><span class=\"line\">        OPERAND, OPERATOR</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">union</span> OperData &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> operatorCh;</span><br><span class=\"line\">        DataType operand;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ExpressionAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        OperType operFlag;</span><br><span class=\"line\">        OperData&lt;DataType&gt; operValue;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。</strong></p>\n<h2 id=\"前缀转中缀表达式\"><a href=\"#前缀转中缀表达式\" class=\"headerlink\" title=\"前缀转中缀表达式\"></a>前缀转中缀表达式</h2><p>前缀表达式不包含括号却表达了正确的运算顺序，因此在转成中缀表达式时将会完全丢失这些信息。由于前缀表达式在第一次访问时输出，而中缀在第二次访问时输出，因此我么可以仿照前缀转后缀代码来实现前缀转中缀，基本实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; PrefixToInfix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; visitTimesStack;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inPrefix.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*中序遍历在第二次访问时弹出*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                        operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPrefix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        operatorStack.push(inPrefix[i]);</span><br><span class=\"line\">                        visitTimesStack.push(<span class=\"number\">0</span>); <span class=\"comment\">/*初始化访问数据*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*每访问一次+1*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!visitTimesStack.empty()) &#123;</span><br><span class=\"line\">                                ++visitTimesStack.top();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        resultQueue.push(inPrefix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultQueue.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultQueue.front());</span><br><span class=\"line\">                resultQueue.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀转中缀代码测试\"><a href=\"#前缀转中缀代码测试\" class=\"headerlink\" title=\"前缀转中缀代码测试\"></a>前缀转中缀代码测试</h2><p>使用如下图所示表达式树生成的前缀表达式来进行测试：<a href=\"http://www.cnblogs.com/lulipro/p/7563217.html\" target=\"_blank\" rel=\"noopener\">图片来源</a><br><img src=\"/images/expression-tree-test.png\" alt=\"表达式树\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PrefixToInfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀转中缀表达式\"><a href=\"#后缀转中缀表达式\" class=\"headerlink\" title=\"后缀转中缀表达式\"></a>后缀转中缀表达式</h2><p>参考后缀转前缀代码，后缀是在第三次访问时输出，而中缀是在第二次访问时输出，同时考虑后缀因该从后往前的扫描，，因此采用栈存放操作数操作符以及根访问次数。只需将后缀转前缀代码稍加修改即可，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; PostfixToInfix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; visitTimesStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)inPostfix.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*前序遍历在第一次访问时弹出*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        resultStack.push(operatorStack.top());</span><br><span class=\"line\">                        operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPostfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        operatorStack.push(inPostfix[i]);</span><br><span class=\"line\">                        visitTimesStack.push(<span class=\"number\">1</span>); <span class=\"comment\">/*中序遍历为第二次访问*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*每访问一次-1*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!visitTimesStack.empty()) &#123;</span><br><span class=\"line\">                                --visitTimesStack.top();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        resultStack.push(inPostfix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultStack.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultStack.top());</span><br><span class=\"line\">                resultStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀转中缀代码测试\"><a href=\"#后缀转中缀代码测试\" class=\"headerlink\" title=\"后缀转中缀代码测试\"></a>后缀转中缀代码测试</h2><p>使用前缀中的表达式树，同时使用括号改变优先级，具体测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PostfixToInfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/波兰表示法\" target=\"_blank\" rel=\"noopener\">波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/中缀表示法\" target=\"_blank\" rel=\"noopener\">中缀表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/逆波兰表示法\" target=\"_blank\" rel=\"noopener\">逆波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/调度场算法\" target=\"_blank\" rel=\"noopener\">调度场算法-维基百科</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前中后缀表达式的基本介绍可见文章：<a href=\"https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html\" target=\"_blank\" rel=\"noopener\">前中转后缀</a>，本文不再赘述。</p>\n<p>本文将实现将前缀、后缀表达式转变为中缀表达式。约定放置表达式的基本数据结构依然如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> OperType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*OPERAND-操作数，OPERATOR-操作符*/</span></span><br><span class=\"line\">        OPERAND, OPERATOR</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">union</span> OperData &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> operatorCh;</span><br><span class=\"line\">        DataType operand;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ExpressionAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        OperType operFlag;</span><br><span class=\"line\">        OperData&lt;DataType&gt; operValue;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注：本文所指表达式操作符只含有双目运算符且运算符的结合顺序为从左到右。</strong></p>\n<h2 id=\"前缀转中缀表达式\"><a href=\"#前缀转中缀表达式\" class=\"headerlink\" title=\"前缀转中缀表达式\"></a>前缀转中缀表达式</h2><p>前缀表达式不包含括号却表达了正确的运算顺序，因此在转成中缀表达式时将会完全丢失这些信息。由于前缀表达式在第一次访问时输出，而中缀在第二次访问时输出，因此我么可以仿照前缀转后缀代码来实现前缀转中缀，基本实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; PrefixToInfix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; visitTimesStack;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inPrefix.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*中序遍历在第二次访问时弹出*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                        operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPrefix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        operatorStack.push(inPrefix[i]);</span><br><span class=\"line\">                        visitTimesStack.push(<span class=\"number\">0</span>); <span class=\"comment\">/*初始化访问数据*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*每访问一次+1*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!visitTimesStack.empty()) &#123;</span><br><span class=\"line\">                                ++visitTimesStack.top();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        resultQueue.push(inPrefix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                resultQueue.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultQueue.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultQueue.front());</span><br><span class=\"line\">                resultQueue.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀转中缀代码测试\"><a href=\"#前缀转中缀代码测试\" class=\"headerlink\" title=\"前缀转中缀代码测试\"></a>前缀转中缀代码测试</h2><p>使用如下图所示表达式树生成的前缀表达式来进行测试：<a href=\"http://www.cnblogs.com/lulipro/p/7563217.html\" target=\"_blank\" rel=\"noopener\">图片来源</a><br><img src=\"/images/expression-tree-test.png\" alt=\"表达式树\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PrefixToInfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀转中缀表达式\"><a href=\"#后缀转中缀表达式\" class=\"headerlink\" title=\"后缀转中缀表达式\"></a>后缀转中缀表达式</h2><p>参考后缀转前缀代码，后缀是在第三次访问时输出，而中缀是在第二次访问时输出，同时考虑后缀因该从后往前的扫描，，因此采用栈存放操作数操作符以及根访问次数。只需将后缀转前缀代码稍加修改即可，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; PostfixToInfix(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; operatorStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; visitTimesStack;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; resultStack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*不做差错检测*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)inPostfix.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*前序遍历在第一次访问时弹出*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        resultStack.push(operatorStack.top());</span><br><span class=\"line\">                        operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inPostfix[i].operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        operatorStack.push(inPostfix[i]);</span><br><span class=\"line\">                        visitTimesStack.push(<span class=\"number\">1</span>); <span class=\"comment\">/*中序遍历为第二次访问*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*每访问一次-1*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!visitTimesStack.empty()) &#123;</span><br><span class=\"line\">                                --visitTimesStack.top();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        resultStack.push(inPostfix[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*清空栈中操作符*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!visitTimesStack.empty() &amp;&amp; visitTimesStack.top() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultStack.push(operatorStack.top());</span><br><span class=\"line\">                operatorStack.pop(); visitTimesStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!resultStack.empty()) &#123;</span><br><span class=\"line\">                result.push_back(resultStack.top());</span><br><span class=\"line\">                resultStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀转中缀代码测试\"><a href=\"#后缀转中缀代码测试\" class=\"headerlink\" title=\"后缀转中缀代码测试\"></a>后缀转中缀代码测试</h2><p>使用前缀中的表达式树，同时使用括号改变优先级，具体测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintExpression</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inExpr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inExpr.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inExpr[i].operFlag == OPERAND) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operand &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; inExpr[i].operValue.operatorCh &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PostfixToInfix(testVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrintExpression(result);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/波兰表示法\" target=\"_blank\" rel=\"noopener\">波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/中缀表示法\" target=\"_blank\" rel=\"noopener\">中缀表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/逆波兰表示法\" target=\"_blank\" rel=\"noopener\">逆波兰表示法-维基百科</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/调度场算法\" target=\"_blank\" rel=\"noopener\">调度场算法-维基百科</a></p>\n"},{"title":"字符串模式匹配及KMP算法分析与实现","urlname":"string-pattern-match-kmp","date":"2018-06-23T07:14:25.000Z","copyright":true,"mathjax":true,"_content":"\n## 字符串基础知识\n\n根据相关资料，字符串定义如下：字符串是由零个或者多个字符组成的有限序列，其中零个字符的串称为空串。字符串的主要存储方式有定长顺序存储（对应于C/C++中栈空间）、堆分配存储（动态申请内存）以及块链存储（链表节点为一个定长小块，多个小块依次组成一个实际串）。\n\n字符串模式匹配是指给定两个串$S_1,S_2$，要求找出串$S_1$中与串$S_2$相等的子串。目前模式匹配算法思路主要有朴素模式匹配算法、KMP算法等（更多的算法可见参考资料）。本文依次分析实现两种算法。\n\n## 朴素模式匹配算法\n\n朴素模式匹配算法是最简单最容易想到的算法，也是最暴力的算法。其基本思路是对于主串$S_1$与模式串$S_2$分别设置两个下标 $i,j$。假设主串比较的起始位置为$startPos$，则置$i=startPos,j=0$，依次比较从 $i$ 和从 $j$ 下标开始的字符序列是否相等，如果比较到模式串最后一个位置相等则返回找到的结果，否则将 $i$ 置为上次起始位置的下一个下标（$i=startPos+1$），$j$ 置为模式字符串起始位置（$j=0$）。具体实现代码如下：\n\n```cpp\n#include <string>\nusing std::string;\n\nint BrutePatternMatch(string mainString, string patternString, size_t startPos)\n{\n        size_t i = startPos, j = 0;\n        while (i < mainString.size() && j < patternString.size()) {\n                if (mainString[i] == patternString[j]) {\n                        ++i; ++j;\n                }\n                else {\n                        startPos += 1;\n                        i = startPos; j = 0;\n                }\n        }\n        if (j >= patternString.size()) {\n                return int(startPos);\n        }\n        else {\n                return -1;\n        }\n}\n```\n\n以上朴素的字符串模式匹配算法可以做进一步优化，比如 $i$ 定位到的位置必须保证剩下的子串长度大于等于模式串的长度。\n\n## KMP算法\n\n### KMP算法基本原理\n\n观察朴素模式匹配算法，每次失配后会导致下标 $i,j$ 均发生回溯，使模式串起始位置（$j=0$）对齐到主串的$startPos+1$位置重新开始下一轮比较。但是我们在 $i,j$ 发生失配时是已知$[0,(j-1)]$与$[i-j,i-1]$之间的字符串是相等，如果我们能找到这部分相等字符子串的某些规律使得我们在对齐主串与模式串的下一轮比较起始位置时能够使 $i$ 尽量多跳几步（即$i=startPos+k,k>1$）甚至使得 $i$ 不发生回溯，那么便可以优化算法的时间复杂度了。根据这种思路得到的算法就是KMP算法了，KMP算法是由D.E.Knuth、J.H.Morris和V.R.Pratt共同发现的，取名字的首字母便得到KMP算法简称。假设主串长度为n模式串长度为m则该算法的时间复杂度为$O(n+m)$。空间复杂度由于增加一个 next 数组为$O(m)$。\n\n如下图为一张KMP算法说明图：\n\n![KMP](/images/kmp-algorithm-pattern.png)\n\n红框内为第一次发生失配的的字符，蓝框为已经匹配相等的子串。如果按照朴素模式匹配算法，则此时对齐位置如下图所示：\n\n![KMP](/images/brute-pattern-algorithm-step.png)\n\n此时显然依旧会发生失配，需要再次将模式串往后移以对齐。但是如果保持 $i$ 不移动，一直移动模式串使得可以再次启动从 $i$ 开始的比较，则会得到如下图所示的对齐位置：\n\n![KMP](/images/kmp-algorithm-step.png)\n\n如上图所示，我们字符串可以直接开始从 $i$ 启动下一轮比较，此时 $i$ 没有发生回溯，只是 $j$ 发生回溯以对齐比较位置。如果我们希望能够一次就可以使得对齐位置移动到如上图所示的位置该如何处理呢？这便是$next$数组需要完成的工作了。比如上述匹配失配发生在$j=7$的位置，如果此时我们令$next[7]=2$，则我们可以当第 7 号（下标从 0 开始）元素发生失配时直接将 $j$ 的值置为$j=next[j]$便可以完成不回溯 $i$ 的情况下一次性对齐主串和模式串使得下一轮比较可以从当前失配 $i$ 开始。以上便是KMP算法的基本思路了，剩下的就是如何得到这个$next$数组了。\n\n### KMP算法Next数组计算\n\n在移动模式串对齐主串的过程中，我们先只观察已经匹配的部分，如下图红框内的字符字串所示：\n\n![KMP](/images/kmp-algorithm-next.png)\n\n我们可以看到在逐步滑动模式串时，会比较主串中已匹配字符子串（图中$ababcab$）的真后缀部分与模式串中已匹配字符子串（和主串中一样）的真前缀部分，我们在滑动过程中发现真前缀和真后缀相等时下标 $i$ 会再次指向上次失配的位置（即图中红框外字符 $c$），如果滑动使得真前缀真后缀不相等会导致 $i$ 回溯至当前失配的前方且必定导致模式串继续向前滑动直到找到一个真前缀与真后缀相等的位置，此时从失配位置（图中红框外字符 $c$）继续比较。如果此时 $i,j$ 对应的字符相等则比较下一个，如果不等则可以重复上述步骤，只是现在已匹配字符子串发生变化（图中在比较主串红框外c再次发生失配，此时已匹配子串为 $ab$）。\n\n通过上述的分析我们可以得知 $next$ 数组的含义是在某个字符上发生失配后已匹配部分字符串的真前缀和真后缀部分最长相等长度（由于下标从0开始，最长是因为在模式串滑动时找到第一个真前缀真后缀相等部分是最长的）。以上是基本的 $next$ 数组含义。接下来就是具体如何计算该数组了。\n\n根据上述分析，$next$ 数组是已匹配字符部分的最大前后缀相等（不包含自身）长度，因此最朴素的想法是针对模式串中的每一段字符分别暴力求解最长前后缀相等长度，但此时时间复杂度过高,可能高达$O(m^3)$。如果我们仔细分析问题会发现求最长前后缀长度也是一个模式匹配问题，只不过此时主串与模式串均为同一个字符串且从主串的第1个字符（下标从0开始）开始匹配。如下图是一个模式串的 $next$ 数组：\n\n![KMP](/images/kmp-next-array.png)\n\n如上图所示，我们依次分析。以 $i,j$ 代表主串和模式串下标。当 $j=0$ 发生失配时，此时已匹配长度为0，因此不应发生回溯而是 $i$ 向前走一步，但在实际编程中为了统一处理需要特殊处理这种情况，因此此处暂时使用问号，后期表明如何设置一个特殊值以方便编程；当 $j=1$ 发生失配时，此时已匹配长度为1，滑动一步即可开始比较，即从头开始比较，此时 $next[1] = 0$；当 $k=j+1$ 时，此时已知 $next[j]$ , 即 $[0, next[j])$ 和 $[j-next[j],j)$之间的字符串相等，如果当模式串的第 $next[j]$ 个字符与第 $j$ 个字符相等时，可推知 $[0, next[j]]$ 和  $[j-next[j],j]$ 之间的字符串相等，可得到 $next[k]=next[j]+1$，如果不等，如下图所示：\n\n![KMP不等](/images/kmp-next-not-equal.png)\n\n此时只能在该区间缩小范围继续查找，从而有缩小区间真前缀串必定是 $[0, next[j])$ 串的真前缀，上图所示第 $next[j]=4$ 个字符不等于第 $j=9$ 个字符，在缩小范围时需要保证  $[0, nextIndex)$ 与  $[j-nextIndex,j)$ 之间的字符串依旧保持相等(其中$nextIndex < next[j]$)，否则此时比较第 $nextIndex$ 个字符与第 $j$ 个字符已经失去意义。而两个区间的字符串又分别是 $[0, next[j])$ 字符串的真前缀真后缀，此时回到了求某个字符串的最长相等真前缀真后缀问题，这在上一步已经解决了，即本问题是一个递推问题，此时 $nextIndex=next[next[j]]$，即反复递推，最后递推到找到满足相等条件或者递推结束。根据上述思路可以得到计算 $next$ 数组的代码。\n\n```cpp\n#include <vector>\n#include <string>\nusing std::vector;\nusing std::string;\n\nvector<int> CalculateNextArray(string patternString)\n{\n        vector<int> nextArray(patternString.size(), -1);\n        if (patternString.size() <= 1) {\n                return nextArray;\n        }\n        nextArray[1] = 0; /*只有一个匹配的字符子串真前缀真后缀均为空*/\n        int i = 1, j = 0;\n        for ( ; i < int(patternString.size()) - 1; i++) {\n                j = nextArray[i]; /*获取真前缀下一个下标*/\n                if (patternString[i] == patternString[j]) {\n                        nextArray[i+1] = j + 1;\n                }\n                else {\n                        if (j == 0) {\n                                nextArray[i+1] = 0;\n                        }\n                        else {\n                                while (1) {\n                                        j = nextArray[j];\n                                        if (j == 0) {\n                                                if (patternString[i] == patternString[j]) {\n                                                        nextArray[i+1] = j + 1;\n                                                }\n                                                else {\n                                                        nextArray[i+1] = 0;\n                                                }\n                                                break;\n                                        }\n                                        else if (patternString[i] == patternString[j]){\n                                                nextArray[i+1] = j + 1; break;\n                                        }\n                                }\n                        }\n                }\n        }\n        return nextArray;\n}\n```\n\n从上述代码可以看出代码重复判断 $j==0$ 的情况，如果可以统一处理可以使得代码更加简洁，这便需要用到前面提到过的 $next[0]$，如何设置该值呢？观察代码，我们可以发现当 $j==0$是有两种情况，一种是此时 $i,j$ 对应的字符相等，此时 $next[i+1]=j+1=0+1=1$，当不等时 $next[i+1]=0=-1+1$，如果我们让 $j==0$ 和字符不等时将 $j$ 置为 $-1$，结合上述思路修改代码如下：\n\n```cpp\n#include <vector>\n#include <string>\nusing std::vector;\nusing std::string;\n\nvector<int> CalculateNextArrayImprove(string patternString)\n{\n        vector<int> nextArray(patternString.size(), -1);\n        if (patternString.size() <= 1) {\n                return nextArray;\n        }\n\n        nextArray[0] = -1; /*第0个赋为-1*/\n        int i = 0, j = 0;\n        for ( ; i < int(patternString.size()) - 1; i++) {\n                j = i; /*获取真前缀下一个下标*/\n                while (1) {\n                        j = nextArray[j];\n                        if (j == -1 || patternString[i] == patternString[j]) {\n                                nextArray[i+1] = j + 1; break;\n                        }\n                }\n        }\n        return nextArray;\n}\n```\n\n上述代码是否还可以进一步优化呢？观察代码我们可以发现每次 $j$ 都重置为 $j=i$，然后才进行迭代查找，实际在一次计算完毕后 $j$ 已经保存了下一轮计算所需的结果，因此可做进一步优化，代码如下：\n\n```cpp\n#include <vector>\n#include <string>\nusing std::vector;\nusing std::string;\n\nvector<int> CalculateNextArrayUltimate(string patternString)\n{\n        vector<int> nextArray(patternString.size(), -1);\n        if (patternString.size() <= 1) {\n                return nextArray;\n        }\n\n        nextArray[0] = -1; /*第0个赋为-1*/\n        int i = 0, j = -1;\n        for ( ; i < int(patternString.size()) - 1; i++) {\n                while (1) {\n                        if (j == -1 || patternString[i] == patternString[j]) {\n                                j += 1;\n                                nextArray[i+1] = j; break;\n                        }\n                        j = nextArray[j];\n                }\n        }\n        return nextArray;\n}\n```\n\n上述代码只是优化掉了一行赋值代码，实际上上面代码依旧可以进行优化，考虑如下图一种情况：\n\n![KMP不等](/images/kmp-next-array-improve.png)\n\n在第 $2,3,5,6,7,8,10,11$ 个字符一旦失配后，如果 $j$ 回溯到 $next[j]$ 时依旧会失效，因为这两个下标的字符是一样的，因此如果在发现第 $j$ 与第 $next[j]$ 字符相等时，可以接着往前回溯，直到不相等。由于递推是从前往后，因此我们只需把值赋为上一个值即可，优化代码如下：\n\n```cpp\n#include <vector>\n#include <string>\nusing std::vector;\nusing std::string;\n\nvector<int> CalculateNextArrayUltimateImprove(string patternString)\n{\n        vector<int> nextArray(patternString.size(), -1);\n        if (patternString.size() <= 1) {\n                return nextArray;\n        }\n\n        nextArray[0] = -1; /*第0个赋为-1*/\n        int i = 0, j = -1;\n        for ( ; i < int(patternString.size()) - 1; i++) {\n                while (1) {\n                        if (j == -1 || patternString[i] == patternString[j]) {\n                                j += 1;\n                                if (patternString[j] == patternString[i+1]) {\n                                        nextArray[i+1] = nextArray[j];\n                                }\n                                else {\n                                        nextArray[i+1] = j;\n                                }\n                                break;\n                        }\n                        j = nextArray[j];\n                }\n        }\n        return nextArray;\n}\n```\n\n### KMP算法实现\n\n既然KMP算法Next数组已经计算得到，则写出KMP模式匹配算法也是非常容易的，考虑 $next[0]=-1$，有如下模式匹配算法：\n\n```cpp\n#include <string>\nusing std::string;\n\nint KMP(string mainString, string patternString, size_t startPos)\n{\n        vector<int> nextArray = CalculateNextArrayUltimate(patternString);\n        int i = startPos, j = 0;\n        for ( ; i < int(mainString.size()) && j < int(patternString.size()); ) {\n                /*相等i，j均向前推，j==-1表明不存在真前缀真后缀相等，i，j也往前推*/\n                if (j == -1 || mainString[i] == patternString[j]) {\n                        ++j; ++i;\n                }\n                else {\n                        j = nextArray[j];\n                }\n        }\n\n        if (j >= int(patternString.size())) {\n                return i - j; /*返回起始位置*/\n        }\n        else {\n                return -1;\n        }\n}\n```\n\n## 算法测试\n\n### Next数组计算代码测试\n\n使用多个案例测试Next数组计算代码，测试代码如下：\n\n```cpp\n#include <vector>\n#include <string>\n#include <iostream>\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\n\nint main()\n{\n        /*问号代表值未确定*/\n        string testStrings[] = {\"ababcabababc\", /*?,0,0,1,2,0,1,2,3,4,3,4*/\n                                \"ababaaababaa\", /*?,0,0,1,2,3,1,1,2,3,4,5*/\n                                \"babababaa\",    /*?,0,0,1,2,3,4,5,6*/\n                                \"aaab\",         /*?,0,1,2*/\n                               };\n\n        vector<vector<int>> correct = {\n                                       {-1,0,0,1,2,0,1,2,3,4,3,4},\n                                       {-1,0,0,1,2,3,1,1,2,3,4,5},\n                                       {-1,0,0,1,2,3,4,5,6},\n                                       {-1,0,1,2}\n                                      };\n\n        for (size_t i = 0; i < sizeof(testStrings)/sizeof(testStrings[0]); i++) {\n                /*调用具体的函数*/\n                vector<int> result = CalculateNextArray(testStrings[i]);\n\n                cout << (result == correct[i] ? \"Correct\" : \"Wrong\") << endl;\n        }\n\n        return 0;\n}\n```\n\n### KMP算法测试\n\nKMP算法测试代码如下所示：\n\n```cpp\n#include <vector>\n#include <string>\n#include <iostream>\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\n\nint main()\n{\n        /*第一个主串，第二个模式串*/\n        vector<vector<string>> testStrings = {\n                                              {\"ababcabcaabcbaabc\", \"ababcabababc\"},\n                                              {\"ababcabcaabcbaabc\", \"cabc\"},\n                                              {\"HA\", \"HAHAHA\"},\n                                              {\"WQN\", \"WQN\"},\n                                              {\"ADDAADAADDAAADAAD\", \"DAD\"},\n                                              {\"BABABABABABABABABB\", \"BABABB\"},\n                                             };\n        vector<int> correct = {-1,\n                                4,\n                               -1,\n                                0,\n                               -1,\n                               12\n                               };\n\n        for (size_t i = 0; i < testStrings.size(); i++) {\n                /*调用具体的函数*/\n                int result = KMP(testStrings[i][0], testStrings[i][1], 0);\n\n                cout << (result == correct[i] ? \"Correct\" : \"Wrong\") << endl;\n        }\n\n        return 0;\n}\n```\n\n\n\n## 参考资料\n\n[字符串](https://zh.wikipedia.org/zh-hans/%E5%AD%97%E7%AC%A6%E4%B8%B2)\n\n[子串](https://zh.wikipedia.org/zh-hans/子串)\n\n[字符串模式匹配算法](http://dsqiu.iteye.com/blog/1700312)\n\n[克努斯-莫里斯-普拉特算法](https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95)\n\n[数据结构](https://book.douban.com/subject/2024655/)\n","source":"_posts/算法设计/字符串模式匹配及KMP算法分析与实现.md","raw":"---\ntitle: 字符串模式匹配及KMP算法分析与实现\nurlname: string-pattern-match-kmp\ndate: 2018-06-23 15:14:25\ncopyright: true\nmathjax: true\ntags:\n- 算法设计\ncategories:\n- 算法设计\n---\n\n## 字符串基础知识\n\n根据相关资料，字符串定义如下：字符串是由零个或者多个字符组成的有限序列，其中零个字符的串称为空串。字符串的主要存储方式有定长顺序存储（对应于C/C++中栈空间）、堆分配存储（动态申请内存）以及块链存储（链表节点为一个定长小块，多个小块依次组成一个实际串）。\n\n字符串模式匹配是指给定两个串$S_1,S_2$，要求找出串$S_1$中与串$S_2$相等的子串。目前模式匹配算法思路主要有朴素模式匹配算法、KMP算法等（更多的算法可见参考资料）。本文依次分析实现两种算法。\n\n## 朴素模式匹配算法\n\n朴素模式匹配算法是最简单最容易想到的算法，也是最暴力的算法。其基本思路是对于主串$S_1$与模式串$S_2$分别设置两个下标 $i,j$。假设主串比较的起始位置为$startPos$，则置$i=startPos,j=0$，依次比较从 $i$ 和从 $j$ 下标开始的字符序列是否相等，如果比较到模式串最后一个位置相等则返回找到的结果，否则将 $i$ 置为上次起始位置的下一个下标（$i=startPos+1$），$j$ 置为模式字符串起始位置（$j=0$）。具体实现代码如下：\n\n```cpp\n#include <string>\nusing std::string;\n\nint BrutePatternMatch(string mainString, string patternString, size_t startPos)\n{\n        size_t i = startPos, j = 0;\n        while (i < mainString.size() && j < patternString.size()) {\n                if (mainString[i] == patternString[j]) {\n                        ++i; ++j;\n                }\n                else {\n                        startPos += 1;\n                        i = startPos; j = 0;\n                }\n        }\n        if (j >= patternString.size()) {\n                return int(startPos);\n        }\n        else {\n                return -1;\n        }\n}\n```\n\n以上朴素的字符串模式匹配算法可以做进一步优化，比如 $i$ 定位到的位置必须保证剩下的子串长度大于等于模式串的长度。\n\n## KMP算法\n\n### KMP算法基本原理\n\n观察朴素模式匹配算法，每次失配后会导致下标 $i,j$ 均发生回溯，使模式串起始位置（$j=0$）对齐到主串的$startPos+1$位置重新开始下一轮比较。但是我们在 $i,j$ 发生失配时是已知$[0,(j-1)]$与$[i-j,i-1]$之间的字符串是相等，如果我们能找到这部分相等字符子串的某些规律使得我们在对齐主串与模式串的下一轮比较起始位置时能够使 $i$ 尽量多跳几步（即$i=startPos+k,k>1$）甚至使得 $i$ 不发生回溯，那么便可以优化算法的时间复杂度了。根据这种思路得到的算法就是KMP算法了，KMP算法是由D.E.Knuth、J.H.Morris和V.R.Pratt共同发现的，取名字的首字母便得到KMP算法简称。假设主串长度为n模式串长度为m则该算法的时间复杂度为$O(n+m)$。空间复杂度由于增加一个 next 数组为$O(m)$。\n\n如下图为一张KMP算法说明图：\n\n![KMP](/images/kmp-algorithm-pattern.png)\n\n红框内为第一次发生失配的的字符，蓝框为已经匹配相等的子串。如果按照朴素模式匹配算法，则此时对齐位置如下图所示：\n\n![KMP](/images/brute-pattern-algorithm-step.png)\n\n此时显然依旧会发生失配，需要再次将模式串往后移以对齐。但是如果保持 $i$ 不移动，一直移动模式串使得可以再次启动从 $i$ 开始的比较，则会得到如下图所示的对齐位置：\n\n![KMP](/images/kmp-algorithm-step.png)\n\n如上图所示，我们字符串可以直接开始从 $i$ 启动下一轮比较，此时 $i$ 没有发生回溯，只是 $j$ 发生回溯以对齐比较位置。如果我们希望能够一次就可以使得对齐位置移动到如上图所示的位置该如何处理呢？这便是$next$数组需要完成的工作了。比如上述匹配失配发生在$j=7$的位置，如果此时我们令$next[7]=2$，则我们可以当第 7 号（下标从 0 开始）元素发生失配时直接将 $j$ 的值置为$j=next[j]$便可以完成不回溯 $i$ 的情况下一次性对齐主串和模式串使得下一轮比较可以从当前失配 $i$ 开始。以上便是KMP算法的基本思路了，剩下的就是如何得到这个$next$数组了。\n\n### KMP算法Next数组计算\n\n在移动模式串对齐主串的过程中，我们先只观察已经匹配的部分，如下图红框内的字符字串所示：\n\n![KMP](/images/kmp-algorithm-next.png)\n\n我们可以看到在逐步滑动模式串时，会比较主串中已匹配字符子串（图中$ababcab$）的真后缀部分与模式串中已匹配字符子串（和主串中一样）的真前缀部分，我们在滑动过程中发现真前缀和真后缀相等时下标 $i$ 会再次指向上次失配的位置（即图中红框外字符 $c$），如果滑动使得真前缀真后缀不相等会导致 $i$ 回溯至当前失配的前方且必定导致模式串继续向前滑动直到找到一个真前缀与真后缀相等的位置，此时从失配位置（图中红框外字符 $c$）继续比较。如果此时 $i,j$ 对应的字符相等则比较下一个，如果不等则可以重复上述步骤，只是现在已匹配字符子串发生变化（图中在比较主串红框外c再次发生失配，此时已匹配子串为 $ab$）。\n\n通过上述的分析我们可以得知 $next$ 数组的含义是在某个字符上发生失配后已匹配部分字符串的真前缀和真后缀部分最长相等长度（由于下标从0开始，最长是因为在模式串滑动时找到第一个真前缀真后缀相等部分是最长的）。以上是基本的 $next$ 数组含义。接下来就是具体如何计算该数组了。\n\n根据上述分析，$next$ 数组是已匹配字符部分的最大前后缀相等（不包含自身）长度，因此最朴素的想法是针对模式串中的每一段字符分别暴力求解最长前后缀相等长度，但此时时间复杂度过高,可能高达$O(m^3)$。如果我们仔细分析问题会发现求最长前后缀长度也是一个模式匹配问题，只不过此时主串与模式串均为同一个字符串且从主串的第1个字符（下标从0开始）开始匹配。如下图是一个模式串的 $next$ 数组：\n\n![KMP](/images/kmp-next-array.png)\n\n如上图所示，我们依次分析。以 $i,j$ 代表主串和模式串下标。当 $j=0$ 发生失配时，此时已匹配长度为0，因此不应发生回溯而是 $i$ 向前走一步，但在实际编程中为了统一处理需要特殊处理这种情况，因此此处暂时使用问号，后期表明如何设置一个特殊值以方便编程；当 $j=1$ 发生失配时，此时已匹配长度为1，滑动一步即可开始比较，即从头开始比较，此时 $next[1] = 0$；当 $k=j+1$ 时，此时已知 $next[j]$ , 即 $[0, next[j])$ 和 $[j-next[j],j)$之间的字符串相等，如果当模式串的第 $next[j]$ 个字符与第 $j$ 个字符相等时，可推知 $[0, next[j]]$ 和  $[j-next[j],j]$ 之间的字符串相等，可得到 $next[k]=next[j]+1$，如果不等，如下图所示：\n\n![KMP不等](/images/kmp-next-not-equal.png)\n\n此时只能在该区间缩小范围继续查找，从而有缩小区间真前缀串必定是 $[0, next[j])$ 串的真前缀，上图所示第 $next[j]=4$ 个字符不等于第 $j=9$ 个字符，在缩小范围时需要保证  $[0, nextIndex)$ 与  $[j-nextIndex,j)$ 之间的字符串依旧保持相等(其中$nextIndex < next[j]$)，否则此时比较第 $nextIndex$ 个字符与第 $j$ 个字符已经失去意义。而两个区间的字符串又分别是 $[0, next[j])$ 字符串的真前缀真后缀，此时回到了求某个字符串的最长相等真前缀真后缀问题，这在上一步已经解决了，即本问题是一个递推问题，此时 $nextIndex=next[next[j]]$，即反复递推，最后递推到找到满足相等条件或者递推结束。根据上述思路可以得到计算 $next$ 数组的代码。\n\n```cpp\n#include <vector>\n#include <string>\nusing std::vector;\nusing std::string;\n\nvector<int> CalculateNextArray(string patternString)\n{\n        vector<int> nextArray(patternString.size(), -1);\n        if (patternString.size() <= 1) {\n                return nextArray;\n        }\n        nextArray[1] = 0; /*只有一个匹配的字符子串真前缀真后缀均为空*/\n        int i = 1, j = 0;\n        for ( ; i < int(patternString.size()) - 1; i++) {\n                j = nextArray[i]; /*获取真前缀下一个下标*/\n                if (patternString[i] == patternString[j]) {\n                        nextArray[i+1] = j + 1;\n                }\n                else {\n                        if (j == 0) {\n                                nextArray[i+1] = 0;\n                        }\n                        else {\n                                while (1) {\n                                        j = nextArray[j];\n                                        if (j == 0) {\n                                                if (patternString[i] == patternString[j]) {\n                                                        nextArray[i+1] = j + 1;\n                                                }\n                                                else {\n                                                        nextArray[i+1] = 0;\n                                                }\n                                                break;\n                                        }\n                                        else if (patternString[i] == patternString[j]){\n                                                nextArray[i+1] = j + 1; break;\n                                        }\n                                }\n                        }\n                }\n        }\n        return nextArray;\n}\n```\n\n从上述代码可以看出代码重复判断 $j==0$ 的情况，如果可以统一处理可以使得代码更加简洁，这便需要用到前面提到过的 $next[0]$，如何设置该值呢？观察代码，我们可以发现当 $j==0$是有两种情况，一种是此时 $i,j$ 对应的字符相等，此时 $next[i+1]=j+1=0+1=1$，当不等时 $next[i+1]=0=-1+1$，如果我们让 $j==0$ 和字符不等时将 $j$ 置为 $-1$，结合上述思路修改代码如下：\n\n```cpp\n#include <vector>\n#include <string>\nusing std::vector;\nusing std::string;\n\nvector<int> CalculateNextArrayImprove(string patternString)\n{\n        vector<int> nextArray(patternString.size(), -1);\n        if (patternString.size() <= 1) {\n                return nextArray;\n        }\n\n        nextArray[0] = -1; /*第0个赋为-1*/\n        int i = 0, j = 0;\n        for ( ; i < int(patternString.size()) - 1; i++) {\n                j = i; /*获取真前缀下一个下标*/\n                while (1) {\n                        j = nextArray[j];\n                        if (j == -1 || patternString[i] == patternString[j]) {\n                                nextArray[i+1] = j + 1; break;\n                        }\n                }\n        }\n        return nextArray;\n}\n```\n\n上述代码是否还可以进一步优化呢？观察代码我们可以发现每次 $j$ 都重置为 $j=i$，然后才进行迭代查找，实际在一次计算完毕后 $j$ 已经保存了下一轮计算所需的结果，因此可做进一步优化，代码如下：\n\n```cpp\n#include <vector>\n#include <string>\nusing std::vector;\nusing std::string;\n\nvector<int> CalculateNextArrayUltimate(string patternString)\n{\n        vector<int> nextArray(patternString.size(), -1);\n        if (patternString.size() <= 1) {\n                return nextArray;\n        }\n\n        nextArray[0] = -1; /*第0个赋为-1*/\n        int i = 0, j = -1;\n        for ( ; i < int(patternString.size()) - 1; i++) {\n                while (1) {\n                        if (j == -1 || patternString[i] == patternString[j]) {\n                                j += 1;\n                                nextArray[i+1] = j; break;\n                        }\n                        j = nextArray[j];\n                }\n        }\n        return nextArray;\n}\n```\n\n上述代码只是优化掉了一行赋值代码，实际上上面代码依旧可以进行优化，考虑如下图一种情况：\n\n![KMP不等](/images/kmp-next-array-improve.png)\n\n在第 $2,3,5,6,7,8,10,11$ 个字符一旦失配后，如果 $j$ 回溯到 $next[j]$ 时依旧会失效，因为这两个下标的字符是一样的，因此如果在发现第 $j$ 与第 $next[j]$ 字符相等时，可以接着往前回溯，直到不相等。由于递推是从前往后，因此我们只需把值赋为上一个值即可，优化代码如下：\n\n```cpp\n#include <vector>\n#include <string>\nusing std::vector;\nusing std::string;\n\nvector<int> CalculateNextArrayUltimateImprove(string patternString)\n{\n        vector<int> nextArray(patternString.size(), -1);\n        if (patternString.size() <= 1) {\n                return nextArray;\n        }\n\n        nextArray[0] = -1; /*第0个赋为-1*/\n        int i = 0, j = -1;\n        for ( ; i < int(patternString.size()) - 1; i++) {\n                while (1) {\n                        if (j == -1 || patternString[i] == patternString[j]) {\n                                j += 1;\n                                if (patternString[j] == patternString[i+1]) {\n                                        nextArray[i+1] = nextArray[j];\n                                }\n                                else {\n                                        nextArray[i+1] = j;\n                                }\n                                break;\n                        }\n                        j = nextArray[j];\n                }\n        }\n        return nextArray;\n}\n```\n\n### KMP算法实现\n\n既然KMP算法Next数组已经计算得到，则写出KMP模式匹配算法也是非常容易的，考虑 $next[0]=-1$，有如下模式匹配算法：\n\n```cpp\n#include <string>\nusing std::string;\n\nint KMP(string mainString, string patternString, size_t startPos)\n{\n        vector<int> nextArray = CalculateNextArrayUltimate(patternString);\n        int i = startPos, j = 0;\n        for ( ; i < int(mainString.size()) && j < int(patternString.size()); ) {\n                /*相等i，j均向前推，j==-1表明不存在真前缀真后缀相等，i，j也往前推*/\n                if (j == -1 || mainString[i] == patternString[j]) {\n                        ++j; ++i;\n                }\n                else {\n                        j = nextArray[j];\n                }\n        }\n\n        if (j >= int(patternString.size())) {\n                return i - j; /*返回起始位置*/\n        }\n        else {\n                return -1;\n        }\n}\n```\n\n## 算法测试\n\n### Next数组计算代码测试\n\n使用多个案例测试Next数组计算代码，测试代码如下：\n\n```cpp\n#include <vector>\n#include <string>\n#include <iostream>\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\n\nint main()\n{\n        /*问号代表值未确定*/\n        string testStrings[] = {\"ababcabababc\", /*?,0,0,1,2,0,1,2,3,4,3,4*/\n                                \"ababaaababaa\", /*?,0,0,1,2,3,1,1,2,3,4,5*/\n                                \"babababaa\",    /*?,0,0,1,2,3,4,5,6*/\n                                \"aaab\",         /*?,0,1,2*/\n                               };\n\n        vector<vector<int>> correct = {\n                                       {-1,0,0,1,2,0,1,2,3,4,3,4},\n                                       {-1,0,0,1,2,3,1,1,2,3,4,5},\n                                       {-1,0,0,1,2,3,4,5,6},\n                                       {-1,0,1,2}\n                                      };\n\n        for (size_t i = 0; i < sizeof(testStrings)/sizeof(testStrings[0]); i++) {\n                /*调用具体的函数*/\n                vector<int> result = CalculateNextArray(testStrings[i]);\n\n                cout << (result == correct[i] ? \"Correct\" : \"Wrong\") << endl;\n        }\n\n        return 0;\n}\n```\n\n### KMP算法测试\n\nKMP算法测试代码如下所示：\n\n```cpp\n#include <vector>\n#include <string>\n#include <iostream>\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\n\nint main()\n{\n        /*第一个主串，第二个模式串*/\n        vector<vector<string>> testStrings = {\n                                              {\"ababcabcaabcbaabc\", \"ababcabababc\"},\n                                              {\"ababcabcaabcbaabc\", \"cabc\"},\n                                              {\"HA\", \"HAHAHA\"},\n                                              {\"WQN\", \"WQN\"},\n                                              {\"ADDAADAADDAAADAAD\", \"DAD\"},\n                                              {\"BABABABABABABABABB\", \"BABABB\"},\n                                             };\n        vector<int> correct = {-1,\n                                4,\n                               -1,\n                                0,\n                               -1,\n                               12\n                               };\n\n        for (size_t i = 0; i < testStrings.size(); i++) {\n                /*调用具体的函数*/\n                int result = KMP(testStrings[i][0], testStrings[i][1], 0);\n\n                cout << (result == correct[i] ? \"Correct\" : \"Wrong\") << endl;\n        }\n\n        return 0;\n}\n```\n\n\n\n## 参考资料\n\n[字符串](https://zh.wikipedia.org/zh-hans/%E5%AD%97%E7%AC%A6%E4%B8%B2)\n\n[子串](https://zh.wikipedia.org/zh-hans/子串)\n\n[字符串模式匹配算法](http://dsqiu.iteye.com/blog/1700312)\n\n[克努斯-莫里斯-普拉特算法](https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95)\n\n[数据结构](https://book.douban.com/subject/2024655/)\n","slug":"算法设计/字符串模式匹配及KMP算法分析与实现","published":1,"updated":"2018-06-23T08:14:31.885Z","_id":"cjir36zn20000sovngsh6h7ho","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"字符串基础知识\"><a href=\"#字符串基础知识\" class=\"headerlink\" title=\"字符串基础知识\"></a>字符串基础知识</h2><p>根据相关资料，字符串定义如下：字符串是由零个或者多个字符组成的有限序列，其中零个字符的串称为空串。字符串的主要存储方式有定长顺序存储（对应于C/C++中栈空间）、堆分配存储（动态申请内存）以及块链存储（链表节点为一个定长小块，多个小块依次组成一个实际串）。</p>\n<p>字符串模式匹配是指给定两个串$S_1,S_2$，要求找出串$S_1$中与串$S_2$相等的子串。目前模式匹配算法思路主要有朴素模式匹配算法、KMP算法等（更多的算法可见参考资料）。本文依次分析实现两种算法。</p>\n<h2 id=\"朴素模式匹配算法\"><a href=\"#朴素模式匹配算法\" class=\"headerlink\" title=\"朴素模式匹配算法\"></a>朴素模式匹配算法</h2><p>朴素模式匹配算法是最简单最容易想到的算法，也是最暴力的算法。其基本思路是对于主串$S_1$与模式串$S_2$分别设置两个下标 $i,j$。假设主串比较的起始位置为$startPos$，则置$i=startPos,j=0$，依次比较从 $i$ 和从 $j$ 下标开始的字符序列是否相等，如果比较到模式串最后一个位置相等则返回找到的结果，否则将 $i$ 置为上次起始位置的下一个下标（$i=startPos+1$），$j$ 置为模式字符串起始位置（$j=0$）。具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BrutePatternMatch</span><span class=\"params\">(<span class=\"built_in\">string</span> mainString, <span class=\"built_in\">string</span> patternString, <span class=\"keyword\">size_t</span> startPos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> i = startPos, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; mainString.size() &amp;&amp; j &lt; patternString.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mainString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                        ++i; ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        startPos += <span class=\"number\">1</span>;</span><br><span class=\"line\">                        i = startPos; j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &gt;= patternString.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">int</span>(startPos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上朴素的字符串模式匹配算法可以做进一步优化，比如 $i$ 定位到的位置必须保证剩下的子串长度大于等于模式串的长度。</p>\n<h2 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h2><h3 id=\"KMP算法基本原理\"><a href=\"#KMP算法基本原理\" class=\"headerlink\" title=\"KMP算法基本原理\"></a>KMP算法基本原理</h3><p>观察朴素模式匹配算法，每次失配后会导致下标 $i,j$ 均发生回溯，使模式串起始位置（$j=0$）对齐到主串的$startPos+1$位置重新开始下一轮比较。但是我们在 $i,j$ 发生失配时是已知$[0,(j-1)]$与$[i-j,i-1]$之间的字符串是相等，如果我们能找到这部分相等字符子串的某些规律使得我们在对齐主串与模式串的下一轮比较起始位置时能够使 $i$ 尽量多跳几步（即$i=startPos+k,k&gt;1$）甚至使得 $i$ 不发生回溯，那么便可以优化算法的时间复杂度了。根据这种思路得到的算法就是KMP算法了，KMP算法是由D.E.Knuth、J.H.Morris和V.R.Pratt共同发现的，取名字的首字母便得到KMP算法简称。假设主串长度为n模式串长度为m则该算法的时间复杂度为$O(n+m)$。空间复杂度由于增加一个 next 数组为$O(m)$。</p>\n<p>如下图为一张KMP算法说明图：</p>\n<p><img src=\"/images/kmp-algorithm-pattern.png\" alt=\"KMP\"></p>\n<p>红框内为第一次发生失配的的字符，蓝框为已经匹配相等的子串。如果按照朴素模式匹配算法，则此时对齐位置如下图所示：</p>\n<p><img src=\"/images/brute-pattern-algorithm-step.png\" alt=\"KMP\"></p>\n<p>此时显然依旧会发生失配，需要再次将模式串往后移以对齐。但是如果保持 $i$ 不移动，一直移动模式串使得可以再次启动从 $i$ 开始的比较，则会得到如下图所示的对齐位置：</p>\n<p><img src=\"/images/kmp-algorithm-step.png\" alt=\"KMP\"></p>\n<p>如上图所示，我们字符串可以直接开始从 $i$ 启动下一轮比较，此时 $i$ 没有发生回溯，只是 $j$ 发生回溯以对齐比较位置。如果我们希望能够一次就可以使得对齐位置移动到如上图所示的位置该如何处理呢？这便是$next$数组需要完成的工作了。比如上述匹配失配发生在$j=7$的位置，如果此时我们令$next[7]=2$，则我们可以当第 7 号（下标从 0 开始）元素发生失配时直接将 $j$ 的值置为$j=next[j]$便可以完成不回溯 $i$ 的情况下一次性对齐主串和模式串使得下一轮比较可以从当前失配 $i$ 开始。以上便是KMP算法的基本思路了，剩下的就是如何得到这个$next$数组了。</p>\n<h3 id=\"KMP算法Next数组计算\"><a href=\"#KMP算法Next数组计算\" class=\"headerlink\" title=\"KMP算法Next数组计算\"></a>KMP算法Next数组计算</h3><p>在移动模式串对齐主串的过程中，我们先只观察已经匹配的部分，如下图红框内的字符字串所示：</p>\n<p><img src=\"/images/kmp-algorithm-next.png\" alt=\"KMP\"></p>\n<p>我们可以看到在逐步滑动模式串时，会比较主串中已匹配字符子串（图中$ababcab$）的真后缀部分与模式串中已匹配字符子串（和主串中一样）的真前缀部分，我们在滑动过程中发现真前缀和真后缀相等时下标 $i$ 会再次指向上次失配的位置（即图中红框外字符 $c$），如果滑动使得真前缀真后缀不相等会导致 $i$ 回溯至当前失配的前方且必定导致模式串继续向前滑动直到找到一个真前缀与真后缀相等的位置，此时从失配位置（图中红框外字符 $c$）继续比较。如果此时 $i,j$ 对应的字符相等则比较下一个，如果不等则可以重复上述步骤，只是现在已匹配字符子串发生变化（图中在比较主串红框外c再次发生失配，此时已匹配子串为 $ab$）。</p>\n<p>通过上述的分析我们可以得知 $next$ 数组的含义是在某个字符上发生失配后已匹配部分字符串的真前缀和真后缀部分最长相等长度（由于下标从0开始，最长是因为在模式串滑动时找到第一个真前缀真后缀相等部分是最长的）。以上是基本的 $next$ 数组含义。接下来就是具体如何计算该数组了。</p>\n<p>根据上述分析，$next$ 数组是已匹配字符部分的最大前后缀相等（不包含自身）长度，因此最朴素的想法是针对模式串中的每一段字符分别暴力求解最长前后缀相等长度，但此时时间复杂度过高,可能高达$O(m^3)$。如果我们仔细分析问题会发现求最长前后缀长度也是一个模式匹配问题，只不过此时主串与模式串均为同一个字符串且从主串的第1个字符（下标从0开始）开始匹配。如下图是一个模式串的 $next$ 数组：</p>\n<p><img src=\"/images/kmp-next-array.png\" alt=\"KMP\"></p>\n<p>如上图所示，我们依次分析。以 $i,j$ 代表主串和模式串下标。当 $j=0$ 发生失配时，此时已匹配长度为0，因此不应发生回溯而是 $i$ 向前走一步，但在实际编程中为了统一处理需要特殊处理这种情况，因此此处暂时使用问号，后期表明如何设置一个特殊值以方便编程；当 $j=1$ 发生失配时，此时已匹配长度为1，滑动一步即可开始比较，即从头开始比较，此时 $next[1] = 0$；当 $k=j+1$ 时，此时已知 $next[j]$ , 即 $[0, next[j])$ 和 $[j-next[j],j)$之间的字符串相等，如果当模式串的第 $next[j]$ 个字符与第 $j$ 个字符相等时，可推知 $[0, next[j]]$ 和  $[j-next[j],j]$ 之间的字符串相等，可得到 $next[k]=next[j]+1$，如果不等，如下图所示：</p>\n<p><img src=\"/images/kmp-next-not-equal.png\" alt=\"KMP不等\"></p>\n<p>此时只能在该区间缩小范围继续查找，从而有缩小区间真前缀串必定是 $[0, next[j])$ 串的真前缀，上图所示第 $next[j]=4$ 个字符不等于第 $j=9$ 个字符，在缩小范围时需要保证  $[0, nextIndex)$ 与  $[j-nextIndex,j)$ 之间的字符串依旧保持相等(其中$nextIndex &lt; next[j]$)，否则此时比较第 $nextIndex$ 个字符与第 $j$ 个字符已经失去意义。而两个区间的字符串又分别是 $[0, next[j])$ 字符串的真前缀真后缀，此时回到了求某个字符串的最长相等真前缀真后缀问题，这在上一步已经解决了，即本问题是一个递推问题，此时 $nextIndex=next[next[j]]$，即反复递推，最后递推到找到满足相等条件或者递推结束。根据上述思路可以得到计算 $next$ 数组的代码。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; CalculateNextArray(<span class=\"built_in\">string</span> patternString)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray(patternString.size(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patternString.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextArray[<span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"comment\">/*只有一个匹配的字符子串真前缀真后缀均为空*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(patternString.size()) - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                j = nextArray[i]; <span class=\"comment\">/*获取真前缀下一个下标*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                        nextArray[i+<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                nextArray[i+<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                        j = nextArray[j];</span><br><span class=\"line\">                                        <span class=\"keyword\">if</span> (j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                                <span class=\"keyword\">if</span> (patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                                                        nextArray[i+<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                                                &#125;</span><br><span class=\"line\">                                                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                                        nextArray[i+<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                                                &#125;</span><br><span class=\"line\">                                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (patternString[i] == patternString[j])&#123;</span><br><span class=\"line\">                                                nextArray[i+<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上述代码可以看出代码重复判断 $j==0$ 的情况，如果可以统一处理可以使得代码更加简洁，这便需要用到前面提到过的 $next[0]$，如何设置该值呢？观察代码，我们可以发现当 $j==0$是有两种情况，一种是此时 $i,j$ 对应的字符相等，此时 $next[i+1]=j+1=0+1=1$，当不等时 $next[i+1]=0=-1+1$，如果我们让 $j==0$ 和字符不等时将 $j$ 置为 $-1$，结合上述思路修改代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; CalculateNextArrayImprove(<span class=\"built_in\">string</span> patternString)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray(patternString.size(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patternString.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nextArray[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>; <span class=\"comment\">/*第0个赋为-1*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(patternString.size()) - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                j = i; <span class=\"comment\">/*获取真前缀下一个下标*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        j = nextArray[j];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                                nextArray[i+<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是否还可以进一步优化呢？观察代码我们可以发现每次 $j$ 都重置为 $j=i$，然后才进行迭代查找，实际在一次计算完毕后 $j$ 已经保存了下一轮计算所需的结果，因此可做进一步优化，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; CalculateNextArrayUltimate(<span class=\"built_in\">string</span> patternString)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray(patternString.size(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patternString.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nextArray[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>; <span class=\"comment\">/*第0个赋为-1*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(patternString.size()) - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                                j += <span class=\"number\">1</span>;</span><br><span class=\"line\">                                nextArray[i+<span class=\"number\">1</span>] = j; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        j = nextArray[j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码只是优化掉了一行赋值代码，实际上上面代码依旧可以进行优化，考虑如下图一种情况：</p>\n<p><img src=\"/images/kmp-next-array-improve.png\" alt=\"KMP不等\"></p>\n<p>在第 $2,3,5,6,7,8,10,11$ 个字符一旦失配后，如果 $j$ 回溯到 $next[j]$ 时依旧会失效，因为这两个下标的字符是一样的，因此如果在发现第 $j$ 与第 $next[j]$ 字符相等时，可以接着往前回溯，直到不相等。由于递推是从前往后，因此我们只需把值赋为上一个值即可，优化代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; CalculateNextArrayUltimateImprove(<span class=\"built_in\">string</span> patternString)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray(patternString.size(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patternString.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nextArray[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>; <span class=\"comment\">/*第0个赋为-1*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(patternString.size()) - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                                j += <span class=\"number\">1</span>;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (patternString[j] == patternString[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                                        nextArray[i+<span class=\"number\">1</span>] = nextArray[j];</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        nextArray[i+<span class=\"number\">1</span>] = j;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        j = nextArray[j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"KMP算法实现\"><a href=\"#KMP算法实现\" class=\"headerlink\" title=\"KMP算法实现\"></a>KMP算法实现</h3><p>既然KMP算法Next数组已经计算得到，则写出KMP模式匹配算法也是非常容易的，考虑 $next[0]=-1$，有如下模式匹配算法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(<span class=\"built_in\">string</span> mainString, <span class=\"built_in\">string</span> patternString, <span class=\"keyword\">size_t</span> startPos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray = CalculateNextArrayUltimate(patternString);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = startPos, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(mainString.size()) &amp;&amp; j &lt; <span class=\"keyword\">int</span>(patternString.size()); ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*相等i，j均向前推，j==-1表明不存在真前缀真后缀相等，i，j也往前推*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || mainString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                        ++j; ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        j = nextArray[j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &gt;= <span class=\"keyword\">int</span>(patternString.size())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i - j; <span class=\"comment\">/*返回起始位置*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"算法测试\"><a href=\"#算法测试\" class=\"headerlink\" title=\"算法测试\"></a>算法测试</h2><h3 id=\"Next数组计算代码测试\"><a href=\"#Next数组计算代码测试\" class=\"headerlink\" title=\"Next数组计算代码测试\"></a>Next数组计算代码测试</h3><p>使用多个案例测试Next数组计算代码，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*问号代表值未确定*/</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> testStrings[] = &#123;<span class=\"string\">\"ababcabababc\"</span>, <span class=\"comment\">/*?,0,0,1,2,0,1,2,3,4,3,4*/</span></span><br><span class=\"line\">                                <span class=\"string\">\"ababaaababaa\"</span>, <span class=\"comment\">/*?,0,0,1,2,3,1,1,2,3,4,5*/</span></span><br><span class=\"line\">                                <span class=\"string\">\"babababaa\"</span>,    <span class=\"comment\">/*?,0,0,1,2,3,4,5,6*/</span></span><br><span class=\"line\">                                <span class=\"string\">\"aaab\"</span>,         <span class=\"comment\">/*?,0,1,2*/</span></span><br><span class=\"line\">                               &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; correct = &#123;</span><br><span class=\"line\">                                       &#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;,</span><br><span class=\"line\">                                       &#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">                                       &#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">                                       &#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">                                      &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(testStrings)/<span class=\"keyword\">sizeof</span>(testStrings[<span class=\"number\">0</span>]); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*调用具体的函数*/</span></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result = CalculateNextArray(testStrings[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; (result == correct[i] ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"KMP算法测试\"><a href=\"#KMP算法测试\" class=\"headerlink\" title=\"KMP算法测试\"></a>KMP算法测试</h3><p>KMP算法测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*第一个主串，第二个模式串*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; testStrings = &#123;</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"ababcabcaabcbaabc\"</span>, <span class=\"string\">\"ababcabababc\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"ababcabcaabcbaabc\"</span>, <span class=\"string\">\"cabc\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"HA\"</span>, <span class=\"string\">\"HAHAHA\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"WQN\"</span>, <span class=\"string\">\"WQN\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"ADDAADAADDAAADAAD\"</span>, <span class=\"string\">\"DAD\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"BABABABABABABABABB\"</span>, <span class=\"string\">\"BABABB\"</span>&#125;,</span><br><span class=\"line\">                                             &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; correct = &#123;<span class=\"number\">-1</span>,</span><br><span class=\"line\">                                <span class=\"number\">4</span>,</span><br><span class=\"line\">                               <span class=\"number\">-1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0</span>,</span><br><span class=\"line\">                               <span class=\"number\">-1</span>,</span><br><span class=\"line\">                               <span class=\"number\">12</span></span><br><span class=\"line\">                               &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; testStrings.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*调用具体的函数*/</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> result = KMP(testStrings[i][<span class=\"number\">0</span>], testStrings[i][<span class=\"number\">1</span>], <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; (result == correct[i] ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/zh-hans/%E5%AD%97%E7%AC%A6%E4%B8%B2\" target=\"_blank\" rel=\"noopener\">字符串</a></p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/子串\" target=\"_blank\" rel=\"noopener\">子串</a></p>\n<p><a href=\"http://dsqiu.iteye.com/blog/1700312\" target=\"_blank\" rel=\"noopener\">字符串模式匹配算法</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">克努斯-莫里斯-普拉特算法</a></p>\n<p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"字符串基础知识\"><a href=\"#字符串基础知识\" class=\"headerlink\" title=\"字符串基础知识\"></a>字符串基础知识</h2><p>根据相关资料，字符串定义如下：字符串是由零个或者多个字符组成的有限序列，其中零个字符的串称为空串。字符串的主要存储方式有定长顺序存储（对应于C/C++中栈空间）、堆分配存储（动态申请内存）以及块链存储（链表节点为一个定长小块，多个小块依次组成一个实际串）。</p>\n<p>字符串模式匹配是指给定两个串$S_1,S_2$，要求找出串$S_1$中与串$S_2$相等的子串。目前模式匹配算法思路主要有朴素模式匹配算法、KMP算法等（更多的算法可见参考资料）。本文依次分析实现两种算法。</p>\n<h2 id=\"朴素模式匹配算法\"><a href=\"#朴素模式匹配算法\" class=\"headerlink\" title=\"朴素模式匹配算法\"></a>朴素模式匹配算法</h2><p>朴素模式匹配算法是最简单最容易想到的算法，也是最暴力的算法。其基本思路是对于主串$S_1$与模式串$S_2$分别设置两个下标 $i,j$。假设主串比较的起始位置为$startPos$，则置$i=startPos,j=0$，依次比较从 $i$ 和从 $j$ 下标开始的字符序列是否相等，如果比较到模式串最后一个位置相等则返回找到的结果，否则将 $i$ 置为上次起始位置的下一个下标（$i=startPos+1$），$j$ 置为模式字符串起始位置（$j=0$）。具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BrutePatternMatch</span><span class=\"params\">(<span class=\"built_in\">string</span> mainString, <span class=\"built_in\">string</span> patternString, <span class=\"keyword\">size_t</span> startPos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> i = startPos, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; mainString.size() &amp;&amp; j &lt; patternString.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mainString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                        ++i; ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        startPos += <span class=\"number\">1</span>;</span><br><span class=\"line\">                        i = startPos; j = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &gt;= patternString.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">int</span>(startPos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上朴素的字符串模式匹配算法可以做进一步优化，比如 $i$ 定位到的位置必须保证剩下的子串长度大于等于模式串的长度。</p>\n<h2 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h2><h3 id=\"KMP算法基本原理\"><a href=\"#KMP算法基本原理\" class=\"headerlink\" title=\"KMP算法基本原理\"></a>KMP算法基本原理</h3><p>观察朴素模式匹配算法，每次失配后会导致下标 $i,j$ 均发生回溯，使模式串起始位置（$j=0$）对齐到主串的$startPos+1$位置重新开始下一轮比较。但是我们在 $i,j$ 发生失配时是已知$[0,(j-1)]$与$[i-j,i-1]$之间的字符串是相等，如果我们能找到这部分相等字符子串的某些规律使得我们在对齐主串与模式串的下一轮比较起始位置时能够使 $i$ 尽量多跳几步（即$i=startPos+k,k&gt;1$）甚至使得 $i$ 不发生回溯，那么便可以优化算法的时间复杂度了。根据这种思路得到的算法就是KMP算法了，KMP算法是由D.E.Knuth、J.H.Morris和V.R.Pratt共同发现的，取名字的首字母便得到KMP算法简称。假设主串长度为n模式串长度为m则该算法的时间复杂度为$O(n+m)$。空间复杂度由于增加一个 next 数组为$O(m)$。</p>\n<p>如下图为一张KMP算法说明图：</p>\n<p><img src=\"/images/kmp-algorithm-pattern.png\" alt=\"KMP\"></p>\n<p>红框内为第一次发生失配的的字符，蓝框为已经匹配相等的子串。如果按照朴素模式匹配算法，则此时对齐位置如下图所示：</p>\n<p><img src=\"/images/brute-pattern-algorithm-step.png\" alt=\"KMP\"></p>\n<p>此时显然依旧会发生失配，需要再次将模式串往后移以对齐。但是如果保持 $i$ 不移动，一直移动模式串使得可以再次启动从 $i$ 开始的比较，则会得到如下图所示的对齐位置：</p>\n<p><img src=\"/images/kmp-algorithm-step.png\" alt=\"KMP\"></p>\n<p>如上图所示，我们字符串可以直接开始从 $i$ 启动下一轮比较，此时 $i$ 没有发生回溯，只是 $j$ 发生回溯以对齐比较位置。如果我们希望能够一次就可以使得对齐位置移动到如上图所示的位置该如何处理呢？这便是$next$数组需要完成的工作了。比如上述匹配失配发生在$j=7$的位置，如果此时我们令$next[7]=2$，则我们可以当第 7 号（下标从 0 开始）元素发生失配时直接将 $j$ 的值置为$j=next[j]$便可以完成不回溯 $i$ 的情况下一次性对齐主串和模式串使得下一轮比较可以从当前失配 $i$ 开始。以上便是KMP算法的基本思路了，剩下的就是如何得到这个$next$数组了。</p>\n<h3 id=\"KMP算法Next数组计算\"><a href=\"#KMP算法Next数组计算\" class=\"headerlink\" title=\"KMP算法Next数组计算\"></a>KMP算法Next数组计算</h3><p>在移动模式串对齐主串的过程中，我们先只观察已经匹配的部分，如下图红框内的字符字串所示：</p>\n<p><img src=\"/images/kmp-algorithm-next.png\" alt=\"KMP\"></p>\n<p>我们可以看到在逐步滑动模式串时，会比较主串中已匹配字符子串（图中$ababcab$）的真后缀部分与模式串中已匹配字符子串（和主串中一样）的真前缀部分，我们在滑动过程中发现真前缀和真后缀相等时下标 $i$ 会再次指向上次失配的位置（即图中红框外字符 $c$），如果滑动使得真前缀真后缀不相等会导致 $i$ 回溯至当前失配的前方且必定导致模式串继续向前滑动直到找到一个真前缀与真后缀相等的位置，此时从失配位置（图中红框外字符 $c$）继续比较。如果此时 $i,j$ 对应的字符相等则比较下一个，如果不等则可以重复上述步骤，只是现在已匹配字符子串发生变化（图中在比较主串红框外c再次发生失配，此时已匹配子串为 $ab$）。</p>\n<p>通过上述的分析我们可以得知 $next$ 数组的含义是在某个字符上发生失配后已匹配部分字符串的真前缀和真后缀部分最长相等长度（由于下标从0开始，最长是因为在模式串滑动时找到第一个真前缀真后缀相等部分是最长的）。以上是基本的 $next$ 数组含义。接下来就是具体如何计算该数组了。</p>\n<p>根据上述分析，$next$ 数组是已匹配字符部分的最大前后缀相等（不包含自身）长度，因此最朴素的想法是针对模式串中的每一段字符分别暴力求解最长前后缀相等长度，但此时时间复杂度过高,可能高达$O(m^3)$。如果我们仔细分析问题会发现求最长前后缀长度也是一个模式匹配问题，只不过此时主串与模式串均为同一个字符串且从主串的第1个字符（下标从0开始）开始匹配。如下图是一个模式串的 $next$ 数组：</p>\n<p><img src=\"/images/kmp-next-array.png\" alt=\"KMP\"></p>\n<p>如上图所示，我们依次分析。以 $i,j$ 代表主串和模式串下标。当 $j=0$ 发生失配时，此时已匹配长度为0，因此不应发生回溯而是 $i$ 向前走一步，但在实际编程中为了统一处理需要特殊处理这种情况，因此此处暂时使用问号，后期表明如何设置一个特殊值以方便编程；当 $j=1$ 发生失配时，此时已匹配长度为1，滑动一步即可开始比较，即从头开始比较，此时 $next[1] = 0$；当 $k=j+1$ 时，此时已知 $next[j]$ , 即 $[0, next[j])$ 和 $[j-next[j],j)$之间的字符串相等，如果当模式串的第 $next[j]$ 个字符与第 $j$ 个字符相等时，可推知 $[0, next[j]]$ 和  $[j-next[j],j]$ 之间的字符串相等，可得到 $next[k]=next[j]+1$，如果不等，如下图所示：</p>\n<p><img src=\"/images/kmp-next-not-equal.png\" alt=\"KMP不等\"></p>\n<p>此时只能在该区间缩小范围继续查找，从而有缩小区间真前缀串必定是 $[0, next[j])$ 串的真前缀，上图所示第 $next[j]=4$ 个字符不等于第 $j=9$ 个字符，在缩小范围时需要保证  $[0, nextIndex)$ 与  $[j-nextIndex,j)$ 之间的字符串依旧保持相等(其中$nextIndex &lt; next[j]$)，否则此时比较第 $nextIndex$ 个字符与第 $j$ 个字符已经失去意义。而两个区间的字符串又分别是 $[0, next[j])$ 字符串的真前缀真后缀，此时回到了求某个字符串的最长相等真前缀真后缀问题，这在上一步已经解决了，即本问题是一个递推问题，此时 $nextIndex=next[next[j]]$，即反复递推，最后递推到找到满足相等条件或者递推结束。根据上述思路可以得到计算 $next$ 数组的代码。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; CalculateNextArray(<span class=\"built_in\">string</span> patternString)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray(patternString.size(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patternString.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextArray[<span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"comment\">/*只有一个匹配的字符子串真前缀真后缀均为空*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(patternString.size()) - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                j = nextArray[i]; <span class=\"comment\">/*获取真前缀下一个下标*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                        nextArray[i+<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                nextArray[i+<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                        j = nextArray[j];</span><br><span class=\"line\">                                        <span class=\"keyword\">if</span> (j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                                <span class=\"keyword\">if</span> (patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                                                        nextArray[i+<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                                                &#125;</span><br><span class=\"line\">                                                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                                        nextArray[i+<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                                                &#125;</span><br><span class=\"line\">                                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (patternString[i] == patternString[j])&#123;</span><br><span class=\"line\">                                                nextArray[i+<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上述代码可以看出代码重复判断 $j==0$ 的情况，如果可以统一处理可以使得代码更加简洁，这便需要用到前面提到过的 $next[0]$，如何设置该值呢？观察代码，我们可以发现当 $j==0$是有两种情况，一种是此时 $i,j$ 对应的字符相等，此时 $next[i+1]=j+1=0+1=1$，当不等时 $next[i+1]=0=-1+1$，如果我们让 $j==0$ 和字符不等时将 $j$ 置为 $-1$，结合上述思路修改代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; CalculateNextArrayImprove(<span class=\"built_in\">string</span> patternString)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray(patternString.size(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patternString.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nextArray[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>; <span class=\"comment\">/*第0个赋为-1*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(patternString.size()) - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                j = i; <span class=\"comment\">/*获取真前缀下一个下标*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        j = nextArray[j];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                                nextArray[i+<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是否还可以进一步优化呢？观察代码我们可以发现每次 $j$ 都重置为 $j=i$，然后才进行迭代查找，实际在一次计算完毕后 $j$ 已经保存了下一轮计算所需的结果，因此可做进一步优化，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; CalculateNextArrayUltimate(<span class=\"built_in\">string</span> patternString)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray(patternString.size(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patternString.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nextArray[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>; <span class=\"comment\">/*第0个赋为-1*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(patternString.size()) - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                                j += <span class=\"number\">1</span>;</span><br><span class=\"line\">                                nextArray[i+<span class=\"number\">1</span>] = j; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        j = nextArray[j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码只是优化掉了一行赋值代码，实际上上面代码依旧可以进行优化，考虑如下图一种情况：</p>\n<p><img src=\"/images/kmp-next-array-improve.png\" alt=\"KMP不等\"></p>\n<p>在第 $2,3,5,6,7,8,10,11$ 个字符一旦失配后，如果 $j$ 回溯到 $next[j]$ 时依旧会失效，因为这两个下标的字符是一样的，因此如果在发现第 $j$ 与第 $next[j]$ 字符相等时，可以接着往前回溯，直到不相等。由于递推是从前往后，因此我们只需把值赋为上一个值即可，优化代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; CalculateNextArrayUltimateImprove(<span class=\"built_in\">string</span> patternString)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray(patternString.size(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patternString.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nextArray[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>; <span class=\"comment\">/*第0个赋为-1*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(patternString.size()) - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || patternString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                                j += <span class=\"number\">1</span>;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (patternString[j] == patternString[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                                        nextArray[i+<span class=\"number\">1</span>] = nextArray[j];</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        nextArray[i+<span class=\"number\">1</span>] = j;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        j = nextArray[j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"KMP算法实现\"><a href=\"#KMP算法实现\" class=\"headerlink\" title=\"KMP算法实现\"></a>KMP算法实现</h3><p>既然KMP算法Next数组已经计算得到，则写出KMP模式匹配算法也是非常容易的，考虑 $next[0]=-1$，有如下模式匹配算法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(<span class=\"built_in\">string</span> mainString, <span class=\"built_in\">string</span> patternString, <span class=\"keyword\">size_t</span> startPos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nextArray = CalculateNextArrayUltimate(patternString);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = startPos, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( ; i &lt; <span class=\"keyword\">int</span>(mainString.size()) &amp;&amp; j &lt; <span class=\"keyword\">int</span>(patternString.size()); ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*相等i，j均向前推，j==-1表明不存在真前缀真后缀相等，i，j也往前推*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || mainString[i] == patternString[j]) &#123;</span><br><span class=\"line\">                        ++j; ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        j = nextArray[j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &gt;= <span class=\"keyword\">int</span>(patternString.size())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i - j; <span class=\"comment\">/*返回起始位置*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"算法测试\"><a href=\"#算法测试\" class=\"headerlink\" title=\"算法测试\"></a>算法测试</h2><h3 id=\"Next数组计算代码测试\"><a href=\"#Next数组计算代码测试\" class=\"headerlink\" title=\"Next数组计算代码测试\"></a>Next数组计算代码测试</h3><p>使用多个案例测试Next数组计算代码，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*问号代表值未确定*/</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> testStrings[] = &#123;<span class=\"string\">\"ababcabababc\"</span>, <span class=\"comment\">/*?,0,0,1,2,0,1,2,3,4,3,4*/</span></span><br><span class=\"line\">                                <span class=\"string\">\"ababaaababaa\"</span>, <span class=\"comment\">/*?,0,0,1,2,3,1,1,2,3,4,5*/</span></span><br><span class=\"line\">                                <span class=\"string\">\"babababaa\"</span>,    <span class=\"comment\">/*?,0,0,1,2,3,4,5,6*/</span></span><br><span class=\"line\">                                <span class=\"string\">\"aaab\"</span>,         <span class=\"comment\">/*?,0,1,2*/</span></span><br><span class=\"line\">                               &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; correct = &#123;</span><br><span class=\"line\">                                       &#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;,</span><br><span class=\"line\">                                       &#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">                                       &#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">                                       &#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">                                      &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">sizeof</span>(testStrings)/<span class=\"keyword\">sizeof</span>(testStrings[<span class=\"number\">0</span>]); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*调用具体的函数*/</span></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result = CalculateNextArray(testStrings[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; (result == correct[i] ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"KMP算法测试\"><a href=\"#KMP算法测试\" class=\"headerlink\" title=\"KMP算法测试\"></a>KMP算法测试</h3><p>KMP算法测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*第一个主串，第二个模式串*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt; testStrings = &#123;</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"ababcabcaabcbaabc\"</span>, <span class=\"string\">\"ababcabababc\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"ababcabcaabcbaabc\"</span>, <span class=\"string\">\"cabc\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"HA\"</span>, <span class=\"string\">\"HAHAHA\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"WQN\"</span>, <span class=\"string\">\"WQN\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"ADDAADAADDAAADAAD\"</span>, <span class=\"string\">\"DAD\"</span>&#125;,</span><br><span class=\"line\">                                              &#123;<span class=\"string\">\"BABABABABABABABABB\"</span>, <span class=\"string\">\"BABABB\"</span>&#125;,</span><br><span class=\"line\">                                             &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; correct = &#123;<span class=\"number\">-1</span>,</span><br><span class=\"line\">                                <span class=\"number\">4</span>,</span><br><span class=\"line\">                               <span class=\"number\">-1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0</span>,</span><br><span class=\"line\">                               <span class=\"number\">-1</span>,</span><br><span class=\"line\">                               <span class=\"number\">12</span></span><br><span class=\"line\">                               &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; testStrings.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*调用具体的函数*/</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> result = KMP(testStrings[i][<span class=\"number\">0</span>], testStrings[i][<span class=\"number\">1</span>], <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; (result == correct[i] ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/zh-hans/%E5%AD%97%E7%AC%A6%E4%B8%B2\" target=\"_blank\" rel=\"noopener\">字符串</a></p>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/子串\" target=\"_blank\" rel=\"noopener\">子串</a></p>\n<p><a href=\"http://dsqiu.iteye.com/blog/1700312\" target=\"_blank\" rel=\"noopener\">字符串模式匹配算法</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">克努斯-莫里斯-普拉特算法</a></p>\n<p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n"},{"title":"稀疏矩阵压缩存储之三元组","urlname":"sparse-matrix-triple-table","date":"2018-06-25T10:57:36.000Z","mathjax":true,"copyright":true,"_content":"\n## 基础知识\n\n在定义稀疏矩阵时，可以引入一个称为稀疏因子的数，其定义如下：假设对于一个 $m\\*n$ 矩阵，其中有 $t$ 个元素不为 $0$， 则定义稀疏因子 $δ=t/(m*n)$，一般认为 $δ<=0.05$ 的矩阵为稀疏矩阵。稀疏矩阵如果采用二维数组直接存储将会导致大量的空间存储 $0$ 值，对于空间是一种极大的浪费，因此一般采用压缩存储，目前稀疏矩阵常用三元组顺序表和十字链表来存储，本文将实现采用三元组顺序表压缩稀疏矩阵并实现矩阵常用的操作。\n\n在实现三元组顺序表压缩存储稀疏矩阵之前，预先定义三元组节点结构如下：\n\n```cpp\ntemplate<typename DataType>\nstruct TripleAtom\n{\n        int row;       /*行号*/\n        int col;       /*列号*/\n        DataType ele;  /*存放的数据*/\n};\n```\n\n需要是实现的矩阵基本运算主要有：\n\n- 矩阵转置：TransposeMatrix\n- 矩阵加法：AddMatrix\n- 矩阵减法：SubMatrix\n- 矩阵乘法：MultiMatrix\n- 打印矩阵：PrintMatrix\n\n## 三元组顺序表基本定义\n\n根据上述分析可定义如下基本ADT:\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate<typename DataType>\nclass TripleTable\n{\npublic:\n        TripleTable(vector<vector<DataType>> &inArray);\n        ~TripleTable();\n        void TransposeMatrix();         /*常规转置思路*/\n        void FastTransposeMatrix();     /*快速转置*/\n        void AddMatrix(TripleTable<DataType> &otherMatrix); /*加上另外一个矩阵，第二个矩阵保持不变*/\n        void SubMatrix(TripleTable<DataType> &otherMatrix); /*减去另外一个矩阵，第二个矩阵保持不变*/\n        void MultiMatrix(TripleTable<DataType> &otherMatrix); /*乘上另外一个矩阵，第二个矩阵保持不变*/\n        vector<vector<DataType>> TransformTo2DArray(); /*转换成二维数组*/\n        void PrintMatrix(); /*打印矩阵*/\nprivate:\n        void CalculateFirstNoneZeroArray(); /*计算每行第一个非零元素下标*/\nprivate:\n        vector<TripleAtom<DataType>> data; /*存储实际的矩阵数据，自包含非零元个数*/\n        int matrixRowNum; /*矩阵行数*/\n        int matrixColNum; /*矩阵列数*/\n        int *rowFirstNoneZeroPos; /*每行第一个非零元素的起始位置，方便乘法*/\n};\n```\n\n如上即为整个三元组顺序表的ADT基本结构，具体含义可见注释。接下来依次实现个函数。\n\n## 三元组顺序表ADT的实现\n\n- 构造函数\n\n构造函数主要将二维存储的稀疏矩阵转变为三元组形式存储的矩阵。\n\n```cpp\ntemplate<typename DataType>\nTripleTable<DataType>::TripleTable(vector<vector<DataType>> &inArray) : matrixRowNum(-1),\n                                matrixColNum(-1), rowFirstNoneZeroPos(nullptr)\n{\n        if (inArray.size() > 0 && inArray[0].size() > 0) {\n\n                matrixRowNum = int(inArray.size());\n                matrixColNum = int(inArray[0].size());\n\n                TripleAtom<DataType> tmpAtom;\n                for (int i = 0; i < int(inArray.size()); i++) {\n                        for (int j = 0; j < int(inArray[i].size()); j++) {\n                                if (inArray[i][j] != DataType(0)) {\n                                        tmpAtom.row = i+1; /*下标从1开始*/\n                                        tmpAtom.col = j+1; /*下标从1开始*/\n                                        tmpAtom.ele = inArray[i][j];\n                                        data.push_back(tmpAtom); /*压入*/\n                                }\n                        }\n                }\n\n                CalculateFirstNoneZeroArray();\n        }\n}\n```\n\n- 析构函数\n\n析构主要释放rowFirstNoneZeroPos申请的空间，实现如下所示：\n\n```cpp\ntemplate<typename DataType>\nTripleTable<DataType>::~TripleTable<DataType>()\n{\n        delete [] rowFirstNoneZeroPos;\n        rowFirstNoneZeroPos = nullptr;\n        matrixRowNum = -1; matrixColNum = -1;\n}\n```\n\n- 常规矩阵转置\n\n由于三元组顺序表的存储顺序是行优先依次存储，而转置后的三元组行号变成列号，原始行号有序使得转置后的列号有序，因此原始三元组转置后的一行中的列相对顺序是正确的。故此有如下代码：\n\n```cpp\n#include <algorithm>\nusing std::swap;\n\ntemplate<typename DataType>\nvoid TripleTable<DataType>::TransposeMatrix()\n{\n        TripleAtom<DataType> tmpAtom;\n        vector<TripleAtom<DataType>> newMatrix;\n        for (int i = 1; i <= matrixColNum; i++) {\n                for (size_t j = 0; j < data.size(); j++) {\n                        if (data[j].col == i) {\n                                tmpAtom.row = data[j].col;\n                                tmpAtom.col = data[j].row;\n                                tmpAtom.ele = data[j].ele;\n                                newMatrix.push_back(tmpAtom); /*压入*/\n                        }\n                }\n        }\n\n        data.assign(newMatrix.begin(), newMatrix.end()); /*转置后的矩阵*/\n        swap(matrixRowNum, matrixColNum);\n\n        CalculateFirstNoneZeroArray();\n}\n```\n\n- 快速矩阵转置\n\n由于在常规转置中，我们需要一行一行来处理，如果每遍历到一个三元组便知道该元素放入的位置，那么可以极大降低时间复杂度，此时我们需要计算一个转置后每行起始的位置，然后在遍历过程中可以快速填写三元组顺序表，具体实现代码如下所示：\n\n```cpp\n#include <algorithm>\nusing std::swap;\n\ntemplate<typename DataType>\nvoid TripleTable<DataType>::FastTransposeMatrix()\n{\n        if (matrixRowNum <= 0 || matrixColNum <= 0) {\n                return;\n        }\n\n        int *colNum = new int[matrixColNum]; /*每列非零元素数量*/\n        int *colIndex = new int[matrixColNum]; /*每列第一个非零元素起始下标*/\n\n        for (int i = 0; i < matrixColNum; i++) {\n                colNum[i] = colIndex[0] = 0;\n        }\n\n        for (size_t i = 0; i < data.size(); i++) {\n                ++colNum[data[i].col - 1];\n        }\n\n        for (int i = 1; i < matrixColNum; i++) {\n                /*计算每一列第一个非零元素下标*/\n                colIndex[i] = colIndex[i-1] + colNum[i-1];\n        }\n\n        vector<TripleAtom<DataType>> newMatrix(data.size());\n        TripleAtom<DataType> tmpAtom;\n        for (size_t i = 0; i < data.size(); i++) {\n\n                tmpAtom.row = data[i].col;\n                tmpAtom.col = data[i].row;\n                tmpAtom.ele = data[i].ele;\n\n                newMatrix[colIndex[tmpAtom.row-1]] = tmpAtom;\n                ++colIndex[tmpAtom.row-1]; /*矩阵下标从1开始*/\n        }\n\n        data.assign(newMatrix.begin(), newMatrix.end()); /*转置后的矩阵*/\n        swap(matrixRowNum, matrixColNum);\n\n        CalculateFirstNoneZeroArray();\n\n        delete [] colNum; delete [] colIndex;\n}\n```\n\n上述代码增加辅助空间后便将时间复杂度降低了一个量级。\n\n- 矩阵相加\n\n在进行矩阵加法，首先需要判断两个矩阵是否能够相加，接着使用双下标指针分别指向第一个矩阵和第二个矩阵，如果两个指向的行列号相等只需直接相加，否则需要判断行列号大小，具体实现代码如下：\n\n```cpp\ntemplate<typename DataType>\nvoid TripleTable<DataType>::AddMatrix(TripleTable<DataType> &otherMatrix)\n{\n        if (matrixRowNum != otherMatrix.matrixRowNum || matrixColNum != otherMatrix.matrixColNum) {\n                return;\n        }\n\n        vector<TripleAtom<DataType>> newMatrix;\n        TripleAtom<DataType> tmpAtom;\n\n        size_t i = 0, j = 0;\n\n        while (i < data.size() && j < otherMatrix.data.size()) {\n                if (data[i].row < otherMatrix.data[j].row) {\n                        newMatrix.push_back(data[i]); ++i;\n                }\n                else if (data[i].row > otherMatrix.data[j].row) {\n                        newMatrix.push_back(otherMatrix.data[j]); ++j;\n                }\n                else if (data[i].col < otherMatrix.data[j].col) {\n                        newMatrix.push_back(data[i]); ++i;\n                }\n                else if (data[i].col > otherMatrix.data[j].col) {\n                        newMatrix.push_back(otherMatrix.data[j]); ++j;\n                }\n                else {\n                        tmpAtom.row = data[i].row;\n                        tmpAtom.col = data[i].col;\n                        tmpAtom.ele = data[i].ele + otherMatrix.data[j].ele;\n                        newMatrix.push_back(tmpAtom);\n                        ++i; ++j;\n                }\n        }\n\n        while (i < data.size()) {\n                newMatrix.push_back(data[i]); ++i;\n        }\n\n        while (j < otherMatrix.data.size()) {\n                newMatrix.push_back(otherMatrix.data[j]); ++j;\n        }\n\n        data.assign(newMatrix.begin(), newMatrix.end()); /*相加后的矩阵*/\n\n        CalculateFirstNoneZeroArray(); /*重新计算*/\n}\n```\n\n- 矩阵减法\n\n矩阵减法和矩阵加法类似，具体代码如下所示：\n\n```cpp\ntemplate<typename DataType>\nvoid TripleTable<DataType>::SubMatrix(TripleTable<DataType> &otherMatrix)\n{\n        if (matrixRowNum != otherMatrix.matrixRowNum || matrixColNum != otherMatrix.matrixColNum) {\n                return;\n        }\n\n        vector<TripleAtom<DataType>> newMatrix;\n        TripleAtom<DataType> tmpAtom;\n\n        size_t i = 0, j = 0;\n\n        while (i < data.size() && j < otherMatrix.data.size()) {\n                if (data[i].row < otherMatrix.data[j].row) {\n                        newMatrix.push_back(data[i]); ++i;\n                }\n                else if (data[i].row > otherMatrix.data[j].row) {\n                        tmpAtom.row = otherMatrix.data[j].row;\n                        tmpAtom.col = otherMatrix.data[j].col;\n                        tmpAtom.ele = -otherMatrix.data[j].ele;\n                        newMatrix.push_back(tmpAtom); ++j;\n                }\n                else if (data[i].col < otherMatrix.data[j].col) {\n                        newMatrix.push_back(data[i]); ++i;\n                }\n                else if (data[i].col > otherMatrix.data[j].col) {\n                        tmpAtom.row = otherMatrix.data[j].row;\n                        tmpAtom.col = otherMatrix.data[j].col;\n                        tmpAtom.ele = -otherMatrix.data[j].ele;\n                        newMatrix.push_back(tmpAtom); ++j;\n                }\n                else {\n                        tmpAtom.row = data[i].row;\n                        tmpAtom.col = data[i].col;\n                        tmpAtom.ele = data[i].ele - otherMatrix.data[j].ele;\n                        newMatrix.push_back(tmpAtom);\n                        ++i; ++j;\n                }\n        }\n\n        while (i < data.size()) {\n                newMatrix.push_back(data[i]); ++i;\n        }\n\n        while (j < otherMatrix.data.size()) {\n                tmpAtom.row = otherMatrix.data[j].row;\n                tmpAtom.col = otherMatrix.data[j].col;\n                tmpAtom.ele = -otherMatrix.data[j].ele;\n                newMatrix.push_back(tmpAtom); ++j;\n        }\n\n        data.assign(newMatrix.begin(), newMatrix.end()); /*相减后的矩阵*/\n\n        CalculateFirstNoneZeroArray(); /*重新计算*/\n}\n```\n\n- 矩阵乘法\n\n矩阵乘法相对而言比较复杂，矩阵乘法如果偷懒可以先解压缩然后使用常规乘法进行计算最后再把结果进行压缩，但这样就不能体现三元组的作用了，因此需要找出一种可以直接在三元组上进行计算的乘法算法。考虑到矩阵乘法的实质是从第一个矩阵抽出一个行向量和从第二个矩阵抽出一个列向量并做向量的点乘，其中行、列号分别对应在结果矩阵中的行、列号，综合上述分析我们可以一行一行处理，其首先也需要判断运算是否合法，具体代码如下所示：\n\n```cpp\ntemplate<typename DataType>\nvoid TripleTable<DataType>::MultiMatrix(TripleTable<DataType> &otherMatrix)\n{\n        if (matrixColNum != otherMatrix.matrixRowNum) {\n                return;\n        }\n        if (data.size() <= 0 || otherMatrix.data.size() <= 0) {\n                /*如果有全零矩阵则相乘结果也是一个全零矩阵*/\n                data.clear(); return;\n        }\n\n        DataType *tmpAccumulate = new int[otherMatrix.matrixColNum]; /*记录每行各列的累加和*/\n\n        vector<TripleAtom<DataType>> newMatrix;\n        /*一行一行处理*/\n        for (int i = 0; i < matrixRowNum; i++) {\n                for (int j = 0; j < otherMatrix.matrixColNum; j++) {\n                        tmpAccumulate[j] = DataType(0); /*清空累加器*/\n                }\n\n                /*行开始的地方*/\n                int rowBegin = rowFirstNoneZeroPos[i];\n                /*行结束的地方*/\n                int rowEnd = i >= matrixRowNum-1 ? int(data.size()) : rowFirstNoneZeroPos[i+1];\n\n                for (int j = rowBegin; j < rowEnd; j++) {\n                        /*(m,n)*(n,k)矩阵的行,列对应下标相等才乘*/\n                        int middleIndex = data[j].col - 1;\n                        int anotherRowBegin = otherMatrix.rowFirstNoneZeroPos[middleIndex];\n                        int anotherRowEnd = middleIndex >= otherMatrix.matrixRowNum-1 ? int(otherMatrix.data.size()) : otherMatrix.rowFirstNoneZeroPos[middleIndex+1];\n                        for (int k = anotherRowBegin; k < anotherRowEnd; k++) {\n                                tmpAccumulate[otherMatrix.data[k].col -1] += data[j].ele * otherMatrix.data[k].ele;\n                        }\n                }\n\n                /*逐行压缩*/\n                TripleAtom<DataType> tmpAtom;\n                for (int j = 0; j < otherMatrix.matrixColNum; j++) {\n                        if (tmpAccumulate[j] != DataType(0)) {\n                                tmpAtom.row = i+1; /*下标从1开始*/\n                                tmpAtom.col = j+1; /*下标从1开始*/\n                                tmpAtom.ele = tmpAccumulate[j];\n                                newMatrix.push_back(tmpAtom);\n                        }\n                }\n        }\n\n        /*修改列数*/\n        matrixColNum = otherMatrix.matrixColNum;\n        data.assign(newMatrix.begin(), newMatrix.end()); /*相乘后的矩阵*/\n\n        CalculateFirstNoneZeroArray(); /*重新计算*/\n\n        delete [] tmpAccumulate;\n}\n```\n\n- 压缩矩阵转成二维数组\n\n直接遍历即可，不存在意味着是零值。\n\n```cpp\ntemplate<typename DataType>\nvector<vector<DataType>> TripleTable<DataType>::TransformTo2DArray()\n{\n        vector<vector<DataType>> result(matrixRowNum, vector<DataType>(matrixColNum, DataType(0)));\n\n        for (size_t i = 0; i < data.size(); i++) {\n                result[data[i].row-1][data[i].col-1] = data[i].ele;\n        }\n\n        return result;\n}\n```\n\n- 打印矩阵\n\n先调用转二维函数然后直接打印即可，代码如下：\n\n```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\n\ntemplate<typename DataType>\nvoid TripleTable<DataType>::PrintMatrix()\n{\n        vector<vector<DataType>> result = TransformTo2DArray();\n\n        for (size_t i = 0; i < result.size(); i++) {\n                for (size_t j = 0; j < result[i].size(); j++) {\n                        cout << result[i][j] << \";\";\n                }\n                cout << endl;\n        }\n}\n```\n\n- 计算每行元素的第一个下标值\n\n这在快速矩阵转置中实现过类似的思路，直接把代码稍作修改即可，结果见下：\n\n```cpp\ntemplate<typename DataType>\nvoid TripleTable<DataType>::CalculateFirstNoneZeroArray()\n{\n        if (rowFirstNoneZeroPos != nullptr) {\n                delete [] rowFirstNoneZeroPos;\n        }\n\n        /*正式给rowFirstNoneZeroPos申请空间*/\n        rowFirstNoneZeroPos = new int[matrixRowNum];\n\n        int *rowlNum = new int[matrixRowNum]; /*每列非零元素数量*/\n\n\n        for (int i = 0; i < matrixRowNum; i++) {\n                rowlNum[i] = rowFirstNoneZeroPos[i] = 0;\n        }\n\n        for (size_t i = 0; i < data.size(); i++) {\n                ++rowlNum[data[i].row - 1];\n        }\n\n        for (int i = 1; i < matrixRowNum; i++) {\n                /*计算每一列第一个非零元素下标*/\n                rowFirstNoneZeroPos[i] = rowFirstNoneZeroPos[i-1] + rowlNum[i-1];\n        }\n\n        delete [] rowlNum;\n}\n```\n\n## 代码测试\n\n通过随机生成两个稀疏矩阵，然后依次测试各个函数是否正确，测试代码如下所示：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<int> intDis(int(-100), int(100)); /*不能太大，防止溢出*/\n        uniform_int_distribution<int> mnDis(int(1), int(100));\n\n        int testTimes = 5;\n\n\twhile ((testTimes--) > 0) {\n\n                int m = mnDis(randEngine);\n                int n = mnDis(randEngine);\n                int k = mnDis(randEngine);\n\n                uniform_int_distribution<int> deltaDis1(int(1), int(m*n));\n                uniform_int_distribution<int> deltaDis2(int(1), int(n*k));\n\n                vector<vector<int>> testMatrix1(m, vector<int>(n, 0));\n                vector<vector<int>> testMatrix2(m, vector<int>(n, 0));\n                vector<vector<int>> testMatrix3(n, vector<int>(k, 0));\n\n                int delta1 = deltaDis1(randEngine);\n\n                /*这里偷个懒，矩阵1，2同时生成*/\n                for (int i = 0; i < delta1; i++) {\n                        int row = mnDis(randEngine) % m;\n                        int col = mnDis(randEngine) % n;\n                        testMatrix1[row][col] = intDis(randEngine);\n\n                        row = mnDis(randEngine) % m;\n                        col = mnDis(randEngine) % n;\n                        testMatrix2[row][col] = intDis(randEngine);\n                }\n\n                int delta2 = deltaDis2(randEngine);\n\n                for (int i = 0; i < delta2; i++) {\n                        int row = mnDis(randEngine) % n;\n                        int col = mnDis(randEngine) % k;\n                        testMatrix3[row][col] = intDis(randEngine);\n                }\n\n                TripleTable<int> tripleTest1(testMatrix1);\n                TripleTable<int> tripleTest2(testMatrix2);\n                TripleTable<int> tripleTest3(testMatrix3);\n\n                tripleTest1.TransposeMatrix(); tripleTest1.TransposeMatrix();\n                cout << \"常规转置测试结果：\" << (tripleTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                tripleTest1.FastTransposeMatrix(); tripleTest1.FastTransposeMatrix();\n                cout << \"快速转置测试结果：\" << (tripleTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                vector<vector<int>> addMatrix(m, vector<int>(n, 0));\n                for (size_t i = 0; i < addMatrix.size(); i++) {\n                        for (size_t j = 0; j < addMatrix[i].size(); j++) {\n                                addMatrix[i][j] = testMatrix1[i][j] + testMatrix2[i][j];\n                        }\n                }\n\n                tripleTest1.AddMatrix(tripleTest2);\n                cout << \"矩阵加法测试结果：\" << (tripleTest1.TransformTo2DArray() == addMatrix ? \"Correct\" : \"Wrong\") << endl;\n\n                tripleTest1.SubMatrix(tripleTest2);\n                cout << \"矩阵减法测试结果：\" << (tripleTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                vector<vector<int>> multiMatrix(m, vector<int>(k, 0));\n\n                for (size_t i = 0; i < multiMatrix.size(); i++) {\n                        for (size_t j = 0; j < multiMatrix[i].size(); j++) {\n                                for (int k = 0; k < n; k++) {\n                                        multiMatrix[i][j] += testMatrix1[i][k]*testMatrix3[k][j];\n                                        /*矩阵乘法*/\n                                }\n                        }\n                }\n\n                tripleTest1.MultiMatrix(tripleTest3);\n                cout << \"矩阵乘法测试结果：\" << (tripleTest1.TransformTo2DArray() == multiMatrix ? \"Correct\" : \"Wrong\") << endl;\n\n                /*tripleTest1.PrintMatrix();*/\n        }\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[稀疏矩阵](https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5)\n\n[数据结构](https://book.douban.com/subject/2024655/)\n","source":"_posts/数据结构/稀疏矩阵压缩存储之三元组.md","raw":"---\ntitle: 稀疏矩阵压缩存储之三元组\nurlname: sparse-matrix-triple-table\ndate: 2018-06-25 18:57:36\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 基础知识\n\n在定义稀疏矩阵时，可以引入一个称为稀疏因子的数，其定义如下：假设对于一个 $m\\*n$ 矩阵，其中有 $t$ 个元素不为 $0$， 则定义稀疏因子 $δ=t/(m*n)$，一般认为 $δ<=0.05$ 的矩阵为稀疏矩阵。稀疏矩阵如果采用二维数组直接存储将会导致大量的空间存储 $0$ 值，对于空间是一种极大的浪费，因此一般采用压缩存储，目前稀疏矩阵常用三元组顺序表和十字链表来存储，本文将实现采用三元组顺序表压缩稀疏矩阵并实现矩阵常用的操作。\n\n在实现三元组顺序表压缩存储稀疏矩阵之前，预先定义三元组节点结构如下：\n\n```cpp\ntemplate<typename DataType>\nstruct TripleAtom\n{\n        int row;       /*行号*/\n        int col;       /*列号*/\n        DataType ele;  /*存放的数据*/\n};\n```\n\n需要是实现的矩阵基本运算主要有：\n\n- 矩阵转置：TransposeMatrix\n- 矩阵加法：AddMatrix\n- 矩阵减法：SubMatrix\n- 矩阵乘法：MultiMatrix\n- 打印矩阵：PrintMatrix\n\n## 三元组顺序表基本定义\n\n根据上述分析可定义如下基本ADT:\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate<typename DataType>\nclass TripleTable\n{\npublic:\n        TripleTable(vector<vector<DataType>> &inArray);\n        ~TripleTable();\n        void TransposeMatrix();         /*常规转置思路*/\n        void FastTransposeMatrix();     /*快速转置*/\n        void AddMatrix(TripleTable<DataType> &otherMatrix); /*加上另外一个矩阵，第二个矩阵保持不变*/\n        void SubMatrix(TripleTable<DataType> &otherMatrix); /*减去另外一个矩阵，第二个矩阵保持不变*/\n        void MultiMatrix(TripleTable<DataType> &otherMatrix); /*乘上另外一个矩阵，第二个矩阵保持不变*/\n        vector<vector<DataType>> TransformTo2DArray(); /*转换成二维数组*/\n        void PrintMatrix(); /*打印矩阵*/\nprivate:\n        void CalculateFirstNoneZeroArray(); /*计算每行第一个非零元素下标*/\nprivate:\n        vector<TripleAtom<DataType>> data; /*存储实际的矩阵数据，自包含非零元个数*/\n        int matrixRowNum; /*矩阵行数*/\n        int matrixColNum; /*矩阵列数*/\n        int *rowFirstNoneZeroPos; /*每行第一个非零元素的起始位置，方便乘法*/\n};\n```\n\n如上即为整个三元组顺序表的ADT基本结构，具体含义可见注释。接下来依次实现个函数。\n\n## 三元组顺序表ADT的实现\n\n- 构造函数\n\n构造函数主要将二维存储的稀疏矩阵转变为三元组形式存储的矩阵。\n\n```cpp\ntemplate<typename DataType>\nTripleTable<DataType>::TripleTable(vector<vector<DataType>> &inArray) : matrixRowNum(-1),\n                                matrixColNum(-1), rowFirstNoneZeroPos(nullptr)\n{\n        if (inArray.size() > 0 && inArray[0].size() > 0) {\n\n                matrixRowNum = int(inArray.size());\n                matrixColNum = int(inArray[0].size());\n\n                TripleAtom<DataType> tmpAtom;\n                for (int i = 0; i < int(inArray.size()); i++) {\n                        for (int j = 0; j < int(inArray[i].size()); j++) {\n                                if (inArray[i][j] != DataType(0)) {\n                                        tmpAtom.row = i+1; /*下标从1开始*/\n                                        tmpAtom.col = j+1; /*下标从1开始*/\n                                        tmpAtom.ele = inArray[i][j];\n                                        data.push_back(tmpAtom); /*压入*/\n                                }\n                        }\n                }\n\n                CalculateFirstNoneZeroArray();\n        }\n}\n```\n\n- 析构函数\n\n析构主要释放rowFirstNoneZeroPos申请的空间，实现如下所示：\n\n```cpp\ntemplate<typename DataType>\nTripleTable<DataType>::~TripleTable<DataType>()\n{\n        delete [] rowFirstNoneZeroPos;\n        rowFirstNoneZeroPos = nullptr;\n        matrixRowNum = -1; matrixColNum = -1;\n}\n```\n\n- 常规矩阵转置\n\n由于三元组顺序表的存储顺序是行优先依次存储，而转置后的三元组行号变成列号，原始行号有序使得转置后的列号有序，因此原始三元组转置后的一行中的列相对顺序是正确的。故此有如下代码：\n\n```cpp\n#include <algorithm>\nusing std::swap;\n\ntemplate<typename DataType>\nvoid TripleTable<DataType>::TransposeMatrix()\n{\n        TripleAtom<DataType> tmpAtom;\n        vector<TripleAtom<DataType>> newMatrix;\n        for (int i = 1; i <= matrixColNum; i++) {\n                for (size_t j = 0; j < data.size(); j++) {\n                        if (data[j].col == i) {\n                                tmpAtom.row = data[j].col;\n                                tmpAtom.col = data[j].row;\n                                tmpAtom.ele = data[j].ele;\n                                newMatrix.push_back(tmpAtom); /*压入*/\n                        }\n                }\n        }\n\n        data.assign(newMatrix.begin(), newMatrix.end()); /*转置后的矩阵*/\n        swap(matrixRowNum, matrixColNum);\n\n        CalculateFirstNoneZeroArray();\n}\n```\n\n- 快速矩阵转置\n\n由于在常规转置中，我们需要一行一行来处理，如果每遍历到一个三元组便知道该元素放入的位置，那么可以极大降低时间复杂度，此时我们需要计算一个转置后每行起始的位置，然后在遍历过程中可以快速填写三元组顺序表，具体实现代码如下所示：\n\n```cpp\n#include <algorithm>\nusing std::swap;\n\ntemplate<typename DataType>\nvoid TripleTable<DataType>::FastTransposeMatrix()\n{\n        if (matrixRowNum <= 0 || matrixColNum <= 0) {\n                return;\n        }\n\n        int *colNum = new int[matrixColNum]; /*每列非零元素数量*/\n        int *colIndex = new int[matrixColNum]; /*每列第一个非零元素起始下标*/\n\n        for (int i = 0; i < matrixColNum; i++) {\n                colNum[i] = colIndex[0] = 0;\n        }\n\n        for (size_t i = 0; i < data.size(); i++) {\n                ++colNum[data[i].col - 1];\n        }\n\n        for (int i = 1; i < matrixColNum; i++) {\n                /*计算每一列第一个非零元素下标*/\n                colIndex[i] = colIndex[i-1] + colNum[i-1];\n        }\n\n        vector<TripleAtom<DataType>> newMatrix(data.size());\n        TripleAtom<DataType> tmpAtom;\n        for (size_t i = 0; i < data.size(); i++) {\n\n                tmpAtom.row = data[i].col;\n                tmpAtom.col = data[i].row;\n                tmpAtom.ele = data[i].ele;\n\n                newMatrix[colIndex[tmpAtom.row-1]] = tmpAtom;\n                ++colIndex[tmpAtom.row-1]; /*矩阵下标从1开始*/\n        }\n\n        data.assign(newMatrix.begin(), newMatrix.end()); /*转置后的矩阵*/\n        swap(matrixRowNum, matrixColNum);\n\n        CalculateFirstNoneZeroArray();\n\n        delete [] colNum; delete [] colIndex;\n}\n```\n\n上述代码增加辅助空间后便将时间复杂度降低了一个量级。\n\n- 矩阵相加\n\n在进行矩阵加法，首先需要判断两个矩阵是否能够相加，接着使用双下标指针分别指向第一个矩阵和第二个矩阵，如果两个指向的行列号相等只需直接相加，否则需要判断行列号大小，具体实现代码如下：\n\n```cpp\ntemplate<typename DataType>\nvoid TripleTable<DataType>::AddMatrix(TripleTable<DataType> &otherMatrix)\n{\n        if (matrixRowNum != otherMatrix.matrixRowNum || matrixColNum != otherMatrix.matrixColNum) {\n                return;\n        }\n\n        vector<TripleAtom<DataType>> newMatrix;\n        TripleAtom<DataType> tmpAtom;\n\n        size_t i = 0, j = 0;\n\n        while (i < data.size() && j < otherMatrix.data.size()) {\n                if (data[i].row < otherMatrix.data[j].row) {\n                        newMatrix.push_back(data[i]); ++i;\n                }\n                else if (data[i].row > otherMatrix.data[j].row) {\n                        newMatrix.push_back(otherMatrix.data[j]); ++j;\n                }\n                else if (data[i].col < otherMatrix.data[j].col) {\n                        newMatrix.push_back(data[i]); ++i;\n                }\n                else if (data[i].col > otherMatrix.data[j].col) {\n                        newMatrix.push_back(otherMatrix.data[j]); ++j;\n                }\n                else {\n                        tmpAtom.row = data[i].row;\n                        tmpAtom.col = data[i].col;\n                        tmpAtom.ele = data[i].ele + otherMatrix.data[j].ele;\n                        newMatrix.push_back(tmpAtom);\n                        ++i; ++j;\n                }\n        }\n\n        while (i < data.size()) {\n                newMatrix.push_back(data[i]); ++i;\n        }\n\n        while (j < otherMatrix.data.size()) {\n                newMatrix.push_back(otherMatrix.data[j]); ++j;\n        }\n\n        data.assign(newMatrix.begin(), newMatrix.end()); /*相加后的矩阵*/\n\n        CalculateFirstNoneZeroArray(); /*重新计算*/\n}\n```\n\n- 矩阵减法\n\n矩阵减法和矩阵加法类似，具体代码如下所示：\n\n```cpp\ntemplate<typename DataType>\nvoid TripleTable<DataType>::SubMatrix(TripleTable<DataType> &otherMatrix)\n{\n        if (matrixRowNum != otherMatrix.matrixRowNum || matrixColNum != otherMatrix.matrixColNum) {\n                return;\n        }\n\n        vector<TripleAtom<DataType>> newMatrix;\n        TripleAtom<DataType> tmpAtom;\n\n        size_t i = 0, j = 0;\n\n        while (i < data.size() && j < otherMatrix.data.size()) {\n                if (data[i].row < otherMatrix.data[j].row) {\n                        newMatrix.push_back(data[i]); ++i;\n                }\n                else if (data[i].row > otherMatrix.data[j].row) {\n                        tmpAtom.row = otherMatrix.data[j].row;\n                        tmpAtom.col = otherMatrix.data[j].col;\n                        tmpAtom.ele = -otherMatrix.data[j].ele;\n                        newMatrix.push_back(tmpAtom); ++j;\n                }\n                else if (data[i].col < otherMatrix.data[j].col) {\n                        newMatrix.push_back(data[i]); ++i;\n                }\n                else if (data[i].col > otherMatrix.data[j].col) {\n                        tmpAtom.row = otherMatrix.data[j].row;\n                        tmpAtom.col = otherMatrix.data[j].col;\n                        tmpAtom.ele = -otherMatrix.data[j].ele;\n                        newMatrix.push_back(tmpAtom); ++j;\n                }\n                else {\n                        tmpAtom.row = data[i].row;\n                        tmpAtom.col = data[i].col;\n                        tmpAtom.ele = data[i].ele - otherMatrix.data[j].ele;\n                        newMatrix.push_back(tmpAtom);\n                        ++i; ++j;\n                }\n        }\n\n        while (i < data.size()) {\n                newMatrix.push_back(data[i]); ++i;\n        }\n\n        while (j < otherMatrix.data.size()) {\n                tmpAtom.row = otherMatrix.data[j].row;\n                tmpAtom.col = otherMatrix.data[j].col;\n                tmpAtom.ele = -otherMatrix.data[j].ele;\n                newMatrix.push_back(tmpAtom); ++j;\n        }\n\n        data.assign(newMatrix.begin(), newMatrix.end()); /*相减后的矩阵*/\n\n        CalculateFirstNoneZeroArray(); /*重新计算*/\n}\n```\n\n- 矩阵乘法\n\n矩阵乘法相对而言比较复杂，矩阵乘法如果偷懒可以先解压缩然后使用常规乘法进行计算最后再把结果进行压缩，但这样就不能体现三元组的作用了，因此需要找出一种可以直接在三元组上进行计算的乘法算法。考虑到矩阵乘法的实质是从第一个矩阵抽出一个行向量和从第二个矩阵抽出一个列向量并做向量的点乘，其中行、列号分别对应在结果矩阵中的行、列号，综合上述分析我们可以一行一行处理，其首先也需要判断运算是否合法，具体代码如下所示：\n\n```cpp\ntemplate<typename DataType>\nvoid TripleTable<DataType>::MultiMatrix(TripleTable<DataType> &otherMatrix)\n{\n        if (matrixColNum != otherMatrix.matrixRowNum) {\n                return;\n        }\n        if (data.size() <= 0 || otherMatrix.data.size() <= 0) {\n                /*如果有全零矩阵则相乘结果也是一个全零矩阵*/\n                data.clear(); return;\n        }\n\n        DataType *tmpAccumulate = new int[otherMatrix.matrixColNum]; /*记录每行各列的累加和*/\n\n        vector<TripleAtom<DataType>> newMatrix;\n        /*一行一行处理*/\n        for (int i = 0; i < matrixRowNum; i++) {\n                for (int j = 0; j < otherMatrix.matrixColNum; j++) {\n                        tmpAccumulate[j] = DataType(0); /*清空累加器*/\n                }\n\n                /*行开始的地方*/\n                int rowBegin = rowFirstNoneZeroPos[i];\n                /*行结束的地方*/\n                int rowEnd = i >= matrixRowNum-1 ? int(data.size()) : rowFirstNoneZeroPos[i+1];\n\n                for (int j = rowBegin; j < rowEnd; j++) {\n                        /*(m,n)*(n,k)矩阵的行,列对应下标相等才乘*/\n                        int middleIndex = data[j].col - 1;\n                        int anotherRowBegin = otherMatrix.rowFirstNoneZeroPos[middleIndex];\n                        int anotherRowEnd = middleIndex >= otherMatrix.matrixRowNum-1 ? int(otherMatrix.data.size()) : otherMatrix.rowFirstNoneZeroPos[middleIndex+1];\n                        for (int k = anotherRowBegin; k < anotherRowEnd; k++) {\n                                tmpAccumulate[otherMatrix.data[k].col -1] += data[j].ele * otherMatrix.data[k].ele;\n                        }\n                }\n\n                /*逐行压缩*/\n                TripleAtom<DataType> tmpAtom;\n                for (int j = 0; j < otherMatrix.matrixColNum; j++) {\n                        if (tmpAccumulate[j] != DataType(0)) {\n                                tmpAtom.row = i+1; /*下标从1开始*/\n                                tmpAtom.col = j+1; /*下标从1开始*/\n                                tmpAtom.ele = tmpAccumulate[j];\n                                newMatrix.push_back(tmpAtom);\n                        }\n                }\n        }\n\n        /*修改列数*/\n        matrixColNum = otherMatrix.matrixColNum;\n        data.assign(newMatrix.begin(), newMatrix.end()); /*相乘后的矩阵*/\n\n        CalculateFirstNoneZeroArray(); /*重新计算*/\n\n        delete [] tmpAccumulate;\n}\n```\n\n- 压缩矩阵转成二维数组\n\n直接遍历即可，不存在意味着是零值。\n\n```cpp\ntemplate<typename DataType>\nvector<vector<DataType>> TripleTable<DataType>::TransformTo2DArray()\n{\n        vector<vector<DataType>> result(matrixRowNum, vector<DataType>(matrixColNum, DataType(0)));\n\n        for (size_t i = 0; i < data.size(); i++) {\n                result[data[i].row-1][data[i].col-1] = data[i].ele;\n        }\n\n        return result;\n}\n```\n\n- 打印矩阵\n\n先调用转二维函数然后直接打印即可，代码如下：\n\n```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\n\ntemplate<typename DataType>\nvoid TripleTable<DataType>::PrintMatrix()\n{\n        vector<vector<DataType>> result = TransformTo2DArray();\n\n        for (size_t i = 0; i < result.size(); i++) {\n                for (size_t j = 0; j < result[i].size(); j++) {\n                        cout << result[i][j] << \";\";\n                }\n                cout << endl;\n        }\n}\n```\n\n- 计算每行元素的第一个下标值\n\n这在快速矩阵转置中实现过类似的思路，直接把代码稍作修改即可，结果见下：\n\n```cpp\ntemplate<typename DataType>\nvoid TripleTable<DataType>::CalculateFirstNoneZeroArray()\n{\n        if (rowFirstNoneZeroPos != nullptr) {\n                delete [] rowFirstNoneZeroPos;\n        }\n\n        /*正式给rowFirstNoneZeroPos申请空间*/\n        rowFirstNoneZeroPos = new int[matrixRowNum];\n\n        int *rowlNum = new int[matrixRowNum]; /*每列非零元素数量*/\n\n\n        for (int i = 0; i < matrixRowNum; i++) {\n                rowlNum[i] = rowFirstNoneZeroPos[i] = 0;\n        }\n\n        for (size_t i = 0; i < data.size(); i++) {\n                ++rowlNum[data[i].row - 1];\n        }\n\n        for (int i = 1; i < matrixRowNum; i++) {\n                /*计算每一列第一个非零元素下标*/\n                rowFirstNoneZeroPos[i] = rowFirstNoneZeroPos[i-1] + rowlNum[i-1];\n        }\n\n        delete [] rowlNum;\n}\n```\n\n## 代码测试\n\n通过随机生成两个稀疏矩阵，然后依次测试各个函数是否正确，测试代码如下所示：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<int> intDis(int(-100), int(100)); /*不能太大，防止溢出*/\n        uniform_int_distribution<int> mnDis(int(1), int(100));\n\n        int testTimes = 5;\n\n\twhile ((testTimes--) > 0) {\n\n                int m = mnDis(randEngine);\n                int n = mnDis(randEngine);\n                int k = mnDis(randEngine);\n\n                uniform_int_distribution<int> deltaDis1(int(1), int(m*n));\n                uniform_int_distribution<int> deltaDis2(int(1), int(n*k));\n\n                vector<vector<int>> testMatrix1(m, vector<int>(n, 0));\n                vector<vector<int>> testMatrix2(m, vector<int>(n, 0));\n                vector<vector<int>> testMatrix3(n, vector<int>(k, 0));\n\n                int delta1 = deltaDis1(randEngine);\n\n                /*这里偷个懒，矩阵1，2同时生成*/\n                for (int i = 0; i < delta1; i++) {\n                        int row = mnDis(randEngine) % m;\n                        int col = mnDis(randEngine) % n;\n                        testMatrix1[row][col] = intDis(randEngine);\n\n                        row = mnDis(randEngine) % m;\n                        col = mnDis(randEngine) % n;\n                        testMatrix2[row][col] = intDis(randEngine);\n                }\n\n                int delta2 = deltaDis2(randEngine);\n\n                for (int i = 0; i < delta2; i++) {\n                        int row = mnDis(randEngine) % n;\n                        int col = mnDis(randEngine) % k;\n                        testMatrix3[row][col] = intDis(randEngine);\n                }\n\n                TripleTable<int> tripleTest1(testMatrix1);\n                TripleTable<int> tripleTest2(testMatrix2);\n                TripleTable<int> tripleTest3(testMatrix3);\n\n                tripleTest1.TransposeMatrix(); tripleTest1.TransposeMatrix();\n                cout << \"常规转置测试结果：\" << (tripleTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                tripleTest1.FastTransposeMatrix(); tripleTest1.FastTransposeMatrix();\n                cout << \"快速转置测试结果：\" << (tripleTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                vector<vector<int>> addMatrix(m, vector<int>(n, 0));\n                for (size_t i = 0; i < addMatrix.size(); i++) {\n                        for (size_t j = 0; j < addMatrix[i].size(); j++) {\n                                addMatrix[i][j] = testMatrix1[i][j] + testMatrix2[i][j];\n                        }\n                }\n\n                tripleTest1.AddMatrix(tripleTest2);\n                cout << \"矩阵加法测试结果：\" << (tripleTest1.TransformTo2DArray() == addMatrix ? \"Correct\" : \"Wrong\") << endl;\n\n                tripleTest1.SubMatrix(tripleTest2);\n                cout << \"矩阵减法测试结果：\" << (tripleTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                vector<vector<int>> multiMatrix(m, vector<int>(k, 0));\n\n                for (size_t i = 0; i < multiMatrix.size(); i++) {\n                        for (size_t j = 0; j < multiMatrix[i].size(); j++) {\n                                for (int k = 0; k < n; k++) {\n                                        multiMatrix[i][j] += testMatrix1[i][k]*testMatrix3[k][j];\n                                        /*矩阵乘法*/\n                                }\n                        }\n                }\n\n                tripleTest1.MultiMatrix(tripleTest3);\n                cout << \"矩阵乘法测试结果：\" << (tripleTest1.TransformTo2DArray() == multiMatrix ? \"Correct\" : \"Wrong\") << endl;\n\n                /*tripleTest1.PrintMatrix();*/\n        }\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[稀疏矩阵](https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5)\n\n[数据结构](https://book.douban.com/subject/2024655/)\n","slug":"数据结构/稀疏矩阵压缩存储之三元组","published":1,"updated":"2018-06-25T11:03:52.329Z","_id":"cjiu5pmt90003ncvnhaipuejy","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>在定义稀疏矩阵时，可以引入一个称为稀疏因子的数，其定义如下：假设对于一个 $m*n$ 矩阵，其中有 $t$ 个元素不为 $0$， 则定义稀疏因子 $δ=t/(m*n)$，一般认为 $δ&lt;=0.05$ 的矩阵为稀疏矩阵。稀疏矩阵如果采用二维数组直接存储将会导致大量的空间存储 $0$ 值，对于空间是一种极大的浪费，因此一般采用压缩存储，目前稀疏矩阵常用三元组顺序表和十字链表来存储，本文将实现采用三元组顺序表压缩稀疏矩阵并实现矩阵常用的操作。</p>\n<p>在实现三元组顺序表压缩存储稀疏矩阵之前，预先定义三元组节点结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TripleAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> row;       <span class=\"comment\">/*行号*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> col;       <span class=\"comment\">/*列号*/</span></span><br><span class=\"line\">        DataType ele;  <span class=\"comment\">/*存放的数据*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>需要是实现的矩阵基本运算主要有：</p>\n<ul>\n<li>矩阵转置：TransposeMatrix</li>\n<li>矩阵加法：AddMatrix</li>\n<li>矩阵减法：SubMatrix</li>\n<li>矩阵乘法：MultiMatrix</li>\n<li>打印矩阵：PrintMatrix</li>\n</ul>\n<h2 id=\"三元组顺序表基本定义\"><a href=\"#三元组顺序表基本定义\" class=\"headerlink\" title=\"三元组顺序表基本定义\"></a>三元组顺序表基本定义</h2><p>根据上述分析可定义如下基本ADT:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TripleTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        TripleTable(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; &amp;inArray);</span><br><span class=\"line\">        ~TripleTable();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TransposeMatrix</span><span class=\"params\">()</span></span>;         <span class=\"comment\">/*常规转置思路*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FastTransposeMatrix</span><span class=\"params\">()</span></span>;     <span class=\"comment\">/*快速转置*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AddMatrix</span><span class=\"params\">(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*加上另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SubMatrix</span><span class=\"params\">(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*减去另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MultiMatrix</span><span class=\"params\">(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*乘上另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; TransformTo2DArray(); <span class=\"comment\">/*转换成二维数组*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintMatrix</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*打印矩阵*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CalculateFirstNoneZeroArray</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*计算每行第一个非零元素下标*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; data; <span class=\"comment\">/*存储实际的矩阵数据，自包含非零元个数*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> matrixRowNum; <span class=\"comment\">/*矩阵行数*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> matrixColNum; <span class=\"comment\">/*矩阵列数*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> *rowFirstNoneZeroPos; <span class=\"comment\">/*每行第一个非零元素的起始位置，方便乘法*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上即为整个三元组顺序表的ADT基本结构，具体含义可见注释。接下来依次实现个函数。</p>\n<h2 id=\"三元组顺序表ADT的实现\"><a href=\"#三元组顺序表ADT的实现\" class=\"headerlink\" title=\"三元组顺序表ADT的实现\"></a>三元组顺序表ADT的实现</h2><ul>\n<li>构造函数</li>\n</ul>\n<p>构造函数主要将二维存储的稀疏矩阵转变为三元组形式存储的矩阵。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TripleTable&lt;DataType&gt;::TripleTable(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; &amp;inArray) : matrixRowNum(<span class=\"number\">-1</span>),</span><br><span class=\"line\">                                matrixColNum(<span class=\"number\">-1</span>), rowFirstNoneZeroPos(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inArray.size() &gt; <span class=\"number\">0</span> &amp;&amp; inArray[<span class=\"number\">0</span>].size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                matrixRowNum = <span class=\"keyword\">int</span>(inArray.size());</span><br><span class=\"line\">                matrixColNum = <span class=\"keyword\">int</span>(inArray[<span class=\"number\">0</span>].size());</span><br><span class=\"line\"></span><br><span class=\"line\">                TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">int</span>(inArray.size()); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"keyword\">int</span>(inArray[i].size()); j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (inArray[i][j] != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                        tmpAtom.row = i+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                        tmpAtom.col = j+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                        tmpAtom.ele = inArray[i][j];</span><br><span class=\"line\">                                        data.push_back(tmpAtom); <span class=\"comment\">/*压入*/</span></span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                CalculateFirstNoneZeroArray();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<p>析构主要释放rowFirstNoneZeroPos申请的空间，实现如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TripleTable&lt;DataType&gt;::~TripleTable&lt;DataType&gt;()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] rowFirstNoneZeroPos;</span><br><span class=\"line\">        rowFirstNoneZeroPos = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        matrixRowNum = <span class=\"number\">-1</span>; matrixColNum = <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常规矩阵转置</li>\n</ul>\n<p>由于三元组顺序表的存储顺序是行优先依次存储，而转置后的三元组行号变成列号，原始行号有序使得转置后的列号有序，因此原始三元组转置后的一行中的列相对顺序是正确的。故此有如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::swap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::TransposeMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= matrixColNum; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; data.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (data[j].col == i) &#123;</span><br><span class=\"line\">                                tmpAtom.row = data[j].col;</span><br><span class=\"line\">                                tmpAtom.col = data[j].row;</span><br><span class=\"line\">                                tmpAtom.ele = data[j].ele;</span><br><span class=\"line\">                                newMatrix.push_back(tmpAtom); <span class=\"comment\">/*压入*/</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*转置后的矩阵*/</span></span><br><span class=\"line\">        swap(matrixRowNum, matrixColNum);</span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>快速矩阵转置</li>\n</ul>\n<p>由于在常规转置中，我们需要一行一行来处理，如果每遍历到一个三元组便知道该元素放入的位置，那么可以极大降低时间复杂度，此时我们需要计算一个转置后每行起始的位置，然后在遍历过程中可以快速填写三元组顺序表，具体实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::swap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::FastTransposeMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrixRowNum &lt;= <span class=\"number\">0</span> || matrixColNum &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> *colNum = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrixColNum]; <span class=\"comment\">/*每列非零元素数量*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> *colIndex = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrixColNum]; <span class=\"comment\">/*每列第一个非零元素起始下标*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixColNum; i++) &#123;</span><br><span class=\"line\">                colNum[i] = colIndex[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\">                ++colNum[data[i].col - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; matrixColNum; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*计算每一列第一个非零元素下标*/</span></span><br><span class=\"line\">                colIndex[i] = colIndex[i<span class=\"number\">-1</span>] + colNum[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix(data.size());</span><br><span class=\"line\">        TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                tmpAtom.row = data[i].col;</span><br><span class=\"line\">                tmpAtom.col = data[i].row;</span><br><span class=\"line\">                tmpAtom.ele = data[i].ele;</span><br><span class=\"line\"></span><br><span class=\"line\">                newMatrix[colIndex[tmpAtom.row<span class=\"number\">-1</span>]] = tmpAtom;</span><br><span class=\"line\">                ++colIndex[tmpAtom.row<span class=\"number\">-1</span>]; <span class=\"comment\">/*矩阵下标从1开始*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*转置后的矩阵*/</span></span><br><span class=\"line\">        swap(matrixRowNum, matrixColNum);</span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] colNum; <span class=\"keyword\">delete</span> [] colIndex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码增加辅助空间后便将时间复杂度降低了一个量级。</p>\n<ul>\n<li>矩阵相加</li>\n</ul>\n<p>在进行矩阵加法，首先需要判断两个矩阵是否能够相加，接着使用双下标指针分别指向第一个矩阵和第二个矩阵，如果两个指向的行列号相等只需直接相加，否则需要判断行列号大小，具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::AddMatrix(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrixRowNum != otherMatrix.matrixRowNum || matrixColNum != otherMatrix.matrixColNum) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix;</span><br><span class=\"line\">        TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; data.size() &amp;&amp; j &lt; otherMatrix.data.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (data[i].row &lt; otherMatrix.data[j].row) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].row &gt; otherMatrix.data[j].row) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(otherMatrix.data[j]); ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].col &lt; otherMatrix.data[j].col) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].col &gt; otherMatrix.data[j].col) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(otherMatrix.data[j]); ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        tmpAtom.row = data[i].row;</span><br><span class=\"line\">                        tmpAtom.col = data[i].col;</span><br><span class=\"line\">                        tmpAtom.ele = data[i].ele + otherMatrix.data[j].ele;</span><br><span class=\"line\">                        newMatrix.push_back(tmpAtom);</span><br><span class=\"line\">                        ++i; ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; data.size()) &#123;</span><br><span class=\"line\">                newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; otherMatrix.data.size()) &#123;</span><br><span class=\"line\">                newMatrix.push_back(otherMatrix.data[j]); ++j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*相加后的矩阵*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray(); <span class=\"comment\">/*重新计算*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵减法</li>\n</ul>\n<p>矩阵减法和矩阵加法类似，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::SubMatrix(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrixRowNum != otherMatrix.matrixRowNum || matrixColNum != otherMatrix.matrixColNum) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix;</span><br><span class=\"line\">        TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; data.size() &amp;&amp; j &lt; otherMatrix.data.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (data[i].row &lt; otherMatrix.data[j].row) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].row &gt; otherMatrix.data[j].row) &#123;</span><br><span class=\"line\">                        tmpAtom.row = otherMatrix.data[j].row;</span><br><span class=\"line\">                        tmpAtom.col = otherMatrix.data[j].col;</span><br><span class=\"line\">                        tmpAtom.ele = -otherMatrix.data[j].ele;</span><br><span class=\"line\">                        newMatrix.push_back(tmpAtom); ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].col &lt; otherMatrix.data[j].col) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].col &gt; otherMatrix.data[j].col) &#123;</span><br><span class=\"line\">                        tmpAtom.row = otherMatrix.data[j].row;</span><br><span class=\"line\">                        tmpAtom.col = otherMatrix.data[j].col;</span><br><span class=\"line\">                        tmpAtom.ele = -otherMatrix.data[j].ele;</span><br><span class=\"line\">                        newMatrix.push_back(tmpAtom); ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        tmpAtom.row = data[i].row;</span><br><span class=\"line\">                        tmpAtom.col = data[i].col;</span><br><span class=\"line\">                        tmpAtom.ele = data[i].ele - otherMatrix.data[j].ele;</span><br><span class=\"line\">                        newMatrix.push_back(tmpAtom);</span><br><span class=\"line\">                        ++i; ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; data.size()) &#123;</span><br><span class=\"line\">                newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; otherMatrix.data.size()) &#123;</span><br><span class=\"line\">                tmpAtom.row = otherMatrix.data[j].row;</span><br><span class=\"line\">                tmpAtom.col = otherMatrix.data[j].col;</span><br><span class=\"line\">                tmpAtom.ele = -otherMatrix.data[j].ele;</span><br><span class=\"line\">                newMatrix.push_back(tmpAtom); ++j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*相减后的矩阵*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray(); <span class=\"comment\">/*重新计算*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵乘法</li>\n</ul>\n<p>矩阵乘法相对而言比较复杂，矩阵乘法如果偷懒可以先解压缩然后使用常规乘法进行计算最后再把结果进行压缩，但这样就不能体现三元组的作用了，因此需要找出一种可以直接在三元组上进行计算的乘法算法。考虑到矩阵乘法的实质是从第一个矩阵抽出一个行向量和从第二个矩阵抽出一个列向量并做向量的点乘，其中行、列号分别对应在结果矩阵中的行、列号，综合上述分析我们可以一行一行处理，其首先也需要判断运算是否合法，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::MultiMatrix(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrixColNum != otherMatrix.matrixRowNum) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data.size() &lt;= <span class=\"number\">0</span> || otherMatrix.data.size() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*如果有全零矩阵则相乘结果也是一个全零矩阵*/</span></span><br><span class=\"line\">                data.clear(); <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType *tmpAccumulate = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[otherMatrix.matrixColNum]; <span class=\"comment\">/*记录每行各列的累加和*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix;</span><br><span class=\"line\">        <span class=\"comment\">/*一行一行处理*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixRowNum; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; otherMatrix.matrixColNum; j++) &#123;</span><br><span class=\"line\">                        tmpAccumulate[j] = DataType(<span class=\"number\">0</span>); <span class=\"comment\">/*清空累加器*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*行开始的地方*/</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rowBegin = rowFirstNoneZeroPos[i];</span><br><span class=\"line\">                <span class=\"comment\">/*行结束的地方*/</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rowEnd = i &gt;= matrixRowNum<span class=\"number\">-1</span> ? <span class=\"keyword\">int</span>(data.size()) : rowFirstNoneZeroPos[i+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = rowBegin; j &lt; rowEnd; j++) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*(m,n)*(n,k)矩阵的行,列对应下标相等才乘*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> middleIndex = data[j].col - <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> anotherRowBegin = otherMatrix.rowFirstNoneZeroPos[middleIndex];</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> anotherRowEnd = middleIndex &gt;= otherMatrix.matrixRowNum<span class=\"number\">-1</span> ? <span class=\"keyword\">int</span>(otherMatrix.data.size()) : otherMatrix.rowFirstNoneZeroPos[middleIndex+<span class=\"number\">1</span>];</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = anotherRowBegin; k &lt; anotherRowEnd; k++) &#123;</span><br><span class=\"line\">                                tmpAccumulate[otherMatrix.data[k].col <span class=\"number\">-1</span>] += data[j].ele * otherMatrix.data[k].ele;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*逐行压缩*/</span></span><br><span class=\"line\">                TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; otherMatrix.matrixColNum; j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tmpAccumulate[j] != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                tmpAtom.row = i+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                tmpAtom.col = j+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                tmpAtom.ele = tmpAccumulate[j];</span><br><span class=\"line\">                                newMatrix.push_back(tmpAtom);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*修改列数*/</span></span><br><span class=\"line\">        matrixColNum = otherMatrix.matrixColNum;</span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*相乘后的矩阵*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray(); <span class=\"comment\">/*重新计算*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] tmpAccumulate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>压缩矩阵转成二维数组</li>\n</ul>\n<p>直接遍历即可，不存在意味着是零值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; TripleTable&lt;DataType&gt;::TransformTo2DArray()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result(matrixRowNum, <span class=\"built_in\">vector</span>&lt;DataType&gt;(matrixColNum, DataType(<span class=\"number\">0</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\">                result[data[i].row<span class=\"number\">-1</span>][data[i].col<span class=\"number\">-1</span>] = data[i].ele;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印矩阵</li>\n</ul>\n<p>先调用转二维函数然后直接打印即可，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::PrintMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result = TransformTo2DArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; result[i].size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; result[i][j] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>计算每行元素的第一个下标值</li>\n</ul>\n<p>这在快速矩阵转置中实现过类似的思路，直接把代码稍作修改即可，结果见下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::CalculateFirstNoneZeroArray()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowFirstNoneZeroPos != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> [] rowFirstNoneZeroPos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*正式给rowFirstNoneZeroPos申请空间*/</span></span><br><span class=\"line\">        rowFirstNoneZeroPos = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrixRowNum];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> *rowlNum = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrixRowNum]; <span class=\"comment\">/*每列非零元素数量*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixRowNum; i++) &#123;</span><br><span class=\"line\">                rowlNum[i] = rowFirstNoneZeroPos[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\">                ++rowlNum[data[i].row - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; matrixRowNum; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*计算每一列第一个非零元素下标*/</span></span><br><span class=\"line\">                rowFirstNoneZeroPos[i] = rowFirstNoneZeroPos[i<span class=\"number\">-1</span>] + rowlNum[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] rowlNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>通过随机生成两个稀疏矩阵，然后依次测试各个函数是否正确，测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-100</span>), <span class=\"keyword\">int</span>(<span class=\"number\">100</span>)); <span class=\"comment\">/*不能太大，防止溢出*/</span></span><br><span class=\"line\">        uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; mnDis(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> m = mnDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> n = mnDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> k = mnDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; deltaDis1(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(m*n));</span><br><span class=\"line\">                uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; deltaDis2(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(n*k));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix1(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix2(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix3(n, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(k, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> delta1 = deltaDis1(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*这里偷个懒，矩阵1，2同时生成*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; delta1; i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> row = mnDis(randEngine) % m;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> col = mnDis(randEngine) % n;</span><br><span class=\"line\">                        testMatrix1[row][col] = intDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                        row = mnDis(randEngine) % m;</span><br><span class=\"line\">                        col = mnDis(randEngine) % n;</span><br><span class=\"line\">                        testMatrix2[row][col] = intDis(randEngine);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> delta2 = deltaDis2(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; delta2; i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> row = mnDis(randEngine) % n;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> col = mnDis(randEngine) % k;</span><br><span class=\"line\">                        testMatrix3[row][col] = intDis(randEngine);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                TripleTable&lt;<span class=\"keyword\">int</span>&gt; tripleTest1(testMatrix1);</span><br><span class=\"line\">                TripleTable&lt;<span class=\"keyword\">int</span>&gt; tripleTest2(testMatrix2);</span><br><span class=\"line\">                TripleTable&lt;<span class=\"keyword\">int</span>&gt; tripleTest3(testMatrix3);</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.TransposeMatrix(); tripleTest1.TransposeMatrix();</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"常规转置测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.FastTransposeMatrix(); tripleTest1.FastTransposeMatrix();</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"快速转置测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; addMatrix(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; addMatrix.size(); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; addMatrix[i].size(); j++) &#123;</span><br><span class=\"line\">                                addMatrix[i][j] = testMatrix1[i][j] + testMatrix2[i][j];</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.AddMatrix(tripleTest2);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵加法测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == addMatrix ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.SubMatrix(tripleTest2);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵减法测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; multiMatrix(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(k, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; multiMatrix.size(); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; multiMatrix[i].size(); j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++) &#123;</span><br><span class=\"line\">                                        multiMatrix[i][j] += testMatrix1[i][k]*testMatrix3[k][j];</span><br><span class=\"line\">                                        <span class=\"comment\">/*矩阵乘法*/</span></span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.MultiMatrix(tripleTest3);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵乘法测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == multiMatrix ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*tripleTest1.PrintMatrix();*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">稀疏矩阵</a></p>\n<p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>在定义稀疏矩阵时，可以引入一个称为稀疏因子的数，其定义如下：假设对于一个 $m*n$ 矩阵，其中有 $t$ 个元素不为 $0$， 则定义稀疏因子 $δ=t/(m*n)$，一般认为 $δ&lt;=0.05$ 的矩阵为稀疏矩阵。稀疏矩阵如果采用二维数组直接存储将会导致大量的空间存储 $0$ 值，对于空间是一种极大的浪费，因此一般采用压缩存储，目前稀疏矩阵常用三元组顺序表和十字链表来存储，本文将实现采用三元组顺序表压缩稀疏矩阵并实现矩阵常用的操作。</p>\n<p>在实现三元组顺序表压缩存储稀疏矩阵之前，预先定义三元组节点结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TripleAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> row;       <span class=\"comment\">/*行号*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> col;       <span class=\"comment\">/*列号*/</span></span><br><span class=\"line\">        DataType ele;  <span class=\"comment\">/*存放的数据*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>需要是实现的矩阵基本运算主要有：</p>\n<ul>\n<li>矩阵转置：TransposeMatrix</li>\n<li>矩阵加法：AddMatrix</li>\n<li>矩阵减法：SubMatrix</li>\n<li>矩阵乘法：MultiMatrix</li>\n<li>打印矩阵：PrintMatrix</li>\n</ul>\n<h2 id=\"三元组顺序表基本定义\"><a href=\"#三元组顺序表基本定义\" class=\"headerlink\" title=\"三元组顺序表基本定义\"></a>三元组顺序表基本定义</h2><p>根据上述分析可定义如下基本ADT:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TripleTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        TripleTable(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; &amp;inArray);</span><br><span class=\"line\">        ~TripleTable();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TransposeMatrix</span><span class=\"params\">()</span></span>;         <span class=\"comment\">/*常规转置思路*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FastTransposeMatrix</span><span class=\"params\">()</span></span>;     <span class=\"comment\">/*快速转置*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AddMatrix</span><span class=\"params\">(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*加上另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SubMatrix</span><span class=\"params\">(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*减去另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MultiMatrix</span><span class=\"params\">(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*乘上另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; TransformTo2DArray(); <span class=\"comment\">/*转换成二维数组*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintMatrix</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*打印矩阵*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CalculateFirstNoneZeroArray</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*计算每行第一个非零元素下标*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; data; <span class=\"comment\">/*存储实际的矩阵数据，自包含非零元个数*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> matrixRowNum; <span class=\"comment\">/*矩阵行数*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> matrixColNum; <span class=\"comment\">/*矩阵列数*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> *rowFirstNoneZeroPos; <span class=\"comment\">/*每行第一个非零元素的起始位置，方便乘法*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上即为整个三元组顺序表的ADT基本结构，具体含义可见注释。接下来依次实现个函数。</p>\n<h2 id=\"三元组顺序表ADT的实现\"><a href=\"#三元组顺序表ADT的实现\" class=\"headerlink\" title=\"三元组顺序表ADT的实现\"></a>三元组顺序表ADT的实现</h2><ul>\n<li>构造函数</li>\n</ul>\n<p>构造函数主要将二维存储的稀疏矩阵转变为三元组形式存储的矩阵。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TripleTable&lt;DataType&gt;::TripleTable(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; &amp;inArray) : matrixRowNum(<span class=\"number\">-1</span>),</span><br><span class=\"line\">                                matrixColNum(<span class=\"number\">-1</span>), rowFirstNoneZeroPos(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inArray.size() &gt; <span class=\"number\">0</span> &amp;&amp; inArray[<span class=\"number\">0</span>].size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                matrixRowNum = <span class=\"keyword\">int</span>(inArray.size());</span><br><span class=\"line\">                matrixColNum = <span class=\"keyword\">int</span>(inArray[<span class=\"number\">0</span>].size());</span><br><span class=\"line\"></span><br><span class=\"line\">                TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">int</span>(inArray.size()); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"keyword\">int</span>(inArray[i].size()); j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (inArray[i][j] != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                        tmpAtom.row = i+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                        tmpAtom.col = j+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                        tmpAtom.ele = inArray[i][j];</span><br><span class=\"line\">                                        data.push_back(tmpAtom); <span class=\"comment\">/*压入*/</span></span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                CalculateFirstNoneZeroArray();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数</li>\n</ul>\n<p>析构主要释放rowFirstNoneZeroPos申请的空间，实现如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TripleTable&lt;DataType&gt;::~TripleTable&lt;DataType&gt;()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] rowFirstNoneZeroPos;</span><br><span class=\"line\">        rowFirstNoneZeroPos = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        matrixRowNum = <span class=\"number\">-1</span>; matrixColNum = <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>常规矩阵转置</li>\n</ul>\n<p>由于三元组顺序表的存储顺序是行优先依次存储，而转置后的三元组行号变成列号，原始行号有序使得转置后的列号有序，因此原始三元组转置后的一行中的列相对顺序是正确的。故此有如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::swap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::TransposeMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= matrixColNum; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; data.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (data[j].col == i) &#123;</span><br><span class=\"line\">                                tmpAtom.row = data[j].col;</span><br><span class=\"line\">                                tmpAtom.col = data[j].row;</span><br><span class=\"line\">                                tmpAtom.ele = data[j].ele;</span><br><span class=\"line\">                                newMatrix.push_back(tmpAtom); <span class=\"comment\">/*压入*/</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*转置后的矩阵*/</span></span><br><span class=\"line\">        swap(matrixRowNum, matrixColNum);</span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>快速矩阵转置</li>\n</ul>\n<p>由于在常规转置中，我们需要一行一行来处理，如果每遍历到一个三元组便知道该元素放入的位置，那么可以极大降低时间复杂度，此时我们需要计算一个转置后每行起始的位置，然后在遍历过程中可以快速填写三元组顺序表，具体实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::swap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::FastTransposeMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrixRowNum &lt;= <span class=\"number\">0</span> || matrixColNum &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> *colNum = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrixColNum]; <span class=\"comment\">/*每列非零元素数量*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> *colIndex = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrixColNum]; <span class=\"comment\">/*每列第一个非零元素起始下标*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixColNum; i++) &#123;</span><br><span class=\"line\">                colNum[i] = colIndex[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\">                ++colNum[data[i].col - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; matrixColNum; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*计算每一列第一个非零元素下标*/</span></span><br><span class=\"line\">                colIndex[i] = colIndex[i<span class=\"number\">-1</span>] + colNum[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix(data.size());</span><br><span class=\"line\">        TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                tmpAtom.row = data[i].col;</span><br><span class=\"line\">                tmpAtom.col = data[i].row;</span><br><span class=\"line\">                tmpAtom.ele = data[i].ele;</span><br><span class=\"line\"></span><br><span class=\"line\">                newMatrix[colIndex[tmpAtom.row<span class=\"number\">-1</span>]] = tmpAtom;</span><br><span class=\"line\">                ++colIndex[tmpAtom.row<span class=\"number\">-1</span>]; <span class=\"comment\">/*矩阵下标从1开始*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*转置后的矩阵*/</span></span><br><span class=\"line\">        swap(matrixRowNum, matrixColNum);</span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] colNum; <span class=\"keyword\">delete</span> [] colIndex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码增加辅助空间后便将时间复杂度降低了一个量级。</p>\n<ul>\n<li>矩阵相加</li>\n</ul>\n<p>在进行矩阵加法，首先需要判断两个矩阵是否能够相加，接着使用双下标指针分别指向第一个矩阵和第二个矩阵，如果两个指向的行列号相等只需直接相加，否则需要判断行列号大小，具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::AddMatrix(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrixRowNum != otherMatrix.matrixRowNum || matrixColNum != otherMatrix.matrixColNum) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix;</span><br><span class=\"line\">        TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; data.size() &amp;&amp; j &lt; otherMatrix.data.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (data[i].row &lt; otherMatrix.data[j].row) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].row &gt; otherMatrix.data[j].row) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(otherMatrix.data[j]); ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].col &lt; otherMatrix.data[j].col) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].col &gt; otherMatrix.data[j].col) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(otherMatrix.data[j]); ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        tmpAtom.row = data[i].row;</span><br><span class=\"line\">                        tmpAtom.col = data[i].col;</span><br><span class=\"line\">                        tmpAtom.ele = data[i].ele + otherMatrix.data[j].ele;</span><br><span class=\"line\">                        newMatrix.push_back(tmpAtom);</span><br><span class=\"line\">                        ++i; ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; data.size()) &#123;</span><br><span class=\"line\">                newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; otherMatrix.data.size()) &#123;</span><br><span class=\"line\">                newMatrix.push_back(otherMatrix.data[j]); ++j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*相加后的矩阵*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray(); <span class=\"comment\">/*重新计算*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵减法</li>\n</ul>\n<p>矩阵减法和矩阵加法类似，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::SubMatrix(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrixRowNum != otherMatrix.matrixRowNum || matrixColNum != otherMatrix.matrixColNum) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix;</span><br><span class=\"line\">        TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; data.size() &amp;&amp; j &lt; otherMatrix.data.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (data[i].row &lt; otherMatrix.data[j].row) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].row &gt; otherMatrix.data[j].row) &#123;</span><br><span class=\"line\">                        tmpAtom.row = otherMatrix.data[j].row;</span><br><span class=\"line\">                        tmpAtom.col = otherMatrix.data[j].col;</span><br><span class=\"line\">                        tmpAtom.ele = -otherMatrix.data[j].ele;</span><br><span class=\"line\">                        newMatrix.push_back(tmpAtom); ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].col &lt; otherMatrix.data[j].col) &#123;</span><br><span class=\"line\">                        newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[i].col &gt; otherMatrix.data[j].col) &#123;</span><br><span class=\"line\">                        tmpAtom.row = otherMatrix.data[j].row;</span><br><span class=\"line\">                        tmpAtom.col = otherMatrix.data[j].col;</span><br><span class=\"line\">                        tmpAtom.ele = -otherMatrix.data[j].ele;</span><br><span class=\"line\">                        newMatrix.push_back(tmpAtom); ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        tmpAtom.row = data[i].row;</span><br><span class=\"line\">                        tmpAtom.col = data[i].col;</span><br><span class=\"line\">                        tmpAtom.ele = data[i].ele - otherMatrix.data[j].ele;</span><br><span class=\"line\">                        newMatrix.push_back(tmpAtom);</span><br><span class=\"line\">                        ++i; ++j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; data.size()) &#123;</span><br><span class=\"line\">                newMatrix.push_back(data[i]); ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; otherMatrix.data.size()) &#123;</span><br><span class=\"line\">                tmpAtom.row = otherMatrix.data[j].row;</span><br><span class=\"line\">                tmpAtom.col = otherMatrix.data[j].col;</span><br><span class=\"line\">                tmpAtom.ele = -otherMatrix.data[j].ele;</span><br><span class=\"line\">                newMatrix.push_back(tmpAtom); ++j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*相减后的矩阵*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray(); <span class=\"comment\">/*重新计算*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵乘法</li>\n</ul>\n<p>矩阵乘法相对而言比较复杂，矩阵乘法如果偷懒可以先解压缩然后使用常规乘法进行计算最后再把结果进行压缩，但这样就不能体现三元组的作用了，因此需要找出一种可以直接在三元组上进行计算的乘法算法。考虑到矩阵乘法的实质是从第一个矩阵抽出一个行向量和从第二个矩阵抽出一个列向量并做向量的点乘，其中行、列号分别对应在结果矩阵中的行、列号，综合上述分析我们可以一行一行处理，其首先也需要判断运算是否合法，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::MultiMatrix(TripleTable&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrixColNum != otherMatrix.matrixRowNum) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data.size() &lt;= <span class=\"number\">0</span> || otherMatrix.data.size() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*如果有全零矩阵则相乘结果也是一个全零矩阵*/</span></span><br><span class=\"line\">                data.clear(); <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType *tmpAccumulate = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[otherMatrix.matrixColNum]; <span class=\"comment\">/*记录每行各列的累加和*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TripleAtom&lt;DataType&gt;&gt; newMatrix;</span><br><span class=\"line\">        <span class=\"comment\">/*一行一行处理*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixRowNum; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; otherMatrix.matrixColNum; j++) &#123;</span><br><span class=\"line\">                        tmpAccumulate[j] = DataType(<span class=\"number\">0</span>); <span class=\"comment\">/*清空累加器*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*行开始的地方*/</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rowBegin = rowFirstNoneZeroPos[i];</span><br><span class=\"line\">                <span class=\"comment\">/*行结束的地方*/</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rowEnd = i &gt;= matrixRowNum<span class=\"number\">-1</span> ? <span class=\"keyword\">int</span>(data.size()) : rowFirstNoneZeroPos[i+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = rowBegin; j &lt; rowEnd; j++) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">/*(m,n)*(n,k)矩阵的行,列对应下标相等才乘*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> middleIndex = data[j].col - <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> anotherRowBegin = otherMatrix.rowFirstNoneZeroPos[middleIndex];</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> anotherRowEnd = middleIndex &gt;= otherMatrix.matrixRowNum<span class=\"number\">-1</span> ? <span class=\"keyword\">int</span>(otherMatrix.data.size()) : otherMatrix.rowFirstNoneZeroPos[middleIndex+<span class=\"number\">1</span>];</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = anotherRowBegin; k &lt; anotherRowEnd; k++) &#123;</span><br><span class=\"line\">                                tmpAccumulate[otherMatrix.data[k].col <span class=\"number\">-1</span>] += data[j].ele * otherMatrix.data[k].ele;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*逐行压缩*/</span></span><br><span class=\"line\">                TripleAtom&lt;DataType&gt; tmpAtom;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; otherMatrix.matrixColNum; j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tmpAccumulate[j] != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                tmpAtom.row = i+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                tmpAtom.col = j+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                tmpAtom.ele = tmpAccumulate[j];</span><br><span class=\"line\">                                newMatrix.push_back(tmpAtom);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*修改列数*/</span></span><br><span class=\"line\">        matrixColNum = otherMatrix.matrixColNum;</span><br><span class=\"line\">        data.assign(newMatrix.begin(), newMatrix.end()); <span class=\"comment\">/*相乘后的矩阵*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        CalculateFirstNoneZeroArray(); <span class=\"comment\">/*重新计算*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] tmpAccumulate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>压缩矩阵转成二维数组</li>\n</ul>\n<p>直接遍历即可，不存在意味着是零值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; TripleTable&lt;DataType&gt;::TransformTo2DArray()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result(matrixRowNum, <span class=\"built_in\">vector</span>&lt;DataType&gt;(matrixColNum, DataType(<span class=\"number\">0</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\">                result[data[i].row<span class=\"number\">-1</span>][data[i].col<span class=\"number\">-1</span>] = data[i].ele;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印矩阵</li>\n</ul>\n<p>先调用转二维函数然后直接打印即可，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::PrintMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result = TransformTo2DArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; result[i].size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; result[i][j] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>计算每行元素的第一个下标值</li>\n</ul>\n<p>这在快速矩阵转置中实现过类似的思路，直接把代码稍作修改即可，结果见下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> TripleTable&lt;DataType&gt;::CalculateFirstNoneZeroArray()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowFirstNoneZeroPos != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> [] rowFirstNoneZeroPos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*正式给rowFirstNoneZeroPos申请空间*/</span></span><br><span class=\"line\">        rowFirstNoneZeroPos = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrixRowNum];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> *rowlNum = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrixRowNum]; <span class=\"comment\">/*每列非零元素数量*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixRowNum; i++) &#123;</span><br><span class=\"line\">                rowlNum[i] = rowFirstNoneZeroPos[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class=\"line\">                ++rowlNum[data[i].row - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; matrixRowNum; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*计算每一列第一个非零元素下标*/</span></span><br><span class=\"line\">                rowFirstNoneZeroPos[i] = rowFirstNoneZeroPos[i<span class=\"number\">-1</span>] + rowlNum[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] rowlNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>通过随机生成两个稀疏矩阵，然后依次测试各个函数是否正确，测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-100</span>), <span class=\"keyword\">int</span>(<span class=\"number\">100</span>)); <span class=\"comment\">/*不能太大，防止溢出*/</span></span><br><span class=\"line\">        uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; mnDis(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> m = mnDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> n = mnDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> k = mnDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; deltaDis1(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(m*n));</span><br><span class=\"line\">                uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; deltaDis2(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(n*k));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix1(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix2(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix3(n, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(k, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> delta1 = deltaDis1(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*这里偷个懒，矩阵1，2同时生成*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; delta1; i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> row = mnDis(randEngine) % m;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> col = mnDis(randEngine) % n;</span><br><span class=\"line\">                        testMatrix1[row][col] = intDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                        row = mnDis(randEngine) % m;</span><br><span class=\"line\">                        col = mnDis(randEngine) % n;</span><br><span class=\"line\">                        testMatrix2[row][col] = intDis(randEngine);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> delta2 = deltaDis2(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; delta2; i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> row = mnDis(randEngine) % n;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> col = mnDis(randEngine) % k;</span><br><span class=\"line\">                        testMatrix3[row][col] = intDis(randEngine);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                TripleTable&lt;<span class=\"keyword\">int</span>&gt; tripleTest1(testMatrix1);</span><br><span class=\"line\">                TripleTable&lt;<span class=\"keyword\">int</span>&gt; tripleTest2(testMatrix2);</span><br><span class=\"line\">                TripleTable&lt;<span class=\"keyword\">int</span>&gt; tripleTest3(testMatrix3);</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.TransposeMatrix(); tripleTest1.TransposeMatrix();</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"常规转置测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.FastTransposeMatrix(); tripleTest1.FastTransposeMatrix();</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"快速转置测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; addMatrix(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; addMatrix.size(); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; addMatrix[i].size(); j++) &#123;</span><br><span class=\"line\">                                addMatrix[i][j] = testMatrix1[i][j] + testMatrix2[i][j];</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.AddMatrix(tripleTest2);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵加法测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == addMatrix ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.SubMatrix(tripleTest2);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵减法测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; multiMatrix(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(k, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; multiMatrix.size(); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; multiMatrix[i].size(); j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++) &#123;</span><br><span class=\"line\">                                        multiMatrix[i][j] += testMatrix1[i][k]*testMatrix3[k][j];</span><br><span class=\"line\">                                        <span class=\"comment\">/*矩阵乘法*/</span></span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                tripleTest1.MultiMatrix(tripleTest3);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵乘法测试结果：\"</span> &lt;&lt; (tripleTest1.TransformTo2DArray() == multiMatrix ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*tripleTest1.PrintMatrix();*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">稀疏矩阵</a></p>\n<p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n"},{"title":"稀疏矩阵压缩存储之十字链表","urlname":"sparse-matrix-orthogonal-linked-list","date":"2018-06-26T12:01:50.000Z","mathjax":true,"copyright":true,"_content":"\n## 基础知识\n\n在使用三元组顺序表实现矩阵压缩存储时，三元组存放在连续的内存区域中，在进行矩阵运算时非零的元素可能变成零元素，非零元素会出现新值，此时需要移动数组中的三元组，对空间消耗是巨大的（本人三元组顺序表实现中直接开辟了一个新的数组），如果结合链表的优点，那么可以使用称为十字链表的数据结构，本文将实现之并完成矩阵常用的操作（可直接采用三元组顺序表中定义的操作）。\n\n在实现十字链表压缩存储稀疏矩阵之前，预先定义十字链表三元组节点结构如下：\n\n```cpp\ntemplate<typename DataType>\nstruct OrthAtom\n{\n        int row;       /*行号*/\n        int col;       /*列号*/\n        DataType ele;  /*存放的数据*/\n        OrthAtom *rowNext; /*同一行下一个元素*/\n        OrthAtom *colNext; /*同一列下一个元素*/\n        OrthAtom() : row(0), col(0), rowNext(nullptr), colNext(nullptr) {}\n};\n```\n\n上述结构和三元组顺序表最大的不同是增加了两个链接指针。\n\n需要是实现的矩阵基本运算主要有：\n\n- 矩阵转置：TransposeMatrix\n- 矩阵加法：AddMatrix\n- 矩阵减法：SubMatrix\n- 矩阵乘法：MultiMatrix\n- 打印矩阵：PrintMatrix\n- 清空整个矩阵：MakeEmpty\n\n## 十字链表基本定义\n\n根据上述分析可定义如下基本ADT:\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate<typename DataType>\nclass OrthList\n{\npublic:\n        OrthList(vector<vector<DataType>> &inArray);\n        ~OrthList();\n        void TransposeMatrix();         /*转置矩阵*/\n        void AddMatrix(OrthList<DataType> &otherMatrix); /*加上另外一个矩阵，第二个矩阵保持不变*/\n        void SubMatrix(OrthList<DataType> &otherMatrix); /*减去另外一个矩阵，第二个矩阵保持不变*/\n        void MultiMatrix(OrthList<DataType> &otherMatrix); /*乘上另外一个矩阵，第二个矩阵保持不变*/\n        vector<vector<DataType>> TransformTo2DArray(); /*转换成二维数组*/\n        void PrintMatrix(); /*打印矩阵*/\n        void MakeEmpty();   /*清空并释放内存*/\nprivate:\n        vector<OrthAtom<DataType>> rowDummy; /*行哑节点，内含矩阵行数*/\n        vector<OrthAtom<DataType>> colDummy; /*列哑节点，内含矩阵列数*/\n};\n```\n\n如上即为整个十字链表的ADT基本结构，基本仿照三元组顺序表中的定义，具体含义可见注释。接下来依次实现个函数。\n\n## 三元组顺序表ADT的实现\n\n- 构造函数\n\n构造函数主要将二维存储的稀疏矩阵转变为十字链表矩阵。\n\n```cpp\ntemplate<typename DataType>\nOrthList<DataType>::OrthList(vector<vector<DataType>> &inArray) : rowDummy(inArray.size()), colDummy(inArray.size() > 0 ? inArray[0].size() : 0)\n{\n        if (inArray.size() > 0 && inArray[0].size() > 0) {\n                for (int i = 0; i < int(inArray.size()); i++) {\n                        for (int j = 0; j < int(inArray[i].size()); j++) {\n                                if (inArray[i][j] != DataType(0)) {\n                                        OrthAtom<DataType> *rowIter = &rowDummy[i]; /*行遍历*/\n                                        OrthAtom<DataType> *colIter = &colDummy[j]; /*列遍历*/\n                                        while (rowIter->rowNext != nullptr && rowIter->rowNext->col < j+1) {\n                                                rowIter = rowIter->rowNext;\n                                        }\n                                        while (colIter->colNext != nullptr && colIter->colNext->row < i+1) {\n                                                colIter = colIter->colNext;\n                                        }\n                                        OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                        newNode->row = i+1; /*下标从1开始*/\n                                        newNode->col = j+1; /*下标从1开始*/\n                                        newNode->ele = inArray[i][j];\n                                        newNode->rowNext = rowIter->rowNext;\n                                        newNode->colNext = colIter->colNext;\n                                        rowIter->rowNext = colIter->colNext = newNode;\n                                }\n                        }\n                }\n        }\n}\n```\n\n上述在定位插入点位置时可以进一步优化。\n\n- 析构函数\n\n析构主要释放创建十字链表节点时申请的空间，直接调用MakeEmpty函数即可，具体代码如下：\n\n```cpp\ntemplate<typename DataType>\nOrthList<DataType>::~OrthList<DataType>()\n{\n        MakeEmpty();\n}\n```\n\n- 矩阵转置\n\n和三元组顺序表不同的是，十字链表转置只需交换节点内数据即可，具体代码如下：\n\n```cpp\n#include <algorithm>\nusing std::swap;\n\ntemplate<typename DataType>\nvoid OrthList<DataType>::TransposeMatrix()\n{\n        OrthAtom<DataType> *cycleIter = nullptr; /*遍历迭代器*/\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                cycleIter = rowDummy[i].rowNext;\n                while (cycleIter != nullptr) {\n                        OrthAtom<DataType> * tmp = cycleIter;\n                         cycleIter = cycleIter->rowNext;\n                         /*交换下标和指针*/\n                         swap(tmp->row, tmp->col);\n                         swap(tmp->rowNext, tmp->colNext);\n                 }\n                 swap(rowDummy[i].rowNext, rowDummy[i].colNext);\n         }\n\n         for (size_t i = 0; i < colDummy.size(); i++) {\n                 swap(colDummy[i].rowNext, colDummy[i].colNext);\n         }\n         swap(rowDummy, colDummy);\n}\n```\n\n- 矩阵相加\n\n在进行矩阵加法，首先需要判断两个矩阵是否能够相加，然后我们也可以借鉴三元组顺序表的处理方式，不过我们在进行加法时按照行的顺序一行一行加并且保持一个列节点数组用来指定列插入的顺序以节省插入时间，具体实现代码如下：\n\n```cpp\ntemplate<typename DataType>\nvoid OrthList<DataType>::AddMatrix(OrthList<DataType> &otherMatrix)\n{\n        if (rowDummy.size() != otherMatrix.rowDummy.size() || colDummy.size() != otherMatrix.colDummy.size() ) {\n                return;\n        }\n\n        vector<OrthAtom<DataType> *> colCycleIter(colDummy.size(), nullptr); /*列指针，方便快速插入列中*/\n        for (size_t i = 0; i < colDummy.size(); i++) {\n                colCycleIter[i] = &colDummy[i];\n        }\n\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                /*重定位列节点*/\n                for (size_t j = 0; j < colCycleIter.size(); j++) {\n                        while (colCycleIter[j]->colNext != nullptr && colCycleIter[j]->colNext->row < int(i)+1) {\n                                colCycleIter[j] = colCycleIter[j]->colNext;\n                        }\n                }\n\n                OrthAtom<DataType> *firstIter = &rowDummy[i]; /*第一个矩阵*/\n                OrthAtom<DataType> *secondIter = &otherMatrix.rowDummy[i]; /*第二个矩阵*/\n                while (firstIter->rowNext != nullptr && secondIter->rowNext != nullptr) {\n                        if (firstIter->rowNext->row < secondIter->rowNext->row) {\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->row > secondIter->rowNext->row) {\n                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                int colIndex = secondIter->rowNext->col;\n                                newNode->rowNext = firstIter->rowNext;\n                                newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                                newNode->ele = secondIter->rowNext->ele;\n                                newNode->row = secondIter->rowNext->row;\n                                newNode->col = secondIter->rowNext->col;\n                                firstIter->rowNext = newNode;\n                                colCycleIter[colIndex-1]->colNext = newNode;\n                                secondIter = secondIter->rowNext;\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->col < secondIter->rowNext->col) {\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->col > secondIter->rowNext->col) {\n                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                int colIndex = secondIter->rowNext->col;\n                                newNode->rowNext = firstIter->rowNext;\n                                newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                                newNode->ele = secondIter->rowNext->ele;\n                                newNode->row = secondIter->rowNext->row;\n                                newNode->col = secondIter->rowNext->col;\n                                firstIter->rowNext = newNode;\n                                colCycleIter[colIndex-1]->colNext = newNode;\n                                secondIter = secondIter->rowNext;\n                                firstIter = firstIter->rowNext;\n                        }\n                        else {\n                                if (firstIter->rowNext->ele + secondIter->rowNext->ele != DataType(0)) {\n                                        firstIter->rowNext->ele += secondIter->rowNext->ele;\n                                        firstIter = firstIter->rowNext;\n                                }\n                                else {\n                                        OrthAtom<DataType> *toBeDelete = firstIter->rowNext; /*待删除节点*/\n                                        firstIter->rowNext = toBeDelete->rowNext;\n                                        int colIndex = toBeDelete->col;\n                                        colCycleIter[colIndex-1]->colNext = toBeDelete->colNext;\n                                        delete toBeDelete;\n                                }\n                                secondIter = secondIter->rowNext;\n                        }\n                }\n\n                /*剩下的第二个矩阵的非零元*/\n                while (secondIter->rowNext != nullptr) {\n                        OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                        int colIndex = secondIter->rowNext->col;\n                        newNode->rowNext = firstIter->rowNext;\n                        newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                        newNode->ele = secondIter->rowNext->ele;\n                        newNode->row = secondIter->rowNext->row;\n                        newNode->col = secondIter->rowNext->col;\n                        firstIter->rowNext = newNode;\n                        colCycleIter[colIndex-1]->colNext = newNode;\n                        secondIter = secondIter->rowNext;\n                        firstIter = firstIter->rowNext;\n                }\n        }\n}\n```\n\n- 矩阵减法\n\n将加法代码稍作修改即可：\n\n```cpp\ntemplate<typename DataType>\nvoid OrthList<DataType>::SubMatrix(OrthList<DataType> &otherMatrix)\n{\n        if (rowDummy.size() != otherMatrix.rowDummy.size() || colDummy.size() != otherMatrix.colDummy.size() ) {\n                return;\n        }\n\n        vector<OrthAtom<DataType> *> colCycleIter(colDummy.size(), nullptr); /*列指针，方便快速插入列中*/\n        for (size_t i = 0; i < colDummy.size(); i++) {\n                colCycleIter[i] = &colDummy[i];\n        }\n\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                /*重定位列节点*/\n                for (size_t j = 0; j < colCycleIter.size(); j++) {\n                        while (colCycleIter[j]->colNext != nullptr && colCycleIter[j]->colNext->row < int(i)+1) {\n                                colCycleIter[j] = colCycleIter[j]->colNext;\n                        }\n                }\n\n                OrthAtom<DataType> *firstIter = &rowDummy[i]; /*第一个矩阵*/\n                OrthAtom<DataType> *secondIter = &otherMatrix.rowDummy[i]; /*第二个矩阵*/\n                while (firstIter->rowNext != nullptr && secondIter->rowNext != nullptr) {\n                        if (firstIter->rowNext->row < secondIter->rowNext->row) {\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->row > secondIter->rowNext->row) {\n                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                int colIndex = secondIter->rowNext->col;\n                                newNode->rowNext = firstIter->rowNext;\n                                newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                                newNode->ele = -secondIter->rowNext->ele;\n                                newNode->row = secondIter->rowNext->row;\n                                newNode->col = secondIter->rowNext->col;\n                                firstIter->rowNext = newNode;\n                                colCycleIter[colIndex-1]->colNext = newNode;\n                                secondIter = secondIter->rowNext;\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->col < secondIter->rowNext->col) {\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->col > secondIter->rowNext->col) {\n                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                int colIndex = secondIter->rowNext->col;\n                                newNode->rowNext = firstIter->rowNext;\n                                newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                                newNode->ele = -secondIter->rowNext->ele;\n                                newNode->row = secondIter->rowNext->row;\n                                newNode->col = secondIter->rowNext->col;\n                                firstIter->rowNext = newNode;\n                                colCycleIter[colIndex-1]->colNext = newNode;\n                                secondIter = secondIter->rowNext;\n                                firstIter = firstIter->rowNext;\n                        }\n                        else {\n                                if (firstIter->rowNext->ele - secondIter->rowNext->ele != DataType(0)) {\n                                        firstIter->rowNext->ele -= secondIter->rowNext->ele;\n                                        firstIter = firstIter->rowNext;\n                                }\n                                else {\n                                        OrthAtom<DataType> *toBeDelete = firstIter->rowNext; /*待删除节点*/\n                                        firstIter->rowNext = toBeDelete->rowNext;\n                                        int colIndex = toBeDelete->col;\n                                        colCycleIter[colIndex-1]->colNext = toBeDelete->colNext;\n                                        delete toBeDelete;\n                                }\n                                secondIter = secondIter->rowNext;\n                        }\n                }\n\n                /*剩下的第二个矩阵的非零元*/\n                while (secondIter->rowNext != nullptr) {\n                        OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                        int colIndex = secondIter->rowNext->col;\n                        newNode->rowNext = firstIter->rowNext;\n                        newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                        newNode->ele = -secondIter->rowNext->ele;\n                        newNode->row = secondIter->rowNext->row;\n                        newNode->col = secondIter->rowNext->col;\n                        firstIter->rowNext = newNode;\n                        colCycleIter[colIndex-1]->colNext = newNode;\n                        secondIter = secondIter->rowNext;\n                        firstIter = firstIter->rowNext;\n                }\n        }\n}\n```\n\n- 矩阵乘法\n\n在进行矩阵乘法时，三元组顺序表需要一个额外的数组来快速定位行，而十字链表由于自身的特性可以快速寻址任意一行，因此在仿照三元组的顺序表乘法时可以简化一部分代码，但是乘法可能会改变矩阵列数，因此需要做一些特别的处理，具体见如下代码：\n\n```cpp\ntemplate<typename DataType>\nvoid OrthList<DataType>::MultiMatrix(OrthList<DataType> &otherMatrix)\n{\n        if (colDummy.size() != otherMatrix.rowDummy.size()) {\n                return; /*是否可以相乘*/\n        }\n\n        /*只是为了快速生成数组，并不是为了复制哑节点*/\n        vector<OrthAtom<DataType>> newColDummy(otherMatrix.colDummy.begin(), otherMatrix.colDummy.end());\n\n        vector<OrthAtom<DataType> *> colCycleIter(newColDummy.size(), nullptr); /*列指针，方便快速插入列中*/\n        for (size_t i = 0; i < newColDummy.size(); i++) {\n                colCycleIter[i] = &newColDummy[i];\n                newColDummy[i].colNext = nullptr; /*清空原始数据*/\n        }\n\n        DataType *tmpAccumulate = new int[otherMatrix.colDummy.size()]; /*记录每行各列的累加和*/\n\n        /*一行一行处理*/\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n\n                for (size_t j = 0; j < otherMatrix.colDummy.size(); j++) {\n                        tmpAccumulate[j] = DataType(0); /*清空累加器*/\n                }\n\n                OrthAtom<DataType> *firstIter = rowDummy[i].rowNext; /*第一个矩阵*/\n\n                while (firstIter != nullptr) {\n                        int rowIndex = firstIter->col - 1; /*相乘矩阵的行号*/\n                        OrthAtom<DataType> *secondIter = otherMatrix.rowDummy[rowIndex].rowNext; /*第二个矩阵*/\n                        while (secondIter != nullptr) {\n                                tmpAccumulate[secondIter->col-1] += firstIter->ele * secondIter->ele;\n                                secondIter = secondIter->rowNext;\n                        }\n                        firstIter = firstIter->rowNext;\n                }\n\n                /*一行计算结束后进行压缩*/\n\n                firstIter = &rowDummy[i]; /*重定位扫描器*/\n\n                for (size_t j = 0; j < otherMatrix.colDummy.size(); j++) {\n                        if (tmpAccumulate[j] != DataType(0)) {\n                                /*行不为空*/\n                                if (firstIter->rowNext != nullptr) {\n                                        /*删除多余的节点*/\n                                        while (firstIter->rowNext != nullptr && firstIter->rowNext->col < int(j) + 1) {\n                                                OrthAtom<DataType> *toBeDelete = firstIter->rowNext; /*待删除节点*/\n                                                firstIter->rowNext = toBeDelete->rowNext;\n                                                delete toBeDelete;\n                                        }\n                                        /*如果下标相等直接修改值*/\n                                        if (firstIter->rowNext != nullptr && firstIter->rowNext->col == int(j) + 1) {\n                                                firstIter->rowNext->ele = tmpAccumulate[j];\n\n                                                firstIter->rowNext->colNext = colCycleIter[j]->colNext;\n                                                colCycleIter[j]->colNext = firstIter->rowNext;\n\n                                                firstIter = firstIter->rowNext;\n\n                                                colCycleIter[j] = colCycleIter[j]->colNext; /*由于逐行压缩，列指针向后移*/\n                                        }\n                                        else { /*否则需要创建一个新节点*/\n                                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n\n                                                newNode->rowNext = firstIter->rowNext;\n                                                newNode->colNext = colCycleIter[j]->colNext;\n                                                newNode->ele = tmpAccumulate[j];\n                                                newNode->row = i+1;\n                                                newNode->col = j+1;\n\n                                                colCycleIter[j]->colNext = newNode;\n                                                colCycleIter[j] = colCycleIter[j]->colNext;\n\n                                                firstIter->rowNext = newNode;\n                                                firstIter = firstIter->rowNext;\n                                        }\n                                }\n                                else { /*直接空了，需要新建节点*/\n                                        OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n\n                                        newNode->rowNext = firstIter->rowNext;\n                                        newNode->colNext = colCycleIter[j]->colNext;\n                                        newNode->ele = tmpAccumulate[j];\n                                        newNode->row = i+1;\n                                        newNode->col = j+1;\n\n                                        colCycleIter[j]->colNext = newNode;\n                                        colCycleIter[j] = colCycleIter[j]->colNext;\n\n                                        firstIter->rowNext = newNode;\n                                        firstIter = firstIter->rowNext;\n                                }\n                        }\n                }\n\n                /*如果此时行后面还有元素说明是遗留的元素，需要删除*/\n                while (firstIter->rowNext != nullptr) {\n                        OrthAtom<DataType> *toBeDelete = firstIter->rowNext; /*待删除节点*/\n                        firstIter->rowNext = toBeDelete->rowNext;\n                        delete toBeDelete;\n                }\n        }\n\n        /*修改列数哑节点*/\n        colDummy.assign(newColDummy.begin(), newColDummy.end());\n\n        delete [] tmpAccumulate;\n}\n```\n\n- 压缩矩阵转成二维数组\n\n直接按行遍历，具体代码如下所示：\n\n```cpp\ntemplate<typename DataType>\nvector<vector<DataType>> OrthList<DataType>::TransformTo2DArray()\n{\n        vector<vector<DataType>> result(rowDummy.size(), vector<DataType>(colDummy.size(), DataType(0)));\n\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                OrthAtom<DataType> *cycleIter = rowDummy[i].rowNext; /*按行遍历*/\n                while (cycleIter != nullptr) {\n                        result[cycleIter->row-1][cycleIter->col-1] = cycleIter->ele;\n                        cycleIter = cycleIter->rowNext;\n                }\n        }\n\n        return result;\n}\n```\n\n- 打印矩阵\n\n先调用转二维函数然后直接打印即可，代码如下：\n\n```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\n\ntemplate<typename DataType>\nvoid OrthList<DataType>::PrintMatrix()\n{\n        vector<vector<DataType>> result = TransformTo2DArray();\n\n        for (size_t i = 0; i < result.size(); i++) {\n                for (size_t j = 0; j < result[i].size(); j++) {\n                        cout << result[i][j] << \";\";\n                }\n                cout << endl;\n        }\n}\n```\n\n- 清空矩阵\n\n一行一行释放空间，代码如下：\n\n```cpp\ntemplate<typename DataType>\nvoid OrthList<DataType>::MakeEmpty()\n{\n        vector<vector<DataType>> result(rowDummy.size(), vector<DataType>(colDummy.size(), DataType(0)));\n\n        for (size_t i = 0; i < colDummy.size(); i++) {\n                colDummy[i].colNext = nullptr; /*置空指针*/\n        }\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                while (rowDummy[i].rowNext != nullptr) {\n                        OrthAtom<DataType> *toBeDelete = rowDummy[i].rowNext; /*即将被删除*/\n                        rowDummy[i].rowNext = toBeDelete->rowNext;\n                        delete toBeDelete;\n                }\n        }\n        return;\n}\n```\n\n## 代码测试\n\n通过随机生成两个稀疏矩阵，然后依次测试各个函数是否正确，测试代码如下所示：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<int> intDis(int(-100), int(100)); /*不能太大，防止溢出*/\n        uniform_int_distribution<int> mnDis(int(1), int(100));\n\n        int testTimes = 50;\n\n\twhile ((testTimes--) > 0) {\n\n                int m = mnDis(randEngine);\n                int n = mnDis(randEngine);\n                int k = mnDis(randEngine);\n\n                uniform_int_distribution<int> deltaDis1(int(1), int(m*n));\n                uniform_int_distribution<int> deltaDis2(int(1), int(n*k));\n\n                vector<vector<int>> testMatrix1(m, vector<int>(n, 0));\n                vector<vector<int>> testMatrix2(m, vector<int>(n, 0));\n                vector<vector<int>> testMatrix3(n, vector<int>(k, 0));\n\n                int delta1 = deltaDis1(randEngine);\n\n                /*这里偷个懒，矩阵1，2同时生成*/\n                for (int i = 0; i < delta1; i++) {\n                        int row = mnDis(randEngine) % m;\n                        int col = mnDis(randEngine) % n;\n                        testMatrix1[row][col] = intDis(randEngine);\n\n                        row = mnDis(randEngine) % m;\n                        col = mnDis(randEngine) % n;\n                        testMatrix2[row][col] = intDis(randEngine);\n                }\n\n                int delta2 = deltaDis2(randEngine);\n\n                for (int i = 0; i < delta2; i++) {\n                        int row = mnDis(randEngine) % n;\n                        int col = mnDis(randEngine) % k;\n                        testMatrix3[row][col] = intDis(randEngine);\n                }\n\n                OrthList<int> orthListTest1(testMatrix1);\n                OrthList<int> orthListTest2(testMatrix2);\n                OrthList<int> orthListTest3(testMatrix3);\n\n                orthListTest1.TransposeMatrix(); orthListTest1.TransposeMatrix();\n                cout << \"矩阵转置测试结果：\" << (orthListTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                vector<vector<int>> addMatrix(m, vector<int>(n, 0));\n                for (size_t i = 0; i < addMatrix.size(); i++) {\n                        for (size_t j = 0; j < addMatrix[i].size(); j++) {\n                                addMatrix[i][j] = testMatrix1[i][j] + testMatrix2[i][j];\n                        }\n                }\n\n                orthListTest1.AddMatrix(orthListTest2);\n                cout << \"矩阵加法测试结果：\" << (orthListTest1.TransformTo2DArray() == addMatrix ? \"Correct\" : \"Wrong\") << endl;\n\n                orthListTest1.SubMatrix(orthListTest2);\n                cout << \"矩阵减法测试结果：\" << (orthListTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                vector<vector<int>> multiMatrix(m, vector<int>(k, 0));\n\n                for (size_t i = 0; i < multiMatrix.size(); i++) {\n                        for (size_t j = 0; j < multiMatrix[i].size(); j++) {\n                                for (int k = 0; k < n; k++) {\n                                        multiMatrix[i][j] += testMatrix1[i][k]*testMatrix3[k][j];\n                                        /*矩阵乘法*/\n                                }\n                        }\n                }\n\n                orthListTest1.MultiMatrix(orthListTest3);\n                cout << \"矩阵乘法测试结果：\" << (orthListTest1.TransformTo2DArray() == multiMatrix ? \"Correct\" : \"Wrong\") << endl;\n\n                /*orthListTest1.PrintMatrix();*/\n        }\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[稀疏矩阵](https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5)\n\n[数据结构](https://book.douban.com/subject/2024655/)\n","source":"_posts/数据结构/稀疏矩阵压缩存储之十字链表.md","raw":"---\ntitle: 稀疏矩阵压缩存储之十字链表\nurlname: sparse-matrix-orthogonal-linked-list\ndate: 2018-06-26 20:01:50\nmathjax: true\ncopyright: true\ntags:\n- 数据结构\ncategories:\n- 数据结构\n---\n\n## 基础知识\n\n在使用三元组顺序表实现矩阵压缩存储时，三元组存放在连续的内存区域中，在进行矩阵运算时非零的元素可能变成零元素，非零元素会出现新值，此时需要移动数组中的三元组，对空间消耗是巨大的（本人三元组顺序表实现中直接开辟了一个新的数组），如果结合链表的优点，那么可以使用称为十字链表的数据结构，本文将实现之并完成矩阵常用的操作（可直接采用三元组顺序表中定义的操作）。\n\n在实现十字链表压缩存储稀疏矩阵之前，预先定义十字链表三元组节点结构如下：\n\n```cpp\ntemplate<typename DataType>\nstruct OrthAtom\n{\n        int row;       /*行号*/\n        int col;       /*列号*/\n        DataType ele;  /*存放的数据*/\n        OrthAtom *rowNext; /*同一行下一个元素*/\n        OrthAtom *colNext; /*同一列下一个元素*/\n        OrthAtom() : row(0), col(0), rowNext(nullptr), colNext(nullptr) {}\n};\n```\n\n上述结构和三元组顺序表最大的不同是增加了两个链接指针。\n\n需要是实现的矩阵基本运算主要有：\n\n- 矩阵转置：TransposeMatrix\n- 矩阵加法：AddMatrix\n- 矩阵减法：SubMatrix\n- 矩阵乘法：MultiMatrix\n- 打印矩阵：PrintMatrix\n- 清空整个矩阵：MakeEmpty\n\n## 十字链表基本定义\n\n根据上述分析可定义如下基本ADT:\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate<typename DataType>\nclass OrthList\n{\npublic:\n        OrthList(vector<vector<DataType>> &inArray);\n        ~OrthList();\n        void TransposeMatrix();         /*转置矩阵*/\n        void AddMatrix(OrthList<DataType> &otherMatrix); /*加上另外一个矩阵，第二个矩阵保持不变*/\n        void SubMatrix(OrthList<DataType> &otherMatrix); /*减去另外一个矩阵，第二个矩阵保持不变*/\n        void MultiMatrix(OrthList<DataType> &otherMatrix); /*乘上另外一个矩阵，第二个矩阵保持不变*/\n        vector<vector<DataType>> TransformTo2DArray(); /*转换成二维数组*/\n        void PrintMatrix(); /*打印矩阵*/\n        void MakeEmpty();   /*清空并释放内存*/\nprivate:\n        vector<OrthAtom<DataType>> rowDummy; /*行哑节点，内含矩阵行数*/\n        vector<OrthAtom<DataType>> colDummy; /*列哑节点，内含矩阵列数*/\n};\n```\n\n如上即为整个十字链表的ADT基本结构，基本仿照三元组顺序表中的定义，具体含义可见注释。接下来依次实现个函数。\n\n## 三元组顺序表ADT的实现\n\n- 构造函数\n\n构造函数主要将二维存储的稀疏矩阵转变为十字链表矩阵。\n\n```cpp\ntemplate<typename DataType>\nOrthList<DataType>::OrthList(vector<vector<DataType>> &inArray) : rowDummy(inArray.size()), colDummy(inArray.size() > 0 ? inArray[0].size() : 0)\n{\n        if (inArray.size() > 0 && inArray[0].size() > 0) {\n                for (int i = 0; i < int(inArray.size()); i++) {\n                        for (int j = 0; j < int(inArray[i].size()); j++) {\n                                if (inArray[i][j] != DataType(0)) {\n                                        OrthAtom<DataType> *rowIter = &rowDummy[i]; /*行遍历*/\n                                        OrthAtom<DataType> *colIter = &colDummy[j]; /*列遍历*/\n                                        while (rowIter->rowNext != nullptr && rowIter->rowNext->col < j+1) {\n                                                rowIter = rowIter->rowNext;\n                                        }\n                                        while (colIter->colNext != nullptr && colIter->colNext->row < i+1) {\n                                                colIter = colIter->colNext;\n                                        }\n                                        OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                        newNode->row = i+1; /*下标从1开始*/\n                                        newNode->col = j+1; /*下标从1开始*/\n                                        newNode->ele = inArray[i][j];\n                                        newNode->rowNext = rowIter->rowNext;\n                                        newNode->colNext = colIter->colNext;\n                                        rowIter->rowNext = colIter->colNext = newNode;\n                                }\n                        }\n                }\n        }\n}\n```\n\n上述在定位插入点位置时可以进一步优化。\n\n- 析构函数\n\n析构主要释放创建十字链表节点时申请的空间，直接调用MakeEmpty函数即可，具体代码如下：\n\n```cpp\ntemplate<typename DataType>\nOrthList<DataType>::~OrthList<DataType>()\n{\n        MakeEmpty();\n}\n```\n\n- 矩阵转置\n\n和三元组顺序表不同的是，十字链表转置只需交换节点内数据即可，具体代码如下：\n\n```cpp\n#include <algorithm>\nusing std::swap;\n\ntemplate<typename DataType>\nvoid OrthList<DataType>::TransposeMatrix()\n{\n        OrthAtom<DataType> *cycleIter = nullptr; /*遍历迭代器*/\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                cycleIter = rowDummy[i].rowNext;\n                while (cycleIter != nullptr) {\n                        OrthAtom<DataType> * tmp = cycleIter;\n                         cycleIter = cycleIter->rowNext;\n                         /*交换下标和指针*/\n                         swap(tmp->row, tmp->col);\n                         swap(tmp->rowNext, tmp->colNext);\n                 }\n                 swap(rowDummy[i].rowNext, rowDummy[i].colNext);\n         }\n\n         for (size_t i = 0; i < colDummy.size(); i++) {\n                 swap(colDummy[i].rowNext, colDummy[i].colNext);\n         }\n         swap(rowDummy, colDummy);\n}\n```\n\n- 矩阵相加\n\n在进行矩阵加法，首先需要判断两个矩阵是否能够相加，然后我们也可以借鉴三元组顺序表的处理方式，不过我们在进行加法时按照行的顺序一行一行加并且保持一个列节点数组用来指定列插入的顺序以节省插入时间，具体实现代码如下：\n\n```cpp\ntemplate<typename DataType>\nvoid OrthList<DataType>::AddMatrix(OrthList<DataType> &otherMatrix)\n{\n        if (rowDummy.size() != otherMatrix.rowDummy.size() || colDummy.size() != otherMatrix.colDummy.size() ) {\n                return;\n        }\n\n        vector<OrthAtom<DataType> *> colCycleIter(colDummy.size(), nullptr); /*列指针，方便快速插入列中*/\n        for (size_t i = 0; i < colDummy.size(); i++) {\n                colCycleIter[i] = &colDummy[i];\n        }\n\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                /*重定位列节点*/\n                for (size_t j = 0; j < colCycleIter.size(); j++) {\n                        while (colCycleIter[j]->colNext != nullptr && colCycleIter[j]->colNext->row < int(i)+1) {\n                                colCycleIter[j] = colCycleIter[j]->colNext;\n                        }\n                }\n\n                OrthAtom<DataType> *firstIter = &rowDummy[i]; /*第一个矩阵*/\n                OrthAtom<DataType> *secondIter = &otherMatrix.rowDummy[i]; /*第二个矩阵*/\n                while (firstIter->rowNext != nullptr && secondIter->rowNext != nullptr) {\n                        if (firstIter->rowNext->row < secondIter->rowNext->row) {\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->row > secondIter->rowNext->row) {\n                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                int colIndex = secondIter->rowNext->col;\n                                newNode->rowNext = firstIter->rowNext;\n                                newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                                newNode->ele = secondIter->rowNext->ele;\n                                newNode->row = secondIter->rowNext->row;\n                                newNode->col = secondIter->rowNext->col;\n                                firstIter->rowNext = newNode;\n                                colCycleIter[colIndex-1]->colNext = newNode;\n                                secondIter = secondIter->rowNext;\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->col < secondIter->rowNext->col) {\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->col > secondIter->rowNext->col) {\n                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                int colIndex = secondIter->rowNext->col;\n                                newNode->rowNext = firstIter->rowNext;\n                                newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                                newNode->ele = secondIter->rowNext->ele;\n                                newNode->row = secondIter->rowNext->row;\n                                newNode->col = secondIter->rowNext->col;\n                                firstIter->rowNext = newNode;\n                                colCycleIter[colIndex-1]->colNext = newNode;\n                                secondIter = secondIter->rowNext;\n                                firstIter = firstIter->rowNext;\n                        }\n                        else {\n                                if (firstIter->rowNext->ele + secondIter->rowNext->ele != DataType(0)) {\n                                        firstIter->rowNext->ele += secondIter->rowNext->ele;\n                                        firstIter = firstIter->rowNext;\n                                }\n                                else {\n                                        OrthAtom<DataType> *toBeDelete = firstIter->rowNext; /*待删除节点*/\n                                        firstIter->rowNext = toBeDelete->rowNext;\n                                        int colIndex = toBeDelete->col;\n                                        colCycleIter[colIndex-1]->colNext = toBeDelete->colNext;\n                                        delete toBeDelete;\n                                }\n                                secondIter = secondIter->rowNext;\n                        }\n                }\n\n                /*剩下的第二个矩阵的非零元*/\n                while (secondIter->rowNext != nullptr) {\n                        OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                        int colIndex = secondIter->rowNext->col;\n                        newNode->rowNext = firstIter->rowNext;\n                        newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                        newNode->ele = secondIter->rowNext->ele;\n                        newNode->row = secondIter->rowNext->row;\n                        newNode->col = secondIter->rowNext->col;\n                        firstIter->rowNext = newNode;\n                        colCycleIter[colIndex-1]->colNext = newNode;\n                        secondIter = secondIter->rowNext;\n                        firstIter = firstIter->rowNext;\n                }\n        }\n}\n```\n\n- 矩阵减法\n\n将加法代码稍作修改即可：\n\n```cpp\ntemplate<typename DataType>\nvoid OrthList<DataType>::SubMatrix(OrthList<DataType> &otherMatrix)\n{\n        if (rowDummy.size() != otherMatrix.rowDummy.size() || colDummy.size() != otherMatrix.colDummy.size() ) {\n                return;\n        }\n\n        vector<OrthAtom<DataType> *> colCycleIter(colDummy.size(), nullptr); /*列指针，方便快速插入列中*/\n        for (size_t i = 0; i < colDummy.size(); i++) {\n                colCycleIter[i] = &colDummy[i];\n        }\n\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                /*重定位列节点*/\n                for (size_t j = 0; j < colCycleIter.size(); j++) {\n                        while (colCycleIter[j]->colNext != nullptr && colCycleIter[j]->colNext->row < int(i)+1) {\n                                colCycleIter[j] = colCycleIter[j]->colNext;\n                        }\n                }\n\n                OrthAtom<DataType> *firstIter = &rowDummy[i]; /*第一个矩阵*/\n                OrthAtom<DataType> *secondIter = &otherMatrix.rowDummy[i]; /*第二个矩阵*/\n                while (firstIter->rowNext != nullptr && secondIter->rowNext != nullptr) {\n                        if (firstIter->rowNext->row < secondIter->rowNext->row) {\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->row > secondIter->rowNext->row) {\n                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                int colIndex = secondIter->rowNext->col;\n                                newNode->rowNext = firstIter->rowNext;\n                                newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                                newNode->ele = -secondIter->rowNext->ele;\n                                newNode->row = secondIter->rowNext->row;\n                                newNode->col = secondIter->rowNext->col;\n                                firstIter->rowNext = newNode;\n                                colCycleIter[colIndex-1]->colNext = newNode;\n                                secondIter = secondIter->rowNext;\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->col < secondIter->rowNext->col) {\n                                firstIter = firstIter->rowNext;\n                        }\n                        else if (firstIter->rowNext->col > secondIter->rowNext->col) {\n                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                                int colIndex = secondIter->rowNext->col;\n                                newNode->rowNext = firstIter->rowNext;\n                                newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                                newNode->ele = -secondIter->rowNext->ele;\n                                newNode->row = secondIter->rowNext->row;\n                                newNode->col = secondIter->rowNext->col;\n                                firstIter->rowNext = newNode;\n                                colCycleIter[colIndex-1]->colNext = newNode;\n                                secondIter = secondIter->rowNext;\n                                firstIter = firstIter->rowNext;\n                        }\n                        else {\n                                if (firstIter->rowNext->ele - secondIter->rowNext->ele != DataType(0)) {\n                                        firstIter->rowNext->ele -= secondIter->rowNext->ele;\n                                        firstIter = firstIter->rowNext;\n                                }\n                                else {\n                                        OrthAtom<DataType> *toBeDelete = firstIter->rowNext; /*待删除节点*/\n                                        firstIter->rowNext = toBeDelete->rowNext;\n                                        int colIndex = toBeDelete->col;\n                                        colCycleIter[colIndex-1]->colNext = toBeDelete->colNext;\n                                        delete toBeDelete;\n                                }\n                                secondIter = secondIter->rowNext;\n                        }\n                }\n\n                /*剩下的第二个矩阵的非零元*/\n                while (secondIter->rowNext != nullptr) {\n                        OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n                        int colIndex = secondIter->rowNext->col;\n                        newNode->rowNext = firstIter->rowNext;\n                        newNode->colNext = colCycleIter[colIndex-1]->colNext;\n                        newNode->ele = -secondIter->rowNext->ele;\n                        newNode->row = secondIter->rowNext->row;\n                        newNode->col = secondIter->rowNext->col;\n                        firstIter->rowNext = newNode;\n                        colCycleIter[colIndex-1]->colNext = newNode;\n                        secondIter = secondIter->rowNext;\n                        firstIter = firstIter->rowNext;\n                }\n        }\n}\n```\n\n- 矩阵乘法\n\n在进行矩阵乘法时，三元组顺序表需要一个额外的数组来快速定位行，而十字链表由于自身的特性可以快速寻址任意一行，因此在仿照三元组的顺序表乘法时可以简化一部分代码，但是乘法可能会改变矩阵列数，因此需要做一些特别的处理，具体见如下代码：\n\n```cpp\ntemplate<typename DataType>\nvoid OrthList<DataType>::MultiMatrix(OrthList<DataType> &otherMatrix)\n{\n        if (colDummy.size() != otherMatrix.rowDummy.size()) {\n                return; /*是否可以相乘*/\n        }\n\n        /*只是为了快速生成数组，并不是为了复制哑节点*/\n        vector<OrthAtom<DataType>> newColDummy(otherMatrix.colDummy.begin(), otherMatrix.colDummy.end());\n\n        vector<OrthAtom<DataType> *> colCycleIter(newColDummy.size(), nullptr); /*列指针，方便快速插入列中*/\n        for (size_t i = 0; i < newColDummy.size(); i++) {\n                colCycleIter[i] = &newColDummy[i];\n                newColDummy[i].colNext = nullptr; /*清空原始数据*/\n        }\n\n        DataType *tmpAccumulate = new int[otherMatrix.colDummy.size()]; /*记录每行各列的累加和*/\n\n        /*一行一行处理*/\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n\n                for (size_t j = 0; j < otherMatrix.colDummy.size(); j++) {\n                        tmpAccumulate[j] = DataType(0); /*清空累加器*/\n                }\n\n                OrthAtom<DataType> *firstIter = rowDummy[i].rowNext; /*第一个矩阵*/\n\n                while (firstIter != nullptr) {\n                        int rowIndex = firstIter->col - 1; /*相乘矩阵的行号*/\n                        OrthAtom<DataType> *secondIter = otherMatrix.rowDummy[rowIndex].rowNext; /*第二个矩阵*/\n                        while (secondIter != nullptr) {\n                                tmpAccumulate[secondIter->col-1] += firstIter->ele * secondIter->ele;\n                                secondIter = secondIter->rowNext;\n                        }\n                        firstIter = firstIter->rowNext;\n                }\n\n                /*一行计算结束后进行压缩*/\n\n                firstIter = &rowDummy[i]; /*重定位扫描器*/\n\n                for (size_t j = 0; j < otherMatrix.colDummy.size(); j++) {\n                        if (tmpAccumulate[j] != DataType(0)) {\n                                /*行不为空*/\n                                if (firstIter->rowNext != nullptr) {\n                                        /*删除多余的节点*/\n                                        while (firstIter->rowNext != nullptr && firstIter->rowNext->col < int(j) + 1) {\n                                                OrthAtom<DataType> *toBeDelete = firstIter->rowNext; /*待删除节点*/\n                                                firstIter->rowNext = toBeDelete->rowNext;\n                                                delete toBeDelete;\n                                        }\n                                        /*如果下标相等直接修改值*/\n                                        if (firstIter->rowNext != nullptr && firstIter->rowNext->col == int(j) + 1) {\n                                                firstIter->rowNext->ele = tmpAccumulate[j];\n\n                                                firstIter->rowNext->colNext = colCycleIter[j]->colNext;\n                                                colCycleIter[j]->colNext = firstIter->rowNext;\n\n                                                firstIter = firstIter->rowNext;\n\n                                                colCycleIter[j] = colCycleIter[j]->colNext; /*由于逐行压缩，列指针向后移*/\n                                        }\n                                        else { /*否则需要创建一个新节点*/\n                                                OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n\n                                                newNode->rowNext = firstIter->rowNext;\n                                                newNode->colNext = colCycleIter[j]->colNext;\n                                                newNode->ele = tmpAccumulate[j];\n                                                newNode->row = i+1;\n                                                newNode->col = j+1;\n\n                                                colCycleIter[j]->colNext = newNode;\n                                                colCycleIter[j] = colCycleIter[j]->colNext;\n\n                                                firstIter->rowNext = newNode;\n                                                firstIter = firstIter->rowNext;\n                                        }\n                                }\n                                else { /*直接空了，需要新建节点*/\n                                        OrthAtom<DataType> *newNode = new OrthAtom<DataType>; /*新节点*/\n\n                                        newNode->rowNext = firstIter->rowNext;\n                                        newNode->colNext = colCycleIter[j]->colNext;\n                                        newNode->ele = tmpAccumulate[j];\n                                        newNode->row = i+1;\n                                        newNode->col = j+1;\n\n                                        colCycleIter[j]->colNext = newNode;\n                                        colCycleIter[j] = colCycleIter[j]->colNext;\n\n                                        firstIter->rowNext = newNode;\n                                        firstIter = firstIter->rowNext;\n                                }\n                        }\n                }\n\n                /*如果此时行后面还有元素说明是遗留的元素，需要删除*/\n                while (firstIter->rowNext != nullptr) {\n                        OrthAtom<DataType> *toBeDelete = firstIter->rowNext; /*待删除节点*/\n                        firstIter->rowNext = toBeDelete->rowNext;\n                        delete toBeDelete;\n                }\n        }\n\n        /*修改列数哑节点*/\n        colDummy.assign(newColDummy.begin(), newColDummy.end());\n\n        delete [] tmpAccumulate;\n}\n```\n\n- 压缩矩阵转成二维数组\n\n直接按行遍历，具体代码如下所示：\n\n```cpp\ntemplate<typename DataType>\nvector<vector<DataType>> OrthList<DataType>::TransformTo2DArray()\n{\n        vector<vector<DataType>> result(rowDummy.size(), vector<DataType>(colDummy.size(), DataType(0)));\n\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                OrthAtom<DataType> *cycleIter = rowDummy[i].rowNext; /*按行遍历*/\n                while (cycleIter != nullptr) {\n                        result[cycleIter->row-1][cycleIter->col-1] = cycleIter->ele;\n                        cycleIter = cycleIter->rowNext;\n                }\n        }\n\n        return result;\n}\n```\n\n- 打印矩阵\n\n先调用转二维函数然后直接打印即可，代码如下：\n\n```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\n\ntemplate<typename DataType>\nvoid OrthList<DataType>::PrintMatrix()\n{\n        vector<vector<DataType>> result = TransformTo2DArray();\n\n        for (size_t i = 0; i < result.size(); i++) {\n                for (size_t j = 0; j < result[i].size(); j++) {\n                        cout << result[i][j] << \";\";\n                }\n                cout << endl;\n        }\n}\n```\n\n- 清空矩阵\n\n一行一行释放空间，代码如下：\n\n```cpp\ntemplate<typename DataType>\nvoid OrthList<DataType>::MakeEmpty()\n{\n        vector<vector<DataType>> result(rowDummy.size(), vector<DataType>(colDummy.size(), DataType(0)));\n\n        for (size_t i = 0; i < colDummy.size(); i++) {\n                colDummy[i].colNext = nullptr; /*置空指针*/\n        }\n        for (size_t i = 0; i < rowDummy.size(); i++) {\n                while (rowDummy[i].rowNext != nullptr) {\n                        OrthAtom<DataType> *toBeDelete = rowDummy[i].rowNext; /*即将被删除*/\n                        rowDummy[i].rowNext = toBeDelete->rowNext;\n                        delete toBeDelete;\n                }\n        }\n        return;\n}\n```\n\n## 代码测试\n\n通过随机生成两个稀疏矩阵，然后依次测试各个函数是否正确，测试代码如下所示：\n\n```cpp\n#include <vector>\n#include <random>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <functional>\nusing namespace std;\nusing namespace chrono;\n\nint main()\n{\n\tdefault_random_engine randEngine(unsigned(time(nullptr)));\n\tuniform_int_distribution<int> intDis(int(-100), int(100)); /*不能太大，防止溢出*/\n        uniform_int_distribution<int> mnDis(int(1), int(100));\n\n        int testTimes = 50;\n\n\twhile ((testTimes--) > 0) {\n\n                int m = mnDis(randEngine);\n                int n = mnDis(randEngine);\n                int k = mnDis(randEngine);\n\n                uniform_int_distribution<int> deltaDis1(int(1), int(m*n));\n                uniform_int_distribution<int> deltaDis2(int(1), int(n*k));\n\n                vector<vector<int>> testMatrix1(m, vector<int>(n, 0));\n                vector<vector<int>> testMatrix2(m, vector<int>(n, 0));\n                vector<vector<int>> testMatrix3(n, vector<int>(k, 0));\n\n                int delta1 = deltaDis1(randEngine);\n\n                /*这里偷个懒，矩阵1，2同时生成*/\n                for (int i = 0; i < delta1; i++) {\n                        int row = mnDis(randEngine) % m;\n                        int col = mnDis(randEngine) % n;\n                        testMatrix1[row][col] = intDis(randEngine);\n\n                        row = mnDis(randEngine) % m;\n                        col = mnDis(randEngine) % n;\n                        testMatrix2[row][col] = intDis(randEngine);\n                }\n\n                int delta2 = deltaDis2(randEngine);\n\n                for (int i = 0; i < delta2; i++) {\n                        int row = mnDis(randEngine) % n;\n                        int col = mnDis(randEngine) % k;\n                        testMatrix3[row][col] = intDis(randEngine);\n                }\n\n                OrthList<int> orthListTest1(testMatrix1);\n                OrthList<int> orthListTest2(testMatrix2);\n                OrthList<int> orthListTest3(testMatrix3);\n\n                orthListTest1.TransposeMatrix(); orthListTest1.TransposeMatrix();\n                cout << \"矩阵转置测试结果：\" << (orthListTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                vector<vector<int>> addMatrix(m, vector<int>(n, 0));\n                for (size_t i = 0; i < addMatrix.size(); i++) {\n                        for (size_t j = 0; j < addMatrix[i].size(); j++) {\n                                addMatrix[i][j] = testMatrix1[i][j] + testMatrix2[i][j];\n                        }\n                }\n\n                orthListTest1.AddMatrix(orthListTest2);\n                cout << \"矩阵加法测试结果：\" << (orthListTest1.TransformTo2DArray() == addMatrix ? \"Correct\" : \"Wrong\") << endl;\n\n                orthListTest1.SubMatrix(orthListTest2);\n                cout << \"矩阵减法测试结果：\" << (orthListTest1.TransformTo2DArray() == testMatrix1 ? \"Correct\" : \"Wrong\") << endl;\n\n                vector<vector<int>> multiMatrix(m, vector<int>(k, 0));\n\n                for (size_t i = 0; i < multiMatrix.size(); i++) {\n                        for (size_t j = 0; j < multiMatrix[i].size(); j++) {\n                                for (int k = 0; k < n; k++) {\n                                        multiMatrix[i][j] += testMatrix1[i][k]*testMatrix3[k][j];\n                                        /*矩阵乘法*/\n                                }\n                        }\n                }\n\n                orthListTest1.MultiMatrix(orthListTest3);\n                cout << \"矩阵乘法测试结果：\" << (orthListTest1.TransformTo2DArray() == multiMatrix ? \"Correct\" : \"Wrong\") << endl;\n\n                /*orthListTest1.PrintMatrix();*/\n        }\n\treturn 0;\n}\n```\n\n## 参考资料\n\n[稀疏矩阵](https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5)\n\n[数据结构](https://book.douban.com/subject/2024655/)\n","slug":"数据结构/稀疏矩阵压缩存储之十字链表","published":1,"updated":"2018-06-26T12:08:25.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnio3v0000vovnxe0v3rxk","content":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>在使用三元组顺序表实现矩阵压缩存储时，三元组存放在连续的内存区域中，在进行矩阵运算时非零的元素可能变成零元素，非零元素会出现新值，此时需要移动数组中的三元组，对空间消耗是巨大的（本人三元组顺序表实现中直接开辟了一个新的数组），如果结合链表的优点，那么可以使用称为十字链表的数据结构，本文将实现之并完成矩阵常用的操作（可直接采用三元组顺序表中定义的操作）。</p>\n<p>在实现十字链表压缩存储稀疏矩阵之前，预先定义十字链表三元组节点结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OrthAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> row;       <span class=\"comment\">/*行号*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> col;       <span class=\"comment\">/*列号*/</span></span><br><span class=\"line\">        DataType ele;  <span class=\"comment\">/*存放的数据*/</span></span><br><span class=\"line\">        OrthAtom *rowNext; <span class=\"comment\">/*同一行下一个元素*/</span></span><br><span class=\"line\">        OrthAtom *colNext; <span class=\"comment\">/*同一列下一个元素*/</span></span><br><span class=\"line\">        OrthAtom() : row(<span class=\"number\">0</span>), col(<span class=\"number\">0</span>), rowNext(<span class=\"literal\">nullptr</span>), colNext(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述结构和三元组顺序表最大的不同是增加了两个链接指针。</p>\n<p>需要是实现的矩阵基本运算主要有：</p>\n<ul>\n<li>矩阵转置：TransposeMatrix</li>\n<li>矩阵加法：AddMatrix</li>\n<li>矩阵减法：SubMatrix</li>\n<li>矩阵乘法：MultiMatrix</li>\n<li>打印矩阵：PrintMatrix</li>\n<li>清空整个矩阵：MakeEmpty</li>\n</ul>\n<h2 id=\"十字链表基本定义\"><a href=\"#十字链表基本定义\" class=\"headerlink\" title=\"十字链表基本定义\"></a>十字链表基本定义</h2><p>根据上述分析可定义如下基本ADT:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrthList</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        OrthList(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; &amp;inArray);</span><br><span class=\"line\">        ~OrthList();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TransposeMatrix</span><span class=\"params\">()</span></span>;         <span class=\"comment\">/*转置矩阵*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AddMatrix</span><span class=\"params\">(OrthList&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*加上另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SubMatrix</span><span class=\"params\">(OrthList&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*减去另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MultiMatrix</span><span class=\"params\">(OrthList&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*乘上另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; TransformTo2DArray(); <span class=\"comment\">/*转换成二维数组*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintMatrix</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*打印矩阵*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;   <span class=\"comment\">/*清空并释放内存*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt;&gt; rowDummy; <span class=\"comment\">/*行哑节点，内含矩阵行数*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt;&gt; colDummy; <span class=\"comment\">/*列哑节点，内含矩阵列数*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上即为整个十字链表的ADT基本结构，基本仿照三元组顺序表中的定义，具体含义可见注释。接下来依次实现个函数。</p>\n<h2 id=\"三元组顺序表ADT的实现\"><a href=\"#三元组顺序表ADT的实现\" class=\"headerlink\" title=\"三元组顺序表ADT的实现\"></a>三元组顺序表ADT的实现</h2><ul>\n<li>构造函数</li>\n</ul>\n<p>构造函数主要将二维存储的稀疏矩阵转变为十字链表矩阵。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">OrthList&lt;DataType&gt;::OrthList(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; &amp;inArray) : rowDummy(inArray.size()), colDummy(inArray.size() &gt; <span class=\"number\">0</span> ? inArray[<span class=\"number\">0</span>].size() : <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inArray.size() &gt; <span class=\"number\">0</span> &amp;&amp; inArray[<span class=\"number\">0</span>].size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">int</span>(inArray.size()); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"keyword\">int</span>(inArray[i].size()); j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (inArray[i][j] != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *rowIter = &amp;rowDummy[i]; <span class=\"comment\">/*行遍历*/</span></span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *colIter = &amp;colDummy[j]; <span class=\"comment\">/*列遍历*/</span></span><br><span class=\"line\">                                        <span class=\"keyword\">while</span> (rowIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; rowIter-&gt;rowNext-&gt;col &lt; j+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                                rowIter = rowIter-&gt;rowNext;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"keyword\">while</span> (colIter-&gt;colNext != <span class=\"literal\">nullptr</span> &amp;&amp; colIter-&gt;colNext-&gt;row &lt; i+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                                colIter = colIter-&gt;colNext;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                        newNode-&gt;row = i+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                        newNode-&gt;col = j+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                        newNode-&gt;ele = inArray[i][j];</span><br><span class=\"line\">                                        newNode-&gt;rowNext = rowIter-&gt;rowNext;</span><br><span class=\"line\">                                        newNode-&gt;colNext = colIter-&gt;colNext;</span><br><span class=\"line\">                                        rowIter-&gt;rowNext = colIter-&gt;colNext = newNode;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述在定位插入点位置时可以进一步优化。</p>\n<ul>\n<li>析构函数</li>\n</ul>\n<p>析构主要释放创建十字链表节点时申请的空间，直接调用MakeEmpty函数即可，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">OrthList&lt;DataType&gt;::~OrthList&lt;DataType&gt;()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        MakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵转置</li>\n</ul>\n<p>和三元组顺序表不同的是，十字链表转置只需交换节点内数据即可，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::swap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::TransposeMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        OrthAtom&lt;DataType&gt; *cycleIter = <span class=\"literal\">nullptr</span>; <span class=\"comment\">/*遍历迭代器*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                cycleIter = rowDummy[i].rowNext;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">                         cycleIter = cycleIter-&gt;rowNext;</span><br><span class=\"line\">                         <span class=\"comment\">/*交换下标和指针*/</span></span><br><span class=\"line\">                         swap(tmp-&gt;row, tmp-&gt;col);</span><br><span class=\"line\">                         swap(tmp-&gt;rowNext, tmp-&gt;colNext);</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 swap(rowDummy[i].rowNext, rowDummy[i].colNext);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; colDummy.size(); i++) &#123;</span><br><span class=\"line\">                 swap(colDummy[i].rowNext, colDummy[i].colNext);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         swap(rowDummy, colDummy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵相加</li>\n</ul>\n<p>在进行矩阵加法，首先需要判断两个矩阵是否能够相加，然后我们也可以借鉴三元组顺序表的处理方式，不过我们在进行加法时按照行的顺序一行一行加并且保持一个列节点数组用来指定列插入的顺序以节省插入时间，具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::AddMatrix(OrthList&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowDummy.size() != otherMatrix.rowDummy.size() || colDummy.size() != otherMatrix.colDummy.size() ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt; *&gt; colCycleIter(colDummy.size(), <span class=\"literal\">nullptr</span>); <span class=\"comment\">/*列指针，方便快速插入列中*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; colDummy.size(); i++) &#123;</span><br><span class=\"line\">                colCycleIter[i] = &amp;colDummy[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*重定位列节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; colCycleIter.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (colCycleIter[j]-&gt;colNext != <span class=\"literal\">nullptr</span> &amp;&amp; colCycleIter[j]-&gt;colNext-&gt;row &lt; <span class=\"keyword\">int</span>(i)+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                colCycleIter[j] = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *firstIter = &amp;rowDummy[i]; <span class=\"comment\">/*第一个矩阵*/</span></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *secondIter = &amp;otherMatrix.rowDummy[i]; <span class=\"comment\">/*第二个矩阵*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; secondIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;row &lt; secondIter-&gt;rowNext-&gt;row) &#123;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;row &gt; secondIter-&gt;rowNext-&gt;row) &#123;</span><br><span class=\"line\">                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                                newNode-&gt;ele = secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                                newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;col &lt; secondIter-&gt;rowNext-&gt;col) &#123;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;col &gt; secondIter-&gt;rowNext-&gt;col) &#123;</span><br><span class=\"line\">                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                                newNode-&gt;ele = secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                                newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;ele + secondIter-&gt;rowNext-&gt;ele != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                        firstIter-&gt;rowNext-&gt;ele += secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *toBeDelete = firstIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                                        firstIter-&gt;rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                                        <span class=\"keyword\">int</span> colIndex = toBeDelete-&gt;col;</span><br><span class=\"line\">                                        colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = toBeDelete-&gt;colNext;</span><br><span class=\"line\">                                        <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*剩下的第二个矩阵的非零元*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (secondIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                        newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                        newNode-&gt;ele = secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                        newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                        newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                        firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                        colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                        secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵减法</li>\n</ul>\n<p>将加法代码稍作修改即可：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::SubMatrix(OrthList&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowDummy.size() != otherMatrix.rowDummy.size() || colDummy.size() != otherMatrix.colDummy.size() ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt; *&gt; colCycleIter(colDummy.size(), <span class=\"literal\">nullptr</span>); <span class=\"comment\">/*列指针，方便快速插入列中*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; colDummy.size(); i++) &#123;</span><br><span class=\"line\">                colCycleIter[i] = &amp;colDummy[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*重定位列节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; colCycleIter.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (colCycleIter[j]-&gt;colNext != <span class=\"literal\">nullptr</span> &amp;&amp; colCycleIter[j]-&gt;colNext-&gt;row &lt; <span class=\"keyword\">int</span>(i)+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                colCycleIter[j] = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *firstIter = &amp;rowDummy[i]; <span class=\"comment\">/*第一个矩阵*/</span></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *secondIter = &amp;otherMatrix.rowDummy[i]; <span class=\"comment\">/*第二个矩阵*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; secondIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;row &lt; secondIter-&gt;rowNext-&gt;row) &#123;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;row &gt; secondIter-&gt;rowNext-&gt;row) &#123;</span><br><span class=\"line\">                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                                newNode-&gt;ele = -secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                                newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;col &lt; secondIter-&gt;rowNext-&gt;col) &#123;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;col &gt; secondIter-&gt;rowNext-&gt;col) &#123;</span><br><span class=\"line\">                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                                newNode-&gt;ele = -secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                                newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;ele - secondIter-&gt;rowNext-&gt;ele != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                        firstIter-&gt;rowNext-&gt;ele -= secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *toBeDelete = firstIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                                        firstIter-&gt;rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                                        <span class=\"keyword\">int</span> colIndex = toBeDelete-&gt;col;</span><br><span class=\"line\">                                        colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = toBeDelete-&gt;colNext;</span><br><span class=\"line\">                                        <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*剩下的第二个矩阵的非零元*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (secondIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                        newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                        newNode-&gt;ele = -secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                        newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                        newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                        firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                        colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                        secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵乘法</li>\n</ul>\n<p>在进行矩阵乘法时，三元组顺序表需要一个额外的数组来快速定位行，而十字链表由于自身的特性可以快速寻址任意一行，因此在仿照三元组的顺序表乘法时可以简化一部分代码，但是乘法可能会改变矩阵列数，因此需要做一些特别的处理，具体见如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::MultiMatrix(OrthList&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (colDummy.size() != otherMatrix.rowDummy.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">/*是否可以相乘*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*只是为了快速生成数组，并不是为了复制哑节点*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt;&gt; newColDummy(otherMatrix.colDummy.begin(), otherMatrix.colDummy.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt; *&gt; colCycleIter(newColDummy.size(), <span class=\"literal\">nullptr</span>); <span class=\"comment\">/*列指针，方便快速插入列中*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; newColDummy.size(); i++) &#123;</span><br><span class=\"line\">                colCycleIter[i] = &amp;newColDummy[i];</span><br><span class=\"line\">                newColDummy[i].colNext = <span class=\"literal\">nullptr</span>; <span class=\"comment\">/*清空原始数据*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType *tmpAccumulate = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[otherMatrix.colDummy.size()]; <span class=\"comment\">/*记录每行各列的累加和*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*一行一行处理*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; otherMatrix.colDummy.size(); j++) &#123;</span><br><span class=\"line\">                        tmpAccumulate[j] = DataType(<span class=\"number\">0</span>); <span class=\"comment\">/*清空累加器*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *firstIter = rowDummy[i].rowNext; <span class=\"comment\">/*第一个矩阵*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (firstIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> rowIndex = firstIter-&gt;col - <span class=\"number\">1</span>; <span class=\"comment\">/*相乘矩阵的行号*/</span></span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *secondIter = otherMatrix.rowDummy[rowIndex].rowNext; <span class=\"comment\">/*第二个矩阵*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (secondIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                                tmpAccumulate[secondIter-&gt;col<span class=\"number\">-1</span>] += firstIter-&gt;ele * secondIter-&gt;ele;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*一行计算结束后进行压缩*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                firstIter = &amp;rowDummy[i]; <span class=\"comment\">/*重定位扫描器*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; otherMatrix.colDummy.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tmpAccumulate[j] != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                <span class=\"comment\">/*行不为空*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                                        <span class=\"comment\">/*删除多余的节点*/</span></span><br><span class=\"line\">                                        <span class=\"keyword\">while</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; firstIter-&gt;rowNext-&gt;col &lt; <span class=\"keyword\">int</span>(j) + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                                OrthAtom&lt;DataType&gt; *toBeDelete = firstIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                                                firstIter-&gt;rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                                                <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"comment\">/*如果下标相等直接修改值*/</span></span><br><span class=\"line\">                                        <span class=\"keyword\">if</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; firstIter-&gt;rowNext-&gt;col == <span class=\"keyword\">int</span>(j) + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                                firstIter-&gt;rowNext-&gt;ele = tmpAccumulate[j];</span><br><span class=\"line\"></span><br><span class=\"line\">                                                firstIter-&gt;rowNext-&gt;colNext = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                                                colCycleIter[j]-&gt;colNext = firstIter-&gt;rowNext;</span><br><span class=\"line\"></span><br><span class=\"line\">                                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\"></span><br><span class=\"line\">                                                colCycleIter[j] = colCycleIter[j]-&gt;colNext; <span class=\"comment\">/*由于逐行压缩，列指针向后移*/</span></span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/*否则需要创建一个新节点*/</span></span><br><span class=\"line\">                                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                                newNode-&gt;colNext = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                                                newNode-&gt;ele = tmpAccumulate[j];</span><br><span class=\"line\">                                                newNode-&gt;row = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                                                newNode-&gt;col = j+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                                                colCycleIter[j]-&gt;colNext = newNode;</span><br><span class=\"line\">                                                colCycleIter[j] = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\"></span><br><span class=\"line\">                                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/*直接空了，需要新建节点*/</span></span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                        newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                        newNode-&gt;colNext = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                                        newNode-&gt;ele = tmpAccumulate[j];</span><br><span class=\"line\">                                        newNode-&gt;row = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                                        newNode-&gt;col = j+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                                        colCycleIter[j]-&gt;colNext = newNode;</span><br><span class=\"line\">                                        colCycleIter[j] = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\"></span><br><span class=\"line\">                                        firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*如果此时行后面还有元素说明是遗留的元素，需要删除*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *toBeDelete = firstIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                        firstIter-&gt;rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                        <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*修改列数哑节点*/</span></span><br><span class=\"line\">        colDummy.assign(newColDummy.begin(), newColDummy.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] tmpAccumulate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>压缩矩阵转成二维数组</li>\n</ul>\n<p>直接按行遍历，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; OrthList&lt;DataType&gt;::TransformTo2DArray()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result(rowDummy.size(), <span class=\"built_in\">vector</span>&lt;DataType&gt;(colDummy.size(), DataType(<span class=\"number\">0</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *cycleIter = rowDummy[i].rowNext; <span class=\"comment\">/*按行遍历*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        result[cycleIter-&gt;row<span class=\"number\">-1</span>][cycleIter-&gt;col<span class=\"number\">-1</span>] = cycleIter-&gt;ele;</span><br><span class=\"line\">                        cycleIter = cycleIter-&gt;rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印矩阵</li>\n</ul>\n<p>先调用转二维函数然后直接打印即可，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::PrintMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result = TransformTo2DArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; result[i].size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; result[i][j] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空矩阵</li>\n</ul>\n<p>一行一行释放空间，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result(rowDummy.size(), <span class=\"built_in\">vector</span>&lt;DataType&gt;(colDummy.size(), DataType(<span class=\"number\">0</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; colDummy.size(); i++) &#123;</span><br><span class=\"line\">                colDummy[i].colNext = <span class=\"literal\">nullptr</span>; <span class=\"comment\">/*置空指针*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (rowDummy[i].rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *toBeDelete = rowDummy[i].rowNext; <span class=\"comment\">/*即将被删除*/</span></span><br><span class=\"line\">                        rowDummy[i].rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                        <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>通过随机生成两个稀疏矩阵，然后依次测试各个函数是否正确，测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-100</span>), <span class=\"keyword\">int</span>(<span class=\"number\">100</span>)); <span class=\"comment\">/*不能太大，防止溢出*/</span></span><br><span class=\"line\">        uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; mnDis(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> m = mnDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> n = mnDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> k = mnDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; deltaDis1(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(m*n));</span><br><span class=\"line\">                uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; deltaDis2(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(n*k));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix1(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix2(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix3(n, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(k, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> delta1 = deltaDis1(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*这里偷个懒，矩阵1，2同时生成*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; delta1; i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> row = mnDis(randEngine) % m;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> col = mnDis(randEngine) % n;</span><br><span class=\"line\">                        testMatrix1[row][col] = intDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                        row = mnDis(randEngine) % m;</span><br><span class=\"line\">                        col = mnDis(randEngine) % n;</span><br><span class=\"line\">                        testMatrix2[row][col] = intDis(randEngine);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> delta2 = deltaDis2(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; delta2; i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> row = mnDis(randEngine) % n;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> col = mnDis(randEngine) % k;</span><br><span class=\"line\">                        testMatrix3[row][col] = intDis(randEngine);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                OrthList&lt;<span class=\"keyword\">int</span>&gt; orthListTest1(testMatrix1);</span><br><span class=\"line\">                OrthList&lt;<span class=\"keyword\">int</span>&gt; orthListTest2(testMatrix2);</span><br><span class=\"line\">                OrthList&lt;<span class=\"keyword\">int</span>&gt; orthListTest3(testMatrix3);</span><br><span class=\"line\"></span><br><span class=\"line\">                orthListTest1.TransposeMatrix(); orthListTest1.TransposeMatrix();</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵转置测试结果：\"</span> &lt;&lt; (orthListTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; addMatrix(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; addMatrix.size(); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; addMatrix[i].size(); j++) &#123;</span><br><span class=\"line\">                                addMatrix[i][j] = testMatrix1[i][j] + testMatrix2[i][j];</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                orthListTest1.AddMatrix(orthListTest2);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵加法测试结果：\"</span> &lt;&lt; (orthListTest1.TransformTo2DArray() == addMatrix ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                orthListTest1.SubMatrix(orthListTest2);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵减法测试结果：\"</span> &lt;&lt; (orthListTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; multiMatrix(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(k, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; multiMatrix.size(); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; multiMatrix[i].size(); j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++) &#123;</span><br><span class=\"line\">                                        multiMatrix[i][j] += testMatrix1[i][k]*testMatrix3[k][j];</span><br><span class=\"line\">                                        <span class=\"comment\">/*矩阵乘法*/</span></span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                orthListTest1.MultiMatrix(orthListTest3);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵乘法测试结果：\"</span> &lt;&lt; (orthListTest1.TransformTo2DArray() == multiMatrix ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*orthListTest1.PrintMatrix();*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">稀疏矩阵</a></p>\n<p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><p>在使用三元组顺序表实现矩阵压缩存储时，三元组存放在连续的内存区域中，在进行矩阵运算时非零的元素可能变成零元素，非零元素会出现新值，此时需要移动数组中的三元组，对空间消耗是巨大的（本人三元组顺序表实现中直接开辟了一个新的数组），如果结合链表的优点，那么可以使用称为十字链表的数据结构，本文将实现之并完成矩阵常用的操作（可直接采用三元组顺序表中定义的操作）。</p>\n<p>在实现十字链表压缩存储稀疏矩阵之前，预先定义十字链表三元组节点结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OrthAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> row;       <span class=\"comment\">/*行号*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> col;       <span class=\"comment\">/*列号*/</span></span><br><span class=\"line\">        DataType ele;  <span class=\"comment\">/*存放的数据*/</span></span><br><span class=\"line\">        OrthAtom *rowNext; <span class=\"comment\">/*同一行下一个元素*/</span></span><br><span class=\"line\">        OrthAtom *colNext; <span class=\"comment\">/*同一列下一个元素*/</span></span><br><span class=\"line\">        OrthAtom() : row(<span class=\"number\">0</span>), col(<span class=\"number\">0</span>), rowNext(<span class=\"literal\">nullptr</span>), colNext(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述结构和三元组顺序表最大的不同是增加了两个链接指针。</p>\n<p>需要是实现的矩阵基本运算主要有：</p>\n<ul>\n<li>矩阵转置：TransposeMatrix</li>\n<li>矩阵加法：AddMatrix</li>\n<li>矩阵减法：SubMatrix</li>\n<li>矩阵乘法：MultiMatrix</li>\n<li>打印矩阵：PrintMatrix</li>\n<li>清空整个矩阵：MakeEmpty</li>\n</ul>\n<h2 id=\"十字链表基本定义\"><a href=\"#十字链表基本定义\" class=\"headerlink\" title=\"十字链表基本定义\"></a>十字链表基本定义</h2><p>根据上述分析可定义如下基本ADT:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrthList</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        OrthList(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; &amp;inArray);</span><br><span class=\"line\">        ~OrthList();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TransposeMatrix</span><span class=\"params\">()</span></span>;         <span class=\"comment\">/*转置矩阵*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AddMatrix</span><span class=\"params\">(OrthList&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*加上另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SubMatrix</span><span class=\"params\">(OrthList&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*减去另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MultiMatrix</span><span class=\"params\">(OrthList&lt;DataType&gt; &amp;otherMatrix)</span></span>; <span class=\"comment\">/*乘上另外一个矩阵，第二个矩阵保持不变*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; TransformTo2DArray(); <span class=\"comment\">/*转换成二维数组*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintMatrix</span><span class=\"params\">()</span></span>; <span class=\"comment\">/*打印矩阵*/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeEmpty</span><span class=\"params\">()</span></span>;   <span class=\"comment\">/*清空并释放内存*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt;&gt; rowDummy; <span class=\"comment\">/*行哑节点，内含矩阵行数*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt;&gt; colDummy; <span class=\"comment\">/*列哑节点，内含矩阵列数*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上即为整个十字链表的ADT基本结构，基本仿照三元组顺序表中的定义，具体含义可见注释。接下来依次实现个函数。</p>\n<h2 id=\"三元组顺序表ADT的实现\"><a href=\"#三元组顺序表ADT的实现\" class=\"headerlink\" title=\"三元组顺序表ADT的实现\"></a>三元组顺序表ADT的实现</h2><ul>\n<li>构造函数</li>\n</ul>\n<p>构造函数主要将二维存储的稀疏矩阵转变为十字链表矩阵。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">OrthList&lt;DataType&gt;::OrthList(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; &amp;inArray) : rowDummy(inArray.size()), colDummy(inArray.size() &gt; <span class=\"number\">0</span> ? inArray[<span class=\"number\">0</span>].size() : <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inArray.size() &gt; <span class=\"number\">0</span> &amp;&amp; inArray[<span class=\"number\">0</span>].size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">int</span>(inArray.size()); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"keyword\">int</span>(inArray[i].size()); j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (inArray[i][j] != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *rowIter = &amp;rowDummy[i]; <span class=\"comment\">/*行遍历*/</span></span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *colIter = &amp;colDummy[j]; <span class=\"comment\">/*列遍历*/</span></span><br><span class=\"line\">                                        <span class=\"keyword\">while</span> (rowIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; rowIter-&gt;rowNext-&gt;col &lt; j+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                                rowIter = rowIter-&gt;rowNext;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"keyword\">while</span> (colIter-&gt;colNext != <span class=\"literal\">nullptr</span> &amp;&amp; colIter-&gt;colNext-&gt;row &lt; i+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                                colIter = colIter-&gt;colNext;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                        newNode-&gt;row = i+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                        newNode-&gt;col = j+<span class=\"number\">1</span>; <span class=\"comment\">/*下标从1开始*/</span></span><br><span class=\"line\">                                        newNode-&gt;ele = inArray[i][j];</span><br><span class=\"line\">                                        newNode-&gt;rowNext = rowIter-&gt;rowNext;</span><br><span class=\"line\">                                        newNode-&gt;colNext = colIter-&gt;colNext;</span><br><span class=\"line\">                                        rowIter-&gt;rowNext = colIter-&gt;colNext = newNode;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述在定位插入点位置时可以进一步优化。</p>\n<ul>\n<li>析构函数</li>\n</ul>\n<p>析构主要释放创建十字链表节点时申请的空间，直接调用MakeEmpty函数即可，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">OrthList&lt;DataType&gt;::~OrthList&lt;DataType&gt;()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        MakeEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵转置</li>\n</ul>\n<p>和三元组顺序表不同的是，十字链表转置只需交换节点内数据即可，具体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::swap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::TransposeMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        OrthAtom&lt;DataType&gt; *cycleIter = <span class=\"literal\">nullptr</span>; <span class=\"comment\">/*遍历迭代器*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                cycleIter = rowDummy[i].rowNext;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; * tmp = cycleIter;</span><br><span class=\"line\">                         cycleIter = cycleIter-&gt;rowNext;</span><br><span class=\"line\">                         <span class=\"comment\">/*交换下标和指针*/</span></span><br><span class=\"line\">                         swap(tmp-&gt;row, tmp-&gt;col);</span><br><span class=\"line\">                         swap(tmp-&gt;rowNext, tmp-&gt;colNext);</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 swap(rowDummy[i].rowNext, rowDummy[i].colNext);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; colDummy.size(); i++) &#123;</span><br><span class=\"line\">                 swap(colDummy[i].rowNext, colDummy[i].colNext);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         swap(rowDummy, colDummy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵相加</li>\n</ul>\n<p>在进行矩阵加法，首先需要判断两个矩阵是否能够相加，然后我们也可以借鉴三元组顺序表的处理方式，不过我们在进行加法时按照行的顺序一行一行加并且保持一个列节点数组用来指定列插入的顺序以节省插入时间，具体实现代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::AddMatrix(OrthList&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowDummy.size() != otherMatrix.rowDummy.size() || colDummy.size() != otherMatrix.colDummy.size() ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt; *&gt; colCycleIter(colDummy.size(), <span class=\"literal\">nullptr</span>); <span class=\"comment\">/*列指针，方便快速插入列中*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; colDummy.size(); i++) &#123;</span><br><span class=\"line\">                colCycleIter[i] = &amp;colDummy[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*重定位列节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; colCycleIter.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (colCycleIter[j]-&gt;colNext != <span class=\"literal\">nullptr</span> &amp;&amp; colCycleIter[j]-&gt;colNext-&gt;row &lt; <span class=\"keyword\">int</span>(i)+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                colCycleIter[j] = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *firstIter = &amp;rowDummy[i]; <span class=\"comment\">/*第一个矩阵*/</span></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *secondIter = &amp;otherMatrix.rowDummy[i]; <span class=\"comment\">/*第二个矩阵*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; secondIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;row &lt; secondIter-&gt;rowNext-&gt;row) &#123;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;row &gt; secondIter-&gt;rowNext-&gt;row) &#123;</span><br><span class=\"line\">                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                                newNode-&gt;ele = secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                                newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;col &lt; secondIter-&gt;rowNext-&gt;col) &#123;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;col &gt; secondIter-&gt;rowNext-&gt;col) &#123;</span><br><span class=\"line\">                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                                newNode-&gt;ele = secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                                newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;ele + secondIter-&gt;rowNext-&gt;ele != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                        firstIter-&gt;rowNext-&gt;ele += secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *toBeDelete = firstIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                                        firstIter-&gt;rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                                        <span class=\"keyword\">int</span> colIndex = toBeDelete-&gt;col;</span><br><span class=\"line\">                                        colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = toBeDelete-&gt;colNext;</span><br><span class=\"line\">                                        <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*剩下的第二个矩阵的非零元*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (secondIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                        newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                        newNode-&gt;ele = secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                        newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                        newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                        firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                        colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                        secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵减法</li>\n</ul>\n<p>将加法代码稍作修改即可：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::SubMatrix(OrthList&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rowDummy.size() != otherMatrix.rowDummy.size() || colDummy.size() != otherMatrix.colDummy.size() ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt; *&gt; colCycleIter(colDummy.size(), <span class=\"literal\">nullptr</span>); <span class=\"comment\">/*列指针，方便快速插入列中*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; colDummy.size(); i++) &#123;</span><br><span class=\"line\">                colCycleIter[i] = &amp;colDummy[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*重定位列节点*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; colCycleIter.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (colCycleIter[j]-&gt;colNext != <span class=\"literal\">nullptr</span> &amp;&amp; colCycleIter[j]-&gt;colNext-&gt;row &lt; <span class=\"keyword\">int</span>(i)+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                colCycleIter[j] = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *firstIter = &amp;rowDummy[i]; <span class=\"comment\">/*第一个矩阵*/</span></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *secondIter = &amp;otherMatrix.rowDummy[i]; <span class=\"comment\">/*第二个矩阵*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; secondIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;row &lt; secondIter-&gt;rowNext-&gt;row) &#123;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;row &gt; secondIter-&gt;rowNext-&gt;row) &#123;</span><br><span class=\"line\">                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                                newNode-&gt;ele = -secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                                newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;col &lt; secondIter-&gt;rowNext-&gt;col) &#123;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;col &gt; secondIter-&gt;rowNext-&gt;col) &#123;</span><br><span class=\"line\">                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                                newNode-&gt;ele = -secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                                newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (firstIter-&gt;rowNext-&gt;ele - secondIter-&gt;rowNext-&gt;ele != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                        firstIter-&gt;rowNext-&gt;ele -= secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *toBeDelete = firstIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                                        firstIter-&gt;rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                                        <span class=\"keyword\">int</span> colIndex = toBeDelete-&gt;col;</span><br><span class=\"line\">                                        colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = toBeDelete-&gt;colNext;</span><br><span class=\"line\">                                        <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*剩下的第二个矩阵的非零元*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (secondIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> colIndex = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                        newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                        newNode-&gt;colNext = colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext;</span><br><span class=\"line\">                        newNode-&gt;ele = -secondIter-&gt;rowNext-&gt;ele;</span><br><span class=\"line\">                        newNode-&gt;row = secondIter-&gt;rowNext-&gt;row;</span><br><span class=\"line\">                        newNode-&gt;col = secondIter-&gt;rowNext-&gt;col;</span><br><span class=\"line\">                        firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                        colCycleIter[colIndex<span class=\"number\">-1</span>]-&gt;colNext = newNode;</span><br><span class=\"line\">                        secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>矩阵乘法</li>\n</ul>\n<p>在进行矩阵乘法时，三元组顺序表需要一个额外的数组来快速定位行，而十字链表由于自身的特性可以快速寻址任意一行，因此在仿照三元组的顺序表乘法时可以简化一部分代码，但是乘法可能会改变矩阵列数，因此需要做一些特别的处理，具体见如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::MultiMatrix(OrthList&lt;DataType&gt; &amp;otherMatrix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (colDummy.size() != otherMatrix.rowDummy.size()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">/*是否可以相乘*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*只是为了快速生成数组，并不是为了复制哑节点*/</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt;&gt; newColDummy(otherMatrix.colDummy.begin(), otherMatrix.colDummy.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;OrthAtom&lt;DataType&gt; *&gt; colCycleIter(newColDummy.size(), <span class=\"literal\">nullptr</span>); <span class=\"comment\">/*列指针，方便快速插入列中*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; newColDummy.size(); i++) &#123;</span><br><span class=\"line\">                colCycleIter[i] = &amp;newColDummy[i];</span><br><span class=\"line\">                newColDummy[i].colNext = <span class=\"literal\">nullptr</span>; <span class=\"comment\">/*清空原始数据*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        DataType *tmpAccumulate = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[otherMatrix.colDummy.size()]; <span class=\"comment\">/*记录每行各列的累加和*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*一行一行处理*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; otherMatrix.colDummy.size(); j++) &#123;</span><br><span class=\"line\">                        tmpAccumulate[j] = DataType(<span class=\"number\">0</span>); <span class=\"comment\">/*清空累加器*/</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *firstIter = rowDummy[i].rowNext; <span class=\"comment\">/*第一个矩阵*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (firstIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> rowIndex = firstIter-&gt;col - <span class=\"number\">1</span>; <span class=\"comment\">/*相乘矩阵的行号*/</span></span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *secondIter = otherMatrix.rowDummy[rowIndex].rowNext; <span class=\"comment\">/*第二个矩阵*/</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (secondIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                                tmpAccumulate[secondIter-&gt;col<span class=\"number\">-1</span>] += firstIter-&gt;ele * secondIter-&gt;ele;</span><br><span class=\"line\">                                secondIter = secondIter-&gt;rowNext;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*一行计算结束后进行压缩*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                firstIter = &amp;rowDummy[i]; <span class=\"comment\">/*重定位扫描器*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; otherMatrix.colDummy.size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tmpAccumulate[j] != DataType(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                                <span class=\"comment\">/*行不为空*/</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                                        <span class=\"comment\">/*删除多余的节点*/</span></span><br><span class=\"line\">                                        <span class=\"keyword\">while</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; firstIter-&gt;rowNext-&gt;col &lt; <span class=\"keyword\">int</span>(j) + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                                OrthAtom&lt;DataType&gt; *toBeDelete = firstIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                                                firstIter-&gt;rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                                                <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"comment\">/*如果下标相等直接修改值*/</span></span><br><span class=\"line\">                                        <span class=\"keyword\">if</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span> &amp;&amp; firstIter-&gt;rowNext-&gt;col == <span class=\"keyword\">int</span>(j) + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                                firstIter-&gt;rowNext-&gt;ele = tmpAccumulate[j];</span><br><span class=\"line\"></span><br><span class=\"line\">                                                firstIter-&gt;rowNext-&gt;colNext = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                                                colCycleIter[j]-&gt;colNext = firstIter-&gt;rowNext;</span><br><span class=\"line\"></span><br><span class=\"line\">                                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\"></span><br><span class=\"line\">                                                colCycleIter[j] = colCycleIter[j]-&gt;colNext; <span class=\"comment\">/*由于逐行压缩，列指针向后移*/</span></span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/*否则需要创建一个新节点*/</span></span><br><span class=\"line\">                                                OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                                newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                                newNode-&gt;colNext = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                                                newNode-&gt;ele = tmpAccumulate[j];</span><br><span class=\"line\">                                                newNode-&gt;row = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                                                newNode-&gt;col = j+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                                                colCycleIter[j]-&gt;colNext = newNode;</span><br><span class=\"line\">                                                colCycleIter[j] = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\"></span><br><span class=\"line\">                                                firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                                firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/*直接空了，需要新建节点*/</span></span><br><span class=\"line\">                                        OrthAtom&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> OrthAtom&lt;DataType&gt;; <span class=\"comment\">/*新节点*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                        newNode-&gt;rowNext = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                        newNode-&gt;colNext = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\">                                        newNode-&gt;ele = tmpAccumulate[j];</span><br><span class=\"line\">                                        newNode-&gt;row = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                                        newNode-&gt;col = j+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                                        colCycleIter[j]-&gt;colNext = newNode;</span><br><span class=\"line\">                                        colCycleIter[j] = colCycleIter[j]-&gt;colNext;</span><br><span class=\"line\"></span><br><span class=\"line\">                                        firstIter-&gt;rowNext = newNode;</span><br><span class=\"line\">                                        firstIter = firstIter-&gt;rowNext;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*如果此时行后面还有元素说明是遗留的元素，需要删除*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (firstIter-&gt;rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *toBeDelete = firstIter-&gt;rowNext; <span class=\"comment\">/*待删除节点*/</span></span><br><span class=\"line\">                        firstIter-&gt;rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                        <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*修改列数哑节点*/</span></span><br><span class=\"line\">        colDummy.assign(newColDummy.begin(), newColDummy.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] tmpAccumulate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>压缩矩阵转成二维数组</li>\n</ul>\n<p>直接按行遍历，具体代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; OrthList&lt;DataType&gt;::TransformTo2DArray()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result(rowDummy.size(), <span class=\"built_in\">vector</span>&lt;DataType&gt;(colDummy.size(), DataType(<span class=\"number\">0</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                OrthAtom&lt;DataType&gt; *cycleIter = rowDummy[i].rowNext; <span class=\"comment\">/*按行遍历*/</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cycleIter != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        result[cycleIter-&gt;row<span class=\"number\">-1</span>][cycleIter-&gt;col<span class=\"number\">-1</span>] = cycleIter-&gt;ele;</span><br><span class=\"line\">                        cycleIter = cycleIter-&gt;rowNext;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>打印矩阵</li>\n</ul>\n<p>先调用转二维函数然后直接打印即可，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::PrintMatrix()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result = TransformTo2DArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; result[i].size(); j++) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">cout</span> &lt;&lt; result[i][j] &lt;&lt; <span class=\"string\">\";\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空矩阵</li>\n</ul>\n<p>一行一行释放空间，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> OrthList&lt;DataType&gt;::MakeEmpty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;DataType&gt;&gt; result(rowDummy.size(), <span class=\"built_in\">vector</span>&lt;DataType&gt;(colDummy.size(), DataType(<span class=\"number\">0</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; colDummy.size(); i++) &#123;</span><br><span class=\"line\">                colDummy[i].colNext = <span class=\"literal\">nullptr</span>; <span class=\"comment\">/*置空指针*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; rowDummy.size(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (rowDummy[i].rowNext != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        OrthAtom&lt;DataType&gt; *toBeDelete = rowDummy[i].rowNext; <span class=\"comment\">/*即将被删除*/</span></span><br><span class=\"line\">                        rowDummy[i].rowNext = toBeDelete-&gt;rowNext;</span><br><span class=\"line\">                        <span class=\"keyword\">delete</span> toBeDelete;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h2><p>通过随机生成两个稀疏矩阵，然后依次测试各个函数是否正确，测试代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> chrono;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tdefault_random_engine randEngine(unsigned(time(nullptr)));</span><br><span class=\"line\">\tuniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; intDis(<span class=\"keyword\">int</span>(<span class=\"number\">-100</span>), <span class=\"keyword\">int</span>(<span class=\"number\">100</span>)); <span class=\"comment\">/*不能太大，防止溢出*/</span></span><br><span class=\"line\">        uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; mnDis(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> testTimes = <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((testTimes--) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> m = mnDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> n = mnDis(randEngine);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> k = mnDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; deltaDis1(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(m*n));</span><br><span class=\"line\">                uniform_int_distribution&lt;<span class=\"keyword\">int</span>&gt; deltaDis2(<span class=\"keyword\">int</span>(<span class=\"number\">1</span>), <span class=\"keyword\">int</span>(n*k));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix1(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix2(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; testMatrix3(n, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(k, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> delta1 = deltaDis1(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*这里偷个懒，矩阵1，2同时生成*/</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; delta1; i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> row = mnDis(randEngine) % m;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> col = mnDis(randEngine) % n;</span><br><span class=\"line\">                        testMatrix1[row][col] = intDis(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                        row = mnDis(randEngine) % m;</span><br><span class=\"line\">                        col = mnDis(randEngine) % n;</span><br><span class=\"line\">                        testMatrix2[row][col] = intDis(randEngine);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> delta2 = deltaDis2(randEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; delta2; i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> row = mnDis(randEngine) % n;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> col = mnDis(randEngine) % k;</span><br><span class=\"line\">                        testMatrix3[row][col] = intDis(randEngine);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                OrthList&lt;<span class=\"keyword\">int</span>&gt; orthListTest1(testMatrix1);</span><br><span class=\"line\">                OrthList&lt;<span class=\"keyword\">int</span>&gt; orthListTest2(testMatrix2);</span><br><span class=\"line\">                OrthList&lt;<span class=\"keyword\">int</span>&gt; orthListTest3(testMatrix3);</span><br><span class=\"line\"></span><br><span class=\"line\">                orthListTest1.TransposeMatrix(); orthListTest1.TransposeMatrix();</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵转置测试结果：\"</span> &lt;&lt; (orthListTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; addMatrix(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; addMatrix.size(); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; addMatrix[i].size(); j++) &#123;</span><br><span class=\"line\">                                addMatrix[i][j] = testMatrix1[i][j] + testMatrix2[i][j];</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                orthListTest1.AddMatrix(orthListTest2);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵加法测试结果：\"</span> &lt;&lt; (orthListTest1.TransformTo2DArray() == addMatrix ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                orthListTest1.SubMatrix(orthListTest2);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵减法测试结果：\"</span> &lt;&lt; (orthListTest1.TransformTo2DArray() == testMatrix1 ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; multiMatrix(m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(k, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; multiMatrix.size(); i++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; multiMatrix[i].size(); j++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++) &#123;</span><br><span class=\"line\">                                        multiMatrix[i][j] += testMatrix1[i][k]*testMatrix3[k][j];</span><br><span class=\"line\">                                        <span class=\"comment\">/*矩阵乘法*/</span></span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                orthListTest1.MultiMatrix(orthListTest3);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"矩阵乘法测试结果：\"</span> &lt;&lt; (orthListTest1.TransformTo2DArray() == multiMatrix ? <span class=\"string\">\"Correct\"</span> : <span class=\"string\">\"Wrong\"</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*orthListTest1.PrintMatrix();*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">稀疏矩阵</a></p>\n<p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n"},{"title":"前、后缀表达式重建表达式树的实现","urlname":"prefix-postfix-to-expr-tree","date":"2018-07-08T07:44:46.000Z","copyright":true,"mathjax":true,"_content":"\n## 前言\n\n前、后缀表达式的基本含义可见本人的文章：[传送门](https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html)，本处不再赘述，表达式树在文中也有图示。针对只含有二元运算符的表达式树，树中所有的叶节点均为操作数，非叶节点均为操作符。前后缀表达式可以通过不同的遍历策略遍历表达式树得到，而通过前后缀表达式也可以重建得到表达式树，重建过程和二叉树的序列化与反序列化非常类似，由于操作树本身带有是叶子节点（无子节点）这一信息并且已知整棵树的根节点位置（中缀就无法直接得出根节点位置），因此可以直接根据表达式进行重建，各表达式的具体重建过程分析及代码实现见下文。\n\n先声明本文将用到的基本数据结构：\n\n```cpp\nenum OperType\n{\n        /*OPERAND-操作数，OPERATOR-操作符*/\n        OPERAND, OPERATOR\n};\n\ntemplate <typename DataType>\nunion OperData {\n        char operatorCh;\n        DataType operand;\n};\n\ntemplate <typename DataType>\nstruct ExpressionAtom\n{\n        OperType operFlag;\n        OperData<DataType> operValue;\n};\n\ntemplate <typename DataType>\nstruct TreeNode\n{\n        ExpressionAtom<DataType> nodeData;\n        TreeNode<DataType> *left; /*左子节点*/\n        TreeNode<DataType> *right; /*右子节点*/\n        TreeNode() : left(nullptr), right(nullptr) {}\n};\n```\n\n## 前缀表达式重建表达式树\n\n由于二叉树是递归定义的，因此自然而然的思路就是尝试使用递归过程来重建二叉树，同时考虑到遍历过程也能通过辅助数据结构变成非递归过程，此时也可以考虑尝试使用非递归来重建，具体递归与非递归实现见下两小节。\n\n### 前缀重建树的递归实现\n\n由于前缀表达式的第一个节点是根节点，如果节点存在子节点，则紧邻其后的为其左子节点，否则需要递归返回，即本处递归终止条件是遇到操作数节点（因为操作数是没有子节点的）或者整个表达式重建完毕，具体实现思路可见代码及注释，代码如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nTreeNode<DataType> *PrefixCore(vector<ExpressionAtom<DataType>> &inPrefix, int &index)\n{\n        if (index >= int(inPrefix.size())) {\n                return nullptr;\n        }\n        TreeNode<DataType> *newNode = new TreeNode<DataType>; /*新建节点*/\n        newNode->nodeData = inPrefix[index];\n\n        /*由于前缀表达式先序遍历得到，先建立左子树，再建立右子树*/\n        if (newNode->nodeData.operFlag != OPERAND) {\n                newNode->left = PrefixCore(inPrefix, ++index);\n                newNode->right = PrefixCore(inPrefix, ++index);\n        }\n        return newNode; /*返回新建立的节点*/\n}\n\ntemplate <typename DataType>\nTreeNode<DataType> *PrefixToExprTreeRecurve(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        if (inPrefix.size() <= 0) {\n                return nullptr;\n        }\n        int index = 0;\n        return PrefixCore(inPrefix, index);\n}\n```\n\n### 前缀重建树的非递归实现\n\n显然，如果需要不使用递归，则必须使用栈这种结构来保存中间结果。考虑到前序遍历的结果是根->左->右，因此我们可以反向遍历表达式，在遇到操作符时可以弹出栈中两个操作数（子表达式树看作一个操作数）和该操作符组成一颗子表达式树并把子表达式树根节点压入栈中，不断重复该过程直到栈中只剩下一个节点即为最终结果，具体实现可见如下代码：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nTreeNode<DataType> *PrefixToExprTree(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        if (inPrefix.size()  <= 1) {\n                return nullptr;\n        }\n        stack<TreeNode<DataType> *> nodeStack; /*放置节点指针*/\n        for (int i = int(inPrefix.size())-1; i >= 0; i--) {\n                TreeNode<DataType> *newNode = new TreeNode<DataType>; /*新建节点*/\n                newNode->nodeData = inPrefix[i];\n                /*遇到操作符弹出两个元素*/\n                if (newNode->nodeData.operFlag == OPERATOR) {\n                        TreeNode<DataType> *operand1 = nodeStack.top(); nodeStack.pop();\n                        TreeNode<DataType> *operand2 = nodeStack.top(); nodeStack.pop();\n                        /*组建子表达式树*/\n                        newNode->left = operand1;\n                        newNode->right = operand2;\n                }\n                nodeStack.push(newNode); /*节点入栈*/\n        }\n        /*返回栈顶元素*/\n        return nodeStack.top();\n}\n```\n\n### 前缀重建树代码测试\n\n考虑使用本人前面测试用的表达式树，树的形态如下图所示：[图片来源](http://www.cnblogs.com/lulipro/p/7563217.html)\n\n![表达式树](/images/expression-tree-test.png)\n\n```cpp\n#include <iostream>\n#include <vector>\nusing std::vector;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nbool isEqual(ExpressionAtom<DataType>&in1, ExpressionAtom<DataType>&in2)\n{\n\tif (in1.operFlag == in2.operFlag) {\n\t\tif (in1.operFlag == OPERAND) {\n\t\t\treturn in1.operValue.operand == in2.operValue.operand;\n\t\t}\n\t\telse {\n\t\t\treturn in1.operValue.operatorCh == in2.operValue.operatorCh;\n\t\t}\n\t}\n\treturn  false;\n}\n\ntemplate <typename DataType>\nvoid PrefixVisit(TreeNode<DataType> *root, vector<ExpressionAtom<DataType>> &result)\n{\n        if (root == nullptr) {\n                return;\n        }\n        result.push_back(root->nodeData);\n\n        PrefixVisit(root->left, result);\n        PrefixVisit(root->right, result);\n}\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        auto result = PrefixToExprTreeRecurve(testVec); /*调用相应的代码*/\n\n        vector<ExpressionAtom<int>> resultVec;\n        PrefixVisit(result, resultVec);\n\n        bool correct = true;\n\tsize_t i = 0;\n\tfor (i = 0; i < resultVec.size() && testVec.size(); i++) {\n\t\tif (!isEqual(resultVec[i], testVec[i])) {\n\t\t\tcorrect = false; break;\n\t\t}\n\t}\n\n\tif (correct && i >= resultVec.size() && i >= testVec.size()) {\n\t\tcout << \"Correct\" << endl;\n\t}\n\telse {\n\t\tcout << \"Wrong\" << endl;\n\t}\n\n        return 0;\n}\n```\n\n## 后缀表达式重建表达式树\n\n后缀表达式和前缀表达式的区别是后缀表达式的操作符是在操作数的后面，即左->右->根，因此后缀重建的递归算法可以参考前缀表达式重建算法，只需稍微改变遍历顺序即可。具体代码可见如下两小节。\n\n### 后缀重建树的递归实现\n\n正如前面所说，后缀前缀表达式不同在于根节点位置，对于后缀表达式根节点在最后，因此参考前缀表达式重建树的递归算法只需从后往前递归即可，基本实现代码如下所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nTreeNode<DataType> *PostfixCore(vector<ExpressionAtom<DataType>> &inPostfix, int &index)\n{\n        if (index < 0) {\n                return nullptr;\n        }\n        TreeNode<DataType> *newNode = new TreeNode<DataType>; /*新建节点*/\n        newNode->nodeData = inPostfix[index];\n\n        /*由于前缀遍历得到，先建立左子树，再建立右子树*/\n        if (newNode->nodeData.operFlag != OPERAND) {\n                newNode->right = PostfixCore(inPostfix, --index);\n                newNode->left = PostfixCore(inPostfix, --index);\n        }\n        return newNode; /*返回新建立的节点*/\n}\n\ntemplate <typename DataType>\nTreeNode<DataType> *PostfixToExprTreeRecurve(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        if (inPostfix.size() <= 1) {\n                return nullptr;\n        }\n        int index = int(inPostfix.size()) - 1;\n        return PostfixCore(inPostfix, index);\n}\n```\n\n### 后缀重建树的非递归实现\n\n直接把后缀计算的代码稍作修改即可，代码如下所示：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nTreeNode<DataType> *PostfixToExprTree(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        if (inPostfix.size()  <= 1) {\n                return nullptr;\n        }\n        stack<TreeNode<DataType> *> nodeStack; /*放置根结点指针*/\n        for (size_t i = 0; i < inPostfix.size(); i++) {\n                TreeNode<DataType> *newNode = new TreeNode<DataType>; /*新建节点*/\n                newNode->nodeData = inPostfix[i];\n                if (newNode->nodeData.operFlag == OPERATOR) {\n                        TreeNode<DataType> *operand1 = nodeStack.top(); nodeStack.pop();\n                        TreeNode<DataType> *operand2 = nodeStack.top(); nodeStack.pop();\n                        /*遇到操作符直接出栈两个操作数*/\n                        newNode->left = operand2;\n                        newNode->right = operand1;\n                }\n                nodeStack.push(newNode); /*操作数或者子表达式树入栈*/\n        }\n        /*返回栈顶元素*/\n        return nodeStack.top();\n}\n```\n\n\n### 后缀重建树代码测试\n\n依旧使用前缀图中的表达式树，测试代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\nusing std::vector;\nusing std::cout;\nusing std::endl;\n\n\ntemplate <typename DataType>\nvoid PostfixVisit(TreeNode<DataType> *root, vector<ExpressionAtom<DataType>> &result)\n{\n        if (root == nullptr) {\n                return;\n        }\n        PostfixVisit(root->left, result);\n        PostfixVisit(root->right, result);\n        result.push_back(root->nodeData);\n}\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        auto result = PostfixToExprTreeRecurve(testVec); /*调用具体的函数*/\n\n        vector<ExpressionAtom<int>> resultVec;\n        PostfixVisit(result, resultVec);\n\n        bool correct = true;\n\tsize_t i = 0;\n\tfor (i = 0; i < resultVec.size() && testVec.size(); i++) {\n\t\tif (!isEqual(resultVec[i], testVec[i])) {\n\t\t\tcorrect = false; break;\n\t\t}\n\t}\n\n\tif (correct && i >= resultVec.size() && i >= testVec.size()) {\n\t\tcout << \"Correct\" << endl;\n\t}\n\telse {\n\t\tcout << \"Wrong\" << endl;\n\t}\n\n        return 0;\n}\n```\n\n## 参考资料\n\n[数据结构](https://book.douban.com/subject/2024655/)\n\n[根据表达式序列构建表达式树](https://www.cnblogs.com/z-sm/p/6807308.html)\n","source":"_posts/算法设计/前_后缀表达式重建表达式树.md","raw":"---\ntitle: 前、后缀表达式重建表达式树的实现\nurlname: prefix-postfix-to-expr-tree\ndate: 2018-07-08 15:44:46\ncopyright: true\nmathjax: true\ntags:\n- 算法设计\ncategories:\n- 算法设计\n---\n\n## 前言\n\n前、后缀表达式的基本含义可见本人的文章：[传送门](https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html)，本处不再赘述，表达式树在文中也有图示。针对只含有二元运算符的表达式树，树中所有的叶节点均为操作数，非叶节点均为操作符。前后缀表达式可以通过不同的遍历策略遍历表达式树得到，而通过前后缀表达式也可以重建得到表达式树，重建过程和二叉树的序列化与反序列化非常类似，由于操作树本身带有是叶子节点（无子节点）这一信息并且已知整棵树的根节点位置（中缀就无法直接得出根节点位置），因此可以直接根据表达式进行重建，各表达式的具体重建过程分析及代码实现见下文。\n\n先声明本文将用到的基本数据结构：\n\n```cpp\nenum OperType\n{\n        /*OPERAND-操作数，OPERATOR-操作符*/\n        OPERAND, OPERATOR\n};\n\ntemplate <typename DataType>\nunion OperData {\n        char operatorCh;\n        DataType operand;\n};\n\ntemplate <typename DataType>\nstruct ExpressionAtom\n{\n        OperType operFlag;\n        OperData<DataType> operValue;\n};\n\ntemplate <typename DataType>\nstruct TreeNode\n{\n        ExpressionAtom<DataType> nodeData;\n        TreeNode<DataType> *left; /*左子节点*/\n        TreeNode<DataType> *right; /*右子节点*/\n        TreeNode() : left(nullptr), right(nullptr) {}\n};\n```\n\n## 前缀表达式重建表达式树\n\n由于二叉树是递归定义的，因此自然而然的思路就是尝试使用递归过程来重建二叉树，同时考虑到遍历过程也能通过辅助数据结构变成非递归过程，此时也可以考虑尝试使用非递归来重建，具体递归与非递归实现见下两小节。\n\n### 前缀重建树的递归实现\n\n由于前缀表达式的第一个节点是根节点，如果节点存在子节点，则紧邻其后的为其左子节点，否则需要递归返回，即本处递归终止条件是遇到操作数节点（因为操作数是没有子节点的）或者整个表达式重建完毕，具体实现思路可见代码及注释，代码如下：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nTreeNode<DataType> *PrefixCore(vector<ExpressionAtom<DataType>> &inPrefix, int &index)\n{\n        if (index >= int(inPrefix.size())) {\n                return nullptr;\n        }\n        TreeNode<DataType> *newNode = new TreeNode<DataType>; /*新建节点*/\n        newNode->nodeData = inPrefix[index];\n\n        /*由于前缀表达式先序遍历得到，先建立左子树，再建立右子树*/\n        if (newNode->nodeData.operFlag != OPERAND) {\n                newNode->left = PrefixCore(inPrefix, ++index);\n                newNode->right = PrefixCore(inPrefix, ++index);\n        }\n        return newNode; /*返回新建立的节点*/\n}\n\ntemplate <typename DataType>\nTreeNode<DataType> *PrefixToExprTreeRecurve(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        if (inPrefix.size() <= 0) {\n                return nullptr;\n        }\n        int index = 0;\n        return PrefixCore(inPrefix, index);\n}\n```\n\n### 前缀重建树的非递归实现\n\n显然，如果需要不使用递归，则必须使用栈这种结构来保存中间结果。考虑到前序遍历的结果是根->左->右，因此我们可以反向遍历表达式，在遇到操作符时可以弹出栈中两个操作数（子表达式树看作一个操作数）和该操作符组成一颗子表达式树并把子表达式树根节点压入栈中，不断重复该过程直到栈中只剩下一个节点即为最终结果，具体实现可见如下代码：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nTreeNode<DataType> *PrefixToExprTree(vector<ExpressionAtom<DataType>> &inPrefix)\n{\n        if (inPrefix.size()  <= 1) {\n                return nullptr;\n        }\n        stack<TreeNode<DataType> *> nodeStack; /*放置节点指针*/\n        for (int i = int(inPrefix.size())-1; i >= 0; i--) {\n                TreeNode<DataType> *newNode = new TreeNode<DataType>; /*新建节点*/\n                newNode->nodeData = inPrefix[i];\n                /*遇到操作符弹出两个元素*/\n                if (newNode->nodeData.operFlag == OPERATOR) {\n                        TreeNode<DataType> *operand1 = nodeStack.top(); nodeStack.pop();\n                        TreeNode<DataType> *operand2 = nodeStack.top(); nodeStack.pop();\n                        /*组建子表达式树*/\n                        newNode->left = operand1;\n                        newNode->right = operand2;\n                }\n                nodeStack.push(newNode); /*节点入栈*/\n        }\n        /*返回栈顶元素*/\n        return nodeStack.top();\n}\n```\n\n### 前缀重建树代码测试\n\n考虑使用本人前面测试用的表达式树，树的形态如下图所示：[图片来源](http://www.cnblogs.com/lulipro/p/7563217.html)\n\n![表达式树](/images/expression-tree-test.png)\n\n```cpp\n#include <iostream>\n#include <vector>\nusing std::vector;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename DataType>\nbool isEqual(ExpressionAtom<DataType>&in1, ExpressionAtom<DataType>&in2)\n{\n\tif (in1.operFlag == in2.operFlag) {\n\t\tif (in1.operFlag == OPERAND) {\n\t\t\treturn in1.operValue.operand == in2.operValue.operand;\n\t\t}\n\t\telse {\n\t\t\treturn in1.operValue.operatorCh == in2.operValue.operatorCh;\n\t\t}\n\t}\n\treturn  false;\n}\n\ntemplate <typename DataType>\nvoid PrefixVisit(TreeNode<DataType> *root, vector<ExpressionAtom<DataType>> &result)\n{\n        if (root == nullptr) {\n                return;\n        }\n        result.push_back(root->nodeData);\n\n        PrefixVisit(root->left, result);\n        PrefixVisit(root->right, result);\n}\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        auto result = PrefixToExprTreeRecurve(testVec); /*调用相应的代码*/\n\n        vector<ExpressionAtom<int>> resultVec;\n        PrefixVisit(result, resultVec);\n\n        bool correct = true;\n\tsize_t i = 0;\n\tfor (i = 0; i < resultVec.size() && testVec.size(); i++) {\n\t\tif (!isEqual(resultVec[i], testVec[i])) {\n\t\t\tcorrect = false; break;\n\t\t}\n\t}\n\n\tif (correct && i >= resultVec.size() && i >= testVec.size()) {\n\t\tcout << \"Correct\" << endl;\n\t}\n\telse {\n\t\tcout << \"Wrong\" << endl;\n\t}\n\n        return 0;\n}\n```\n\n## 后缀表达式重建表达式树\n\n后缀表达式和前缀表达式的区别是后缀表达式的操作符是在操作数的后面，即左->右->根，因此后缀重建的递归算法可以参考前缀表达式重建算法，只需稍微改变遍历顺序即可。具体代码可见如下两小节。\n\n### 后缀重建树的递归实现\n\n正如前面所说，后缀前缀表达式不同在于根节点位置，对于后缀表达式根节点在最后，因此参考前缀表达式重建树的递归算法只需从后往前递归即可，基本实现代码如下所示：\n\n```cpp\n#include <vector>\nusing std::vector;\n\ntemplate <typename DataType>\nTreeNode<DataType> *PostfixCore(vector<ExpressionAtom<DataType>> &inPostfix, int &index)\n{\n        if (index < 0) {\n                return nullptr;\n        }\n        TreeNode<DataType> *newNode = new TreeNode<DataType>; /*新建节点*/\n        newNode->nodeData = inPostfix[index];\n\n        /*由于前缀遍历得到，先建立左子树，再建立右子树*/\n        if (newNode->nodeData.operFlag != OPERAND) {\n                newNode->right = PostfixCore(inPostfix, --index);\n                newNode->left = PostfixCore(inPostfix, --index);\n        }\n        return newNode; /*返回新建立的节点*/\n}\n\ntemplate <typename DataType>\nTreeNode<DataType> *PostfixToExprTreeRecurve(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        if (inPostfix.size() <= 1) {\n                return nullptr;\n        }\n        int index = int(inPostfix.size()) - 1;\n        return PostfixCore(inPostfix, index);\n}\n```\n\n### 后缀重建树的非递归实现\n\n直接把后缀计算的代码稍作修改即可，代码如下所示：\n\n```cpp\n#include <vector>\n#include <stack>\nusing std::vector;\nusing std::stack;\n\ntemplate <typename DataType>\nTreeNode<DataType> *PostfixToExprTree(vector<ExpressionAtom<DataType>> &inPostfix)\n{\n        if (inPostfix.size()  <= 1) {\n                return nullptr;\n        }\n        stack<TreeNode<DataType> *> nodeStack; /*放置根结点指针*/\n        for (size_t i = 0; i < inPostfix.size(); i++) {\n                TreeNode<DataType> *newNode = new TreeNode<DataType>; /*新建节点*/\n                newNode->nodeData = inPostfix[i];\n                if (newNode->nodeData.operFlag == OPERATOR) {\n                        TreeNode<DataType> *operand1 = nodeStack.top(); nodeStack.pop();\n                        TreeNode<DataType> *operand2 = nodeStack.top(); nodeStack.pop();\n                        /*遇到操作符直接出栈两个操作数*/\n                        newNode->left = operand2;\n                        newNode->right = operand1;\n                }\n                nodeStack.push(newNode); /*操作数或者子表达式树入栈*/\n        }\n        /*返回栈顶元素*/\n        return nodeStack.top();\n}\n```\n\n\n### 后缀重建树代码测试\n\n依旧使用前缀图中的表达式树，测试代码如下：\n\n```cpp\n#include <iostream>\n#include <vector>\nusing std::vector;\nusing std::cout;\nusing std::endl;\n\n\ntemplate <typename DataType>\nvoid PostfixVisit(TreeNode<DataType> *root, vector<ExpressionAtom<DataType>> &result)\n{\n        if (root == nullptr) {\n                return;\n        }\n        PostfixVisit(root->left, result);\n        PostfixVisit(root->right, result);\n        result.push_back(root->nodeData);\n}\n\nint main()\n{\n        vector<ExpressionAtom<int>> testVec;\n\n        ExpressionAtom<int> manualData;\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 1;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 9;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 5;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 2;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '/';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 3;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 7;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 4;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '*';\n        testVec.push_back(manualData);\n\n\n        manualData.operFlag = OPERAND;\n        manualData.operValue.operand = 6;\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '+';\n        testVec.push_back(manualData);\n\n        manualData.operFlag = OPERATOR;\n        manualData.operValue.operatorCh = '-';\n        testVec.push_back(manualData);\n\n        auto result = PostfixToExprTreeRecurve(testVec); /*调用具体的函数*/\n\n        vector<ExpressionAtom<int>> resultVec;\n        PostfixVisit(result, resultVec);\n\n        bool correct = true;\n\tsize_t i = 0;\n\tfor (i = 0; i < resultVec.size() && testVec.size(); i++) {\n\t\tif (!isEqual(resultVec[i], testVec[i])) {\n\t\t\tcorrect = false; break;\n\t\t}\n\t}\n\n\tif (correct && i >= resultVec.size() && i >= testVec.size()) {\n\t\tcout << \"Correct\" << endl;\n\t}\n\telse {\n\t\tcout << \"Wrong\" << endl;\n\t}\n\n        return 0;\n}\n```\n\n## 参考资料\n\n[数据结构](https://book.douban.com/subject/2024655/)\n\n[根据表达式序列构建表达式树](https://www.cnblogs.com/z-sm/p/6807308.html)\n","slug":"算法设计/前_后缀表达式重建表达式树","published":1,"updated":"2018-07-08T07:58:40.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjcjs73o0000yku8lhzw7akz","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前、后缀表达式的基本含义可见本人的文章：<a href=\"https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html\" target=\"_blank\" rel=\"noopener\">传送门</a>，本处不再赘述，表达式树在文中也有图示。针对只含有二元运算符的表达式树，树中所有的叶节点均为操作数，非叶节点均为操作符。前后缀表达式可以通过不同的遍历策略遍历表达式树得到，而通过前后缀表达式也可以重建得到表达式树，重建过程和二叉树的序列化与反序列化非常类似，由于操作树本身带有是叶子节点（无子节点）这一信息并且已知整棵树的根节点位置（中缀就无法直接得出根节点位置），因此可以直接根据表达式进行重建，各表达式的具体重建过程分析及代码实现见下文。</p>\n<p>先声明本文将用到的基本数据结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> OperType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*OPERAND-操作数，OPERATOR-操作符*/</span></span><br><span class=\"line\">        OPERAND, OPERATOR</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">union</span> OperData &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> operatorCh;</span><br><span class=\"line\">        DataType operand;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ExpressionAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        OperType operFlag;</span><br><span class=\"line\">        OperData&lt;DataType&gt; operValue;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        ExpressionAtom&lt;DataType&gt; nodeData;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *left; <span class=\"comment\">/*左子节点*/</span></span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *right; <span class=\"comment\">/*右子节点*/</span></span><br><span class=\"line\">        TreeNode() : left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀表达式重建表达式树\"><a href=\"#前缀表达式重建表达式树\" class=\"headerlink\" title=\"前缀表达式重建表达式树\"></a>前缀表达式重建表达式树</h2><p>由于二叉树是递归定义的，因此自然而然的思路就是尝试使用递归过程来重建二叉树，同时考虑到遍历过程也能通过辅助数据结构变成非递归过程，此时也可以考虑尝试使用非递归来重建，具体递归与非递归实现见下两小节。</p>\n<h3 id=\"前缀重建树的递归实现\"><a href=\"#前缀重建树的递归实现\" class=\"headerlink\" title=\"前缀重建树的递归实现\"></a>前缀重建树的递归实现</h3><p>由于前缀表达式的第一个节点是根节点，如果节点存在子节点，则紧邻其后的为其左子节点，否则需要递归返回，即本处递归终止条件是遇到操作数节点（因为操作数是没有子节点的）或者整个表达式重建完毕，具体实现思路可见代码及注释，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PrefixCore(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix, <span class=\"keyword\">int</span> &amp;index)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= <span class=\"keyword\">int</span>(inPrefix.size())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> TreeNode&lt;DataType&gt;; <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">        newNode-&gt;nodeData = inPrefix[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*由于前缀表达式先序遍历得到，先建立左子树，再建立右子树*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newNode-&gt;nodeData.operFlag != OPERAND) &#123;</span><br><span class=\"line\">                newNode-&gt;left = PrefixCore(inPrefix, ++index);</span><br><span class=\"line\">                newNode-&gt;right = PrefixCore(inPrefix, ++index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode; <span class=\"comment\">/*返回新建立的节点*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PrefixToExprTreeRecurve(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inPrefix.size() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> PrefixCore(inPrefix, index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"前缀重建树的非递归实现\"><a href=\"#前缀重建树的非递归实现\" class=\"headerlink\" title=\"前缀重建树的非递归实现\"></a>前缀重建树的非递归实现</h3><p>显然，如果需要不使用递归，则必须使用栈这种结构来保存中间结果。考虑到前序遍历的结果是根-&gt;左-&gt;右，因此我们可以反向遍历表达式，在遇到操作符时可以弹出栈中两个操作数（子表达式树看作一个操作数）和该操作符组成一颗子表达式树并把子表达式树根节点压入栈中，不断重复该过程直到栈中只剩下一个节点即为最终结果，具体实现可见如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PrefixToExprTree(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inPrefix.size()  &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack; <span class=\"comment\">/*放置节点指针*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"keyword\">int</span>(inPrefix.size())<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> TreeNode&lt;DataType&gt;; <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">                newNode-&gt;nodeData = inPrefix[i];</span><br><span class=\"line\">                <span class=\"comment\">/*遇到操作符弹出两个元素*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newNode-&gt;nodeData.operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        TreeNode&lt;DataType&gt; *operand1 = nodeStack.top(); nodeStack.pop();</span><br><span class=\"line\">                        TreeNode&lt;DataType&gt; *operand2 = nodeStack.top(); nodeStack.pop();</span><br><span class=\"line\">                        <span class=\"comment\">/*组建子表达式树*/</span></span><br><span class=\"line\">                        newNode-&gt;left = operand1;</span><br><span class=\"line\">                        newNode-&gt;right = operand2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nodeStack.push(newNode); <span class=\"comment\">/*节点入栈*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*返回栈顶元素*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nodeStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"前缀重建树代码测试\"><a href=\"#前缀重建树代码测试\" class=\"headerlink\" title=\"前缀重建树代码测试\"></a>前缀重建树代码测试</h3><p>考虑使用本人前面测试用的表达式树，树的形态如下图所示：<a href=\"http://www.cnblogs.com/lulipro/p/7563217.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/expression-tree-test.png\" alt=\"表达式树\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEqual</span><span class=\"params\">(ExpressionAtom&lt;DataType&gt;&amp;in1, ExpressionAtom&lt;DataType&gt;&amp;in2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (in1.operFlag == in2.operFlag) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (in1.operFlag == OPERAND) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> in1.operValue.operand == in2.operValue.operand;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> in1.operValue.operatorCh == in2.operValue.operatorCh;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrefixVisit</span><span class=\"params\">(TreeNode&lt;DataType&gt; *root, <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result.push_back(root-&gt;nodeData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrefixVisit(root-&gt;left, result);</span><br><span class=\"line\">        PrefixVisit(root-&gt;right, result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PrefixToExprTreeRecurve(testVec); <span class=\"comment\">/*调用相应的代码*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; resultVec;</span><br><span class=\"line\">        PrefixVisit(result, resultVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> correct = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; resultVec.size() &amp;&amp; testVec.size(); i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEqual(resultVec[i], testVec[i])) &#123;</span><br><span class=\"line\">\t\t\tcorrect = <span class=\"literal\">false</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (correct &amp;&amp; i &gt;= resultVec.size() &amp;&amp; i &gt;= testVec.size()) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Correct\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Wrong\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀表达式重建表达式树\"><a href=\"#后缀表达式重建表达式树\" class=\"headerlink\" title=\"后缀表达式重建表达式树\"></a>后缀表达式重建表达式树</h2><p>后缀表达式和前缀表达式的区别是后缀表达式的操作符是在操作数的后面，即左-&gt;右-&gt;根，因此后缀重建的递归算法可以参考前缀表达式重建算法，只需稍微改变遍历顺序即可。具体代码可见如下两小节。</p>\n<h3 id=\"后缀重建树的递归实现\"><a href=\"#后缀重建树的递归实现\" class=\"headerlink\" title=\"后缀重建树的递归实现\"></a>后缀重建树的递归实现</h3><p>正如前面所说，后缀前缀表达式不同在于根节点位置，对于后缀表达式根节点在最后，因此参考前缀表达式重建树的递归算法只需从后往前递归即可，基本实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PostfixCore(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix, <span class=\"keyword\">int</span> &amp;index)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> TreeNode&lt;DataType&gt;; <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">        newNode-&gt;nodeData = inPostfix[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*由于前缀遍历得到，先建立左子树，再建立右子树*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newNode-&gt;nodeData.operFlag != OPERAND) &#123;</span><br><span class=\"line\">                newNode-&gt;right = PostfixCore(inPostfix, --index);</span><br><span class=\"line\">                newNode-&gt;left = PostfixCore(inPostfix, --index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode; <span class=\"comment\">/*返回新建立的节点*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PostfixToExprTreeRecurve(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inPostfix.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"keyword\">int</span>(inPostfix.size()) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> PostfixCore(inPostfix, index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后缀重建树的非递归实现\"><a href=\"#后缀重建树的非递归实现\" class=\"headerlink\" title=\"后缀重建树的非递归实现\"></a>后缀重建树的非递归实现</h3><p>直接把后缀计算的代码稍作修改即可，代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PostfixToExprTree(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inPostfix.size()  &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack; <span class=\"comment\">/*放置根结点指针*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inPostfix.size(); i++) &#123;</span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> TreeNode&lt;DataType&gt;; <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">                newNode-&gt;nodeData = inPostfix[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newNode-&gt;nodeData.operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        TreeNode&lt;DataType&gt; *operand1 = nodeStack.top(); nodeStack.pop();</span><br><span class=\"line\">                        TreeNode&lt;DataType&gt; *operand2 = nodeStack.top(); nodeStack.pop();</span><br><span class=\"line\">                        <span class=\"comment\">/*遇到操作符直接出栈两个操作数*/</span></span><br><span class=\"line\">                        newNode-&gt;left = operand2;</span><br><span class=\"line\">                        newNode-&gt;right = operand1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nodeStack.push(newNode); <span class=\"comment\">/*操作数或者子表达式树入栈*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*返回栈顶元素*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nodeStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后缀重建树代码测试\"><a href=\"#后缀重建树代码测试\" class=\"headerlink\" title=\"后缀重建树代码测试\"></a>后缀重建树代码测试</h3><p>依旧使用前缀图中的表达式树，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostfixVisit</span><span class=\"params\">(TreeNode&lt;DataType&gt; *root, <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PostfixVisit(root-&gt;left, result);</span><br><span class=\"line\">        PostfixVisit(root-&gt;right, result);</span><br><span class=\"line\">        result.push_back(root-&gt;nodeData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PostfixToExprTreeRecurve(testVec); <span class=\"comment\">/*调用具体的函数*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; resultVec;</span><br><span class=\"line\">        PostfixVisit(result, resultVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> correct = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; resultVec.size() &amp;&amp; testVec.size(); i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEqual(resultVec[i], testVec[i])) &#123;</span><br><span class=\"line\">\t\t\tcorrect = <span class=\"literal\">false</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (correct &amp;&amp; i &gt;= resultVec.size() &amp;&amp; i &gt;= testVec.size()) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Correct\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Wrong\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n<p><a href=\"https://www.cnblogs.com/z-sm/p/6807308.html\" target=\"_blank\" rel=\"noopener\">根据表达式序列构建表达式树</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前、后缀表达式的基本含义可见本人的文章：<a href=\"https://hsuloong.github.io/algorithms-design/prefix-infix-to-postfix.html\" target=\"_blank\" rel=\"noopener\">传送门</a>，本处不再赘述，表达式树在文中也有图示。针对只含有二元运算符的表达式树，树中所有的叶节点均为操作数，非叶节点均为操作符。前后缀表达式可以通过不同的遍历策略遍历表达式树得到，而通过前后缀表达式也可以重建得到表达式树，重建过程和二叉树的序列化与反序列化非常类似，由于操作树本身带有是叶子节点（无子节点）这一信息并且已知整棵树的根节点位置（中缀就无法直接得出根节点位置），因此可以直接根据表达式进行重建，各表达式的具体重建过程分析及代码实现见下文。</p>\n<p>先声明本文将用到的基本数据结构：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> OperType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*OPERAND-操作数，OPERATOR-操作符*/</span></span><br><span class=\"line\">        OPERAND, OPERATOR</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"keyword\">union</span> OperData &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> operatorCh;</span><br><span class=\"line\">        DataType operand;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ExpressionAtom</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        OperType operFlag;</span><br><span class=\"line\">        OperData&lt;DataType&gt; operValue;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">        ExpressionAtom&lt;DataType&gt; nodeData;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *left; <span class=\"comment\">/*左子节点*/</span></span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *right; <span class=\"comment\">/*右子节点*/</span></span><br><span class=\"line\">        TreeNode() : left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀表达式重建表达式树\"><a href=\"#前缀表达式重建表达式树\" class=\"headerlink\" title=\"前缀表达式重建表达式树\"></a>前缀表达式重建表达式树</h2><p>由于二叉树是递归定义的，因此自然而然的思路就是尝试使用递归过程来重建二叉树，同时考虑到遍历过程也能通过辅助数据结构变成非递归过程，此时也可以考虑尝试使用非递归来重建，具体递归与非递归实现见下两小节。</p>\n<h3 id=\"前缀重建树的递归实现\"><a href=\"#前缀重建树的递归实现\" class=\"headerlink\" title=\"前缀重建树的递归实现\"></a>前缀重建树的递归实现</h3><p>由于前缀表达式的第一个节点是根节点，如果节点存在子节点，则紧邻其后的为其左子节点，否则需要递归返回，即本处递归终止条件是遇到操作数节点（因为操作数是没有子节点的）或者整个表达式重建完毕，具体实现思路可见代码及注释，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PrefixCore(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix, <span class=\"keyword\">int</span> &amp;index)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= <span class=\"keyword\">int</span>(inPrefix.size())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> TreeNode&lt;DataType&gt;; <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">        newNode-&gt;nodeData = inPrefix[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*由于前缀表达式先序遍历得到，先建立左子树，再建立右子树*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newNode-&gt;nodeData.operFlag != OPERAND) &#123;</span><br><span class=\"line\">                newNode-&gt;left = PrefixCore(inPrefix, ++index);</span><br><span class=\"line\">                newNode-&gt;right = PrefixCore(inPrefix, ++index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode; <span class=\"comment\">/*返回新建立的节点*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PrefixToExprTreeRecurve(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inPrefix.size() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> PrefixCore(inPrefix, index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"前缀重建树的非递归实现\"><a href=\"#前缀重建树的非递归实现\" class=\"headerlink\" title=\"前缀重建树的非递归实现\"></a>前缀重建树的非递归实现</h3><p>显然，如果需要不使用递归，则必须使用栈这种结构来保存中间结果。考虑到前序遍历的结果是根-&gt;左-&gt;右，因此我们可以反向遍历表达式，在遇到操作符时可以弹出栈中两个操作数（子表达式树看作一个操作数）和该操作符组成一颗子表达式树并把子表达式树根节点压入栈中，不断重复该过程直到栈中只剩下一个节点即为最终结果，具体实现可见如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PrefixToExprTree(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPrefix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inPrefix.size()  &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack; <span class=\"comment\">/*放置节点指针*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"keyword\">int</span>(inPrefix.size())<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> TreeNode&lt;DataType&gt;; <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">                newNode-&gt;nodeData = inPrefix[i];</span><br><span class=\"line\">                <span class=\"comment\">/*遇到操作符弹出两个元素*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newNode-&gt;nodeData.operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        TreeNode&lt;DataType&gt; *operand1 = nodeStack.top(); nodeStack.pop();</span><br><span class=\"line\">                        TreeNode&lt;DataType&gt; *operand2 = nodeStack.top(); nodeStack.pop();</span><br><span class=\"line\">                        <span class=\"comment\">/*组建子表达式树*/</span></span><br><span class=\"line\">                        newNode-&gt;left = operand1;</span><br><span class=\"line\">                        newNode-&gt;right = operand2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nodeStack.push(newNode); <span class=\"comment\">/*节点入栈*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*返回栈顶元素*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nodeStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"前缀重建树代码测试\"><a href=\"#前缀重建树代码测试\" class=\"headerlink\" title=\"前缀重建树代码测试\"></a>前缀重建树代码测试</h3><p>考虑使用本人前面测试用的表达式树，树的形态如下图所示：<a href=\"http://www.cnblogs.com/lulipro/p/7563217.html\" target=\"_blank\" rel=\"noopener\">图片来源</a></p>\n<p><img src=\"/images/expression-tree-test.png\" alt=\"表达式树\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEqual</span><span class=\"params\">(ExpressionAtom&lt;DataType&gt;&amp;in1, ExpressionAtom&lt;DataType&gt;&amp;in2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (in1.operFlag == in2.operFlag) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (in1.operFlag == OPERAND) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> in1.operValue.operand == in2.operValue.operand;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> in1.operValue.operatorCh == in2.operValue.operatorCh;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrefixVisit</span><span class=\"params\">(TreeNode&lt;DataType&gt; *root, <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result.push_back(root-&gt;nodeData);</span><br><span class=\"line\"></span><br><span class=\"line\">        PrefixVisit(root-&gt;left, result);</span><br><span class=\"line\">        PrefixVisit(root-&gt;right, result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PrefixToExprTreeRecurve(testVec); <span class=\"comment\">/*调用相应的代码*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; resultVec;</span><br><span class=\"line\">        PrefixVisit(result, resultVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> correct = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; resultVec.size() &amp;&amp; testVec.size(); i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEqual(resultVec[i], testVec[i])) &#123;</span><br><span class=\"line\">\t\t\tcorrect = <span class=\"literal\">false</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (correct &amp;&amp; i &gt;= resultVec.size() &amp;&amp; i &gt;= testVec.size()) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Correct\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Wrong\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后缀表达式重建表达式树\"><a href=\"#后缀表达式重建表达式树\" class=\"headerlink\" title=\"后缀表达式重建表达式树\"></a>后缀表达式重建表达式树</h2><p>后缀表达式和前缀表达式的区别是后缀表达式的操作符是在操作数的后面，即左-&gt;右-&gt;根，因此后缀重建的递归算法可以参考前缀表达式重建算法，只需稍微改变遍历顺序即可。具体代码可见如下两小节。</p>\n<h3 id=\"后缀重建树的递归实现\"><a href=\"#后缀重建树的递归实现\" class=\"headerlink\" title=\"后缀重建树的递归实现\"></a>后缀重建树的递归实现</h3><p>正如前面所说，后缀前缀表达式不同在于根节点位置，对于后缀表达式根节点在最后，因此参考前缀表达式重建树的递归算法只需从后往前递归即可，基本实现代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PostfixCore(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix, <span class=\"keyword\">int</span> &amp;index)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> TreeNode&lt;DataType&gt;; <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">        newNode-&gt;nodeData = inPostfix[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*由于前缀遍历得到，先建立左子树，再建立右子树*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newNode-&gt;nodeData.operFlag != OPERAND) &#123;</span><br><span class=\"line\">                newNode-&gt;right = PostfixCore(inPostfix, --index);</span><br><span class=\"line\">                newNode-&gt;left = PostfixCore(inPostfix, --index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode; <span class=\"comment\">/*返回新建立的节点*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PostfixToExprTreeRecurve(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inPostfix.size() &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"keyword\">int</span>(inPostfix.size()) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> PostfixCore(inPostfix, index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后缀重建树的非递归实现\"><a href=\"#后缀重建树的非递归实现\" class=\"headerlink\" title=\"后缀重建树的非递归实现\"></a>后缀重建树的非递归实现</h3><p>直接把后缀计算的代码稍作修改即可，代码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\">TreeNode&lt;DataType&gt; *PostfixToExprTree(<span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;inPostfix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inPostfix.size()  &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode&lt;DataType&gt; *&gt; nodeStack; <span class=\"comment\">/*放置根结点指针*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; inPostfix.size(); i++) &#123;</span><br><span class=\"line\">                TreeNode&lt;DataType&gt; *newNode = <span class=\"keyword\">new</span> TreeNode&lt;DataType&gt;; <span class=\"comment\">/*新建节点*/</span></span><br><span class=\"line\">                newNode-&gt;nodeData = inPostfix[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newNode-&gt;nodeData.operFlag == OPERATOR) &#123;</span><br><span class=\"line\">                        TreeNode&lt;DataType&gt; *operand1 = nodeStack.top(); nodeStack.pop();</span><br><span class=\"line\">                        TreeNode&lt;DataType&gt; *operand2 = nodeStack.top(); nodeStack.pop();</span><br><span class=\"line\">                        <span class=\"comment\">/*遇到操作符直接出栈两个操作数*/</span></span><br><span class=\"line\">                        newNode-&gt;left = operand2;</span><br><span class=\"line\">                        newNode-&gt;right = operand1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nodeStack.push(newNode); <span class=\"comment\">/*操作数或者子表达式树入栈*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*返回栈顶元素*/</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nodeStack.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后缀重建树代码测试\"><a href=\"#后缀重建树代码测试\" class=\"headerlink\" title=\"后缀重建树代码测试\"></a>后缀重建树代码测试</h3><p>依旧使用前缀图中的表达式树，测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> DataType&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostfixVisit</span><span class=\"params\">(TreeNode&lt;DataType&gt; *root, <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;DataType&gt;&gt; &amp;result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PostfixVisit(root-&gt;left, result);</span><br><span class=\"line\">        PostfixVisit(root-&gt;right, result);</span><br><span class=\"line\">        result.push_back(root-&gt;nodeData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; testVec;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt; manualData;</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">1</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">9</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">5</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">2</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">3</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">7</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">4</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERAND;</span><br><span class=\"line\">        manualData.operValue.operand = <span class=\"number\">6</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'+'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        manualData.operFlag = OPERATOR;</span><br><span class=\"line\">        manualData.operValue.operatorCh = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">        testVec.push_back(manualData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> result = PostfixToExprTreeRecurve(testVec); <span class=\"comment\">/*调用具体的函数*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;ExpressionAtom&lt;<span class=\"keyword\">int</span>&gt;&gt; resultVec;</span><br><span class=\"line\">        PostfixVisit(result, resultVec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> correct = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; resultVec.size() &amp;&amp; testVec.size(); i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEqual(resultVec[i], testVec[i])) &#123;</span><br><span class=\"line\">\t\t\tcorrect = <span class=\"literal\">false</span>; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (correct &amp;&amp; i &gt;= resultVec.size() &amp;&amp; i &gt;= testVec.size()) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Correct\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Wrong\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://book.douban.com/subject/2024655/\" target=\"_blank\" rel=\"noopener\">数据结构</a></p>\n<p><a href=\"https://www.cnblogs.com/z-sm/p/6807308.html\" target=\"_blank\" rel=\"noopener\">根据表达式序列构建表达式树</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjida4x280000gsvnrvalqn0j","category_id":"cji37vw1q00048kvneepgk4dy","_id":"cjida4x2q0005gsvns0kv3dh1"},{"post_id":"cjida4x2h0001gsvnprmvglig","category_id":"cji37vw1q00048kvneepgk4dy","_id":"cjida4x2s0007gsvnke9dtsyn"},{"post_id":"cjida4x2n0003gsvn7aqx9rxu","category_id":"cji37vw1q00048kvneepgk4dy","_id":"cjida4x2y000bgsvnm5jus496"},{"post_id":"cjida4x2p0004gsvncq76vdyx","category_id":"cji37vw1q00048kvneepgk4dy","_id":"cjida4x30000egsvntwaummy0"},{"post_id":"cjida4x2r0006gsvn6vp1iajj","category_id":"cji37vw1q00048kvneepgk4dy","_id":"cjida4x33000igsvnbkx0x0ko"},{"post_id":"cjida4x2y000agsvnnt3e923e","category_id":"cji37vw1q00048kvneepgk4dy","_id":"cjida4x39000lgsvnjvqxqbdb"},{"post_id":"cjida4x2z000dgsvnq38fdhk3","category_id":"cji37vw2b000o8kvne8ukbame","_id":"cjida4x3b000pgsvnzevflin3"},{"post_id":"cjida4x32000hgsvn92stff1o","category_id":"cji37vw2b000o8kvne8ukbame","_id":"cjida4x3c000rgsvnn1tq8osx"},{"post_id":"cjida4x38000kgsvneju6p6un","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3e000ugsvna2id73i2"},{"post_id":"cjida4x3a000ogsvnxt84m1n9","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3g000xgsvnt0ahe73q"},{"post_id":"cjida4x3c000qgsvn5dfewo0r","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3i0011gsvnqzdxzg8u"},{"post_id":"cjida4x3d000tgsvn9hkuoiu8","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3j0014gsvnyt83bmy6"},{"post_id":"cjida4x3f000wgsvn743erqxu","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3l0017gsvn379amryo"},{"post_id":"cjida4x3h0010gsvn334qdkgd","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3m001agsvnpo6jeqtb"},{"post_id":"cjida4x3i0013gsvnw2cylmgf","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3o001egsvndqad7xvg"},{"post_id":"cjida4x3k0016gsvn23ttcn6m","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3q001hgsvndx5br3hz"},{"post_id":"cjida4x3l0019gsvn6ugxykg2","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3s001lgsvn669x6jy4"},{"post_id":"cjida4x3n001dgsvnpj7ilja9","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3t001ogsvniq5e8sfe"},{"post_id":"cjida4x3p001ggsvnlfjt2wgy","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3v001sgsvn354vl7m6"},{"post_id":"cjida4x3r001kgsvnvoae8xj6","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3x001vgsvndo9imy30"},{"post_id":"cjida4x3s001ngsvnifvqpalh","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x3z001zgsvnjawgoehy"},{"post_id":"cjida4x3u001rgsvnud5blpu2","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x410022gsvnb6sk99pv"},{"post_id":"cjida4x3w001ugsvnhurm2v6n","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x430026gsvnfhrkg3z3"},{"post_id":"cjida4x3y001ygsvny92u3d1n","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x440029gsvnmmiui165"},{"post_id":"cjida4x400021gsvn4m5ea28y","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x46002dgsvn4mw9jcjv"},{"post_id":"cjida4x420025gsvniypl70o4","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x48002ggsvnh7636zrk"},{"post_id":"cjida4x430028gsvnl74sdfyx","category_id":"cji37vw32001s8kvnh2mp17oy","_id":"cjida4x4a002kgsvnv58yw32g"},{"post_id":"cjida4x45002cgsvn30twuxxk","category_id":"cji37vw32001s8kvnh2mp17oy","_id":"cjida4x4b002ngsvntcgteoj1"},{"post_id":"cjida4x47002fgsvn1m5pc5pl","category_id":"cji37vw32001s8kvnh2mp17oy","_id":"cjida4x4d002qgsvnonn6vvug"},{"post_id":"cjida4x49002jgsvnfxmuxjed","category_id":"cji37vw32001s8kvnh2mp17oy","_id":"cjida4x4f002ugsvnrgg5jvw5"},{"post_id":"cjida4x4a002mgsvn4wdaezkh","category_id":"cji37vw2k00128kvn6rbfyxog","_id":"cjida4x4g002xgsvnptj7rvvj"},{"post_id":"cjida4x4c002pgsvnnwzkoa1t","category_id":"cji37vw2k00128kvn6rbfyxog","_id":"cjida4x4j0031gsvn8e8wc2jz"},{"post_id":"cjida4x4e002tgsvn4xhdxsmc","category_id":"cji37vw2k00128kvn6rbfyxog","_id":"cjida4x4l0034gsvnjowrk2bx"},{"post_id":"cjida4x4f002wgsvn7s4ov9k3","category_id":"cji37vw2k00128kvn6rbfyxog","_id":"cjida4x4n0038gsvnviza8bu8"},{"post_id":"cjida4x4i0030gsvn7bx7kc4k","category_id":"cji37vw2k00128kvn6rbfyxog","_id":"cjida4x4p003bgsvnvcx9ct4f"},{"post_id":"cjida4x4k0033gsvn1p69b0r4","category_id":"cji37vw2k00128kvn6rbfyxog","_id":"cjida4x4s003fgsvngoqb5msq"},{"post_id":"cjida4x4m0037gsvnb25z1o86","category_id":"cji37vw4p004c8kvn7yr38zos","_id":"cjida4x4s003hgsvn0od6f2vp"},{"post_id":"cjida4x4o003agsvnnbamvobc","category_id":"cji37vw32001s8kvnh2mp17oy","_id":"cjida4x4t003kgsvnijiivuxk"},{"post_id":"cjida4x4q003egsvn1hdcdv6n","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjida4x4u003mgsvn94yiy5wz"},{"post_id":"cjiemwkrl00007wvnn7c2ku14","category_id":"cji37vw32001s8kvnh2mp17oy","_id":"cjiemwkrz00047wvnlsak9vmw"},{"post_id":"cjiemwkrv00017wvn7g0owvwn","category_id":"cji37vw32001s8kvnh2mp17oy","_id":"cjiemwks000057wvnqaszvp4r"},{"post_id":"cjir36zn20000sovngsh6h7ho","category_id":"cji37vw32001s8kvnh2mp17oy","_id":"cjir36znt0002sovnydmgs7f1"},{"post_id":"cjiu5pmt90003ncvnhaipuejy","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjiu5pmtc0005ncvnfq6g5s2e"},{"post_id":"cjivnio3v0000vovnxe0v3rxk","category_id":"cji37vw3j002g8kvn8ocmeapi","_id":"cjivnio440002vovnsfv1yv1y"},{"post_id":"cjjcjs73o0000yku8lhzw7akz","category_id":"cji37vw32001s8kvnh2mp17oy","_id":"cjjcjs7570002yku8j4g7ehli"}],"PostTag":[{"post_id":"cjida4x280000gsvnrvalqn0j","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x2x0009gsvnedn4ngpb"},{"post_id":"cjida4x2r0006gsvn6vp1iajj","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x2z000cgsvn0ck1epau"},{"post_id":"cjida4x2y000agsvnnt3e923e","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x31000ggsvna12yj02b"},{"post_id":"cjida4x2h0001gsvnprmvglig","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x38000jgsvnukef02fb"},{"post_id":"cjida4x2n0003gsvn7aqx9rxu","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x3a000ngsvn4gugl2fk"},{"post_id":"cjida4x2p0004gsvncq76vdyx","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x3e000vgsvnx3wr5qd3"},{"post_id":"cjida4x2p0004gsvncq76vdyx","tag_id":"cjida4x39000mgsvnjmtvq701","_id":"cjida4x3g000ygsvnofw9r3p2"},{"post_id":"cjida4x2z000dgsvnq38fdhk3","tag_id":"cjida4x3d000sgsvnzy90nbln","_id":"cjida4x3i0012gsvn0u4b21h3"},{"post_id":"cjida4x32000hgsvn92stff1o","tag_id":"cjida4x3d000sgsvnzy90nbln","_id":"cjida4x3l0018gsvnpzgvazdi"},{"post_id":"cjida4x3k0016gsvn23ttcn6m","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x3n001bgsvnwm5pbqnj"},{"post_id":"cjida4x3k0016gsvn23ttcn6m","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x3p001fgsvnirhmnewn"},{"post_id":"cjida4x38000kgsvneju6p6un","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x3q001igsvnr6yhf1hp"},{"post_id":"cjida4x3l0019gsvn6ugxykg2","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x3s001mgsvnaog6po80"},{"post_id":"cjida4x3l0019gsvn6ugxykg2","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x3u001pgsvn4rzsleuc"},{"post_id":"cjida4x3n001dgsvnpj7ilja9","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x3w001tgsvn6m5prp18"},{"post_id":"cjida4x3a000ogsvnxt84m1n9","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x3x001wgsvnztc074i6"},{"post_id":"cjida4x3p001ggsvnlfjt2wgy","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x3z0020gsvn6nkcf0lc"},{"post_id":"cjida4x3r001kgsvnvoae8xj6","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x410023gsvntym66tyd"},{"post_id":"cjida4x3c000qgsvn5dfewo0r","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x430027gsvnaaspmnfd"},{"post_id":"cjida4x3s001ngsvnifvqpalh","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x45002agsvn3uiascyd"},{"post_id":"cjida4x3s001ngsvnifvqpalh","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x47002egsvn0h7ijlmj"},{"post_id":"cjida4x3u001rgsvnud5blpu2","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x48002hgsvnnlxu6ooj"},{"post_id":"cjida4x3d000tgsvn9hkuoiu8","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x4a002lgsvnqy2w2yy4"},{"post_id":"cjida4x3w001ugsvnhurm2v6n","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x4c002ogsvns1l6lozh"},{"post_id":"cjida4x3w001ugsvnhurm2v6n","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x4e002sgsvnj231iz6l"},{"post_id":"cjida4x3y001ygsvny92u3d1n","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x4f002vgsvnqqm13rof"},{"post_id":"cjida4x3f000wgsvn743erqxu","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x4i002zgsvnndeio8cb"},{"post_id":"cjida4x400021gsvn4m5ea28y","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x4k0032gsvnhsji7tc6"},{"post_id":"cjida4x420025gsvniypl70o4","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x4m0036gsvngeningxk"},{"post_id":"cjida4x3h0010gsvn334qdkgd","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x4n0039gsvn36jsrubk"},{"post_id":"cjida4x3i0013gsvnw2cylmgf","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x4q003dgsvnxuf5ogba"},{"post_id":"cjida4x3i0013gsvnw2cylmgf","tag_id":"cjida4x2k0002gsvn6q04nj3m","_id":"cjida4x4s003ggsvny231jyfg"},{"post_id":"cjida4x430028gsvnl74sdfyx","tag_id":"cjida4x48002igsvnppvf7kn8","_id":"cjida4x4t003jgsvnpht74h3m"},{"post_id":"cjida4x45002cgsvn30twuxxk","tag_id":"cjida4x48002igsvnppvf7kn8","_id":"cjida4x4u003lgsvnj5x4nxbj"},{"post_id":"cjida4x47002fgsvn1m5pc5pl","tag_id":"cjida4x48002igsvnppvf7kn8","_id":"cjida4x4u003ogsvncox2tkss"},{"post_id":"cjida4x49002jgsvnfxmuxjed","tag_id":"cjida4x48002igsvnppvf7kn8","_id":"cjida4x4v003pgsvnbpajms4u"},{"post_id":"cjida4x4o003agsvnnbamvobc","tag_id":"cjida4x48002igsvnppvf7kn8","_id":"cjida4x4v003rgsvnymcwo8uu"},{"post_id":"cjida4x4q003egsvn1hdcdv6n","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjida4x4w003sgsvnm0qwnjx6"},{"post_id":"cjida4x4a002mgsvn4wdaezkh","tag_id":"cjida4x4p003cgsvnyjjepfb5","_id":"cjida4x4x003ugsvny1we6hts"},{"post_id":"cjida4x4a002mgsvn4wdaezkh","tag_id":"cjida4x4t003igsvnco77qhhm","_id":"cjida4x4x003vgsvngn4wtu9s"},{"post_id":"cjida4x4c002pgsvnnwzkoa1t","tag_id":"cjida4x4p003cgsvnyjjepfb5","_id":"cjida4x4y003xgsvnywygyks0"},{"post_id":"cjida4x4e002tgsvn4xhdxsmc","tag_id":"cjida4x4p003cgsvnyjjepfb5","_id":"cjida4x4y003ygsvnvy7wy6r6"},{"post_id":"cjida4x4f002wgsvn7s4ov9k3","tag_id":"cjida4x4p003cgsvnyjjepfb5","_id":"cjida4x4z0040gsvndzglexwe"},{"post_id":"cjida4x4i0030gsvn7bx7kc4k","tag_id":"cjida4x4p003cgsvnyjjepfb5","_id":"cjida4x4z0041gsvn7xjuw5iu"},{"post_id":"cjida4x4k0033gsvn1p69b0r4","tag_id":"cjida4x4p003cgsvnyjjepfb5","_id":"cjida4x500043gsvn68b4wsw1"},{"post_id":"cjida4x4m0037gsvnb25z1o86","tag_id":"cjida4x4z0042gsvnghzebz1d","_id":"cjida4x500044gsvnm0e4etwg"},{"post_id":"cjiemwkrl00007wvnn7c2ku14","tag_id":"cjida4x48002igsvnppvf7kn8","_id":"cjiemwkrx00027wvnbgq5pnr6"},{"post_id":"cjiemwkrv00017wvn7g0owvwn","tag_id":"cjida4x48002igsvnppvf7kn8","_id":"cjiemwkry00037wvndepmus0m"},{"post_id":"cjir36zn20000sovngsh6h7ho","tag_id":"cjida4x48002igsvnppvf7kn8","_id":"cjir36znr0001sovnu2b62t4g"},{"post_id":"cjiu5pmt90003ncvnhaipuejy","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjiu5pmtc0004ncvnhf21a183"},{"post_id":"cjivnio3v0000vovnxe0v3rxk","tag_id":"cjida4x3j0015gsvnhr9es96m","_id":"cjivnio430001vovnww5h8mp4"},{"post_id":"cjjcjs73o0000yku8lhzw7akz","tag_id":"cjida4x48002igsvnppvf7kn8","_id":"cjjcjs7530001yku8mrdsacgk"}],"Tag":[{"name":"C++","_id":"cjida4x2k0002gsvn6q04nj3m"},{"name":"STL","_id":"cjida4x39000mgsvnjmtvq701"},{"name":"Hexo","_id":"cjida4x3d000sgsvnzy90nbln"},{"name":"数据结构","_id":"cjida4x3j0015gsvnhr9es96m"},{"name":"算法设计","_id":"cjida4x48002igsvnppvf7kn8"},{"name":"操作系统","_id":"cjida4x4p003cgsvnyjjepfb5"},{"name":"Linux","_id":"cjida4x4t003igsvnco77qhhm"},{"name":"计算机网络","_id":"cjida4x4z0042gsvnghzebz1d"}]}}